//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-security")]
use objc2_security::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionkerberosmapping?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct ASAuthorizationProviderExtensionKerberosMapping;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for ASAuthorizationProviderExtensionKerberosMapping {}
);

impl ASAuthorizationProviderExtensionKerberosMapping {
    extern_methods!(
        /// The keypath in the response JSON that uses this set of mappings.
        ///
        /// If the response tokens from login contain this keypath, then the mapping in this class will be used to create a Kerberos ticket. The expected response is a JSON dictionary with the supplied key names.
        #[unsafe(method(ticketKeyPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn ticketKeyPath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`ticketKeyPath`][Self::ticketKeyPath].
        #[unsafe(method(setTicketKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTicketKeyPath(&self, ticket_key_path: Option<&NSString>);

        /// The key name that contains the base64 encoded kerberos AS-REP string.
        #[unsafe(method(messageBufferKeyName))]
        #[unsafe(method_family = none)]
        pub unsafe fn messageBufferKeyName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`messageBufferKeyName`][Self::messageBufferKeyName].
        #[unsafe(method(setMessageBufferKeyName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMessageBufferKeyName(&self, message_buffer_key_name: Option<&NSString>);

        /// The key name that contains the Kerberos Realm string.
        #[unsafe(method(realmKeyName))]
        #[unsafe(method_family = none)]
        pub unsafe fn realmKeyName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`realmKeyName`][Self::realmKeyName].
        #[unsafe(method(setRealmKeyName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRealmKeyName(&self, realm_key_name: Option<&NSString>);

        /// The key name that contains the Kerberos service name string.
        #[unsafe(method(serviceNameKeyName))]
        #[unsafe(method_family = none)]
        pub unsafe fn serviceNameKeyName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`serviceNameKeyName`][Self::serviceNameKeyName].
        #[unsafe(method(setServiceNameKeyName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServiceNameKeyName(&self, service_name_key_name: Option<&NSString>);

        /// The key name that contains the Kerberos client name string.
        #[unsafe(method(clientNameKeyName))]
        #[unsafe(method_family = none)]
        pub unsafe fn clientNameKeyName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`clientNameKeyName`][Self::clientNameKeyName].
        #[unsafe(method(setClientNameKeyName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClientNameKeyName(&self, client_name_key_name: Option<&NSString>);

        /// The key name that contains the Kerberos session key type number.
        ///
        /// The value for this key should be the correct encryption type per RFC3962, section 7 for the session key.
        #[unsafe(method(encryptionKeyTypeKeyName))]
        #[unsafe(method_family = none)]
        pub unsafe fn encryptionKeyTypeKeyName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`encryptionKeyTypeKeyName`][Self::encryptionKeyTypeKeyName].
        #[unsafe(method(setEncryptionKeyTypeKeyName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEncryptionKeyTypeKeyName(
            &self,
            encryption_key_type_key_name: Option<&NSString>,
        );

        /// The key name that contains the Kerberos session key.
        #[unsafe(method(sessionKeyKeyName))]
        #[unsafe(method_family = none)]
        pub unsafe fn sessionKeyKeyName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`sessionKeyKeyName`][Self::sessionKeyKeyName].
        #[unsafe(method(setSessionKeyKeyName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSessionKeyKeyName(&self, session_key_key_name: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl ASAuthorizationProviderExtensionKerberosMapping {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionfederationtype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct ASAuthorizationProviderExtensionFederationType(pub NSInteger);
impl ASAuthorizationProviderExtensionFederationType {
    #[doc(alias = "ASAuthorizationProviderExtensionFederationTypeNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "ASAuthorizationProviderExtensionFederationTypeWSTrust")]
    pub const WSTrust: Self = Self(1);
    #[doc(alias = "ASAuthorizationProviderExtensionFederationTypeDynamicWSTrust")]
    pub const DynamicWSTrust: Self = Self(2);
}

unsafe impl Encode for ASAuthorizationProviderExtensionFederationType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for ASAuthorizationProviderExtensionFederationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionusersecureenclavekeybiometricpolicy?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicy(pub NSUInteger);
bitflags::bitflags! {
    impl ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicy: NSUInteger {
        #[doc(alias = "ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicyNone")]
        const None = 0;
        #[doc(alias = "ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicyTouchIDOrWatchCurrentSet")]
        const TouchIDOrWatchCurrentSet = 1<<0;
        #[doc(alias = "ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicyTouchIDOrWatchAny")]
        const TouchIDOrWatchAny = 1<<1;
        #[doc(alias = "ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicyReuseDuringUnlock")]
        const ReuseDuringUnlock = 1<<2;
        #[doc(alias = "ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicyPasswordFallback")]
        const PasswordFallback = 1<<3;
    }
}

unsafe impl Encode for ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicy {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicy {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionencryptionalgorithm?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type ASAuthorizationProviderExtensionEncryptionAlgorithm = NSNumber;

extern "C" {
    /// A encryption algorithm that uses NIST P-256 elliptic curve key agreement, ConcatKDF key derivation
    /// with a 256-bit digest, and the Advanced Encryption Standard cipher in Galois/Counter Mode with a key length of 256 bits.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionencryptionalgorithmecdhe_a256gcm?language=objc)
    pub static ASAuthorizationProviderExtensionEncryptionAlgorithmECDHE_A256GCM:
        &'static ASAuthorizationProviderExtensionEncryptionAlgorithm;
}

extern "C" {
    /// A cipher suite for HPKE that uses NIST P-256 elliptic curve key agreement, SHA-2 key derivation
    /// with a 256-bit digest, and the Advanced Encryption Standard cipher in Galois/Counter Mode with a key length of 256 bits.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionencryptionalgorithmhpke_p256_sha256_aes_gcm_256?language=objc)
    pub static ASAuthorizationProviderExtensionEncryptionAlgorithmHPKE_P256_SHA256_AES_GCM_256:
        &'static ASAuthorizationProviderExtensionEncryptionAlgorithm;
}

extern "C" {
    /// A cipher suite that you use for HPKE using NIST P-384 elliptic curve key agreement, SHA-2 key derivation
    /// with a 384-bit digest, and the Advanced Encryption Standard cipher in Galois/Counter Mode with a key length of 256 bits.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionencryptionalgorithmhpke_p384_sha384_aes_gcm_256?language=objc)
    pub static ASAuthorizationProviderExtensionEncryptionAlgorithmHPKE_P384_SHA384_AES_GCM_256:
        &'static ASAuthorizationProviderExtensionEncryptionAlgorithm;
}

extern "C" {
    /// A cipher suite for HPKE that uses X25519 elliptic curve key agreement, SHA-2 key derivation
    /// with a 256-bit digest, and the ChaCha20 stream cipher with the Poly1305 message authentication code.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionencryptionalgorithmhpke_curve25519_sha256_chachapoly?language=objc)
    pub static ASAuthorizationProviderExtensionEncryptionAlgorithmHPKE_Curve25519_SHA256_ChachaPoly:
        &'static ASAuthorizationProviderExtensionEncryptionAlgorithm;
}

/// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionsigningalgorithm?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type ASAuthorizationProviderExtensionSigningAlgorithm = NSNumber;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionsigningalgorithmes256?language=objc)
    pub static ASAuthorizationProviderExtensionSigningAlgorithmES256:
        &'static ASAuthorizationProviderExtensionSigningAlgorithm;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionsigningalgorithmes384?language=objc)
    pub static ASAuthorizationProviderExtensionSigningAlgorithmES384:
        &'static ASAuthorizationProviderExtensionSigningAlgorithm;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionsigningalgorithmed25519?language=objc)
    pub static ASAuthorizationProviderExtensionSigningAlgorithmEd25519:
        &'static ASAuthorizationProviderExtensionSigningAlgorithm;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asauthorizationproviderextensionloginconfiguration?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct ASAuthorizationProviderExtensionLoginConfiguration;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for ASAuthorizationProviderExtensionLoginConfiguration {}
);

impl ASAuthorizationProviderExtensionLoginConfiguration {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Initializes an ASAuthorizationProviderExtensionLoginConfiguration class with the required values.
        ///
        /// Parameter `clientID`: The client_id for the Apple platform SSO login at the identity provider.
        ///
        /// Parameter `issuer`: The issuer for the requests, used to validate responses.
        ///
        /// Parameter `tokenEndpointURL`: The token endpoint at the idP for login.
        ///
        /// Parameter `jwksEndpointURL`: The JWKS URL at the idP for validating tokens.
        ///
        /// Parameter `audience`: The audience used for signed assertions.  This should be the tenent at the idP.
        ///
        /// Returns: An instance of a ASAuthorizationProviderExtensionLoginConfiguration.
        #[unsafe(method(initWithClientID:issuer:tokenEndpointURL:jwksEndpointURL:audience:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithClientID_issuer_tokenEndpointURL_jwksEndpointURL_audience(
            this: Allocated<Self>,
            client_id: &NSString,
            issuer: &NSString,
            token_endpoint_url: &NSURL,
            jwks_endpoint_url: &NSURL,
            audience: Option<&NSString>,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Creates a login configuration using the OpenID configuration.
        ///
        /// Parameter `openIDConfigurationURL`: The base URL to load the .well-known/openid-configuration.
        ///
        /// Parameter `clientID`: The client_id for the Apple platform SSO login at the identity provider.
        ///
        /// Parameter `issuer`: The issuer for the requests, used to validate responses.
        ///
        /// Parameter `completion`: The completion called when it is complete or the error.
        #[unsafe(method(configurationWithOpenIDConfigurationURL:clientID:issuer:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationWithOpenIDConfigurationURL_clientID_issuer_completion(
            open_id_configuration_url: &NSURL,
            client_id: &NSString,
            issuer: Option<&NSString>,
            completion: &block2::DynBlock<
                dyn Fn(*mut ASAuthorizationProviderExtensionLoginConfiguration, *mut NSError),
            >,
        );

        /// Predicate string used to identify invalid credential errors.
        ///
        /// If there is an HTTP 400 or HTTP 401 error when authenticating, this predicate will be used on the response body JSON to determine if the error is due to an invalid password or something else.  If nil, then only an HTTP 401 will be used for an invalid credential.
        #[unsafe(method(invalidCredentialPredicate))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidCredentialPredicate(&self) -> Option<Retained<NSString>>;

        /// Setter for [`invalidCredentialPredicate`][Self::invalidCredentialPredicate].
        #[unsafe(method(setInvalidCredentialPredicate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInvalidCredentialPredicate(
            &self,
            invalid_credential_predicate: Option<&NSString>,
        );

        /// The display name for the account.  Used for notifications and login prompts.
        #[unsafe(method(accountDisplayName))]
        #[unsafe(method_family = none)]
        pub unsafe fn accountDisplayName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`accountDisplayName`][Self::accountDisplayName].
        #[unsafe(method(setAccountDisplayName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAccountDisplayName(&self, account_display_name: Option<&NSString>);

        /// The login client_id.
        #[unsafe(method(clientID))]
        #[unsafe(method_family = none)]
        pub unsafe fn clientID(&self) -> Retained<NSString>;

        /// The issuer for validation.
        #[unsafe(method(issuer))]
        #[unsafe(method_family = none)]
        pub unsafe fn issuer(&self) -> Retained<NSString>;

        /// The audience for validation and requests.
        #[unsafe(method(audience))]
        #[unsafe(method_family = none)]
        pub unsafe fn audience(&self) -> Retained<NSString>;

        /// Setter for [`audience`][Self::audience].
        #[unsafe(method(setAudience:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAudience(&self, audience: &NSString);

        /// Token Endpoint URL for login request.
        #[unsafe(method(tokenEndpointURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn tokenEndpointURL(&self) -> Retained<NSURL>;

        /// Setter for [`tokenEndpointURL`][Self::tokenEndpointURL].
        #[unsafe(method(setTokenEndpointURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTokenEndpointURL(&self, token_endpoint_url: &NSURL);

        /// JWKS Endpoint URL for keys.
        #[unsafe(method(jwksEndpointURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn jwksEndpointURL(&self) -> Retained<NSURL>;

        /// Setter for [`jwksEndpointURL`][Self::jwksEndpointURL].
        #[unsafe(method(setJwksEndpointURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setJwksEndpointURL(&self, jwks_endpoint_url: &NSURL);

        /// The root certificates to use for trust evaluation of jwks keys.
        ///
        /// if set, certificates will be required in jwks responses and evaluated using the supplied certificates.  If the jwks certificates are missing or fail trust evaluation the login will fail.
        #[unsafe(method(jwksTrustedRootCertificates))]
        #[unsafe(method_family = none)]
        pub unsafe fn jwksTrustedRootCertificates(&self) -> Retained<NSArray>;

        /// Setter for [`jwksTrustedRootCertificates`][Self::jwksTrustedRootCertificates].
        #[unsafe(method(setJwksTrustedRootCertificates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setJwksTrustedRootCertificates(
            &self,
            jwks_trusted_root_certificates: &NSArray,
        );

        /// The device context for storing device meta data.
        #[unsafe(method(deviceContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceContext(&self) -> Option<Retained<NSData>>;

        /// Setter for [`deviceContext`][Self::deviceContext].
        #[unsafe(method(setDeviceContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDeviceContext(&self, device_context: Option<&NSData>);

        /// The biometric policy for User Secure Enclave Key authentication.
        #[unsafe(method(userSecureEnclaveKeyBiometricPolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn userSecureEnclaveKeyBiometricPolicy(
            &self,
        ) -> ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicy;

        /// Setter for [`userSecureEnclaveKeyBiometricPolicy`][Self::userSecureEnclaveKeyBiometricPolicy].
        #[unsafe(method(setUserSecureEnclaveKeyBiometricPolicy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserSecureEnclaveKeyBiometricPolicy(
            &self,
            user_secure_enclave_key_biometric_policy: ASAuthorizationProviderExtensionUserSecureEnclaveKeyBiometricPolicy,
        );

        /// Nonce Endpoint URL, defaults to token tokenEndpointURL.
        #[unsafe(method(nonceEndpointURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn nonceEndpointURL(&self) -> Retained<NSURL>;

        /// Setter for [`nonceEndpointURL`][Self::nonceEndpointURL].
        #[unsafe(method(setNonceEndpointURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNonceEndpointURL(&self, nonce_endpoint_url: &NSURL);

        /// The keypath in the nonce response that contains the nonce value.
        #[unsafe(method(nonceResponseKeypath))]
        #[unsafe(method_family = none)]
        pub unsafe fn nonceResponseKeypath(&self) -> Retained<NSString>;

        /// Setter for [`nonceResponseKeypath`][Self::nonceResponseKeypath].
        #[unsafe(method(setNonceResponseKeypath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNonceResponseKeypath(&self, nonce_response_keypath: &NSString);

        /// The name of the server nonce claim when included in authentication requests.
        #[unsafe(method(serverNonceClaimName))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverNonceClaimName(&self) -> Retained<NSString>;

        /// Setter for [`serverNonceClaimName`][Self::serverNonceClaimName].
        #[unsafe(method(setServerNonceClaimName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerNonceClaimName(&self, server_nonce_claim_name: &NSString);

        /// Custom values added to the server nonce POST request body.
        #[unsafe(method(customNonceRequestValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn customNonceRequestValues(&self) -> Retained<NSArray<NSURLQueryItem>>;

        /// Setter for [`customNonceRequestValues`][Self::customNonceRequestValues].
        #[unsafe(method(setCustomNonceRequestValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomNonceRequestValues(
            &self,
            custom_nonce_request_values: &NSArray<NSURLQueryItem>,
        );

        /// Sets custom claims to be added to the embedded assertion request header.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomAssertionRequestHeaderClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomAssertionRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Sets custom claims to be added to the embedded assertion request body.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomAssertionRequestBodyClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomAssertionRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Additional login scopes.
        #[unsafe(method(additionalScopes))]
        #[unsafe(method_family = none)]
        pub unsafe fn additionalScopes(&self) -> Retained<NSString>;

        /// Setter for [`additionalScopes`][Self::additionalScopes].
        #[unsafe(method(setAdditionalScopes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAdditionalScopes(&self, additional_scopes: &NSString);

        /// Additional authorization scopes.
        #[unsafe(method(additionalAuthorizationScopes))]
        #[unsafe(method_family = none)]
        pub unsafe fn additionalAuthorizationScopes(&self) -> Option<Retained<NSString>>;

        /// Setter for [`additionalAuthorizationScopes`][Self::additionalAuthorizationScopes].
        #[unsafe(method(setAdditionalAuthorizationScopes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAdditionalAuthorizationScopes(
            &self,
            additional_authorization_scopes: Option<&NSString>,
        );

        /// If true and there is a refresh token for the user in the SSO tokens, it will be included in the login request.
        #[unsafe(method(includePreviousRefreshTokenInLoginRequest))]
        #[unsafe(method_family = none)]
        pub unsafe fn includePreviousRefreshTokenInLoginRequest(&self) -> bool;

        /// Setter for [`includePreviousRefreshTokenInLoginRequest`][Self::includePreviousRefreshTokenInLoginRequest].
        #[unsafe(method(setIncludePreviousRefreshTokenInLoginRequest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIncludePreviousRefreshTokenInLoginRequest(
            &self,
            include_previous_refresh_token_in_login_request: bool,
        );

        /// The claim name for the previous SSO token value in the login request.
        #[unsafe(method(previousRefreshTokenClaimName))]
        #[unsafe(method_family = none)]
        pub unsafe fn previousRefreshTokenClaimName(&self) -> Retained<NSString>;

        /// Setter for [`previousRefreshTokenClaimName`][Self::previousRefreshTokenClaimName].
        #[unsafe(method(setPreviousRefreshTokenClaimName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreviousRefreshTokenClaimName(
            &self,
            previous_refresh_token_claim_name: &NSString,
        );

        /// The request parameter name for the JWT.  The default is "assertion".
        #[unsafe(method(customRequestJWTParameterName))]
        #[unsafe(method_family = none)]
        pub unsafe fn customRequestJWTParameterName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`customRequestJWTParameterName`][Self::customRequestJWTParameterName].
        #[unsafe(method(setCustomRequestJWTParameterName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomRequestJWTParameterName(
            &self,
            custom_request_jwt_parameter_name: Option<&NSString>,
        );

        /// Custom values added to the login POST request body.
        #[unsafe(method(customLoginRequestValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn customLoginRequestValues(&self) -> Retained<NSArray<NSURLQueryItem>>;

        /// Setter for [`customLoginRequestValues`][Self::customLoginRequestValues].
        #[unsafe(method(setCustomLoginRequestValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomLoginRequestValues(
            &self,
            custom_login_request_values: &NSArray<NSURLQueryItem>,
        );

        /// Sets custom claims to be added to the login request header.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomLoginRequestHeaderClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomLoginRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Sets custom claims to be added to the login request body.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomLoginRequestBodyClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomLoginRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// The claim name for the user unique identifier in the id token. Defaults to "sub".
        #[unsafe(method(uniqueIdentifierClaimName))]
        #[unsafe(method_family = none)]
        pub unsafe fn uniqueIdentifierClaimName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`uniqueIdentifierClaimName`][Self::uniqueIdentifierClaimName].
        #[unsafe(method(setUniqueIdentifierClaimName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUniqueIdentifierClaimName(
            &self,
            unique_identifier_claim_name: Option<&NSString>,
        );

        /// The claim name for group membership request.
        #[unsafe(method(groupRequestClaimName))]
        #[unsafe(method_family = none)]
        pub unsafe fn groupRequestClaimName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`groupRequestClaimName`][Self::groupRequestClaimName].
        #[unsafe(method(setGroupRequestClaimName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGroupRequestClaimName(&self, group_request_claim_name: Option<&NSString>);

        /// The claim name for group responses in the id_token.
        #[unsafe(method(groupResponseClaimName))]
        #[unsafe(method_family = none)]
        pub unsafe fn groupResponseClaimName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`groupResponseClaimName`][Self::groupResponseClaimName].
        #[unsafe(method(setGroupResponseClaimName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGroupResponseClaimName(
            &self,
            group_response_claim_name: Option<&NSString>,
        );

        /// The Kerberos ticket mappings to use.
        #[unsafe(method(kerberosTicketMappings))]
        #[unsafe(method_family = none)]
        pub unsafe fn kerberosTicketMappings(
            &self,
        ) -> Retained<NSArray<ASAuthorizationProviderExtensionKerberosMapping>>;

        /// Setter for [`kerberosTicketMappings`][Self::kerberosTicketMappings].
        #[unsafe(method(setKerberosTicketMappings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setKerberosTicketMappings(
            &self,
            kerberos_ticket_mappings: &NSArray<ASAuthorizationProviderExtensionKerberosMapping>,
        );

        /// Token Refresh Endpoint URL for login request.  Defaults to the tokenEndpointURL.
        #[unsafe(method(refreshEndpointURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn refreshEndpointURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`refreshEndpointURL`][Self::refreshEndpointURL].
        #[unsafe(method(setRefreshEndpointURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRefreshEndpointURL(&self, refresh_endpoint_url: Option<&NSURL>);

        /// Custom values added to the refresh POST request body.
        #[unsafe(method(customRefreshRequestValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn customRefreshRequestValues(&self) -> Retained<NSArray<NSURLQueryItem>>;

        /// Setter for [`customRefreshRequestValues`][Self::customRefreshRequestValues].
        #[unsafe(method(setCustomRefreshRequestValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomRefreshRequestValues(
            &self,
            custom_refresh_request_values: &NSArray<NSURLQueryItem>,
        );

        /// Sets custom claims to be added to the refresh request header.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomRefreshRequestHeaderClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomRefreshRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Sets custom claims to be added to the refresh request bode.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomRefreshRequestBodyClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomRefreshRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// The federation method to use.
        #[unsafe(method(federationType))]
        #[unsafe(method_family = none)]
        pub unsafe fn federationType(&self) -> ASAuthorizationProviderExtensionFederationType;

        /// Setter for [`federationType`][Self::federationType].
        #[unsafe(method(setFederationType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFederationType(
            &self,
            federation_type: ASAuthorizationProviderExtensionFederationType,
        );

        /// The URN to request when performing a federated login.
        #[unsafe(method(federationRequestURN))]
        #[unsafe(method_family = none)]
        pub unsafe fn federationRequestURN(&self) -> Option<Retained<NSString>>;

        /// Setter for [`federationRequestURN`][Self::federationRequestURN].
        #[unsafe(method(setFederationRequestURN:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFederationRequestURN(&self, federation_request_urn: Option<&NSString>);

        /// The federation MEX URL to use.  This can be overwritten when using dynamic federation.
        #[unsafe(method(federationMEXURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn federationMEXURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`federationMEXURL`][Self::federationMEXURL].
        #[unsafe(method(setFederationMEXURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFederationMEXURL(&self, federation_mexurl: Option<&NSURL>);

        /// The URL to use when performing dynamic federation.
        #[unsafe(method(federationUserPreauthenticationURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn federationUserPreauthenticationURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`federationUserPreauthenticationURL`][Self::federationUserPreauthenticationURL].
        #[unsafe(method(setFederationUserPreauthenticationURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFederationUserPreauthenticationURL(
            &self,
            federation_user_preauthentication_url: Option<&NSURL>,
        );

        /// The claim in the preauthentication response that contains the MEX URL.
        #[unsafe(method(federationMEXURLKeypath))]
        #[unsafe(method_family = none)]
        pub unsafe fn federationMEXURLKeypath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`federationMEXURLKeypath`][Self::federationMEXURLKeypath].
        #[unsafe(method(setFederationMEXURLKeypath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFederationMEXURLKeypath(
            &self,
            federation_mexurl_keypath: Option<&NSString>,
        );

        /// The predicate to apply to the preauthentication response to perform federation or not.
        #[unsafe(method(federationPredicate))]
        #[unsafe(method_family = none)]
        pub unsafe fn federationPredicate(&self) -> Option<Retained<NSString>>;

        /// Setter for [`federationPredicate`][Self::federationPredicate].
        #[unsafe(method(setFederationPredicate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFederationPredicate(&self, federation_predicate: Option<&NSString>);

        /// The custom query string values to add when making the preauthenticaion request.
        #[unsafe(method(customFederationUserPreauthenticationRequestValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn customFederationUserPreauthenticationRequestValues(
            &self,
        ) -> Retained<NSArray<NSURLQueryItem>>;

        /// Setter for [`customFederationUserPreauthenticationRequestValues`][Self::customFederationUserPreauthenticationRequestValues].
        #[unsafe(method(setCustomFederationUserPreauthenticationRequestValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomFederationUserPreauthenticationRequestValues(
            &self,
            custom_federation_user_preauthentication_request_values: &NSArray<NSURLQueryItem>,
        );

        #[cfg(feature = "objc2-security")]
        /// The public key to use for encrypting the embedded login assertion.
        ///
        /// Only applies to password authentication.  If set, the password will encrypted in an embedded assertion instead of the login request itself.
        #[unsafe(method(loginRequestEncryptionPublicKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn loginRequestEncryptionPublicKey(&self) -> Option<Retained<SecKey>>;

        #[cfg(feature = "objc2-security")]
        /// Setter for [`loginRequestEncryptionPublicKey`][Self::loginRequestEncryptionPublicKey].
        #[unsafe(method(setLoginRequestEncryptionPublicKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLoginRequestEncryptionPublicKey(
            &self,
            login_request_encryption_public_key: Option<&SecKey>,
        );

        /// The APV prefix used for encrypted embedded login assertions.
        #[unsafe(method(loginRequestEncryptionAPVPrefix))]
        #[unsafe(method_family = none)]
        pub unsafe fn loginRequestEncryptionAPVPrefix(&self) -> Option<Retained<NSData>>;

        /// Setter for [`loginRequestEncryptionAPVPrefix`][Self::loginRequestEncryptionAPVPrefix].
        #[unsafe(method(setLoginRequestEncryptionAPVPrefix:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLoginRequestEncryptionAPVPrefix(
            &self,
            login_request_encryption_apv_prefix: Option<&NSData>,
        );

        /// The encryption algorithm to use for the embedded login assertion.
        #[unsafe(method(loginRequestEncryptionAlgorithm))]
        #[unsafe(method_family = none)]
        pub unsafe fn loginRequestEncryptionAlgorithm(
            &self,
        ) -> Retained<ASAuthorizationProviderExtensionEncryptionAlgorithm>;

        /// Setter for [`loginRequestEncryptionAlgorithm`][Self::loginRequestEncryptionAlgorithm].
        #[unsafe(method(setLoginRequestEncryptionAlgorithm:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLoginRequestEncryptionAlgorithm(
            &self,
            login_request_encryption_algorithm: &ASAuthorizationProviderExtensionEncryptionAlgorithm,
        );

        /// The PreSharedKey to be used for HKPE for embedded login assertions. Setting this value will change the mode to PSK if the loginRequestHPKEPreSharedKeyID is also set. Must be at least 32 bytes.
        #[unsafe(method(loginRequestHPKEPreSharedKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn loginRequestHPKEPreSharedKey(&self) -> Option<Retained<NSData>>;

        /// Setter for [`loginRequestHPKEPreSharedKey`][Self::loginRequestHPKEPreSharedKey].
        #[unsafe(method(setLoginRequestHPKEPreSharedKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLoginRequestHPKEPreSharedKey(
            &self,
            login_request_hpke_pre_shared_key: Option<&NSData>,
        );

        /// The PreSharedKey Id to be used for HPKE PSK for embedded login assertions.  This is required if the loginRequestHPKEPreSharedKey is set.
        #[unsafe(method(loginRequestHPKEPreSharedKeyID))]
        #[unsafe(method_family = none)]
        pub unsafe fn loginRequestHPKEPreSharedKeyID(&self) -> Option<Retained<NSData>>;

        /// Setter for [`loginRequestHPKEPreSharedKeyID`][Self::loginRequestHPKEPreSharedKeyID].
        #[unsafe(method(setLoginRequestHPKEPreSharedKeyID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLoginRequestHPKEPreSharedKeyID(
            &self,
            login_request_hpke_pre_shared_key_id: Option<&NSData>,
        );

        /// The url endpoint for key service, defaults to token tokenEndpointURL.
        #[unsafe(method(keyEndpointURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyEndpointURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`keyEndpointURL`][Self::keyEndpointURL].
        #[unsafe(method(setKeyEndpointURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setKeyEndpointURL(&self, key_endpoint_url: Option<&NSURL>);

        /// Custom values added to the key exchange POST request body.
        #[unsafe(method(customKeyExchangeRequestValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn customKeyExchangeRequestValues(&self) -> Retained<NSArray<NSURLQueryItem>>;

        /// Setter for [`customKeyExchangeRequestValues`][Self::customKeyExchangeRequestValues].
        #[unsafe(method(setCustomKeyExchangeRequestValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomKeyExchangeRequestValues(
            &self,
            custom_key_exchange_request_values: &NSArray<NSURLQueryItem>,
        );

        /// Sets custom claims to be added to the key exchange request header.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomKeyExchangeRequestHeaderClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomKeyExchangeRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Sets custom claims to be added to the key exchange request body.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomKeyExchangeRequestBodyClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomKeyExchangeRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Custom values added to the key request POST request body.
        #[unsafe(method(customKeyRequestValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn customKeyRequestValues(&self) -> Retained<NSArray<NSURLQueryItem>>;

        /// Setter for [`customKeyRequestValues`][Self::customKeyRequestValues].
        #[unsafe(method(setCustomKeyRequestValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomKeyRequestValues(
            &self,
            custom_key_request_values: &NSArray<NSURLQueryItem>,
        );

        /// Sets custom claims to be added to the key request header.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomKeyRequestHeaderClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomKeyRequestHeaderClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Sets custom claims to be added to the key request body.
        ///
        /// Parameter `claims`: The claims to be added. It must serialize as valid JSON to be accepted.
        ///
        /// Parameter `error`: Nil or an NSError indicating why the claims were rejected.
        ///
        /// Returns: YES when successful and NO when claims are rejected.
        #[unsafe(method(setCustomKeyRequestBodyClaims:returningError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomKeyRequestBodyClaims_returningError(
            &self,
            claims: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// The PreSharedKey to be used for HKPE. Setting this value will change the mode to PSK or AuthPSK if the hpkeAuthPublicKey is also set. Must be at least 32 bytes.
        #[unsafe(method(hpkePreSharedKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn hpkePreSharedKey(&self) -> Option<Retained<NSData>>;

        /// Setter for [`hpkePreSharedKey`][Self::hpkePreSharedKey].
        #[unsafe(method(setHpkePreSharedKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHpkePreSharedKey(&self, hpke_pre_shared_key: Option<&NSData>);

        /// The PreSharedKey Id to be used for HPKE PSK or AuthPSK mode.  This is requred if the hpkePreSharedKey is set.
        #[unsafe(method(hpkePreSharedKeyID))]
        #[unsafe(method_family = none)]
        pub unsafe fn hpkePreSharedKeyID(&self) -> Option<Retained<NSData>>;

        /// Setter for [`hpkePreSharedKeyID`][Self::hpkePreSharedKeyID].
        #[unsafe(method(setHpkePreSharedKeyID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHpkePreSharedKeyID(&self, hpke_pre_shared_key_id: Option<&NSData>);

        #[cfg(feature = "objc2-security")]
        /// The Authentication public key to be used for HPKE.  Setting this value with changet the mode to Auth or AuthPSK if the hpkePreSharedKey is also set.  This public key is used to authenticate HPKE responses.
        #[unsafe(method(hpkeAuthPublicKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn hpkeAuthPublicKey(&self) -> Option<Retained<SecKey>>;

        #[cfg(feature = "objc2-security")]
        /// Setter for [`hpkeAuthPublicKey`][Self::hpkeAuthPublicKey].
        #[unsafe(method(setHpkeAuthPublicKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHpkeAuthPublicKey(&self, hpke_auth_public_key: Option<&SecKey>);
    );
}
