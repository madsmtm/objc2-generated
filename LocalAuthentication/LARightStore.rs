//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A container for data protected by a right.
    ///
    /// ## Overview
    ///
    /// Use an [`LARightStore`](https://developer.apple.com/documentation/localauthentication/larightstore) along with an [`LARight`](https://developer.apple.com/documentation/localauthentication/laright) to make secrets accessible only after certain conditions, including authentication, are met. Storing secrets this way lets you tie the availability of sensitive resources to the authorization status of the user.
    ///
    /// The following stores a named access token behind the default authorization requirements:
    ///
    /// ```swift
    /// func storeBackendAccessToken(_ token: Data) async throws {
    ///     let loginRight = LARight()
    ///     _ = try await LARightStore.shared.saveRight(loginRight, identifier: "access-token", secret: token)
    /// }
    /// ```
    ///
    /// The system stores your secret in the keychain and protects it with a unique key in the Secure Enclave. The system associates the key with your right and with an access control list that ensures that the data is only accessible after your access requirements are met.
    ///
    /// You can retrieve stored secrets later using the rightâ€™s identifier:
    ///
    /// ```swift
    /// func fetchBackendAccessToken() async throws -> Data {
    ///     let loginRight = try await LARightStore.shared.right(forIdentifier: "access-token")
    ///
    ///     // Authorize the right or else the secret is unavailable.
    ///     try await loginRight.authorize(localizedReason: "Access sandcastle competition server")
    ///     return try await loginRight.secret.rawData
    /// }
    /// ```
    ///
    ///
    /// Persistent storage for
    /// `LARight`instances.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct LARightStore;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for LARightStore {}
);

impl LARightStore {
    extern_methods!(
        /// Shared instance of
        /// `LARightStore.`
        #[unsafe(method(sharedStore))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedStore() -> Retained<LARightStore>;

        #[cfg(all(feature = "LAPersistedRight", feature = "LARight", feature = "block2"))]
        /// Fetches a right stored under the given identifier.
        ///
        /// Parameter `identifier`: Identifier associated with a previously stored right.
        ///
        /// Parameter `handler`: Completion handler with the fetched right or an error on failure.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(rightForIdentifier:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightForIdentifier_completion(
            &self,
            identifier: &NSString,
            handler: &block2::DynBlock<dyn Fn(*mut LAPersistedRight, *mut NSError)>,
        );

        #[cfg(all(feature = "LAPersistedRight", feature = "LARight", feature = "block2"))]
        /// Persists a right for later usage.
        ///
        /// Parameter `right`: `LARight`instance to store.
        ///
        /// Parameter `identifier`: Identifier to be associated with the right. Useful for later retrieval.
        ///
        /// Parameter `handler`: Completion handler with the persisted right or an error on failure.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(saveRight:identifier:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveRight_identifier_completion(
            &self,
            right: &LARight,
            identifier: &NSString,
            handler: &block2::DynBlock<dyn Fn(*mut LAPersistedRight, *mut NSError)>,
        );

        #[cfg(all(feature = "LAPersistedRight", feature = "LARight", feature = "block2"))]
        /// Persists a right for later usage.
        ///
        /// Parameter `right`: `LARight`instance to store.
        ///
        /// Parameter `identifier`: Identifier to be associated with the right. Useful for later retrieval.
        ///
        /// Parameter `secret`: Secret data to be associated with the provided right.
        ///
        /// Parameter `handler`: Completion handler with the persisted right or an error on failure.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(saveRight:identifier:secret:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveRight_identifier_secret_completion(
            &self,
            right: &LARight,
            identifier: &NSString,
            secret: &NSData,
            handler: &block2::DynBlock<dyn Fn(*mut LAPersistedRight, *mut NSError)>,
        );

        #[cfg(all(feature = "LAPersistedRight", feature = "LARight", feature = "block2"))]
        /// Removes a right from the persistent storage along with its associated resources.
        ///
        /// Parameter `right`: `LAPersistedRight`instance to remove.
        ///
        /// Parameter `handler`: Completion handler with an error on failure.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(removeRight:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeRight_completion(
            &self,
            right: &LAPersistedRight,
            handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Removes right with provided identifier from persistant storage.
        ///
        /// Parameter `identifier`: Identifier of
        /// `LAPersistedRight`instance to remove.
        ///
        /// Parameter `handler`: Completion handler with an error on failure.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(removeRightForIdentifier:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeRightForIdentifier_completion(
            &self,
            identifier: &NSString,
            handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Removes all rights stored by the client
        ///
        /// Parameter `handler`: Completion handler with an error on failure.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(removeAllRightsWithCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAllRightsWithCompletion(
            &self,
            handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// Clients should rely on the
        /// `shared`instance instead
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Clients should rely on the
        /// `shared`instance instead
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}
