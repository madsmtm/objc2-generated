//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// This class represents a file on an ICCameraDevice object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/imagecapturecore/iccamerafile?language=objc)
    #[unsafe(super(ICCameraItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "ICCameraItem")]
    pub struct ICCameraFile;
);

#[cfg(feature = "ICCameraItem")]
extern_conformance!(
    unsafe impl NSObjectProtocol for ICCameraFile {}
);

#[cfg(feature = "ICCameraItem")]
impl ICCameraFile {
    extern_methods!(
        /// Width of an image or movie frame.
        #[unsafe(method(width))]
        #[unsafe(method_family = none)]
        pub unsafe fn width(&self) -> NSInteger;

        /// Height of an image or movie frame.
        #[unsafe(method(height))]
        #[unsafe(method_family = none)]
        pub unsafe fn height(&self) -> NSInteger;

        /// Original filename on disk
        #[unsafe(method(originalFilename))]
        #[unsafe(method_family = none)]
        pub unsafe fn originalFilename(&self) -> Option<Retained<NSString>>;

        /// Created filename
        #[unsafe(method(createdFilename))]
        #[unsafe(method_family = none)]
        pub unsafe fn createdFilename(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "libc")]
        /// ￼Size of file in bytes.
        #[unsafe(method(fileSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileSize(&self) -> libc::off_t;

        #[cfg(feature = "ImageCaptureConstants")]
        /// ￼Desired orientation of image to use when it is downloaded.
        ///
        /// This property is set to ICEXIFOrientation1 initially. If the format of this file supports EXIF orientation tag, then this property will be updated to match the value of that tag, when the thumbnail or metadata for this file is received.
        #[unsafe(method(orientation))]
        #[unsafe(method_family = none)]
        pub unsafe fn orientation(&self) -> ICEXIFOrientationType;

        #[cfg(feature = "ImageCaptureConstants")]
        /// Setter for [`orientation`][Self::orientation].
        #[unsafe(method(setOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOrientation(&self, orientation: ICEXIFOrientationType);

        /// ￼Duration of audio/video file in seconds.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> c_double;

        /// True if file is a slo-mo or high framerate video file, nil otherwise.
        #[unsafe(method(highFramerate))]
        #[unsafe(method_family = none)]
        pub unsafe fn highFramerate(&self) -> bool;

        /// True if file is a time-lapse video file, nil otherwise.
        #[unsafe(method(timeLapse))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeLapse(&self) -> bool;

        /// True if file is a firstPicked nil otherwise.
        #[unsafe(method(firstPicked))]
        #[unsafe(method_family = none)]
        pub unsafe fn firstPicked(&self) -> bool;

        /// originatingAssetID of file if present, nil if not a HEIF or HVEC.
        #[unsafe(method(originatingAssetID))]
        #[unsafe(method_family = none)]
        pub unsafe fn originatingAssetID(&self) -> Option<Retained<NSString>>;

        /// groupUUID of file if present, nil if file has no groupUUID.
        #[unsafe(method(groupUUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn groupUUID(&self) -> Option<Retained<NSString>>;

        /// GPS String in standard format.
        #[unsafe(method(gpsString))]
        #[unsafe(method_family = none)]
        pub unsafe fn gpsString(&self) -> Option<Retained<NSString>>;

        /// Internal related UUID for dbg/aae/etc.
        #[unsafe(method(relatedUUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn relatedUUID(&self) -> Option<Retained<NSString>>;

        /// burstUUID of file if present, nil if not in a burst.
        #[unsafe(method(burstUUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn burstUUID(&self) -> Option<Retained<NSString>>;

        /// True if burst favorite, ignored if not in a burst or not a burst favorite.
        #[unsafe(method(burstFavorite))]
        #[unsafe(method_family = none)]
        pub unsafe fn burstFavorite(&self) -> bool;

        /// True if burst user picked, ignored if not in a burst or not a burst user picked.
        #[unsafe(method(burstPicked))]
        #[unsafe(method_family = none)]
        pub unsafe fn burstPicked(&self) -> bool;

        /// This property is NULL if there are no sidecar files associated with this file. Otherwise it is an array of
        /// ICCameraFile instances of sidecar files associated with this file. An example of a sidecar file is a file with the same base
        /// name as this file and having an extension XMP.
        #[unsafe(method(sidecarFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn sidecarFiles(&self) -> Option<Retained<NSArray<ICCameraItem>>>;

        /// A single item subset of the sidecarFiles array, which contains the logical RAW compliment of a JPG or other
        /// format image.
        #[unsafe(method(pairedRawImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn pairedRawImage(&self) -> Option<Retained<ICCameraFile>>;

        /// Properties will either represent the actual file creation
        /// date, or nil.
        #[unsafe(method(fileCreationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileCreationDate(&self) -> Option<Retained<NSDate>>;

        /// Properties will either represent the actual file modification
        /// date, or nil.
        #[unsafe(method(fileModificationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileModificationDate(&self) -> Option<Retained<NSDate>>;

        /// Properties will either represent the exif creation
        /// date, or nil.
        #[unsafe(method(exifCreationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn exifCreationDate(&self) -> Option<Retained<NSDate>>;

        /// Properties will either represent the exif modification
        /// date, or nil.
        #[unsafe(method(exifModificationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn exifModificationDate(&self) -> Option<Retained<NSDate>>;

        /// A fingerprint generated from the camera file data
        /// date, or nil.
        #[unsafe(method(fingerprint))]
        #[unsafe(method_family = none)]
        pub unsafe fn fingerprint(&self) -> Option<Retained<NSString>>;

        /// Generates a fingerprint given a URL
        /// date, or nil.
        #[unsafe(method(fingerprintForFileAtURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fingerprintForFileAtURL(url: &NSURL) -> Option<Retained<NSString>>;

        #[cfg(feature = "block2")]
        /// ￼Perform a thumbnail request and execute the block callback in place of the delegate.
        ///
        /// Parameter `options`: Options dictionary
        ///
        /// - 'kCGImageSourceThumbnailMaxPixelSize' - Request a width different from the embedded EXIF thumbnail
        ///
        ///
        /// Parameter `completion`: Completion block called with an NSData* object representing the JPG, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(requestThumbnailDataWithOptions:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestThumbnailDataWithOptions_completion(
            &self,
            options: Option<&NSDictionary<ICCameraItemThumbnailOption, AnyObject>>,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Perform a metadata request and execute the block callback in place of the delegate.
        ///
        /// Parameter `options`: Options dictionary
        ///
        /// Parameter `completion`: Completion block called with an NSDictionary* object containing the metadata, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(requestMetadataDictionaryWithOptions:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestMetadataDictionaryWithOptions_completion(
            &self,
            options: Option<&NSDictionary<ICCameraItemMetadataOption, AnyObject>>,
            completion: &block2::DynBlock<dyn Fn(*mut NSDictionary, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Perform a download request and execute the block callback in place of the delegate.
        ///
        /// Parameter `options`: Dictionary Keys:
        ///
        /// - `ICDownloadsDirectoryURL`
        /// - `ICSaveAsFilename`
        /// - `ICOverwriteExistingFile`
        /// - `ICDeleteAfterDownload`
        /// - `ICAdjustCreationDate`
        ///
        ///
        /// Parameter `completion`: Completion block to executed after request has returned,
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(requestDownloadWithOptions:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestDownloadWithOptions_completion(
            &self,
            options: Option<&NSDictionary<ICDownloadOption, AnyObject>>,
            completion: &block2::DynBlock<dyn Fn(*mut NSString, *mut NSError)>,
        ) -> Option<Retained<NSProgress>>;

        #[cfg(all(feature = "block2", feature = "libc"))]
        /// This method asynchronously reads data of a specified length from a specified offset.
        ///
        /// Parameter `offset`: The offset into the file to start reading from
        ///
        /// Parameter `length`: The length of data to be read.
        ///
        /// Parameter `completion`: Completion block called with an NSData* object representing the data, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[unsafe(method(requestReadDataAtOffset:length:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestReadDataAtOffset_length_completion(
            &self,
            offset: libc::off_t,
            length: libc::off_t,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Requests a security scoped NSURL* for a media file on a mass storage volume. The returned NSURL* requires the use of
        /// startAccessingSecurityScopedResource, and stopAccessingSecurityScopedResource for access.
        ///
        /// Parameter `completion`: Completion block called with an NSURL*, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[unsafe(method(requestSecurityScopedURLWithCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestSecurityScopedURLWithCompletion(
            &self,
            completion: &block2::DynBlock<dyn Fn(*mut NSURL, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// ￼Requests a fingerprint be generated for camera file.
        ///
        /// Parameter `completion`: Completion block called with an NSString*, and an NSError* for status.
        ///
        /// Note: The completion block will execute on an any available queue, often this will not be the main queue.
        #[unsafe(method(requestFingerprintWithCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestFingerprintWithCompletion(
            &self,
            completion: &block2::DynBlock<dyn Fn(*mut NSString, *mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "ICCameraItem")]
impl ICCameraFile {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
