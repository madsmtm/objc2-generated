//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Constants that define the type of navigation controller transitions that can occur.
/// UINavigationController manages a stack of view controllers and a navigation bar.
/// It performs horizontal view transitions for pushed and popped views while keeping the navigation bar in sync.
///
/// Most clients will not need to subclass UINavigationController.
///
/// If a navigation controller is nested in a tab bar controller, it uses the title and toolbar attributes of the bottom view controller on the stack.
///
/// UINavigationController is rotatable if its top view controller is rotatable.
/// Navigation between controllers with non-uniform rotatability is currently not supported.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UINavigationControllerOperation(pub NSInteger);
impl UINavigationControllerOperation {
    /// A constant that indicates no operation is taking place.
    #[doc(alias = "UINavigationControllerOperationNone")]
    pub const None: Self = Self(0);
    /// A constant that indicates a view controller is being pushed onto the navigation stack.
    #[doc(alias = "UINavigationControllerOperationPush")]
    pub const Push: Self = Self(1);
    /// A constant that indicates the topmost view controller is being removed from the navigation stack.
    #[doc(alias = "UINavigationControllerOperationPop")]
    pub const Pop: Self = Self(2);
}

unsafe impl Encode for UINavigationControllerOperation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UINavigationControllerOperation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A variable that specifies the duration when animating the navigation bar.
    ///
    /// ## Discussion
    ///
    /// Note that this is a constant value, so it can’t be set.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static UINavigationControllerHideShowBarDuration: CGFloat;
}

extern_class!(
    /// A container view controller that defines a stack-based scheme for navigating hierarchical content.
    ///
    /// ## Overview
    ///
    /// A navigation controller is a container view controller that manages one or more contained view controllers in a navigation interface. In this type of interface, only one contained view controller is visible at a time. Selecting an item in the view controller pushes a new view controller onscreen using an animation, hiding the previous view controller. Tapping the back button in the navigation bar at the top of the interface removes the top view controller, thereby revealing the view controller underneath.
    ///
    /// Use a navigation interface to mimic the organization of hierarchical data managed by your app. At each level of the hierarchy, you provide an appropriate screen (managed by a custom view controller) to display the content at that level. The following image shows an example of the navigation interface presented by the Settings application in a simulated iOS device. The first screen presents the user with the list of groups that organize preferences. Selecting a group reveals individual settings and groups of settings for that application. For all but the root view, the navigation controller provides a back button to allow the user to move back up the hierarchy.
    ///
    ///
    /// ![A sample navigation interface](https://docs-assets.developer.apple.com/published/ec22a982d6cb1673c1190305d79cb382/media-1965789%402x.png)
    ///
    ///
    /// A navigation controller object manages the view controllers it contains using an ordered array, known as the _navigation stack_. The first view controller in the array is the root view controller and represents the bottom of the stack. The last view controller in the array is the topmost item on the stack, and represents the view controller that the system is currently displaying. You add and remove view controllers from the stack using segues or using the methods of this class. The user can also remove the topmost view controller using the back button in the navigation bar or using a swipe gesture.
    ///
    /// The navigation controller manages the navigation bar at the top of the interface and an optional toolbar at the bottom of the interface. The navigation bar is always present and is managed by the navigation controller itself, which updates the navigation bar using the content provided by its contained view controllers. When the [`toolbarHidden`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/istoolbarhidden) property is [`false`](https://developer.apple.com/documentation/swift/false), the navigation controller similarly updates the toolbar with contents provided by the topmost view controller.
    ///
    /// A navigation controller coordinates its behavior with its [`delegate`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/delegate) object. The delegate object can override the pushing or popping of view controllers, provide custom animation transitions, and specify the preferred orientation for the navigation interface. The delegate object you provide must conform to the [`UINavigationControllerDelegate`](https://developer.apple.com/documentation/uikit/uinavigationcontrollerdelegate) protocol.
    ///
    /// The following image shows the relationships between the navigation controller and the objects it manages. Use the specified properties of the navigation controller to access these objects.
    ///
    ///
    /// ![Diagram of objects managed by the navigation controller.](https://docs-assets.developer.apple.com/published/743ee76b71b9c1cc86c8e691d6bb17b7/media-1965791.jpg)
    ///
    ///
    /// ### Navigation controller views
    ///
    /// A navigation controller is a container view controller — that is, it embeds the content of other view controllers inside of itself. You access a navigation controller’s view from its [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property. This view incorporates the navigation bar, an optional toolbar, and the content view corresponding to the topmost view controller. The following image shows how these views assemble to present the overall navigation interface. In this figure, the navigation interface is further embedded inside a tab bar interface. Although the content of the navigation bar and toolbar views changes, the views themselves don’t. The only view that actually changes is the custom content view provided by the topmost view controller on the navigation stack.
    ///
    ///
    /// ![The views of a navigation controller](https://docs-assets.developer.apple.com/published/aaa68d2967e5dacf95bed1c774852347/media-1965793%402x.png)
    ///
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Because the content view underlaps the navigation bar, consider that space when designing your view controller content.
    ///
    ///
    ///
    /// </div>
    /// The navigation controller manages the creation, configuration, and display of the navigation bar and optional navigation toolbar. Don’t change the navigation bar’s [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame), [`bounds`](https://developer.apple.com/documentation/uikit/uiview/bounds), or [`alpha`](https://developer.apple.com/documentation/uikit/uiview/alpha) values directly. If you subclass [`UINavigationBar`](https://developer.apple.com/documentation/uikit/uinavigationbar), initialize your navigation controller using the [`initWithNavigationBarClass:toolbarClass:`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/init(navigationbarclass:toolbarclass:)) method. To hide or show the navigation bar, use the [`navigationBarHidden`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/isnavigationbarhidden) property or [`setNavigationBarHidden:animated:`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/setnavigationbarhidden(_:animated:)) method.
    ///
    /// A navigation controller builds the contents of the navigation bar dynamically using the navigation item objects (instances of the [`UINavigationItem`](https://developer.apple.com/documentation/uikit/uinavigationitem) class) associated with the view controllers on the navigation stack. To change the contents of the navigation bar, configure the navigation items of your custom view controllers. For more information about navigation items, see [`UINavigationItem`](https://developer.apple.com/documentation/uikit/uinavigationitem).
    ///
    /// <div class="warning">
    ///
    /// ### Tip
    /// Avoid using custom backgrounds and [`UIAppearance`](https://developer.apple.com/documentation/uikit/uiappearance) APIs to prevent interfering with Liquid Glass in your navigation bar.
    ///
    ///
    ///
    /// </div>
    /// ### Updating the navigation bar
    ///
    /// Each time the top-level view controller changes, the navigation controller updates the navigation bar accordingly. Specifically, the navigation controller updates the bar button items displayed in each of the three navigation bar positions: left, middle, and right. Bar button items are instances of the [`UIBarButtonItem`](https://developer.apple.com/documentation/uikit/uibarbuttonitem) class. You can create items with custom content or create standard system items depending on your needs.
    ///
    /// When your navigation bar displays with Liquid Glass, don’t add a background or apply a tint color. Add color to the text or image in a bar button item with [`tintColor`](https://developer.apple.com/documentation/uikit/uibarbuttonitem/tintcolor). To add color to the background of a bar button item, set the [`style`](https://developer.apple.com/documentation/uikit/uibarbuttonitem/style-swift.property) to [`UIBarButtonItemStyleProminent`](https://developer.apple.com/documentation/uikit/uibarbuttonitem/style-swift.enum/prominent).
    ///
    /// For more information about the navigation bar, see [`UINavigationBar`](https://developer.apple.com/documentation/uikit/uinavigationbar). For more information about how to create bar button items, see [`UIBarButtonItem`](https://developer.apple.com/documentation/uikit/uibarbuttonitem).
    ///
    /// #### The left item
    ///
    /// For all but the root view controller on the navigation stack, the item on the left side of the navigation bar provides navigation back to the previous view controller. The contents of this left-most button are determined as follows:
    ///
    /// - If the new top-level view controller has a custom left bar button item, that item is displayed. To specify a custom left bar button item, set the [`leftBarButtonItem`](https://developer.apple.com/documentation/uikit/uinavigationitem/leftbarbuttonitem) property of the view controller’s navigation item.
    ///
    /// - If the top-level view controller doesn’t have a custom left bar button item, but the navigation item of the previous view controller has an object in its [`backBarButtonItem`](https://developer.apple.com/documentation/uikit/uinavigationitem/backbarbuttonitem) property, the navigation bar displays that item.
    ///
    /// - If a custom bar button item isn’t specified by either of the view controllers, the system uses a default back button that displays a back image.
    ///
    /// - If there’s only one view controller on the navigation stack, it doesn’t display a back button.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  In cases where the title of a back button is too long to fit in the available space, the navigation bar may substitute the string “Back” for the actual button title. The navigation bar does this only if the back button is provided by the previous view controller. If the new top-level view controller has a custom left-bar button item — an object in the [`leftBarButtonItem`](https://developer.apple.com/documentation/uikit/uinavigationitem/leftbarbuttonitem) or [`leftBarButtonItems`](https://developer.apple.com/documentation/uikit/uinavigationitem/leftbarbuttonitems) property of its navigation item — the navigation bar doesn’t change the button title.
    ///
    ///
    ///
    /// </div>
    /// #### The middle item
    ///
    /// The navigation controller updates the middle of the navigation bar as follows:
    ///
    /// - If the new top-level view controller has a custom title view, the navigation bar displays that view in place of the default title view. To specify a custom title view, set the [`titleView`](https://developer.apple.com/documentation/uikit/uinavigationitem/titleview) property of the view controller’s navigation item.
    ///
    /// - If no custom title view is set, the navigation bar displays a label containing the view controller’s default title. The string for this label is usually obtained from the [`title`](https://developer.apple.com/documentation/uikit/uiviewcontroller/title) property of the view controller itself. If you want to display a different title than the one associated with the view controller, set the [`title`](https://developer.apple.com/documentation/uikit/uiviewcontroller/title) property of the view controller’s navigation item instead.
    ///
    /// #### The right item
    ///
    /// The navigation controller updates the right side of the navigation bar as follows:
    ///
    /// - If the new top-level view controller has custom right bar button items, it displays those items. To specify a custom right-bar button item or items, set the [`rightBarButtonItem`](https://developer.apple.com/documentation/uikit/uinavigationitem/rightbarbuttonitem) or [`rightBarButtonItems`](https://developer.apple.com/documentation/uikit/uinavigationitem/rightbarbuttonitems) property of the view controller’s navigation item.
    ///
    /// - If the view controller doesn’t have any custom right-bar button items, the navigation bar doesn’t display anything on the right side of the bar.
    ///
    /// ### Displaying a toolbar
    ///
    /// A navigation controller object manages an optional toolbar in its view hierarchy. When displayed, this toolbar obtains its current set of items from the [`toolbarItems`](https://developer.apple.com/documentation/uikit/uiviewcontroller/toolbaritems) property of the active view controller. When the active view controller changes, the navigation controller updates the toolbar items to match the new view controller, animating the new items into position when appropriate.
    ///
    /// The navigation toolbar is hidden by default but you can show it for your navigation interface by calling the [`setToolbarHidden:animated:`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/settoolbarhidden(_:animated:)) method of your navigation controller object. If not all of your view controllers support toolbar items, your delegate object can call this method to toggle the visibility of the toolbar during subsequent push and pop operations. To use a custom [`UIToolbar`](https://developer.apple.com/documentation/uikit/uitoolbar) subclass, initialize the navigation controller using the [`initWithNavigationBarClass:toolbarClass:`](https://developer.apple.com/documentation/uikit/uinavigationcontroller/init(navigationbarclass:toolbarclass:)) method. If you use custom toolbar and navigation bar subclasses to create a navigation controller, note that you’re responsible for pushing and setting view controllers before presenting the navigation controller onscreen.
    ///
    /// ### Adapting to different environments
    ///
    /// The navigation interface remains the same in both horizontally compact and horizontally regular environments. When toggling between the two environments, only the size of the navigation controller’s view changes. The navigation controller doesn’t change its view hierarchy or the layout of its views.
    ///
    /// When configuring segues between view controllers on a navigation stack, the standard Show and Show Detail segues behave as follows:
    ///
    /// - Show segue: The navigation controller pushes the specified view controller onto its navigation stack.
    ///
    /// - Show Detail segue: The navigation controller presents the specified view controller modally.
    ///
    /// The behaviors of other segue types are unchanged.
    ///
    /// ### Interface behaviors
    ///
    /// A navigation controller supports the following behaviors for its interface:
    ///
    /// - Supported interface orientations: A navigation controller object doesn’t consult the view controllers on its navigation stack when determining the supported interface orientations. On iPhone, a navigation controller supports all orientations except portrait upside-down. On iPad, a navigation controller supports all orientations. If the navigation controller has a delegate object, the delegate can specify a different set of supported orientations using the [`navigationControllerSupportedInterfaceOrientations:`](https://developer.apple.com/documentation/uikit/uinavigationcontrollerdelegate/navigationcontrollersupportedinterfaceorientations(_:)) method.
    ///
    /// - Presentation context: A navigation controller defines the presentation context for modally presented view controllers. When the modal transition style is [`UIModalPresentationCurrentContext`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/currentcontext) or [`UIModalPresentationOverCurrentContext`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/overcurrentcontext), modal presentations from the view controllers in the navigation stack cover the entire navigation interface.
    ///
    /// ### State preservation
    ///
    /// When you assign a value to a navigation controller’s [`restorationIdentifier`](https://developer.apple.com/documentation/uikit/uiviewcontroller/restorationidentifier) property, it attempts to preserve itself and the contained view controllers on its navigation stack. The navigation controller starts at the bottom of the stack and moves upward, encoding each view controller that also has a valid restoration identifier string. During the next launch cycle, the navigation controller restores the preserved view controllers to the navigation stack in the same order that they were preserved.
    ///
    /// The view controllers you push onto the navigation stack may use the same restoration identifiers. The navigation controller automatically stores additional information to ensure that each view controller’s restoration path is unique.
    ///
    /// For more information about how state preservation and restoration works, see [Preserving your app’s UI across launches](https://developer.apple.com/documentation/uikit/preserving-your-app-s-ui-across-launches).
    ///
    ///
    #[unsafe(super(UIViewController, UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
    pub struct UINavigationController;
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl NSCoding for UINavigationController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for UINavigationController {}
);

#[cfg(all(
    feature = "UIAppearance",
    feature = "UIResponder",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UINavigationController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl UIContentContainer for UINavigationController {}
);

#[cfg(all(
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UINavigationController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UINavigationController {}
);

#[cfg(all(
    feature = "UIResponder",
    feature = "UITraitCollection",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UITraitEnvironment for UINavigationController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UINavigationController {
    extern_methods!(
        /// # Safety
        ///
        /// - `navigation_bar_class` probably has further requirements.
        /// - `toolbar_class` probably has further requirements.
        #[unsafe(method(initWithNavigationBarClass:toolbarClass:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNavigationBarClass_toolbarClass(
            this: Allocated<Self>,
            navigation_bar_class: Option<&AnyClass>,
            toolbar_class: Option<&AnyClass>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithRootViewController:))]
        #[unsafe(method_family = init)]
        pub fn initWithRootViewController(
            this: Allocated<Self>,
            root_view_controller: &UIViewController,
        ) -> Retained<Self>;

        #[unsafe(method(initWithNibName:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithNibName_bundle(
            this: Allocated<Self>,
            nib_name_or_nil: Option<&NSString>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(pushViewController:animated:))]
        #[unsafe(method_family = none)]
        pub fn pushViewController_animated(
            &self,
            view_controller: &UIViewController,
            animated: bool,
        );

        #[unsafe(method(popViewControllerAnimated:))]
        #[unsafe(method_family = none)]
        pub fn popViewControllerAnimated(
            &self,
            animated: bool,
        ) -> Option<Retained<UIViewController>>;

        #[unsafe(method(popToViewController:animated:))]
        #[unsafe(method_family = none)]
        pub fn popToViewController_animated(
            &self,
            view_controller: &UIViewController,
            animated: bool,
        ) -> Option<Retained<NSArray<UIViewController>>>;

        #[unsafe(method(popToRootViewControllerAnimated:))]
        #[unsafe(method_family = none)]
        pub fn popToRootViewControllerAnimated(
            &self,
            animated: bool,
        ) -> Option<Retained<NSArray<UIViewController>>>;

        #[unsafe(method(topViewController))]
        #[unsafe(method_family = none)]
        pub fn topViewController(&self) -> Option<Retained<UIViewController>>;

        #[unsafe(method(visibleViewController))]
        #[unsafe(method_family = none)]
        pub fn visibleViewController(&self) -> Option<Retained<UIViewController>>;

        #[unsafe(method(viewControllers))]
        #[unsafe(method_family = none)]
        pub fn viewControllers(&self) -> Retained<NSArray<UIViewController>>;

        /// Setter for [`viewControllers`][Self::viewControllers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setViewControllers:))]
        #[unsafe(method_family = none)]
        pub fn setViewControllers(&self, view_controllers: &NSArray<UIViewController>);

        #[unsafe(method(setViewControllers:animated:))]
        #[unsafe(method_family = none)]
        pub fn setViewControllers_animated(
            &self,
            view_controllers: &NSArray<UIViewController>,
            animated: bool,
        );

        #[unsafe(method(isNavigationBarHidden))]
        #[unsafe(method_family = none)]
        pub fn isNavigationBarHidden(&self) -> bool;

        /// Setter for [`isNavigationBarHidden`][Self::isNavigationBarHidden].
        #[unsafe(method(setNavigationBarHidden:))]
        #[unsafe(method_family = none)]
        pub fn setNavigationBarHidden(&self, navigation_bar_hidden: bool);

        #[unsafe(method(setNavigationBarHidden:animated:))]
        #[unsafe(method_family = none)]
        pub fn setNavigationBarHidden_animated(&self, hidden: bool, animated: bool);

        #[cfg(all(feature = "UINavigationBar", feature = "UIView"))]
        #[unsafe(method(navigationBar))]
        #[unsafe(method_family = none)]
        pub fn navigationBar(&self) -> Retained<UINavigationBar>;

        #[unsafe(method(isToolbarHidden))]
        #[unsafe(method_family = none)]
        pub fn isToolbarHidden(&self) -> bool;

        /// Setter for [`isToolbarHidden`][Self::isToolbarHidden].
        #[unsafe(method(setToolbarHidden:))]
        #[unsafe(method_family = none)]
        pub fn setToolbarHidden(&self, toolbar_hidden: bool);

        #[unsafe(method(setToolbarHidden:animated:))]
        #[unsafe(method_family = none)]
        pub fn setToolbarHidden_animated(&self, hidden: bool, animated: bool);

        #[cfg(all(feature = "UIToolbar", feature = "UIView"))]
        #[unsafe(method(toolbar))]
        #[unsafe(method_family = none)]
        pub fn toolbar(&self) -> Option<Retained<UIToolbar>>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UINavigationControllerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn UINavigationControllerDelegate>>,
        );

        #[cfg(feature = "UIGestureRecognizer")]
        /// The interactive pop gesture recognizes on the leading screen edge and initiates an interactive pop.
        /// This property should only be used to set up failure requirements with it.
        #[unsafe(method(interactivePopGestureRecognizer))]
        #[unsafe(method_family = none)]
        pub fn interactivePopGestureRecognizer(&self) -> Option<Retained<UIGestureRecognizer>>;

        #[cfg(feature = "UIGestureRecognizer")]
        /// The interactive content pop gesture recognizes on the entire content area of the navigation controller
        /// in cases that are not covered by the interactive pop gesture recognizer and initiates an interactive pop.
        /// This property should only be used to set up failure requirements with it.
        #[unsafe(method(interactiveContentPopGestureRecognizer))]
        #[unsafe(method_family = none)]
        pub fn interactiveContentPopGestureRecognizer(
            &self,
        ) -> Option<Retained<UIGestureRecognizer>>;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(showViewController:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showViewController_sender(
            &self,
            vc: &UIViewController,
            sender: Option<&AnyObject>,
        );

        /// When the keyboard appears, the navigation controller's navigationBar toolbar will be hidden. The bars will remain hidden when the keyboard dismisses, but a tap in the content area will show them.
        #[unsafe(method(hidesBarsWhenKeyboardAppears))]
        #[unsafe(method_family = none)]
        pub fn hidesBarsWhenKeyboardAppears(&self) -> bool;

        /// Setter for [`hidesBarsWhenKeyboardAppears`][Self::hidesBarsWhenKeyboardAppears].
        #[unsafe(method(setHidesBarsWhenKeyboardAppears:))]
        #[unsafe(method_family = none)]
        pub fn setHidesBarsWhenKeyboardAppears(&self, hides_bars_when_keyboard_appears: bool);

        /// When the user swipes, the navigation controller's navigationBar
        /// &
        /// toolbar will be hidden (on a swipe up) or shown (on a swipe down). The toolbar only participates if it has items.
        #[unsafe(method(hidesBarsOnSwipe))]
        #[unsafe(method_family = none)]
        pub fn hidesBarsOnSwipe(&self) -> bool;

        /// Setter for [`hidesBarsOnSwipe`][Self::hidesBarsOnSwipe].
        #[unsafe(method(setHidesBarsOnSwipe:))]
        #[unsafe(method_family = none)]
        pub fn setHidesBarsOnSwipe(&self, hides_bars_on_swipe: bool);

        #[cfg(all(feature = "UIGestureRecognizer", feature = "UIPanGestureRecognizer"))]
        /// The gesture recognizer that triggers if the bars will hide or show due to a swipe. Do not change the delegate or attempt to replace this gesture by overriding this method.
        #[unsafe(method(barHideOnSwipeGestureRecognizer))]
        #[unsafe(method_family = none)]
        pub fn barHideOnSwipeGestureRecognizer(&self) -> Retained<UIPanGestureRecognizer>;

        /// When the UINavigationController's vertical size class is compact, hide the UINavigationBar and UIToolbar. Unhandled taps in the regions that would normally be occupied by these bars will reveal the bars.
        #[unsafe(method(hidesBarsWhenVerticallyCompact))]
        #[unsafe(method_family = none)]
        pub fn hidesBarsWhenVerticallyCompact(&self) -> bool;

        /// Setter for [`hidesBarsWhenVerticallyCompact`][Self::hidesBarsWhenVerticallyCompact].
        #[unsafe(method(setHidesBarsWhenVerticallyCompact:))]
        #[unsafe(method_family = none)]
        pub fn setHidesBarsWhenVerticallyCompact(&self, hides_bars_when_vertically_compact: bool);

        /// When the user taps, the navigation controller's navigationBar
        /// &
        /// toolbar will be hidden or shown, depending on the hidden state of the navigationBar. The toolbar will only be shown if it has items to display.
        #[unsafe(method(hidesBarsOnTap))]
        #[unsafe(method_family = none)]
        pub fn hidesBarsOnTap(&self) -> bool;

        /// Setter for [`hidesBarsOnTap`][Self::hidesBarsOnTap].
        #[unsafe(method(setHidesBarsOnTap:))]
        #[unsafe(method_family = none)]
        pub fn setHidesBarsOnTap(&self, hides_bars_on_tap: bool);

        #[cfg(all(feature = "UIGestureRecognizer", feature = "UITapGestureRecognizer"))]
        /// The gesture recognizer used to recognize if the bars will hide or show due to a tap in content. Do not change the delegate or attempt to replace this gesture by overriding this method.
        ///
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(barHideOnTapGestureRecognizer))]
        #[unsafe(method_family = none)]
        pub unsafe fn barHideOnTapGestureRecognizer(&self) -> Retained<UITapGestureRecognizer>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UINavigationController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_protocol!(
    /// The interface for an object that serves as a navigation controller’s delegate.
    ///
    /// ## Overview
    ///
    /// Use a navigation controller delegate (a custom object that implements this protocol) to modify behavior when a view controller is pushed or popped from the navigation stack of a [`UINavigationController`](https://developer.apple.com/documentation/uikit/uinavigationcontroller) object.
    ///
    ///
    pub unsafe trait UINavigationControllerDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(navigationController:willShowViewController:animated:))]
        #[unsafe(method_family = none)]
        fn navigationController_willShowViewController_animated(
            &self,
            navigation_controller: &UINavigationController,
            view_controller: &UIViewController,
            animated: bool,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(navigationController:didShowViewController:animated:))]
        #[unsafe(method_family = none)]
        fn navigationController_didShowViewController_animated(
            &self,
            navigation_controller: &UINavigationController,
            view_controller: &UIViewController,
            animated: bool,
        );

        #[cfg(all(
            feature = "UIOrientation",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[unsafe(method(navigationControllerSupportedInterfaceOrientations:))]
        #[unsafe(method_family = none)]
        fn navigationControllerSupportedInterfaceOrientations(
            &self,
            navigation_controller: &UINavigationController,
        ) -> UIInterfaceOrientationMask;

        #[cfg(all(
            feature = "UIOrientation",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[unsafe(method(navigationControllerPreferredInterfaceOrientationForPresentation:))]
        #[unsafe(method_family = none)]
        fn navigationControllerPreferredInterfaceOrientationForPresentation(
            &self,
            navigation_controller: &UINavigationController,
        ) -> UIInterfaceOrientation;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitioning"
        ))]
        #[optional]
        #[unsafe(method(navigationController:interactionControllerForAnimationController:))]
        #[unsafe(method_family = none)]
        fn navigationController_interactionControllerForAnimationController(
            &self,
            navigation_controller: &UINavigationController,
            animation_controller: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitioning"
        ))]
        #[optional]
        #[unsafe(method(navigationController:animationControllerForOperation:fromViewController:toViewController:))]
        #[unsafe(method_family = none)]
        fn navigationController_animationControllerForOperation_fromViewController_toViewController(
            &self,
            navigation_controller: &UINavigationController,
            operation: UINavigationControllerOperation,
            from_vc: &UIViewController,
            to_vc: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;
    }
);

/// UINavigationControllerItem.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UINavigationItem")]
        #[unsafe(method(navigationItem))]
        #[unsafe(method_family = none)]
        pub fn navigationItem(&self) -> Retained<UINavigationItem>;

        #[unsafe(method(hidesBottomBarWhenPushed))]
        #[unsafe(method_family = none)]
        pub fn hidesBottomBarWhenPushed(&self) -> bool;

        /// Setter for [`hidesBottomBarWhenPushed`][Self::hidesBottomBarWhenPushed].
        #[unsafe(method(setHidesBottomBarWhenPushed:))]
        #[unsafe(method_family = none)]
        pub fn setHidesBottomBarWhenPushed(&self, hides_bottom_bar_when_pushed: bool);

        #[unsafe(method(navigationController))]
        #[unsafe(method_family = none)]
        pub fn navigationController(&self) -> Option<Retained<UINavigationController>>;
    );
}

/// UINavigationControllerContextualToolbarItems.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UIViewController {
    extern_methods!(
        #[cfg(all(feature = "UIBarButtonItem", feature = "UIBarItem"))]
        #[unsafe(method(toolbarItems))]
        #[unsafe(method_family = none)]
        pub fn toolbarItems(&self) -> Option<Retained<NSArray<UIBarButtonItem>>>;

        #[cfg(all(feature = "UIBarButtonItem", feature = "UIBarItem"))]
        /// Setter for [`toolbarItems`][Self::toolbarItems].
        #[unsafe(method(setToolbarItems:))]
        #[unsafe(method_family = none)]
        pub fn setToolbarItems(&self, toolbar_items: Option<&NSArray<UIBarButtonItem>>);

        #[cfg(all(feature = "UIBarButtonItem", feature = "UIBarItem"))]
        #[unsafe(method(setToolbarItems:animated:))]
        #[unsafe(method_family = none)]
        pub fn setToolbarItems_animated(
            &self,
            toolbar_items: Option<&NSArray<UIBarButtonItem>>,
            animated: bool,
        );
    );
}
