//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
use objc2_quartz_core::*;

use crate::*;

/// The styles of the segmented control.
///
/// ## Overview
///
/// You use these constants as values for the [`segmentedControlStyle`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/segmentedcontrolstyle) property.
///
///
// NS_ENUM
#[deprecated = "The segmentedControlStyle property no longer has any effect"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UISegmentedControlStyle(pub NSInteger);
impl UISegmentedControlStyle {
    /// The large plain style for segmented controls.
    ///
    /// ## Discussion
    ///
    /// This style is the default.
    ///
    ///
    #[doc(alias = "UISegmentedControlStylePlain")]
    #[deprecated = "The segmentedControlStyle property no longer has any effect"]
    pub const Plain: Self = Self(0);
    /// The large bordered style for segmented controls.
    #[doc(alias = "UISegmentedControlStyleBordered")]
    #[deprecated = "The segmentedControlStyle property no longer has any effect"]
    pub const Bordered: Self = Self(1);
    /// The small toolbar style for segmented controls.
    ///
    /// ## Discussion
    ///
    /// Segmented controls in this style can have a tint color (see `tintColor`).
    ///
    ///
    #[doc(alias = "UISegmentedControlStyleBar")]
    #[deprecated = "The segmentedControlStyle property no longer has any effect"]
    pub const Bar: Self = Self(2);
    /// The large bezeled style for segmented controls.
    ///
    /// ## Discussion
    ///
    /// Segmented controls in this style can have a tint color (see `tintColor`).
    ///
    ///
    #[doc(alias = "UISegmentedControlStyleBezeled")]
    #[deprecated = "The segmentedControlStyle property no longer has any effect"]
    pub const Bezeled: Self = Self(3);
}

unsafe impl Encode for UISegmentedControlStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UISegmentedControlStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A segment index value indicating that there’s no selected segment.
///
/// ## Discussion
///
/// See [`selectedSegmentIndex`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/selectedsegmentindex) for more information.
///
///
pub const UISegmentedControlNoSegment: c_int = -1;

/// Constants for specifying a segment in a control.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UISegmentedControlSegment(pub NSInteger);
impl UISegmentedControlSegment {
    /// Specifies any segment.
    #[doc(alias = "UISegmentedControlSegmentAny")]
    pub const Any: Self = Self(0);
    /// The capped, leftmost segment.
    ///
    /// ## Discussion
    ///
    /// Applies only when [`numberOfSegments`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/numberofsegments) is greater than 1.
    ///
    ///
    #[doc(alias = "UISegmentedControlSegmentLeft")]
    pub const Left: Self = Self(1);
    /// Any segment between the left and rightmost segments.
    ///
    /// ## Discussion
    ///
    /// Applies only when [`numberOfSegments`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/numberofsegments) is greater than 2.
    ///
    ///
    #[doc(alias = "UISegmentedControlSegmentCenter")]
    pub const Center: Self = Self(2);
    /// The capped, rightmost segment.
    ///
    /// ## Discussion
    ///
    /// Applies only when [`numberOfSegments`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/numberofsegments) is greater than 1.
    ///
    ///
    #[doc(alias = "UISegmentedControlSegmentRight")]
    pub const Right: Self = Self(3);
    /// The standalone segment, capped on both ends.
    ///
    /// ## Discussion
    ///
    /// Applies only when [`numberOfSegments`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/numberofsegments) is 1.
    ///
    ///
    #[doc(alias = "UISegmentedControlSegmentAlone")]
    pub const Alone: Self = Self(4);
}

unsafe impl Encode for UISegmentedControlSegment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UISegmentedControlSegment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A horizontal control that consists of multiple segments, each segment functioning as a discrete button.
    ///
    /// ## Overview
    ///
    /// A segmented control can display a title (an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object) or an image ([`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) object). The [`UISegmentedControl`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol) object automatically resizes segments to fit proportionally within their superview unless they have a specific width set. When you add and remove segments, you can request that the action be animated with sliding and fading effects.
    ///
    /// You register the target-action methods for a segmented control using the [`UIControlEventValueChanged`](https://developer.apple.com/documentation/uikit/uicontrol/event/valuechanged) constant as shown below.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["segmentedControl.addTarget(self, action: \"action:\", forControlEvents: .valueChanged)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[segmentedControl addTarget:self", "                     action:@selector(action:)", "           forControlEvents:UIControlEventValueChanged];"], metadata: None }] }] })
    /// How you configure a segmented control can affect its display behavior:
    ///
    /// - If you set a segmented control to have a momentary style, a segment doesn’t show itself as selected (blue background) when the user touches it. The disclosure button is always momentary and doesn’t affect the actual selection.
    ///
    /// - In versions of iOS prior to 3.0, if a segmented control has only two segments, then it behaves like a switch — tapping the currently-selected segment causes the other segment to be selected. In iOS 3.0 and later, tapping the currently-selected segment doesn’t cause the other segment to be selected.
    ///
    /// ### Customize appearance
    ///
    /// You can customize the appearance of segmented controls using the methods listed in [Customizing appearance](https://developer.apple.com/documentation/uikit/uisegmentedcontrol#customizing-appearance). You can customize the appearance of all segmented controls using the appearance proxy (for example, `[UISegmentedControl appearance]`), or just of a single control.
    ///
    /// When customizing appearance, in general, you should specify a value for the normal state of a property to be used by other states which don’t have a custom value set. Similarly, when a property is dependent on the bar metrics (on the iPhone in landscape orientation, bars have a different height from standard), you should make sure you specify a value for [`UIBarMetricsDefault`](https://developer.apple.com/documentation/uikit/uibarmetrics/default).
    ///
    /// In the case of the segmented control, appearance properties for [`UIBarMetricsLandscapePhone`](https://developer.apple.com/documentation/uikit/uibarmetrics/landscapephone) are only respected for segmented controls in the smaller navigation and toolbars that are used in landscape orientation on the iPhone.
    ///
    /// To provide complete customization, you need to provide divider images for different state combinations, using [`setDividerImage:forLeftSegmentState:rightSegmentState:barMetrics:`](https://developer.apple.com/documentation/uikit/uisegmentedcontrol/setdividerimage(_:forleftsegmentstate:rightsegmentstate:barmetrics:)):
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Image between two unselected segments.", "mySegmentedControl.setDividerImage(myImage, forLeftSegmentState: UIControlState.Normal,", "                                   rightSegmentState: UIControlState.Normal, barMetrics: UIBarMetrics.Default)", " ", "// Image between segment selected on the left and unselected on the right.", "mySegmentedControl.setDividerImage(myImage, forLeftSegmentState: UIControlState.Selected,", "                                   rightSegmentState: UIControlState.Normal, barMetrics: UIBarMetrics.Default)", " ", "// Image between segment selected on the right and unselected on the left.", "mySegmentedControl.setDividerImage(myImage, forLeftSegmentState: UIControlState.Normal,", "                                   rightSegmentState: UIControlState.Selected, barMetrics: UIBarMetrics.Default)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Image between two unselected segments.", "[mySegmentedControl setDividerImage:image1 forLeftSegmentState:UIControlStateNormal", "                  rightSegmentState:UIControlStateNormal barMetrics:barMetrics];", "// Image between segment selected on the left and unselected on the right.", "[mySegmentedControl setDividerImage:image1 forLeftSegmentState:UIControlStateSelected", "                  rightSegmentState:UIControlStateNormal barMetrics:barMetrics];", "// Image between segment selected on the right and unselected on the right.", "[mySegmentedControl setDividerImage:image1 forLeftSegmentState:UIControlStateNormal", "                  rightSegmentState:UIControlStateSelected barMetrics:barMetrics];"], metadata: None }] }] })
    ///
    #[unsafe(super(UIControl, UIView, UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
    pub struct UISegmentedControl;
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView",
    feature = "objc2-quartz-core"
))]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl CALayerDelegate for UISegmentedControl {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl NSCoding for UISegmentedControl {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIAppearance",
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIAppearance for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIAppearance",
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UISegmentedControl {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl UICoordinateSpace for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIDynamicBehavior",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIDynamicItem for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIFocusItem for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIFocusItemContainer for UISegmentedControl {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UISegmentedControl {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UITraitCollection",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITraitEnvironment for UISegmentedControl {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UISegmentedControl {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame(this: Allocated<Self>, frame: CGRect) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        /// Initializes the segmented control with the given items. Items may be NSStrings, UIImages, or (as of iOS 14.0) UIActions. When constructing from a UIAction segments will prefer images over titles when both are provided. The segmented control is automatically sized to fit content.
        ///
        /// # Safety
        ///
        /// `items` generic should be of the correct type.
        #[unsafe(method(initWithItems:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithItems(
            this: Allocated<Self>,
            items: Option<&NSArray>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "UIAction",
            feature = "UIMenuElement",
            feature = "objc2-core-foundation"
        ))]
        /// Initializes the segmented control with the given frame and segments constructed from the given UIActions. Segments will prefer images over titles when both are provided. Selecting a segment calls UIAction.actionHandler as well as handlers for the ValueChanged and PrimaryActionTriggered control events.
        #[unsafe(method(initWithFrame:actions:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame_actions(
            this: Allocated<Self>,
            frame: CGRect,
            actions: &NSArray<UIAction>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "UIAction", feature = "UIMenuElement"))]
        /// Insert a segment with the given action at the given index. Segments will prefer images over titles when both are provided. When the segment is selected UIAction.actionHandler is called. If a segment already exists with the action's identifier that segment will either be updated (if the index is the same) or it will be removed (if different).
        #[unsafe(method(insertSegmentWithAction:atIndex:animated:))]
        #[unsafe(method_family = none)]
        pub fn insertSegmentWithAction_atIndex_animated(
            &self,
            action: &UIAction,
            segment: NSUInteger,
            animated: bool,
        );

        #[cfg(all(feature = "UIAction", feature = "UIMenuElement"))]
        /// Reconfigures the given segment with this action. Segments will prefer images over titles when both are provided. When the segment is selected UIAction.actionHandler is called. UIAction.identifier must either match the action of the existing segment at this index, or be unique within all actions associated with the segmented control, or this method will assert.
        #[unsafe(method(setAction:forSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setAction_forSegmentAtIndex(&self, action: &UIAction, segment: NSUInteger);

        #[cfg(all(feature = "UIAction", feature = "UIMenuElement"))]
        /// Fetch the action for the given segment, if one has been assigned to that segment
        #[unsafe(method(actionForSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn actionForSegmentAtIndex(&self, segment: NSUInteger) -> Option<Retained<UIAction>>;

        #[cfg(feature = "UIAction")]
        /// Returns the index of the segment associated with the given actionIdentifier, or NSNotFound if the identifier could not be found.
        #[unsafe(method(segmentIndexForActionIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn segmentIndexForActionIdentifier(
            &self,
            action_identifier: &UIActionIdentifier,
        ) -> NSInteger;

        #[deprecated = "The segmentedControlStyle property no longer has any effect"]
        #[unsafe(method(segmentedControlStyle))]
        #[unsafe(method_family = none)]
        pub fn segmentedControlStyle(&self) -> UISegmentedControlStyle;

        /// Setter for [`segmentedControlStyle`][Self::segmentedControlStyle].
        #[deprecated = "The segmentedControlStyle property no longer has any effect"]
        #[unsafe(method(setSegmentedControlStyle:))]
        #[unsafe(method_family = none)]
        pub fn setSegmentedControlStyle(&self, segmented_control_style: UISegmentedControlStyle);

        #[unsafe(method(isMomentary))]
        #[unsafe(method_family = none)]
        pub fn isMomentary(&self) -> bool;

        /// Setter for [`isMomentary`][Self::isMomentary].
        #[unsafe(method(setMomentary:))]
        #[unsafe(method_family = none)]
        pub fn setMomentary(&self, momentary: bool);

        #[unsafe(method(numberOfSegments))]
        #[unsafe(method_family = none)]
        pub fn numberOfSegments(&self) -> NSUInteger;

        #[unsafe(method(apportionsSegmentWidthsByContent))]
        #[unsafe(method_family = none)]
        pub fn apportionsSegmentWidthsByContent(&self) -> bool;

        /// Setter for [`apportionsSegmentWidthsByContent`][Self::apportionsSegmentWidthsByContent].
        #[unsafe(method(setApportionsSegmentWidthsByContent:))]
        #[unsafe(method_family = none)]
        pub fn setApportionsSegmentWidthsByContent(
            &self,
            apportions_segment_widths_by_content: bool,
        );

        #[unsafe(method(insertSegmentWithTitle:atIndex:animated:))]
        #[unsafe(method_family = none)]
        pub fn insertSegmentWithTitle_atIndex_animated(
            &self,
            title: Option<&NSString>,
            segment: NSUInteger,
            animated: bool,
        );

        #[cfg(feature = "UIImage")]
        #[unsafe(method(insertSegmentWithImage:atIndex:animated:))]
        #[unsafe(method_family = none)]
        pub fn insertSegmentWithImage_atIndex_animated(
            &self,
            image: Option<&UIImage>,
            segment: NSUInteger,
            animated: bool,
        );

        #[unsafe(method(removeSegmentAtIndex:animated:))]
        #[unsafe(method_family = none)]
        pub fn removeSegmentAtIndex_animated(&self, segment: NSUInteger, animated: bool);

        #[unsafe(method(removeAllSegments))]
        #[unsafe(method_family = none)]
        pub fn removeAllSegments(&self);

        #[unsafe(method(setTitle:forSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setTitle_forSegmentAtIndex(&self, title: Option<&NSString>, segment: NSUInteger);

        #[unsafe(method(titleForSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn titleForSegmentAtIndex(&self, segment: NSUInteger) -> Option<Retained<NSString>>;

        #[cfg(feature = "UIImage")]
        #[unsafe(method(setImage:forSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setImage_forSegmentAtIndex(&self, image: Option<&UIImage>, segment: NSUInteger);

        #[cfg(feature = "UIImage")]
        #[unsafe(method(imageForSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn imageForSegmentAtIndex(&self, segment: NSUInteger) -> Option<Retained<UIImage>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(setWidth:forSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setWidth_forSegmentAtIndex(&self, width: CGFloat, segment: NSUInteger);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(widthForSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn widthForSegmentAtIndex(&self, segment: NSUInteger) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(setContentOffset:forSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setContentOffset_forSegmentAtIndex(&self, offset: CGSize, segment: NSUInteger);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentOffsetForSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn contentOffsetForSegmentAtIndex(&self, segment: NSUInteger) -> CGSize;

        #[unsafe(method(setEnabled:forSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setEnabled_forSegmentAtIndex(&self, enabled: bool, segment: NSUInteger);

        #[unsafe(method(isEnabledForSegmentAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn isEnabledForSegmentAtIndex(&self, segment: NSUInteger) -> bool;

        #[unsafe(method(selectedSegmentIndex))]
        #[unsafe(method_family = none)]
        pub fn selectedSegmentIndex(&self) -> NSInteger;

        /// Setter for [`selectedSegmentIndex`][Self::selectedSegmentIndex].
        #[unsafe(method(setSelectedSegmentIndex:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedSegmentIndex(&self, selected_segment_index: NSInteger);

        #[cfg(feature = "UIColor")]
        #[unsafe(method(selectedSegmentTintColor))]
        #[unsafe(method_family = none)]
        pub fn selectedSegmentTintColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`selectedSegmentTintColor`][Self::selectedSegmentTintColor].
        #[unsafe(method(setSelectedSegmentTintColor:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedSegmentTintColor(&self, selected_segment_tint_color: Option<&UIColor>);

        #[cfg(all(feature = "UIBarCommon", feature = "UIImage"))]
        #[unsafe(method(setBackgroundImage:forState:barMetrics:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundImage_forState_barMetrics(
            &self,
            background_image: Option<&UIImage>,
            state: UIControlState,
            bar_metrics: UIBarMetrics,
        );

        #[cfg(all(feature = "UIBarCommon", feature = "UIImage"))]
        #[unsafe(method(backgroundImageForState:barMetrics:))]
        #[unsafe(method_family = none)]
        pub fn backgroundImageForState_barMetrics(
            &self,
            state: UIControlState,
            bar_metrics: UIBarMetrics,
        ) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "UIBarCommon", feature = "UIImage"))]
        #[unsafe(method(setDividerImage:forLeftSegmentState:rightSegmentState:barMetrics:))]
        #[unsafe(method_family = none)]
        pub fn setDividerImage_forLeftSegmentState_rightSegmentState_barMetrics(
            &self,
            divider_image: Option<&UIImage>,
            left_state: UIControlState,
            right_state: UIControlState,
            bar_metrics: UIBarMetrics,
        );

        #[cfg(all(feature = "UIBarCommon", feature = "UIImage"))]
        #[unsafe(method(dividerImageForLeftSegmentState:rightSegmentState:barMetrics:))]
        #[unsafe(method_family = none)]
        pub fn dividerImageForLeftSegmentState_rightSegmentState_barMetrics(
            &self,
            left_state: UIControlState,
            right_state: UIControlState,
            bar_metrics: UIBarMetrics,
        ) -> Option<Retained<UIImage>>;

        /// # Safety
        ///
        /// `attributes` generic should be of the correct type.
        #[unsafe(method(setTitleTextAttributes:forState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTitleTextAttributes_forState(
            &self,
            attributes: Option<&NSDictionary<NSAttributedStringKey, AnyObject>>,
            state: UIControlState,
        );

        #[unsafe(method(titleTextAttributesForState:))]
        #[unsafe(method_family = none)]
        pub fn titleTextAttributesForState(
            &self,
            state: UIControlState,
        ) -> Option<Retained<NSDictionary<NSAttributedStringKey, AnyObject>>>;

        #[cfg(all(
            feature = "UIBarCommon",
            feature = "UIGeometry",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(setContentPositionAdjustment:forSegmentType:barMetrics:))]
        #[unsafe(method_family = none)]
        pub fn setContentPositionAdjustment_forSegmentType_barMetrics(
            &self,
            adjustment: UIOffset,
            left_center_right_or_alone: UISegmentedControlSegment,
            bar_metrics: UIBarMetrics,
        );

        #[cfg(all(
            feature = "UIBarCommon",
            feature = "UIGeometry",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(contentPositionAdjustmentForSegmentType:barMetrics:))]
        #[unsafe(method_family = none)]
        pub fn contentPositionAdjustmentForSegmentType_barMetrics(
            &self,
            left_center_right_or_alone: UISegmentedControlSegment,
            bar_metrics: UIBarMetrics,
        ) -> UIOffset;
    );
}

/// Methods declared on superclass `UIControl`.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UISegmentedControl {
    extern_methods!(
        #[cfg(all(
            feature = "UIAction",
            feature = "UIMenuElement",
            feature = "objc2-core-foundation"
        ))]
        /// Initializes the control and adds primaryAction for the UIControlEventPrimaryActionTriggered control event. Subclasses of UIControl may alter or add behaviors around the usage of primaryAction, see subclass documentation of this initializer for additional information.
        #[unsafe(method(initWithFrame:primaryAction:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame_primaryAction(
            this: Allocated<Self>,
            frame: CGRect,
            primary_action: Option<&UIAction>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `UIView`.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UISegmentedControl {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UISegmentedControl {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// SpringLoading.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UISegmentedControl {
    extern_methods!();
}

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UISpringLoadedInteractionSupporting",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UISpringLoadedInteractionSupporting for UISegmentedControl {}
);
