//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// The layout priority is used to indicate to the constraint-based layout system which constraints are more important, allowing the system to make appropriate tradeoffs when satisfying the constraints of the system as a whole.
// NS_TYPED_EXTENSIBLE_ENUM
pub type UILayoutPriority = c_float;

/// A required constraint.
///
/// ## Discussion
///
/// Don’t specify a layout constraint that exceeds this number.
///
///
pub static UILayoutPriorityRequired: UILayoutPriority = 1000 as _;

/// The priority level with which a button resists compressing its content.
pub static UILayoutPriorityDefaultHigh: UILayoutPriority = 750 as _;

/// The priority level for a drag that may end up resizing the window’s scene.
pub static UILayoutPriorityDragThatCanResizeScene: UILayoutPriority = 510 as _;

/// The priority level at which the window’s scene prefers to stay the same size.
///
/// ## Discussion
///
/// Specify constraint priorities that are either higher or lower than this value, rather than equal to it.
///
///
pub static UILayoutPrioritySceneSizeStayPut: UILayoutPriority = 500 as _;

/// The priority level for a drag that won’t resize the window’s scene.
pub static UILayoutPriorityDragThatCannotResizeScene: UILayoutPriority = 490 as _;

/// The priority level at which a button hugs its contents horizontally.
pub static UILayoutPriorityDefaultLow: UILayoutPriority = 250 as _;

/// The priority level with which the view wants to conform to the target size in that computation.
///
/// ## Discussion
///
/// When you send a [`systemLayoutSizeFittingSize:`](https://developer.apple.com/documentation/uikit/uiview/systemlayoutsizefitting(_:)) message to a view, the size fitting most closely to the target size is computed. This priority is quite low. It’s generally not appropriate to make a constraint at exactly this priority. You want to be higher or lower.
///
///
pub static UILayoutPriorityFittingSizeLevel: UILayoutPriority = 50 as _;

/// The relation between the first attribute and the modified second attribute in a constraint.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutRelation(pub NSInteger);
impl NSLayoutRelation {
    /// The constraint requires the first attribute to be less than or equal to the modified second attribute.
    #[doc(alias = "NSLayoutRelationLessThanOrEqual")]
    pub const LessThanOrEqual: Self = Self(-1);
    /// The constraint requires the first attribute to be exactly equal to the modified second attribute.
    #[doc(alias = "NSLayoutRelationEqual")]
    pub const Equal: Self = Self(0);
    /// The constraint requires the first attribute to be greater than or equal to the modified second attribute.
    #[doc(alias = "NSLayoutRelationGreaterThanOrEqual")]
    pub const GreaterThanOrEqual: Self = Self(1);
}

unsafe impl Encode for NSLayoutRelation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutRelation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The part of the object’s visual representation that should be used to get the value for the constraint.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutAttribute(pub NSInteger);
impl NSLayoutAttribute {
    /// The left side of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeLeft")]
    pub const Left: Self = Self(1);
    /// The right side of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeRight")]
    pub const Right: Self = Self(2);
    /// The top of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeTop")]
    pub const Top: Self = Self(3);
    /// The bottom of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeBottom")]
    pub const Bottom: Self = Self(4);
    /// The leading edge of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeLeading")]
    pub const Leading: Self = Self(5);
    /// The trailing edge of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeTrailing")]
    pub const Trailing: Self = Self(6);
    /// The width of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeWidth")]
    pub const Width: Self = Self(7);
    /// The height of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeHeight")]
    pub const Height: Self = Self(8);
    /// The center along the x-axis of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeCenterX")]
    pub const CenterX: Self = Self(9);
    /// The center along the y-axis of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeCenterY")]
    pub const CenterY: Self = Self(10);
    /// The object’s baseline.
    ///
    /// ## Discussion
    ///
    /// For objects with more than one line of text, this is the baseline for the bottommost line of text.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeLastBaseline")]
    pub const LastBaseline: Self = Self(11);
    /// The object’s baseline.
    #[doc(alias = "NSLayoutAttributeBaseline")]
    pub const Baseline: Self = Self(NSLayoutAttribute::LastBaseline.0);
    /// The object’s baseline.
    ///
    /// ## Discussion
    ///
    /// For objects with more than one line of text, this is the baseline for the topmost line of text.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeFirstBaseline")]
    pub const FirstBaseline: Self = Self(12);
    /// The object’s left margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeLeftMargin")]
    pub const LeftMargin: Self = Self(13);
    /// The object’s right margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeRightMargin")]
    pub const RightMargin: Self = Self(14);
    /// The object’s top margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeTopMargin")]
    pub const TopMargin: Self = Self(15);
    /// The object’s bottom margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeBottomMargin")]
    pub const BottomMargin: Self = Self(16);
    /// The object’s leading margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeLeadingMargin")]
    pub const LeadingMargin: Self = Self(17);
    /// The object’s trailing margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeTrailingMargin")]
    pub const TrailingMargin: Self = Self(18);
    /// The center along the x-axis between the object’s left and right margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeCenterXWithinMargins")]
    pub const CenterXWithinMargins: Self = Self(19);
    /// The center along the y-axis between the object’s top and bottom margin.
    ///
    /// ## Discussion
    ///
    /// For [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects, the margins are defined by their [`layoutMargins`](https://developer.apple.com/documentation/uikit/uiview/layoutmargins) property.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeCenterYWithinMargins")]
    pub const CenterYWithinMargins: Self = Self(20);
    /// A placeholder value for indicating that the constraint’s second item and second attribute aren’t used in any calculations.
    ///
    /// ## Discussion
    ///
    /// Use this value when creating a constraint that assigns a constant to an attribute. For example, `item1.height >= 40`. If a constraint only has one item, set the second item to `nil`, and set the second attribute to [`NSLayoutAttributeNotAnAttribute`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/notanattribute).
    ///
    ///
    #[doc(alias = "NSLayoutAttributeNotAnAttribute")]
    pub const NotAnAttribute: Self = Self(0);
}

unsafe impl Encode for NSLayoutAttribute {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutAttribute {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A bit mask that specifies both a part of an interface element to align and a direction for the alignment between two interface elements.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutFormatOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSLayoutFormatOptions: NSUInteger {
/// Align all specified interface elements using [`NSLayoutAttributeLeft`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/left) on each.
        #[doc(alias = "NSLayoutFormatAlignAllLeft")]
        const AlignAllLeft = 1<<NSLayoutAttribute::Left.0;
/// Align all specified interface elements using [`NSLayoutAttributeRight`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/right) on each.
        #[doc(alias = "NSLayoutFormatAlignAllRight")]
        const AlignAllRight = 1<<NSLayoutAttribute::Right.0;
/// Align all specified interface elements using [`NSLayoutAttributeTop`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/top) on each.
        #[doc(alias = "NSLayoutFormatAlignAllTop")]
        const AlignAllTop = 1<<NSLayoutAttribute::Top.0;
/// Align all specified interface elements using [`NSLayoutAttributeBottom`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/bottom) on each.
        #[doc(alias = "NSLayoutFormatAlignAllBottom")]
        const AlignAllBottom = 1<<NSLayoutAttribute::Bottom.0;
/// Align all specified interface elements using [`NSLayoutAttributeLeading`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/leading) on each.
        #[doc(alias = "NSLayoutFormatAlignAllLeading")]
        const AlignAllLeading = 1<<NSLayoutAttribute::Leading.0;
/// Align all specified interface elements using [`NSLayoutAttributeTrailing`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/trailing) on each.
        #[doc(alias = "NSLayoutFormatAlignAllTrailing")]
        const AlignAllTrailing = 1<<NSLayoutAttribute::Trailing.0;
/// Align all specified interface elements using [`NSLayoutAttributeCenterX`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/centerx) on each.
        #[doc(alias = "NSLayoutFormatAlignAllCenterX")]
        const AlignAllCenterX = 1<<NSLayoutAttribute::CenterX.0;
/// Align all specified interface elements using [`NSLayoutAttributeCenterY`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/attribute/centery) on each.
        #[doc(alias = "NSLayoutFormatAlignAllCenterY")]
        const AlignAllCenterY = 1<<NSLayoutAttribute::CenterY.0;
/// Align all specified interface elements using the last baseline of each one.
        #[doc(alias = "NSLayoutFormatAlignAllLastBaseline")]
        const AlignAllLastBaseline = 1<<NSLayoutAttribute::LastBaseline.0;
/// Align all specified interface elements using the first baseline of each one.
        #[doc(alias = "NSLayoutFormatAlignAllFirstBaseline")]
        const AlignAllFirstBaseline = 1<<NSLayoutAttribute::FirstBaseline.0;
/// Align all specified interface elements using [`NSLayoutAttributeBaseline`](https://developer.apple.com/documentation/uikit/nslayoutattribute/nslayoutattributebaseline) on each.
        #[doc(alias = "NSLayoutFormatAlignAllBaseline")]
        const AlignAllBaseline = NSLayoutFormatOptions::AlignAllLastBaseline.0;
/// Bit mask that can be combined with a [`NSLayoutFormatOptions`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/formatoptions) variable to yield only the alignment portion of the format options.
        #[doc(alias = "NSLayoutFormatAlignmentMask")]
        const AlignmentMask = 0xFFFF;
/// Arrange objects in order based on the normal text flow for the current user interface language. In left-to-right languages (like English), this arrangement results in the first object being placed farthest to the left, the next one to its right, and so on. In right-to-left languages (like Arabic or Hebrew), the ordering is reversed.
        #[doc(alias = "NSLayoutFormatDirectionLeadingToTrailing")]
        const DirectionLeadingToTrailing = 0<<16;
/// Arrange objects in order from left to right.
        #[doc(alias = "NSLayoutFormatDirectionLeftToRight")]
        const DirectionLeftToRight = 1<<16;
/// Arrange objects in order from right to left.
        #[doc(alias = "NSLayoutFormatDirectionRightToLeft")]
        const DirectionRightToLeft = 2<<16;
/// A bit mask that can be combined with an [`NSLayoutFormatOptions`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/formatoptions) variable to yield only the direction portion of the format options.
        #[doc(alias = "NSLayoutFormatDirectionMask")]
        const DirectionMask = 0x3<<16;
/// Align the elements using their edges instead of using their baselines.
        #[doc(alias = "NSLayoutFormatSpacingEdgeToEdge")]
        const SpacingEdgeToEdge = 0<<19;
/// Align elements vertically according to their baseline positions.
        #[doc(alias = "NSLayoutFormatSpacingBaselineToBaseline")]
        const SpacingBaselineToBaseline = 1<<19;
/// A bit mask that can be combined with an [`NSLayoutFormatOptions`](https://developer.apple.com/documentation/uikit/nslayoutconstraint/formatoptions) variable to yield only the spacing baseline spacing portion of the format options.
        #[doc(alias = "NSLayoutFormatSpacingMask")]
        const SpacingMask = 0x1<<19;
    }
}

unsafe impl Encode for NSLayoutFormatOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutFormatOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The relationship between two user interface objects that must be satisfied by the constraint-based layout system.
    ///
    /// ## Overview
    ///
    /// Each constraint is a linear equation with the following format:
    ///
    /// ```objc
    /// item1.attribute1 = multiplier × item2.attribute2 + constant
    /// ```
    ///
    /// In this equation, `attribute1` and `attribute2` are the variables that Auto Layout can adjust when solving these constraints. The other values are defined when you create the constraint. For example, If you’re defining the relative position of two buttons, you might say “the leading edge of the second button should be 8 points after the trailing edge of the first button.” The linear equation for this relationship is shown below:
    ///
    /// ```objc
    /// // positive values move to the right in left-to-right languages like English.
    /// button2.leading = 1.0 × button1.trailing + 8.0
    /// ```
    ///
    /// Auto Layout then modifies the values of the specified leading and trailing edges until both sides of the equation are equal. Note that Auto Layout does not simply assign the value of the right side of this equation to the left side. Instead, the system can modify either attribute or both attributes as needed to solve for this constraint.
    ///
    /// The fact that constraints are equations (and not assignment operators) means that you can switch the order of the items in the equation as needed to more clearly express the desired relationship. However, if you switch the order, you must also invert the multiplier and constant. For example, the following two equations produce identical constraints:
    ///
    /// ```objc
    /// // These equations produce identical constraints
    /// button2.leading = 1.0 × button1.trailing + 8.0
    /// button1.trailing = 1.0 × button2.leading - 8.0
    /// ```
    ///
    /// A valid layout is defined as a set constraints with one and only one possible solution. Valid layouts are also referred to as a nonambiguous, nonconflicting layouts. Constraints with more than one solution are ambiguous. Constraints with no valid solutions are conflicting. For more information on resolving ambiguous and conflicting constraints, see [Types of Errors](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH17) in [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853).
    ///
    /// Additionally, constraints are not limited to equality relationships. They can also use greater than or equal to (>=) or less than or equal to (<=) to describe the relationship between the two attributes. Constraints also have priorities between 1 and 1,000. Constraints with a priority of 1,000 are required. All priorities less than 1,000 are optional. By default, all constraints are required (priority = 1,000).
    ///
    /// After solving for the required constraints, Auto Layout tries to solve all the optional constraints in priority order from highest to lowest. If it cannot solve for an optional constraint, it tries to come as close as possible to the desired result, and then moves on to the next constraint.
    ///
    /// This combination of inequalities, equalities, and priorities gives you a great amount of flexibility and power. By combining multiple constraints, you can define layouts that dynamically adapt as the size and location of the elements in your user interface change. For some example layouts, see [Stack Views](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11) in [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSLayoutConstraint;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSLayoutConstraint {}
);

impl NSLayoutConstraint {
    extern_methods!(
        /// # Safety
        ///
        /// - `metrics` generic should be of the correct type.
        /// - `views` generic should be of the correct type.
        #[unsafe(method(constraintsWithVisualFormat:options:metrics:views:))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraintsWithVisualFormat_options_metrics_views(
            format: &NSString,
            opts: NSLayoutFormatOptions,
            metrics: Option<&NSDictionary<NSString, AnyObject>>,
            views: &NSDictionary<NSString, AnyObject>,
            mtm: MainThreadMarker,
        ) -> Retained<NSArray<NSLayoutConstraint>>;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// - `view1` should be of the correct type.
        /// - `view2` should be of the correct type.
        #[unsafe(method(constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraintWithItem_attribute_relatedBy_toItem_attribute_multiplier_constant(
            view1: &AnyObject,
            attr1: NSLayoutAttribute,
            relation: NSLayoutRelation,
            view2: Option<&AnyObject>,
            attr2: NSLayoutAttribute,
            multiplier: CGFloat,
            c: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(priority))]
        #[unsafe(method_family = none)]
        pub fn priority(&self) -> UILayoutPriority;

        /// Setter for [`priority`][Self::priority].
        #[unsafe(method(setPriority:))]
        #[unsafe(method_family = none)]
        pub fn setPriority(&self, priority: UILayoutPriority);

        #[unsafe(method(shouldBeArchived))]
        #[unsafe(method_family = none)]
        pub fn shouldBeArchived(&self) -> bool;

        /// Setter for [`shouldBeArchived`][Self::shouldBeArchived].
        #[unsafe(method(setShouldBeArchived:))]
        #[unsafe(method_family = none)]
        pub fn setShouldBeArchived(&self, should_be_archived: bool);

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(firstItem))]
        #[unsafe(method_family = none)]
        pub unsafe fn firstItem(&self) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(secondItem))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondItem(&self) -> Option<Retained<AnyObject>>;

        #[unsafe(method(firstAttribute))]
        #[unsafe(method_family = none)]
        pub fn firstAttribute(&self) -> NSLayoutAttribute;

        #[unsafe(method(secondAttribute))]
        #[unsafe(method_family = none)]
        pub fn secondAttribute(&self) -> NSLayoutAttribute;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(firstAnchor))]
        #[unsafe(method_family = none)]
        pub fn firstAnchor(&self) -> Retained<NSLayoutAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(secondAnchor))]
        #[unsafe(method_family = none)]
        pub fn secondAnchor(&self) -> Option<Retained<NSLayoutAnchor>>;

        #[unsafe(method(relation))]
        #[unsafe(method_family = none)]
        pub fn relation(&self) -> NSLayoutRelation;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(multiplier))]
        #[unsafe(method_family = none)]
        pub fn multiplier(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(constant))]
        #[unsafe(method_family = none)]
        pub fn constant(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`constant`][Self::constant].
        #[unsafe(method(setConstant:))]
        #[unsafe(method_family = none)]
        pub fn setConstant(&self, constant: CGFloat);

        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub fn isActive(&self) -> bool;

        /// Setter for [`isActive`][Self::isActive].
        #[unsafe(method(setActive:))]
        #[unsafe(method_family = none)]
        pub fn setActive(&self, active: bool);

        #[unsafe(method(activateConstraints:))]
        #[unsafe(method_family = none)]
        pub fn activateConstraints(
            constraints: &NSArray<NSLayoutConstraint>,
            mtm: MainThreadMarker,
        );

        #[unsafe(method(deactivateConstraints:))]
        #[unsafe(method_family = none)]
        pub fn deactivateConstraints(
            constraints: &NSArray<NSLayoutConstraint>,
            mtm: MainThreadMarker,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSLayoutConstraint {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSIdentifier.
impl NSLayoutConstraint {
    extern_methods!(
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub fn identifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`identifier`][Self::identifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setIdentifier(&self, identifier: Option<&NSString>);
    );
}

extern_protocol!(
    /// A set of methods that provide layout support and access to layout anchors.
    ///
    /// ## Overview
    ///
    /// This protocol is implemented by the [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) properties [`topLayoutGuide`](https://developer.apple.com/documentation/uikit/uiviewcontroller/toplayoutguide) and [`bottomLayoutGuide`](https://developer.apple.com/documentation/uikit/uiviewcontroller/bottomlayoutguide) to support using Auto Layout with a view controller’s view. You can use layout guides as layout items in the [`NSLayoutConstraint`](https://developer.apple.com/documentation/uikit/nslayoutconstraint) factory methods.
    ///
    ///
    pub unsafe trait UILayoutSupport: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        fn length(&self) -> CGFloat;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(topAnchor))]
        #[unsafe(method_family = none)]
        fn topAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(bottomAnchor))]
        #[unsafe(method_family = none)]
        fn bottomAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(heightAnchor))]
        #[unsafe(method_family = none)]
        fn heightAnchor(&self) -> Retained<NSLayoutDimension>;
    }
);
