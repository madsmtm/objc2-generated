//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
#[cfg(feature = "objc2-core-image")]
#[cfg(not(target_os = "watchos"))]
use objc2_core_image::*;
use objc2_foundation::*;

use crate::*;

/// Constants that specify the intended display orientation for an image.
///
/// ## Overview
///
/// Orientation values are commonly found in image metadata, and specifying image orientation correctly can be important both for displaying the image and for certain kinds of image processing.
///
/// The [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) class automatically handles the transform necessary to present an image in the correct display orientation according to its orientation metadata, so an image object’s [`imageOrientation`](https://developer.apple.com/documentation/uikit/uiimage/imageorientation) property simply indicates which transform was applied.
///
/// For example, an iOS device camera always encodes pixel data in the camera sensor’s native landscape orientation, along with metadata indicating the camera orientation. When UIImage loads a photo shot in portrait orientation, it automatically applies a 90° rotation before displaying the image data, and the image’s [`imageOrientation`](https://developer.apple.com/documentation/uikit/uiimage/imageorientation) value of [`UIImageOrientationRight`](https://developer.apple.com/documentation/uikit/uiimage/orientation/right) indicates that this rotation has been applied.
///
///
/// ![UIImage rotates an image with right orientation for correct display](https://docs-assets.developer.apple.com/published/a4de8a358cbf9a76800cc595fceb8892/media-2948302%402x.png)
///
///
/// <div class="warning">
///
/// ### Note
///  Some frameworks describe image orientation using the [`CGImagePropertyOrientation`](https://developer.apple.com/documentation/imageio/cgimagepropertyorientation) type (or the raw TIFF/Exif numeric values that type defines symbols for). However, the underlying numeric values of that type are incompatible with [`UIImageOrientation`](https://developer.apple.com/documentation/uikit/uiimage/orientation). For conversion help, see the [`CGImagePropertyOrientation`](https://developer.apple.com/documentation/imageio/cgimagepropertyorientation) overview.
///
///
///
/// </div>
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIImageOrientation(pub NSInteger);
impl UIImageOrientation {
    /// The original pixel data matches the image’s intended display orientation.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears correctly “right side up”. That is, this orientation is an identity value.
    ///
    ///
    /// ![An image in up orientation can be presented for display without rotating or flipping.](https://docs-assets.developer.apple.com/published/08b6857053beb92301df7ceb36ab8175/media-2948308%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationUp")]
    pub const Up: Self = Self(0);
    /// The image has been rotated 180° from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears rotated 180°.
    ///
    ///
    /// ![To correct an image with down orientation for display, rotate it 180°.](https://docs-assets.developer.apple.com/published/1530f2c9454d2a3fb9e99de9bee4fe01/media-2948301%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationDown")]
    pub const Down: Self = Self(1);
    /// The image has been rotated 90° counterclockwise from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears to be rotated 90° clockwise. (That is, to present the image in its intended orientation, you must rotate 90° counter-clockwise.)
    ///
    ///
    /// ![To correct an image with left orientation for display, rotate it 90° counterclockwise.](https://docs-assets.developer.apple.com/published/a33bb23b55f1eb490a0abf2b86b81f66/media-2948305%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationLeft")]
    pub const Left: Self = Self(2);
    /// The image has been rotated 90° clockwise from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears to be rotated 90° counter-clockwise. (That is, to present the image in its intended orientation, you must rotate it 90° clockwise.)
    ///
    ///
    /// ![To correct an image with right orientation for display, rotate it 90° clockwise.](https://docs-assets.developer.apple.com/published/a4de8a358cbf9a76800cc595fceb8892/media-2948303%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationRight")]
    pub const Right: Self = Self(3);
    /// The image has been horizontally flipped from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears horizontally mirrored.
    ///
    ///
    /// ![To correct an image with upMirrored orientation for display, flip it horizontally.](https://docs-assets.developer.apple.com/published/3b93501e18e409bc3d6f779ae1e59673/media-2948304%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationUpMirrored")]
    pub const UpMirrored: Self = Self(4);
    /// The image has been vertically flipped from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears vertically flipped. (Alternatively, the image is rotated 180° and then flipped horizontally.)
    ///
    ///
    /// ![To correct an image with downMirrored orientation for display, flip it vertically.](https://docs-assets.developer.apple.com/published/8170a1cc20c32b7a29544fc6e92a7f74/media-2948309%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationDownMirrored")]
    pub const DownMirrored: Self = Self(5);
    /// The image has been rotated 90° clockwise and flipped horizontally from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears to be horizontally mirrored, then rotated 90° counter-clockwise. (That is, to present the image in its intended orientation, you can rotate it 90° clockwise, then flip horizontally.)
    ///
    ///
    /// ![To correct an image with leftMirrored orientation for display, rotate it 90° clockwise then flip it horizontally.](https://docs-assets.developer.apple.com/published/ed7462784881f7d23e39b968a2ecefff/media-2948307%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationLeftMirrored")]
    pub const LeftMirrored: Self = Self(6);
    /// The image has been rotated 90° counterclockwise and flipped horizontally from the orientation of its original pixel data.
    ///
    /// ## Discussion
    ///
    /// If an image is encoded with this orientation, then displayed by software unaware of orientation metadata, the image appears to be horizontally mirrored, then rotated 90° clockwise. (That is, to present the image in its intended orientation, you can rotate  90° counter-clockwise, then flip horizontally.)
    ///
    ///
    /// ![To correct an image with rightMirrored orientation for display, rotate it 90° counterclockwise then flip it horizontally.](https://docs-assets.developer.apple.com/published/6427cc1184994ac80c5119002426bac6/media-2948306%402x.png)
    ///
    ///
    ///
    #[doc(alias = "UIImageOrientationRightMirrored")]
    pub const RightMirrored: Self = Self(7);
}

unsafe impl Encode for UIImageOrientation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIImageOrientation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that specify the possible resizing modes for an image.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIImageResizingMode(pub NSInteger);
impl UIImageResizingMode {}

unsafe impl Encode for UIImageResizingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIImageResizingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that specify the possible rendering modes for an image.
///
/// ## Overview
///
/// The rendering mode controls how UIKit uses color information to display an image. See [Providing images for different appearances](https://developer.apple.com/documentation/uikit/providing-images-for-different-appearances) for creating tintable images with template mode.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIImageRenderingMode(pub NSInteger);
impl UIImageRenderingMode {
    /// Draw the image using the context’s default rendering mode.
    #[doc(alias = "UIImageRenderingModeAutomatic")]
    pub const Automatic: Self = Self(0);
    /// Always draw the original image, without treating it as a template.
    #[doc(alias = "UIImageRenderingModeAlwaysOriginal")]
    pub const AlwaysOriginal: Self = Self(1);
    /// Always draw the image as a template image, ignoring its color information.
    #[doc(alias = "UIImageRenderingModeAlwaysTemplate")]
    pub const AlwaysTemplate: Self = Self(2);
}

unsafe impl Encode for UIImageRenderingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIImageRenderingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that manages image data in your app.
    ///
    /// ## Overview
    ///
    /// You use image objects to represent image data of all kinds, and the [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) class is capable of managing data for all image formats supported by the underlying platform. Image objects are immutable, so you always create them from existing image data, such as an image file on disk or programmatically created image data. An image object may contain a single image or a sequence of images for use in an animation.
    ///
    /// You can use image objects in several different ways:
    ///
    /// - Assign an image to a [`UIImageView`](https://developer.apple.com/documentation/uikit/uiimageview) object to display the image in your interface.
    ///
    /// - Use an image to customize system controls such as buttons, sliders, and segmented controls.
    ///
    /// - Draw an image directly into a view or other graphics context.
    ///
    /// - Pass an image to other APIs that might require image data.
    ///
    /// Although image objects support all platform-native image formats, it’s recommended that you use PNG or JPEG files for most images in your app. Image objects are optimized for reading and displaying both formats, and those formats offer better performance than most other image formats. Because the PNG format is lossless, it’s especially recommended for the images you use in your app’s interface.
    ///
    /// ### Create image objects
    ///
    /// When creating image objects using the methods of this class, you must have existing image data located in a file or data structure. You can’t create an empty image and draw content into it. There are many options for creating image objects, each of which is best for specific situations:
    ///
    /// - Use the [`imageNamed:inBundle:compatibleWithTraitCollection:`](https://developer.apple.com/documentation/uikit/uiimage/init(named:in:compatiblewith:)) method (or the [`imageNamed:`](https://developer.apple.com/documentation/uikit/uiimage/init(named:)) method) to create an image from an image asset or image file located in your app’s main bundle (or some other known bundle). Because these methods cache the image data automatically, they’re especially recommended for images that you use frequently.
    ///
    /// - Use the [`imageWithContentsOfFile:`](https://developer.apple.com/documentation/uikit/uiimage/imagewithcontentsoffile:) or [`initWithContentsOfFile:`](https://developer.apple.com/documentation/uikit/uiimage/init(contentsoffile:)) method to create an image object where the initial data isn’t in a bundle. These methods load the image data from disk each time, so don’t use them to load the same image repeatedly.
    ///
    /// - Use the [`animatedImageWithImages:duration:`](https://developer.apple.com/documentation/uikit/uiimage/animatedimage(with:duration:)) and [`animatedImageNamed:duration:`](https://developer.apple.com/documentation/uikit/uiimage/animatedimagenamed(_:duration:)) methods to create a single [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) object comprised of multiple sequential images. Install the resulting image in a [`UIImageView`](https://developer.apple.com/documentation/uikit/uiimageview) object to create animations in your interface.
    ///
    /// Other methods of the [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) class let you create animations from specific types of data, such as Core Graphics images or image data you create yourself. UIKit also provides the [`UIGraphicsGetImageFromCurrentImageContext`](https://developer.apple.com/documentation/uikit/uigraphicsgetimagefromcurrentimagecontext()) function to create images from content you draw yourself. You use that function in conjunction with a bitmap-based graphics context, which you use to capture your drawing commands.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Because image objects are immutable, you can’t change their properties after creation. Most image properties are set automatically using metadata in the accompanying image file or image data. The immutable nature of image objects also means they’re safe to create and use from any thread.
    ///
    ///
    ///
    /// </div>
    /// Image assets are the easiest way to manage the images that ship with your app. Each new Xcode project contains an assets library, to which you can add multiple image sets. An image set contains the variations of a single image that your app uses. A single image set can provide different versions of an image for different platforms, for different trait environments (compact or regular), and for different scale factors.
    ///
    /// In addition to loading images from disk, you can ask the user to supply images from an available camera or photo library using a [`UIImagePickerController`](https://developer.apple.com/documentation/uikit/uiimagepickercontroller) object. An image picker displays a custom user interface for selecting images. Accessing user-supplied images requires explicit user permission. For more information about using an image picker, see [`UIImagePickerController`](https://developer.apple.com/documentation/uikit/uiimagepickercontroller).
    ///
    /// ### Define a stretchable image
    ///
    /// A stretchable image is one that defines regions where you can duplicate the underlying image data in an aesthetically pleasing way. Stretchable images are commonly used to create backgrounds that can grow or shrink to fill the available space.
    ///
    /// Define a stretchable image by adding insets to an existing image using the [`resizableImageWithCapInsets:`](https://developer.apple.com/documentation/uikit/uiimage/resizableimage(withcapinsets:)) or [`resizableImageWithCapInsets:resizingMode:`](https://developer.apple.com/documentation/uikit/uiimage/resizableimage(withcapinsets:resizingmode:)) method. The insets subdivide the image into two or more parts. Specifying nonzero values for each inset yields an image divided into nine parts, as shown in the following image:
    ///
    ///
    /// ![An image that depicts how to use insets to define stretchable regions. The image on the left is stretched and shows Left, Right, Top, and Bottom insets. The image on the right is condensed and also shows Left, Right, Top, and Bottom insets.](https://docs-assets.developer.apple.com/published/a24122a4b3a9289007f9bcad22d8667d/media-1965929%402x.png)
    ///
    ///
    /// Each inset defines the portion of the image that doesn’t stretch in the given dimension. The regions inside an image’s top and bottom insets maintain a fixed height, and the areas inside the left and right insets maintain a fixed width. The following image shows how each part of a nine-part image stretches as the image itself is stretched to fill the available space. The corners of the image don’t change size because they’re inside both a horizontal and vertical inset:
    ///
    ///
    /// ![An image that depicts the stretchable portions of a nine-part image. The image on the left is stretched. The image on the right is condensed. The corners of both images remain the same size.](https://docs-assets.developer.apple.com/published/dcf9ad7415ffdb2dd9a753a3be251cce/media-1965930%402x.png)
    ///
    ///
    /// ### Compare images
    ///
    /// The [`isEqual:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/isequal(_:)) method is the only reliable way to determine whether two image objects contain the same image data. The following code illustrates the correct and incorrect ways to compare images.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Load the same image twice.", "let image1 = UIImage(named: \"MyImage\")", "let image2 = UIImage(named: \"MyImage\") ", "", "// The image objects may be different, but the contents are still equal.", "if image1 != nil && image1!.isEqual(image2) {", "    // Correct. This technique compares the image data correctly.", "} ", "if image1 == image2 {", "    // Incorrect! Direct object comparisons may not work.", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Load the same image twice.", "UIImage* image1 = [UIImage imageNamed:@\"MyImage\"];", "UIImage* image2 = [UIImage imageNamed:@\"MyImage\"];", " ", "// The image objects may be different, but the contents are still equal", "if ([image1 isEqual:image2]) {", "   // Correct. This technique compares the image data correctly.", "}", " ", "if (image1 == image2) {", "   // Incorrect! Direct object comparisons may not work.", "}"], metadata: None }] }] })
    /// ### Access the image data
    ///
    /// Image objects don’t provide direct access to their underlying image data. However, you can retrieve the image data in other formats for use in your app. Specifically, you can use the [`CGImage`](https://developer.apple.com/documentation/uikit/uiimage/cgimage) and [`CIImage`](https://developer.apple.com/documentation/uikit/uiimage/ciimage) properties to retrieve versions of the image that are compatible with Core Graphics and Core Image, respectively. You can also use the [`UIImagePNGRepresentation`](https://developer.apple.com/documentation/uikit/uiimage/pngdata()) and [`UIImageJPEGRepresentation`](https://developer.apple.com/documentation/uikit/uiimage/jpegdata(compressionquality:)) functions to generate an [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) object containing the image data in either the PNG or JPEG format.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIImage;
);

unsafe impl Send for UIImage {}

unsafe impl Sync for UIImage {}

extern_conformance!(
    unsafe impl NSCoding for UIImage {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UIImage {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UIImage {}
);

impl UIImage {
    extern_methods!(
        #[unsafe(method(systemImageNamed:))]
        #[unsafe(method_family = none)]
        pub fn systemImageNamed(name: &NSString) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method(systemImageNamed:withConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn systemImageNamed_withConfiguration(
            name: &NSString,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method(systemImageNamed:compatibleWithTraitCollection:))]
        #[unsafe(method_family = none)]
        pub fn systemImageNamed_compatibleWithTraitCollection(
            name: &NSString,
            trait_collection: Option<&UITraitCollection>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        /// Retrieve a system-provided image with the specified name and variable value (between 0 and 1).
        ///
        /// This will only return system-provided images. If you want a custom image as defined in your own catalogs,
        /// you should use
        /// `+imageNamed:inBundle:variableValue:withConfiguration:.`
        /// Returns
        /// `nil`if an image with specified name doesn't exist.
        #[unsafe(method(systemImageNamed:variableValue:withConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn systemImageNamed_variableValue_withConfiguration(
            name: &NSString,
            value: c_double,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method(imageNamed:))]
        #[unsafe(method_family = none)]
        pub fn imageNamed(name: &NSString) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method(imageNamed:inBundle:withConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn imageNamed_inBundle_withConfiguration(
            name: &NSString,
            bundle: Option<&NSBundle>,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method(imageNamed:inBundle:compatibleWithTraitCollection:))]
        #[unsafe(method_family = none)]
        pub fn imageNamed_inBundle_compatibleWithTraitCollection(
            name: &NSString,
            bundle: Option<&NSBundle>,
            trait_collection: Option<&UITraitCollection>,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImageConfiguration")]
        /// Retrieve a image with the specified name and variable value (between 0 and 1).
        ///
        /// This will only return custom images defined in your own catalogs. If you want a system-provided image,
        /// you should use
        /// `+systemImageNamed:variableValue:withConfiguration:.`
        /// Returns
        /// `nil`if an image with specified name doesn't exist.
        #[unsafe(method(imageNamed:inBundle:variableValue:withConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn imageNamed_inBundle_variableValue_withConfiguration(
            name: &NSString,
            bundle: Option<&NSBundle>,
            value: c_double,
            configuration: Option<&UIImageConfiguration>,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method(imageWithContentsOfFile:))]
        #[unsafe(method_family = none)]
        pub fn imageWithContentsOfFile(path: &NSString) -> Option<Retained<UIImage>>;

        #[unsafe(method(imageWithData:))]
        #[unsafe(method_family = none)]
        pub fn imageWithData(data: &NSData) -> Option<Retained<UIImage>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageWithData:scale:))]
        #[unsafe(method_family = none)]
        pub fn imageWithData_scale(data: &NSData, scale: CGFloat) -> Option<Retained<UIImage>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(imageWithCGImage:))]
        #[unsafe(method_family = none)]
        pub fn imageWithCGImage(cg_image: &CGImage) -> Retained<UIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(imageWithCGImage:scale:orientation:))]
        #[unsafe(method_family = none)]
        pub fn imageWithCGImage_scale_orientation(
            cg_image: &CGImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<UIImage>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(imageWithCIImage:))]
        #[unsafe(method_family = none)]
        pub fn imageWithCIImage(ci_image: &CIImage) -> Retained<UIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-image"))]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(imageWithCIImage:scale:orientation:))]
        #[unsafe(method_family = none)]
        pub fn imageWithCIImage_scale_orientation(
            ci_image: &CIImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<UIImage>;

        #[unsafe(method(initWithContentsOfFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub fn initWithData(this: Allocated<Self>, data: &NSData) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(initWithData:scale:))]
        #[unsafe(method_family = init)]
        pub fn initWithData_scale(
            this: Allocated<Self>,
            data: &NSData,
            scale: CGFloat,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(initWithCGImage:))]
        #[unsafe(method_family = init)]
        pub fn initWithCGImage(this: Allocated<Self>, cg_image: &CGImage) -> Retained<Self>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(initWithCGImage:scale:orientation:))]
        #[unsafe(method_family = init)]
        pub fn initWithCGImage_scale_orientation(
            this: Allocated<Self>,
            cg_image: &CGImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(initWithCIImage:))]
        #[unsafe(method_family = init)]
        pub fn initWithCIImage(this: Allocated<Self>, ci_image: &CIImage) -> Retained<Self>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-image"))]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(initWithCIImage:scale:orientation:))]
        #[unsafe(method_family = init)]
        pub fn initWithCIImage_scale_orientation(
            this: Allocated<Self>,
            ci_image: &CIImage,
            scale: CGFloat,
            orientation: UIImageOrientation,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(size))]
        #[unsafe(method_family = none)]
        pub unsafe fn size(&self) -> CGSize;

        #[cfg(feature = "objc2-core-graphics")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(CGImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn CGImage(&self) -> Option<Retained<CGImage>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(CIImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn CIImage(&self) -> Option<Retained<CIImage>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(imageOrientation))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageOrientation(&self) -> UIImageOrientation;

        #[cfg(feature = "objc2-core-foundation")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(scale))]
        #[unsafe(method_family = none)]
        pub unsafe fn scale(&self) -> CGFloat;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isSymbolImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSymbolImage(&self) -> bool;

        #[unsafe(method(animatedImageNamed:duration:))]
        #[unsafe(method_family = none)]
        pub fn animatedImageNamed_duration(
            name: &NSString,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(animatedResizableImageNamed:capInsets:duration:))]
        #[unsafe(method_family = none)]
        pub fn animatedResizableImageNamed_capInsets_duration(
            name: &NSString,
            cap_insets: UIEdgeInsets,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(animatedResizableImageNamed:capInsets:resizingMode:duration:))]
        #[unsafe(method_family = none)]
        pub fn animatedResizableImageNamed_capInsets_resizingMode_duration(
            name: &NSString,
            cap_insets: UIEdgeInsets,
            resizing_mode: UIImageResizingMode,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        #[unsafe(method(animatedImageWithImages:duration:))]
        #[unsafe(method_family = none)]
        pub fn animatedImageWithImages_duration(
            images: &NSArray<UIImage>,
            duration: NSTimeInterval,
        ) -> Option<Retained<UIImage>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(images))]
        #[unsafe(method_family = none)]
        pub unsafe fn images(&self) -> Option<Retained<NSArray<UIImage>>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> NSTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawAtPoint:))]
        #[unsafe(method_family = none)]
        pub fn drawAtPoint(&self, point: CGPoint);

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(drawAtPoint:blendMode:alpha:))]
        #[unsafe(method_family = none)]
        pub fn drawAtPoint_blendMode_alpha(
            &self,
            point: CGPoint,
            blend_mode: CGBlendMode,
            alpha: CGFloat,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawInRect:))]
        #[unsafe(method_family = none)]
        pub fn drawInRect(&self, rect: CGRect);

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(drawInRect:blendMode:alpha:))]
        #[unsafe(method_family = none)]
        pub fn drawInRect_blendMode_alpha(
            &self,
            rect: CGRect,
            blend_mode: CGBlendMode,
            alpha: CGFloat,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawAsPatternInRect:))]
        #[unsafe(method_family = none)]
        pub fn drawAsPatternInRect(&self, rect: CGRect);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(resizableImageWithCapInsets:))]
        #[unsafe(method_family = none)]
        pub fn resizableImageWithCapInsets(&self, cap_insets: UIEdgeInsets) -> Retained<UIImage>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(resizableImageWithCapInsets:resizingMode:))]
        #[unsafe(method_family = none)]
        pub fn resizableImageWithCapInsets_resizingMode(
            &self,
            cap_insets: UIEdgeInsets,
            resizing_mode: UIImageResizingMode,
        ) -> Retained<UIImage>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(capInsets))]
        #[unsafe(method_family = none)]
        pub unsafe fn capInsets(&self) -> UIEdgeInsets;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(resizingMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn resizingMode(&self) -> UIImageResizingMode;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(imageWithAlignmentRectInsets:))]
        #[unsafe(method_family = none)]
        pub fn imageWithAlignmentRectInsets(
            &self,
            alignment_insets: UIEdgeInsets,
        ) -> Retained<UIImage>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(alignmentRectInsets))]
        #[unsafe(method_family = none)]
        pub unsafe fn alignmentRectInsets(&self) -> UIEdgeInsets;

        #[unsafe(method(imageWithRenderingMode:))]
        #[unsafe(method_family = none)]
        pub fn imageWithRenderingMode(
            &self,
            rendering_mode: UIImageRenderingMode,
        ) -> Retained<UIImage>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(renderingMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn renderingMode(&self) -> UIImageRenderingMode;

        #[cfg(all(feature = "UIGraphicsImageRenderer", feature = "UIGraphicsRenderer"))]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(imageRendererFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageRendererFormat(&self) -> Retained<UIGraphicsImageRendererFormat>;

        #[cfg(feature = "UITraitCollection")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(traitCollection))]
        #[unsafe(method_family = none)]
        pub unsafe fn traitCollection(&self) -> Retained<UITraitCollection>;

        #[cfg(feature = "UIImageAsset")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(imageAsset))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageAsset(&self) -> Option<Retained<UIImageAsset>>;

        #[unsafe(method(imageFlippedForRightToLeftLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn imageFlippedForRightToLeftLayoutDirection(&self) -> Retained<UIImage>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(flipsForRightToLeftLayoutDirection))]
        #[unsafe(method_family = none)]
        pub unsafe fn flipsForRightToLeftLayoutDirection(&self) -> bool;

        #[unsafe(method(imageWithHorizontallyFlippedOrientation))]
        #[unsafe(method_family = none)]
        pub fn imageWithHorizontallyFlippedOrientation(&self) -> Retained<UIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(baselineOffsetFromBottom))]
        #[unsafe(method_family = none)]
        pub unsafe fn baselineOffsetFromBottom(&self) -> CGFloat;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(hasBaseline))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasBaseline(&self) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageWithBaselineOffsetFromBottom:))]
        #[unsafe(method_family = none)]
        pub fn imageWithBaselineOffsetFromBottom(
            &self,
            baseline_offset: CGFloat,
        ) -> Retained<UIImage>;

        #[unsafe(method(imageWithoutBaseline))]
        #[unsafe(method_family = none)]
        pub fn imageWithoutBaseline(&self) -> Retained<UIImage>;

        #[cfg(feature = "UIImageConfiguration")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn configuration(&self) -> Option<Retained<UIImageConfiguration>>;

        #[cfg(feature = "UIImageConfiguration")]
        #[unsafe(method(imageWithConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn imageWithConfiguration(
            &self,
            configuration: &UIImageConfiguration,
        ) -> Retained<UIImage>;

        #[cfg(all(
            feature = "UIImageConfiguration",
            feature = "UIImageSymbolConfiguration"
        ))]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(symbolConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn symbolConfiguration(&self) -> Option<Retained<UIImageSymbolConfiguration>>;

        #[cfg(all(
            feature = "UIImageConfiguration",
            feature = "UIImageSymbolConfiguration"
        ))]
        #[unsafe(method(imageByApplyingSymbolConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn imageByApplyingSymbolConfiguration(
            &self,
            configuration: &UIImageSymbolConfiguration,
        ) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIColor")]
        #[unsafe(method(imageWithTintColor:))]
        #[unsafe(method_family = none)]
        pub fn imageWithTintColor(&self, color: &UIColor) -> Retained<UIImage>;

        #[cfg(feature = "UIColor")]
        #[unsafe(method(imageWithTintColor:renderingMode:))]
        #[unsafe(method_family = none)]
        pub fn imageWithTintColor_renderingMode(
            &self,
            color: &UIColor,
            rendering_mode: UIImageRenderingMode,
        ) -> Retained<UIImage>;

        /// Decodes an image synchronously and provides a new one for display in views and animations.
        ///
        ///
        /// Returns: A new version of the image object for display. If the system can’t decode the image, this method returns `nil`.
        ///
        ///
        /// Note: The prepared `UIImage` is not related to the original image. If the properties of the screen (such as its resolution or color gamut) change, or if the image is displayed on a different screen that the one it was prepared for, it may not render correctly.
        #[unsafe(method(imageByPreparingForDisplay))]
        #[unsafe(method_family = none)]
        pub fn imageByPreparingForDisplay(&self) -> Option<Retained<UIImage>>;

        #[cfg(feature = "block2")]
        /// Decodes an image asynchronously and provides a new one for display in views and animations.
        ///
        /// The completion handler will be invoked on a private queue. Be sure to return to the main queue before assigning the prepared image to an image view.
        ///
        ///
        /// Parameter `completionHandler`: A block to invoke with the prepared image. If preparation failed (for example, because the image data is corrupt),
        /// `image`will be `nil`.
        ///
        ///
        /// Note: The prepared `UIImage` is not related to the original image. If the properties of the screen (such as its resolution or color gamut) change, or if the image is displayed on a different screen that the one it was prepared for, it may not render correctly.
        #[unsafe(method(prepareForDisplayWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn prepareForDisplayWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut UIImage)>,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageByPreparingThumbnailOfSize:))]
        #[unsafe(method_family = none)]
        pub fn imageByPreparingThumbnailOfSize(&self, size: CGSize) -> Option<Retained<UIImage>>;

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        #[unsafe(method(prepareThumbnailOfSize:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn prepareThumbnailOfSize_completionHandler(
            &self,
            size: CGSize,
            completion_handler: &block2::DynBlock<dyn Fn(*mut UIImage)>,
        );

        /// Indicates that this image is tagged for display of high dynamic range content.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isHighDynamicRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn isHighDynamicRange(&self) -> bool;

        /// Returns a new image that will render within the standard range.
        #[unsafe(method(imageRestrictedToStandardDynamicRange))]
        #[unsafe(method_family = none)]
        pub fn imageRestrictedToStandardDynamicRange(&self) -> Retained<UIImage>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UIImage {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for UIImage {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// PreconfiguredSystemImages.
impl UIImage {
    extern_methods!(
        #[unsafe(method(actionsImage))]
        #[unsafe(method_family = none)]
        pub fn actionsImage() -> Retained<UIImage>;

        #[unsafe(method(addImage))]
        #[unsafe(method_family = none)]
        pub fn addImage() -> Retained<UIImage>;

        #[unsafe(method(removeImage))]
        #[unsafe(method_family = none)]
        pub fn removeImage() -> Retained<UIImage>;

        #[unsafe(method(checkmarkImage))]
        #[unsafe(method_family = none)]
        pub fn checkmarkImage() -> Retained<UIImage>;

        #[unsafe(method(strokedCheckmarkImage))]
        #[unsafe(method_family = none)]
        pub fn strokedCheckmarkImage() -> Retained<UIImage>;
    );
}

/// NSItemProvider.
impl UIImage {
    extern_methods!();
}

extern_conformance!(
    unsafe impl NSItemProviderReading for UIImage {}
);

extern_conformance!(
    unsafe impl NSItemProviderWriting for UIImage {}
);

/// UIImage.
#[cfg(feature = "NSTextAttachment")]
impl NSTextAttachment {
    extern_methods!(
        #[unsafe(method(textAttachmentWithImage:))]
        #[unsafe(method_family = none)]
        pub fn textAttachmentWithImage(image: &UIImage) -> Retained<NSTextAttachment>;
    );
}

/// UIImageDeprecated.
impl UIImage {
    extern_methods!(
        #[unsafe(method(stretchableImageWithLeftCapWidth:topCapHeight:))]
        #[unsafe(method_family = none)]
        pub fn stretchableImageWithLeftCapWidth_topCapHeight(
            &self,
            left_cap_width: NSInteger,
            top_cap_height: NSInteger,
        ) -> Retained<UIImage>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(leftCapWidth))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftCapWidth(&self) -> NSInteger;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(topCapHeight))]
        #[unsafe(method_family = none)]
        pub unsafe fn topCapHeight(&self) -> NSInteger;
    );
}

mod private_CIImageUIKitAdditions {
    pub trait Sealed {}
}

/// Category "UIKitAdditions" on [`CIImage`].
#[doc(alias = "UIKitAdditions")]
pub unsafe trait CIImageUIKitAdditions:
    ClassType + Sized + private_CIImageUIKitAdditions::Sealed
{
    extern_methods!(
        #[unsafe(method(initWithImage:))]
        #[unsafe(method_family = init)]
        fn initWithImage(this: Allocated<Self>, image: &UIImage) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithImage:options:))]
        #[unsafe(method_family = init)]
        unsafe fn initWithImage_options(
            this: Allocated<Self>,
            image: &UIImage,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<Self>>;
    );
}

#[cfg(feature = "objc2-core-image")]
#[cfg(not(target_os = "watchos"))]
impl private_CIImageUIKitAdditions::Sealed for CIImage {}
#[cfg(feature = "objc2-core-image")]
#[cfg(not(target_os = "watchos"))]
unsafe impl CIImageUIKitAdditions for CIImage {}

impl UIImage {
    /// Returns a data object that contains the specified image in PNG format.
    ///
    /// Parameters:
    /// - image: The original image data.
    ///
    ///
    /// ## Return Value
    ///
    /// A data object containing the PNG data, or `nil` if there was a problem generating the data. This function may return `nil` if the image has no data or if the underlying `CGImageRef` contains data in an unsupported bitmap format.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the image object’s underlying image data has been purged, calling this function forces that data to be reloaded into memory.
    ///
    ///
    /// return image as PNG. May return nil if image has no CGImageRef or invalid bitmap format
    #[doc(alias = "UIImagePNGRepresentation")]
    #[inline]
    pub fn png_representation(&self) -> Option<Retained<NSData>> {
        extern "C-unwind" {
            fn UIImagePNGRepresentation(image: &UIImage) -> *mut NSData;
        }
        let ret = unsafe { UIImagePNGRepresentation(self) };
        unsafe { Retained::retain_autoreleased(ret) }
    }

    /// Returns a data object that contains the image in JPEG format.
    ///
    /// Parameters:
    /// - image: The original image data.
    ///
    /// - compressionQuality: The quality of the resulting JPEG image, expressed as a value from `0.0` to `1.0`. The value `0.0` represents the maximum compression (or lowest quality) while the value `1.0` represents the least compression (or best quality).
    ///
    ///
    /// ## Return Value
    ///
    /// A data object containing the JPEG data, or `nil` if there’s a problem generating the data. This function may return `nil` if the image has no data or if the underlying `CGImageRef` contains data in an unsupported bitmap format.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the image object’s underlying image data has been purged, calling this function forces that data to be reloaded into memory.
    ///
    ///
    /// return image as JPEG. May return nil if image has no CGImageRef or invalid bitmap format. compression is 0(most)..1(least)
    #[doc(alias = "UIImageJPEGRepresentation")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn jpeg_representation(&self, compression_quality: CGFloat) -> Option<Retained<NSData>> {
        extern "C-unwind" {
            fn UIImageJPEGRepresentation(
                image: &UIImage,
                compression_quality: CGFloat,
            ) -> *mut NSData;
        }
        let ret = unsafe { UIImageJPEGRepresentation(self, compression_quality) };
        unsafe { Retained::retain_autoreleased(ret) }
    }

    /// Returns HEIC data representing the image, or nil if such a representation could not be generated. HEIC is recommended for efficiently storing all kinds of images, including those with high dynamic range content.
    #[doc(alias = "UIImageHEICRepresentation")]
    #[inline]
    pub fn heic_representation(&self) -> Option<Retained<NSData>> {
        extern "C-unwind" {
            fn UIImageHEICRepresentation(image: &UIImage) -> *mut NSData;
        }
        let ret = unsafe { UIImageHEICRepresentation(self) };
        unsafe { Retained::retain_autoreleased(ret) }
    }
}

#[deprecated = "renamed to `UIImage::png_representation`"]
#[inline]
pub extern "C-unwind" fn UIImagePNGRepresentation(image: &UIImage) -> Option<Retained<NSData>> {
    extern "C-unwind" {
        fn UIImagePNGRepresentation(image: &UIImage) -> *mut NSData;
    }
    let ret = unsafe { UIImagePNGRepresentation(image) };
    unsafe { Retained::retain_autoreleased(ret) }
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `UIImage::jpeg_representation`"]
#[inline]
pub extern "C-unwind" fn UIImageJPEGRepresentation(
    image: &UIImage,
    compression_quality: CGFloat,
) -> Option<Retained<NSData>> {
    extern "C-unwind" {
        fn UIImageJPEGRepresentation(image: &UIImage, compression_quality: CGFloat) -> *mut NSData;
    }
    let ret = unsafe { UIImageJPEGRepresentation(image, compression_quality) };
    unsafe { Retained::retain_autoreleased(ret) }
}

#[deprecated = "renamed to `UIImage::heic_representation`"]
#[inline]
pub extern "C-unwind" fn UIImageHEICRepresentation(image: &UIImage) -> Option<Retained<NSData>> {
    extern "C-unwind" {
        fn UIImageHEICRepresentation(image: &UIImage) -> *mut NSData;
    }
    let ret = unsafe { UIImageHEICRepresentation(image) };
    unsafe { Retained::retain_autoreleased(ret) }
}
