//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A tab bar’s display mode.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITabBarControllerMode(pub NSInteger);
impl UITabBarControllerMode {
    /// The system sets the display mode based on the tab’s content.
    ///
    /// ## Discussion
    ///
    /// Different platforms handle the mode differently:
    ///
    /// - On iPad, If the [`tabs`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/tabs) array contains one or more [`UITabGroup`](https://developer.apple.com/documentation/uikit/uitabgroup) items, the system displays the content as either a tab bar or a sidebar, depending on the context. Otherwise, it only displays the content only as a tab bar.
    ///
    /// - On Mac Catalyst, the system displays a sidebar if the [`tabs`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/tabs) array contains one or more [`UITabGroup`](https://developer.apple.com/documentation/uikit/uitabgroup) items. Otherwise, it displays a tab bar.
    ///
    /// - On iPhone and Apple TV, the system displays the platform’s regular tab bar.
    ///
    /// - In visionOS, the system displays the platform’s regular tabs, but a [`UITabGroup`](https://developer.apple.com/documentation/uikit/uitabgroup) can display a sidebar when it displays the group’s view controller.
    ///
    /// For more information, see [Elevating your iPad app with a tab bar and sidebar](https://developer.apple.com/documentation/uikit/elevating-your-ipad-app-with-a-tab-bar-and-sidebar).
    ///
    ///
    /// The default tab bar controller mode.
    /// Resolves to `tabSidebar` if any of the tab elements of the tab bar controller is a group, and
    /// if the platform supports displaying a sidebar mode. Otherwise, resolves to `tabBar`.
    #[doc(alias = "UITabBarControllerModeAutomatic")]
    pub const Automatic: Self = Self(0);
    /// The system displays the content only as a tab bar.
    ///
    /// ## Discussion
    ///
    /// For more information, see [Elevating your iPad app with a tab bar and sidebar](https://developer.apple.com/documentation/uikit/elevating-your-ipad-app-with-a-tab-bar-and-sidebar).
    ///
    ///
    /// Displays tabs in a tab bar.
    #[doc(alias = "UITabBarControllerModeTabBar")]
    pub const TabBar: Self = Self(1);
    /// The system displays the content as either a tab bar or a sidebar, depending on the context.
    ///
    /// ## Discussion
    ///
    /// Different platforms handle the mode differently:
    ///
    /// - On iPad, the system displays the content as either a tab bar or a sidebar, depending on the context.
    ///
    /// - On Mac Catalyst, the system displays a sidebar.
    ///
    /// - On iPhone and Apple TV, the system displays the platform’s regular tab bar.
    ///
    /// - In visionOS, the system displays the platform’s regular tabs, but a [`UITabGroup`](https://developer.apple.com/documentation/uikit/uitabgroup) can display a sidebar when it displays the group’s view controller.
    ///
    /// For more information, see [Elevating your iPad app with a tab bar and sidebar](https://developer.apple.com/documentation/uikit/elevating-your-ipad-app-with-a-tab-bar-and-sidebar).
    ///
    ///
    /// Displays tabs in a tab bar and sidebar.
    #[doc(alias = "UITabBarControllerModeTabSidebar")]
    pub const TabSidebar: Self = Self(2);
}

unsafe impl Encode for UITabBarControllerMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITabBarControllerMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITabBarMinimizeBehavior(pub NSInteger);
impl UITabBarMinimizeBehavior {
    /// Resolves to the system default minimize behavior.
    /// Resolves to the system default minimize behavior.
    #[doc(alias = "UITabBarMinimizeBehaviorAutomatic")]
    pub const Automatic: Self = Self(0);
    /// The tab bar does not minimize.
    /// The tab bar does not minimize.
    #[doc(alias = "UITabBarMinimizeBehaviorNever")]
    pub const Never: Self = Self(1);
    /// The tab bar minimizes when scrolling down, and expands when scrolling back up.
    /// The tab bar minimizes when scrolling down, and expands when scrolling back up.
    #[doc(alias = "UITabBarMinimizeBehaviorOnScrollDown")]
    pub const OnScrollDown: Self = Self(2);
    /// The tab bar minimizes when scrolling up, and expands when scrolling back down. Recommended if the scroll view content is aligned to the bottom.
    /// The tab bar minimizes when scrolling up, and expands when scrolling back down.
    /// Recommended if the scroll view content is aligned to the bottom.
    #[doc(alias = "UITabBarMinimizeBehaviorOnScrollUp")]
    pub const OnScrollUp: Self = Self(3);
}

unsafe impl Encode for UITabBarMinimizeBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITabBarMinimizeBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A container view controller that manages a multiselection interface, where the selection determines which child view controller to display.
    ///
    /// ## Overview
    ///
    /// The tab bar interface displays tabs at the bottom of the window for selecting between the different modes and for displaying the views for that mode. This class is generally used as-is, but may also be subclassed.
    ///
    /// Each tab of a tab bar controller interface is associated with a custom view controller. When the user selects a specific tab, the tab bar controller displays the root view of the corresponding view controller, replacing any previous views. (User taps always display the root view of the tab, regardless of which tab was previously selected. This is true even if the tab was already selected.) Because selecting a tab replaces the contents of the interface, the type of interface managed in each tab need not be similar in any way. In fact, tab bar interfaces are commonly used either to present different types of information or to present the same information using a completely different style of interface. The following image shows the tab bar interface presented by the Clock app, each tab of which presents a type of time based information.
    ///
    ///
    /// ![Four screenshots of the Clock app, showing the World Clock, Alarm, Stopwatch, and Timer tabs](https://docs-assets.developer.apple.com/published/9b792d41bfe1e8281689c4cba29bf0a0/media-2934713%402x.png)
    ///
    ///
    /// You should never access the tab bar view of a tab bar controller directly. To configure the tabs of a tab bar controller, you assign the view controllers that provide the root view for each tab to the [`viewControllers`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/viewcontrollers) property. The order in which you specify the view controllers determines the order in which they appear in the tab bar. When setting this property, you should also assign a value to the [`selectedViewController`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/selectedviewcontroller) property to indicate which view controller is selected initially. (You can also select view controllers by array index using the [`selectedIndex`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/selectedindex) property.) When you embed the tab bar controller’s view (obtained using the inherited [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property) in your app window, the tab bar controller automatically selects that view controller and displays its contents, resizing them as needed to fit the tab bar interface.
    ///
    /// Tab bar items are configured through their corresponding view controller. To associate a tab bar item with a view controller, create a new instance of the [`UITabBarItem`](https://developer.apple.com/documentation/uikit/uitabbaritem) class, configure it appropriately for the view controller, and assign it to the view controller’s [`tabBarItem`](https://developer.apple.com/documentation/uikit/uiviewcontroller/tabbaritem) property. If you don’t provide a custom tab bar item for your view controller, the view controller creates a default item containing no image and the text from the view controller’s [`title`](https://developer.apple.com/documentation/uikit/uiviewcontroller/title) property.
    ///
    /// As the user interacts with a tab bar interface, the tab bar controller object sends notifications about the interactions to its delegate. The delegate can be any object you specify but must conform to the [`UITabBarControllerDelegate`](https://developer.apple.com/documentation/uikit/uitabbarcontrollerdelegate) protocol. You can use the delegate to prevent specific tab bar items from being selected and to perform additional tasks when tabs are selected. You can also use the delegate to monitor changes to the tab bar that are made by the More navigation controller, which is described in more detail in [The More navigation controller](https://developer.apple.com/documentation/uikit/uitabbarcontroller#the-more-navigation-controller).
    ///
    /// ### The views of a tab bar controller
    ///
    /// Because the [`UITabBarController`](https://developer.apple.com/documentation/uikit/uitabbarcontroller) class inherits from the [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) class, tab bar controllers have their own view that’s accessible through the [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property. The view for a tab bar controller is just a container for a tab bar view and the view containing your custom content. The tab bar view provides the selection controls for the user and consists of one or more tab bar items. The following image shows how these views are assembled to present the overall tab bar interface. Although the items in the tab bar and toolbar views can change, the views that manage them don’t. Only the custom content view changes to reflect the view controller for the currently selected tab.
    ///
    ///
    /// ![A diagram of the views that are stacked together in a tab bar interface](https://docs-assets.developer.apple.com/published/5b64300bc1148d4c5228708f98e4fec5/media-2934714%402x.png)
    ///
    ///
    /// You can use navigation controllers or custom view controllers as the root view controller for a tab. If the root view controller is a navigation controller, the tab bar controller makes further adjustments to the size of the displayed navigation content so that it doesn’t overlap the tab bar. Any views you display in a tab bar interface should therefore have their [`autoresizingMask`](https://developer.apple.com/documentation/uikit/uiview/autoresizingmask-swift.property) property set to resize the view appropriately under any conditions.
    ///
    /// ### The More navigation controller
    ///
    /// The tab bar has limited space for displaying your custom items. If you add six or more custom view controllers to a tab bar controller, the tab bar controller displays only the first four items plus the standard More item on the tab bar. Tapping the More item brings up a standard interface for selecting the remaining items.
    ///
    /// The interface for the standard More item includes an Edit button that allows the user to reconfigure the tab bar. By default, the user is allowed to rearrange all items on the tab bar. If you do not want the user to modify some items, though, you can remove the appropriate view controllers from the array in the [`customizableViewControllers`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/customizableviewcontrollers) property.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Tab bar customization and the More interface are not available in tvOS.
    ///
    ///
    ///
    /// </div>
    /// ### State preservation
    ///
    /// When you assign a value to this view controller’s [`restorationIdentifier`](https://developer.apple.com/documentation/uikit/uiviewcontroller/restorationidentifier) property, it preserves a reference to the view controller in the selected tab. At restore time, it uses the reference to select the tab with the same view controller.
    ///
    /// When preserving a tab bar controller, assign unique restoration identifiers to the child view controllers you want to preserve. Omitting a restoration identifier from a child view controller causes that tab to return to its default configuration. Although the tab bar controller saves its tabs in the same order that they are listed in the [`viewControllers`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/viewcontrollers) property, the save order is actually irrelevant. Your code is responsible for providing the new tab bar controller during the next launch cycle, so your code can adjust the order of the tabs as needed. The state preservation system restores the contents of each tab based on the assigned restoration identifier, not based on the position of the tab.
    ///
    /// For more information about how state preservation and restoration works, see [App Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072).
    ///
    /// ### Differences between iOS and tvOS
    ///
    /// Tab bar controllers serve the same purpose in tvOS as in iOS, but provide slightly different user interface features:
    ///
    /// - In tvOS, the tab bar interface appears at the top of the window. When focus leaves the tab bar, the tab bar remains fixed at the top of the screen by default. To create an interface where the tab bar doesn’t remain fixed, but instead scrolls with the content, set the [`tabBarObservedScrollView`](https://developer.apple.com/documentation/uikit/uiviewcontroller/tabbarobservedscrollview) property to the appropriate scroll view. In iOS, the tab bar always stays pinned at the bottom of the screen.
    ///
    /// - In tvOS, swiping down from the tab bar moves focus into the content view; specifically, to the first focusable view that’s visually below the selected tab. Swiping down behaves like a normal focus-changing gesture — that is, focus moves in the direction the user swiped. If nothing is focusable immediately below the selected tab, the closest focusable view is focused instead. In iOS, the tab bar always remains in focus at the bottom of the screen.
    ///
    /// - In tvOS, pressing the Select button while a tab is focused moves focus into the content view. Because there’s no direction associated with this change, focus moves to the most appropriate view specified in the content view’s [`preferredFocusEnvironments`](https://developer.apple.com/documentation/uikit/uifocusenvironment/preferredfocusenvironments) property. In iOS, there’s no notion of focusing between views.
    ///
    /// - Tab bar controllers in tvOS don’t support customization. A tab bar controller displays only the number of view controllers from its [`viewControllers`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/viewcontrollers) array that fit on the screen, and doesn’t provide the More interface seen in iOS.
    ///
    ///
    /// UITabBarController manages a button bar and transition view, for an application with multiple top-level modes.
    ///
    /// To use in your application, add its view to the view hierarchy, then add top-level view controllers in order.
    /// Most clients will not need to subclass UITabBarController.
    ///
    /// If more than five view controllers are added to a tab bar controller, only the first four will display.
    /// The rest will be accessible under an automatically generated More item.
    ///
    /// UITabBarController is rotatable if all of its view controllers are rotatable.
    #[unsafe(super(UIViewController, UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
    pub struct UITabBarController;
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl NSCoding for UITabBarController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for UITabBarController {}
);

#[cfg(all(
    feature = "UIAppearance",
    feature = "UIResponder",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UITabBarController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl UIContentContainer for UITabBarController {}
);

#[cfg(all(
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UITabBarController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UITabBarController {}
);

#[cfg(all(
    feature = "UIResponder",
    feature = "UITabBar",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UITabBarDelegate for UITabBarController {}
);

#[cfg(all(
    feature = "UIResponder",
    feature = "UITraitCollection",
    feature = "UIViewController"
))]
extern_conformance!(
    unsafe impl UITraitEnvironment for UITabBarController {}
);

#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UITabBarController {
    extern_methods!(
        /// The object managing the delegate of the tab bar controller.
        ///
        /// The default value for this property is `nil`.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn UITabBarControllerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn UITabBarControllerDelegate>>,
        );

        /// The object managing the tab sidebar for the tab bar controller.
        ///
        /// The default value for this property is `UITabBarControllerModeAutomatic`.
        #[unsafe(method(mode))]
        #[unsafe(method_family = none)]
        pub fn mode(&self) -> UITabBarControllerMode;

        /// Setter for [`mode`][Self::mode].
        #[unsafe(method(setMode:))]
        #[unsafe(method_family = none)]
        pub fn setMode(&self, mode: UITabBarControllerMode);

        #[cfg(feature = "UITabBarControllerSidebar")]
        /// The object managing the tab sidebar for the tab bar controller.
        #[unsafe(method(sidebar))]
        #[unsafe(method_family = none)]
        pub fn sidebar(&self) -> Retained<UITabBarControllerSidebar>;

        /// The customization identifier for the tab bar and sidebar for persistence.
        ///
        /// The identifier is useful for when an app has multiple tab bar controllers, each with their own customizations.
        /// If the customization identifier is `nil`, a system default is used. Default is `nil`.
        #[unsafe(method(customizationIdentifier))]
        #[unsafe(method_family = none)]
        pub fn customizationIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`customizationIdentifier`][Self::customizationIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCustomizationIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setCustomizationIdentifier(&self, customization_identifier: Option<&NSString>);

        /// An optional filter to display only select root-level tabs when in a compact appearance.
        ///
        /// The default value is is `nil`, which would make all tabs available.
        #[unsafe(method(compactTabIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn compactTabIdentifiers(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`compactTabIdentifiers`][Self::compactTabIdentifiers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCompactTabIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn setCompactTabIdentifiers(&self, compact_tab_identifiers: Option<&NSArray<NSString>>);

        #[cfg(feature = "UITab")]
        /// The currently selected tab, which can be a root tab or any of their descendants.
        ///
        /// The default value for this property is `nil`.
        #[unsafe(method(selectedTab))]
        #[unsafe(method_family = none)]
        pub fn selectedTab(&self) -> Option<Retained<UITab>>;

        #[cfg(feature = "UITab")]
        /// Setter for [`selectedTab`][Self::selectedTab].
        #[unsafe(method(setSelectedTab:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedTab(&self, selected_tab: Option<&UITab>);

        #[cfg(feature = "UITab")]
        /// An array of root tabs representing view controllers to display by the tab bar interface.
        ///
        /// Once set, `UITabBarController.viewControllers` and related properties and methods will not be called.
        #[unsafe(method(tabs))]
        #[unsafe(method_family = none)]
        pub fn tabs(&self) -> Retained<NSArray<UITab>>;

        #[cfg(feature = "UITab")]
        /// Setter for [`tabs`][Self::tabs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTabs:))]
        #[unsafe(method_family = none)]
        pub fn setTabs(&self, tabs: &NSArray<UITab>);

        #[cfg(feature = "UITab")]
        /// Sets the root tabs of the tab bar controller, with an option to animate the change.
        #[unsafe(method(setTabs:animated:))]
        #[unsafe(method_family = none)]
        pub fn setTabs_animated(&self, tabs: &NSArray<UITab>, animated: bool);

        #[cfg(feature = "UITab")]
        /// Returns the `tab` matching the specified `identifier` in the tab bar controller's tabs. Returns nil if no tab is found matching the `identifier`.
        #[unsafe(method(tabForIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn tabForIdentifier(&self, identifier: &NSString) -> Option<Retained<UITab>>;

        #[cfg(feature = "UITab")]
        /// Creates a tab bar controller with the specified tabs.
        #[unsafe(method(initWithTabs:))]
        #[unsafe(method_family = init)]
        pub fn initWithTabs(this: Allocated<Self>, tabs: &NSArray<UITab>) -> Retained<Self>;

        /// Defines the minimize behavior for the tab bar, if it is supported.
        ///
        /// The default value for this property is `UITabBarMinimizeBehaviorAutomatic`.
        #[unsafe(method(tabBarMinimizeBehavior))]
        #[unsafe(method_family = none)]
        pub fn tabBarMinimizeBehavior(&self) -> UITabBarMinimizeBehavior;

        /// Setter for [`tabBarMinimizeBehavior`][Self::tabBarMinimizeBehavior].
        #[unsafe(method(setTabBarMinimizeBehavior:))]
        #[unsafe(method_family = none)]
        pub fn setTabBarMinimizeBehavior(
            &self,
            tab_bar_minimize_behavior: UITabBarMinimizeBehavior,
        );

        /// Determines if the active tab bar is currently hidden.
        ///
        /// The default value for this property is `NO`.
        #[unsafe(method(isTabBarHidden))]
        #[unsafe(method_family = none)]
        pub fn isTabBarHidden(&self) -> bool;

        /// Setter for [`isTabBarHidden`][Self::isTabBarHidden].
        #[unsafe(method(setTabBarHidden:))]
        #[unsafe(method_family = none)]
        pub fn setTabBarHidden(&self, tab_bar_hidden: bool);

        /// Changes the active tab bar's visibility with an option to animate the change.
        #[unsafe(method(setTabBarHidden:animated:))]
        #[unsafe(method_family = none)]
        pub fn setTabBarHidden_animated(&self, hidden: bool, animated: bool);

        #[cfg(feature = "UILayoutGuide")]
        /// The content layout guide provides the layout area for the UITabBarController unobscured by the tab bar or sidebar.
        #[unsafe(method(contentLayoutGuide))]
        #[unsafe(method_family = none)]
        pub fn contentLayoutGuide(&self) -> Retained<UILayoutGuide>;

        #[cfg(feature = "UITabAccessory")]
        /// An optional bottom accessory of the tab bar controller.
        ///
        /// The default value for this property is `nil`.
        #[unsafe(method(bottomAccessory))]
        #[unsafe(method_family = none)]
        pub fn bottomAccessory(&self) -> Option<Retained<UITabAccessory>>;

        #[cfg(feature = "UITabAccessory")]
        /// Setter for [`bottomAccessory`][Self::bottomAccessory].
        #[unsafe(method(setBottomAccessory:))]
        #[unsafe(method_family = none)]
        pub fn setBottomAccessory(&self, bottom_accessory: Option<&UITabAccessory>);

        #[cfg(feature = "UITabAccessory")]
        /// Sets a bottom accessory with an option to animate the change.
        #[unsafe(method(setBottomAccessory:animated:))]
        #[unsafe(method_family = none)]
        pub fn setBottomAccessory_animated(
            &self,
            bottom_accessory: Option<&UITabAccessory>,
            animated: bool,
        );

        #[unsafe(method(viewControllers))]
        #[unsafe(method_family = none)]
        pub fn viewControllers(&self) -> Option<Retained<NSArray<UIViewController>>>;

        /// Setter for [`viewControllers`][Self::viewControllers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setViewControllers:))]
        #[unsafe(method_family = none)]
        pub fn setViewControllers(&self, view_controllers: Option<&NSArray<UIViewController>>);

        #[unsafe(method(setViewControllers:animated:))]
        #[unsafe(method_family = none)]
        pub fn setViewControllers_animated(
            &self,
            view_controllers: Option<&NSArray<UIViewController>>,
            animated: bool,
        );

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(selectedViewController))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectedViewController(&self) -> Option<Retained<UIViewController>>;

        /// Setter for [`selectedViewController`][Self::selectedViewController].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setSelectedViewController:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSelectedViewController(
            &self,
            selected_view_controller: Option<&UIViewController>,
        );

        #[unsafe(method(selectedIndex))]
        #[unsafe(method_family = none)]
        pub fn selectedIndex(&self) -> NSUInteger;

        /// Setter for [`selectedIndex`][Self::selectedIndex].
        #[unsafe(method(setSelectedIndex:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedIndex(&self, selected_index: NSUInteger);

        #[cfg(feature = "UINavigationController")]
        #[unsafe(method(moreNavigationController))]
        #[unsafe(method_family = none)]
        pub fn moreNavigationController(&self) -> Retained<UINavigationController>;

        #[unsafe(method(customizableViewControllers))]
        #[unsafe(method_family = none)]
        pub fn customizableViewControllers(&self) -> Option<Retained<NSArray<UIViewController>>>;

        /// Setter for [`customizableViewControllers`][Self::customizableViewControllers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCustomizableViewControllers:))]
        #[unsafe(method_family = none)]
        pub fn setCustomizableViewControllers(
            &self,
            customizable_view_controllers: Option<&NSArray<UIViewController>>,
        );

        #[cfg(all(feature = "UITabBar", feature = "UIView"))]
        #[unsafe(method(tabBar))]
        #[unsafe(method_family = none)]
        pub fn tabBar(&self) -> Retained<UITabBar>;
    );
}

/// Methods declared on superclass `UIViewController`.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UITabBarController {
    extern_methods!(
        #[unsafe(method(initWithNibName:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithNibName_bundle(
            this: Allocated<Self>,
            nib_name_or_nil: Option<&NSString>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UITabBarController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_protocol!(
    /// A set of methods you implement to customize the behavior of a tab bar.
    ///
    /// ## Overview
    ///
    /// You use the [`UITabBarControllerDelegate`](https://developer.apple.com/documentation/uikit/uitabbarcontrollerdelegate) protocol when you want to augment the behavior of a tab bar. In particular, you can use it to determine whether specific tabs should be selected, to perform actions after a tab is selected, or to perform actions before or after the user customizes the order of the tabs. After implementing these methods in your custom object, you should then assign that object to the [`delegate`](https://developer.apple.com/documentation/uikit/uitabbarcontroller/delegate) property of the corresponding [`UITabBarController`](https://developer.apple.com/documentation/uikit/uitabbarcontroller) object.
    ///
    /// All of the methods in this protocol are optional. For more information on how to use and configure tab bar controllers and their delegates, see [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).
    ///
    ///
    pub unsafe trait UITabBarControllerDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(all(
            feature = "UIResponder",
            feature = "UITab",
            feature = "UIViewController"
        ))]
        /// Asks the delegate whether the specified tab should be made active.
        ///
        /// Return
        /// `YES`if the specified
        /// `tab`can be selected by the user. Otherwise, return
        /// `NO`
        #[optional]
        #[unsafe(method(tabBarController:shouldSelectTab:))]
        #[unsafe(method_family = none)]
        fn tabBarController_shouldSelectTab(
            &self,
            tab_bar_controller: &UITabBarController,
            tab: &UITab,
        ) -> bool;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UITab",
            feature = "UIViewController"
        ))]
        /// Tells the delegate that the user selected the specified
        /// `selectedTab`in the tab bar controller.
        ///
        /// This specified
        /// `selectedTab`is either a root tab or any of their descendants.
        #[optional]
        #[unsafe(method(tabBarController:didSelectTab:previousTab:))]
        #[unsafe(method_family = none)]
        fn tabBarController_didSelectTab_previousTab(
            &self,
            tab_bar_controller: &UITabBarController,
            selected_tab: &UITab,
            previous_tab: Option<&UITab>,
        );

        #[cfg(all(
            feature = "UIDragSession",
            feature = "UIDropInteraction",
            feature = "UIResponder",
            feature = "UITab",
            feature = "UIViewController"
        ))]
        /// Asks the delegate for a drop operation to determine if drag items can be dropped into the specified
        /// `tab`
        /// If the operation is either a `.move` or `.copy`, then the drop will proceed and `tabBarController:tab:acceptItemsFromDropSession:`
        /// is called. By default, the drop will be treated as a cancel operation if this is not implemented.
        #[optional]
        #[unsafe(method(tabBarController:tab:operationForAcceptingItemsFromDropSession:))]
        #[unsafe(method_family = none)]
        fn tabBarController_tab_operationForAcceptingItemsFromDropSession(
            &self,
            tab_bar_controller: &UITabBarController,
            tab: &UITab,
            session: &ProtocolObject<dyn UIDropSession>,
        ) -> UIDropOperation;

        #[cfg(all(
            feature = "UIDragSession",
            feature = "UIResponder",
            feature = "UITab",
            feature = "UIViewController"
        ))]
        /// Notifies the delegate to perform a drop into the specified
        /// `tab`from the specified session.
        ///
        /// This is only called if the operation returned from `tabBarController:tab:operationForAcceptingItemsFromDropSession` is valid for a drop.
        #[optional]
        #[unsafe(method(tabBarController:tab:acceptItemsFromDropSession:))]
        #[unsafe(method_family = none)]
        fn tabBarController_tab_acceptItemsFromDropSession(
            &self,
            tab_bar_controller: &UITabBarController,
            tab: &UITab,
            session: &ProtocolObject<dyn UIDropSession>,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        /// Notifies the delegate when the tab bar controller is about to begin editing.
        #[optional]
        #[unsafe(method(tabBarControllerWillBeginEditing:))]
        #[unsafe(method_family = none)]
        fn tabBarControllerWillBeginEditing(&self, tab_bar_controller: &UITabBarController);

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        /// Notifies the delegate when the tab bar controller's current editing state has ended.
        #[optional]
        #[unsafe(method(tabBarControllerDidEndEditing:))]
        #[unsafe(method_family = none)]
        fn tabBarControllerDidEndEditing(&self, tab_bar_controller: &UITabBarController);

        #[cfg(all(
            feature = "UIResponder",
            feature = "UITab",
            feature = "UIViewController"
        ))]
        /// Notifies the delegate when editing has ended and the specified tabs have had their `isHidden` values changed by the user.
        #[optional]
        #[unsafe(method(tabBarController:visibilityDidChangeForTabs:))]
        #[unsafe(method_family = none)]
        fn tabBarController_visibilityDidChangeForTabs(
            &self,
            tab_bar_controller: &UITabBarController,
            tabs: &NSArray<UITab>,
        );

        #[cfg(all(
            feature = "UIResponder",
            feature = "UITab",
            feature = "UITabGroup",
            feature = "UIViewController"
        ))]
        /// Notifies the delegate that the display order for the specified tab has been changed by the user.
        #[optional]
        #[unsafe(method(tabBarController:displayOrderDidChangeForGroup:))]
        #[unsafe(method_family = none)]
        fn tabBarController_displayOrderDidChangeForGroup(
            &self,
            tab_bar_controller: &UITabBarController,
            group: &UITabGroup,
        );

        #[cfg(all(
            feature = "UIResponder",
            feature = "UITab",
            feature = "UIViewController"
        ))]
        /// Used with `UITabGroup.managingNavigationController`, this method allows the delegate to customize the displayed view controllers
        /// within the navigation stack for each level of selected tab. This method is called by the system if the selected tab in the `UITabBarController`
        /// belongs to or is in the hierarchy of a managing tab group (i.e. a `UITabGroup` with a non-nil `managingNavigationController`). By default,
        /// if this method is not implemented, the system will build the navigation stack by adding each tab's `viewController` into the hierarchy, if one exists.
        /// This is especially useful to hide certain view controllers when transitioning between compact and regular size classes.
        ///
        ///
        /// Parameter `tabBarController`: The tab bar controller managed by the delegate.
        ///
        /// Parameter `tab`: The tab for which the displayed view controllers is being requested for by its `managingTabGroup`. Each tab in the selection hierarchy will be called once.
        ///
        /// Parameter `proposedViewControllers`: The proposed view controllers for the given tab. In general, the proposed view controller is a single-item array of the tab's viewController. If other view controllers are pushed onto the navigation stack, they will be part of the last (leaf-most) tab's `proposedViewControllers` such that they are preserved between updates.
        ///
        ///
        /// Returns: A list of view controllers represented by the tab in the navigation stack.
        #[optional]
        #[unsafe(method(tabBarController:displayedViewControllersForTab:proposedViewControllers:))]
        #[unsafe(method_family = none)]
        fn tabBarController_displayedViewControllersForTab_proposedViewControllers(
            &self,
            tab_bar_controller: &UITabBarController,
            tab: &UITab,
            proposed_view_controllers: &NSArray<UIViewController>,
        ) -> Retained<NSArray<UIViewController>>;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(tabBarController:shouldSelectViewController:))]
        #[unsafe(method_family = none)]
        fn tabBarController_shouldSelectViewController(
            &self,
            tab_bar_controller: &UITabBarController,
            view_controller: &UIViewController,
        ) -> bool;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(tabBarController:didSelectViewController:))]
        #[unsafe(method_family = none)]
        fn tabBarController_didSelectViewController(
            &self,
            tab_bar_controller: &UITabBarController,
            view_controller: &UIViewController,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(tabBarController:willBeginCustomizingViewControllers:))]
        #[unsafe(method_family = none)]
        fn tabBarController_willBeginCustomizingViewControllers(
            &self,
            tab_bar_controller: &UITabBarController,
            view_controllers: &NSArray<UIViewController>,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(tabBarController:willEndCustomizingViewControllers:changed:))]
        #[unsafe(method_family = none)]
        fn tabBarController_willEndCustomizingViewControllers_changed(
            &self,
            tab_bar_controller: &UITabBarController,
            view_controllers: &NSArray<UIViewController>,
            changed: bool,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(tabBarController:didEndCustomizingViewControllers:changed:))]
        #[unsafe(method_family = none)]
        fn tabBarController_didEndCustomizingViewControllers_changed(
            &self,
            tab_bar_controller: &UITabBarController,
            view_controllers: &NSArray<UIViewController>,
            changed: bool,
        );

        #[cfg(all(
            feature = "UIOrientation",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[unsafe(method(tabBarControllerSupportedInterfaceOrientations:))]
        #[unsafe(method_family = none)]
        fn tabBarControllerSupportedInterfaceOrientations(
            &self,
            tab_bar_controller: &UITabBarController,
        ) -> UIInterfaceOrientationMask;

        #[cfg(all(
            feature = "UIOrientation",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[unsafe(method(tabBarControllerPreferredInterfaceOrientationForPresentation:))]
        #[unsafe(method_family = none)]
        fn tabBarControllerPreferredInterfaceOrientationForPresentation(
            &self,
            tab_bar_controller: &UITabBarController,
        ) -> UIInterfaceOrientation;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitioning"
        ))]
        #[optional]
        #[unsafe(method(tabBarController:interactionControllerForAnimationController:))]
        #[unsafe(method_family = none)]
        fn tabBarController_interactionControllerForAnimationController(
            &self,
            tab_bar_controller: &UITabBarController,
            animation_controller: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitioning"
        ))]
        #[optional]
        #[unsafe(method(tabBarController:animationControllerForTransitionFromViewController:toViewController:))]
        #[unsafe(method_family = none)]
        fn tabBarController_animationControllerForTransitionFromViewController_toViewController(
            &self,
            tab_bar_controller: &UITabBarController,
            from_vc: &UIViewController,
            to_vc: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;
    }
);

/// UITabBarControllerItem.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UIViewController {
    extern_methods!(
        #[cfg(all(feature = "UIBarItem", feature = "UITabBarItem"))]
        #[unsafe(method(tabBarItem))]
        #[unsafe(method_family = none)]
        pub fn tabBarItem(&self) -> Option<Retained<UITabBarItem>>;

        #[cfg(all(feature = "UIBarItem", feature = "UITabBarItem"))]
        /// Setter for [`tabBarItem`][Self::tabBarItem].
        ///
        /// # Safety
        ///
        /// `tab_bar_item` might not allow `None`.
        #[unsafe(method(setTabBarItem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTabBarItem(&self, tab_bar_item: Option<&UITabBarItem>);

        #[unsafe(method(tabBarController))]
        #[unsafe(method_family = none)]
        pub fn tabBarController(&self) -> Option<Retained<UITabBarController>>;

        #[cfg(all(feature = "UIScrollView", feature = "UIView"))]
        #[deprecated = "Use -setContentScrollView:forEdge: instead."]
        #[unsafe(method(tabBarObservedScrollView))]
        #[unsafe(method_family = none)]
        pub fn tabBarObservedScrollView(&self) -> Option<Retained<UIScrollView>>;

        #[cfg(all(feature = "UIScrollView", feature = "UIView"))]
        /// Setter for [`tabBarObservedScrollView`][Self::tabBarObservedScrollView].
        #[deprecated = "Use -setContentScrollView:forEdge: instead."]
        #[unsafe(method(setTabBarObservedScrollView:))]
        #[unsafe(method_family = none)]
        pub fn setTabBarObservedScrollView(
            &self,
            tab_bar_observed_scroll_view: Option<&UIScrollView>,
        );
    );
}
