//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
use objc2_quartz_core::*;

use crate::*;

/// Specifies the supported animation curves.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewAnimationCurve(pub NSInteger);
impl UIViewAnimationCurve {
    /// An ease-in ease-out curve causes the animation to begin slowly, accelerate through the middle of its duration, and then slow again before completing. This is the default curve for most animations.
    #[doc(alias = "UIViewAnimationCurveEaseInOut")]
    pub const EaseInOut: Self = Self(0);
    /// An ease-in curve causes the animation to begin slowly, and then speed up as it progresses.
    #[doc(alias = "UIViewAnimationCurveEaseIn")]
    pub const EaseIn: Self = Self(1);
    /// An ease-out curve causes the animation to begin quickly, and then slow down as it completes.
    #[doc(alias = "UIViewAnimationCurveEaseOut")]
    pub const EaseOut: Self = Self(2);
    /// A linear animation curve causes an animation to occur evenly over its duration.
    #[doc(alias = "UIViewAnimationCurveLinear")]
    pub const Linear: Self = Self(3);
}

unsafe impl Encode for UIViewAnimationCurve {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIViewAnimationCurve {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options to specify how a view adjusts its content when its size changes.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewContentMode(pub NSInteger);
impl UIViewContentMode {
    /// The option to scale the content to fit the size of itself by changing the aspect ratio of the content if necessary.
    #[doc(alias = "UIViewContentModeScaleToFill")]
    pub const ScaleToFill: Self = Self(0);
    /// The option to scale the content to fit the size of the view by maintaining the aspect ratio. Any remaining area of the view’s bounds is transparent.
    #[doc(alias = "UIViewContentModeScaleAspectFit")]
    pub const ScaleAspectFit: Self = Self(1);
    /// The option to scale the content to fill the size of the view. Some portion of the content may be clipped to fill the view’s bounds.
    #[doc(alias = "UIViewContentModeScaleAspectFill")]
    pub const ScaleAspectFill: Self = Self(2);
    /// The option to redisplay the view when the bounds change by invoking the [`setNeedsDisplay`](https://developer.apple.com/documentation/uikit/uiview/setneedsdisplay()) method.
    #[doc(alias = "UIViewContentModeRedraw")]
    pub const Redraw: Self = Self(3);
    /// The option to center the content in the view’s bounds, keeping the proportions the same.
    #[doc(alias = "UIViewContentModeCenter")]
    pub const Center: Self = Self(4);
    /// The option to center the content aligned at the top in the view’s bounds.
    #[doc(alias = "UIViewContentModeTop")]
    pub const Top: Self = Self(5);
    /// The option to center the content aligned at the bottom in the view’s bounds.
    #[doc(alias = "UIViewContentModeBottom")]
    pub const Bottom: Self = Self(6);
    /// The option to align the content on the left of the view.
    #[doc(alias = "UIViewContentModeLeft")]
    pub const Left: Self = Self(7);
    /// The option to align the content on the right of the view.
    #[doc(alias = "UIViewContentModeRight")]
    pub const Right: Self = Self(8);
    /// The option to align the content in the top-left corner of the view.
    #[doc(alias = "UIViewContentModeTopLeft")]
    pub const TopLeft: Self = Self(9);
    /// The option to align the content in the top-right corner of the view.
    #[doc(alias = "UIViewContentModeTopRight")]
    pub const TopRight: Self = Self(10);
    /// The option to align the content in the bottom-left corner of the view.
    #[doc(alias = "UIViewContentModeBottomLeft")]
    pub const BottomLeft: Self = Self(11);
    /// The option to align the content in the bottom-right corner of the view.
    #[doc(alias = "UIViewContentModeBottomRight")]
    pub const BottomRight: Self = Self(12);
}

unsafe impl Encode for UIViewContentMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIViewContentMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Animation transition options for use in an animation block object.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewAnimationTransition(pub NSInteger);
impl UIViewAnimationTransition {
    /// The option for indicating that no transition is specified.
    #[doc(alias = "UIViewAnimationTransitionNone")]
    pub const None: Self = Self(0);
    /// A transition that flips a view around a vertical axis from left to right. The left side of the view moves towards the front and right side towards the back.
    #[doc(alias = "UIViewAnimationTransitionFlipFromLeft")]
    pub const FlipFromLeft: Self = Self(1);
    /// A transition that flips a view around a vertical axis from right to left. The right side of the view moves towards the front and left side towards the back.
    #[doc(alias = "UIViewAnimationTransitionFlipFromRight")]
    pub const FlipFromRight: Self = Self(2);
    /// A transition that curls a view up from the bottom.
    #[doc(alias = "UIViewAnimationTransitionCurlUp")]
    pub const CurlUp: Self = Self(3);
    /// A transition that curls a view down from the top.
    #[doc(alias = "UIViewAnimationTransitionCurlDown")]
    pub const CurlDown: Self = Self(4);
}

unsafe impl Encode for UIViewAnimationTransition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIViewAnimationTransition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for automatic view resizing.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewAutoresizing(pub NSUInteger);
bitflags::bitflags! {
    impl UIViewAutoresizing: NSUInteger {
/// The option for indicating that the view does not resize.
        #[doc(alias = "UIViewAutoresizingNone")]
        const None = 0;
/// Resizing performed by expanding or shrinking a view in the direction of the left margin.
        #[doc(alias = "UIViewAutoresizingFlexibleLeftMargin")]
        const FlexibleLeftMargin = 1<<0;
/// Resizing performed by expanding or shrinking a view’s width.
        #[doc(alias = "UIViewAutoresizingFlexibleWidth")]
        const FlexibleWidth = 1<<1;
/// Resizing performed by expanding or shrinking a view in the direction of the right margin.
        #[doc(alias = "UIViewAutoresizingFlexibleRightMargin")]
        const FlexibleRightMargin = 1<<2;
/// Resizing performed by expanding or shrinking a view in the direction of the top margin.
        #[doc(alias = "UIViewAutoresizingFlexibleTopMargin")]
        const FlexibleTopMargin = 1<<3;
/// Resizing performed by expanding or shrinking a view’s height.
        #[doc(alias = "UIViewAutoresizingFlexibleHeight")]
        const FlexibleHeight = 1<<4;
/// Resizing performed by expanding or shrinking a view in the direction of the bottom margin.
        #[doc(alias = "UIViewAutoresizingFlexibleBottomMargin")]
        const FlexibleBottomMargin = 1<<5;
    }
}

unsafe impl Encode for UIViewAutoresizing {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIViewAutoresizing {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for animating views using block objects.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewAnimationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl UIViewAnimationOptions: NSUInteger {
/// Lay out subviews at commit time so that they are animated along with their parent.
        #[doc(alias = "UIViewAnimationOptionLayoutSubviews")]
        const LayoutSubviews = 1<<0;
/// Allow the user to interact with views while they are being animated.
        #[doc(alias = "UIViewAnimationOptionAllowUserInteraction")]
        const AllowUserInteraction = 1<<1;
/// Start the animation from the current setting associated with an already in-flight animation.
///
/// ## Discussion
///
/// If this key is not present, all in-flight animations are allowed to finish before the new animation is started. If another animation is not in flight, this key has no effect.
///
///
        #[doc(alias = "UIViewAnimationOptionBeginFromCurrentState")]
        const BeginFromCurrentState = 1<<2;
/// Repeat the animation indefinitely.
        #[doc(alias = "UIViewAnimationOptionRepeat")]
        const Repeat = 1<<3;
/// Run the animation backwards and forwards (must be combined with the repeat option).
        #[doc(alias = "UIViewAnimationOptionAutoreverse")]
        const Autoreverse = 1<<4;
/// Force the animation to use the original duration value specified when the animation was submitted.
///
/// ## Discussion
///
/// If this key is not present, the animation inherits the remaining duration of the in-flight animation, if any.
///
///
        #[doc(alias = "UIViewAnimationOptionOverrideInheritedDuration")]
        const OverrideInheritedDuration = 1<<5;
/// Force the animation to use the original curve value specified when the animation was submitted.
///
/// ## Discussion
///
/// If this key is not present, the animation inherits the curve of the in-flight animation, if any.
///
///
        #[doc(alias = "UIViewAnimationOptionOverrideInheritedCurve")]
        const OverrideInheritedCurve = 1<<6;
/// Animate the views by changing the property values dynamically and redrawing the view.
///
/// ## Discussion
///
/// If this key is not present, the views are animated using a snapshot image.
///
///
        #[doc(alias = "UIViewAnimationOptionAllowAnimatedContent")]
        const AllowAnimatedContent = 1<<7;
/// Hide or show views during a view transition.
///
/// ## Discussion
///
/// When present, this key causes views to be hidden or shown (instead of removed or added) when performing a view transition. Both views must already be present in the parent view’s hierarchy when using this key. If this key is not present, the to-view in a transition is added to, and the from-view is removed from, the parent view’s list of subviews.
///
///
        #[doc(alias = "UIViewAnimationOptionShowHideTransitionViews")]
        const ShowHideTransitionViews = 1<<8;
/// The option to not inherit the animation type or any options.
        #[doc(alias = "UIViewAnimationOptionOverrideInheritedOptions")]
        const OverrideInheritedOptions = 1<<9;
/// Specify an ease-in ease-out curve, which causes the animation to begin slowly, accelerate through the middle of its duration, and then slow again before completing.
        #[doc(alias = "UIViewAnimationOptionCurveEaseInOut")]
        const CurveEaseInOut = 0<<16;
/// An ease-in curve causes the animation to begin slowly, and then speed up as it progresses.
        #[doc(alias = "UIViewAnimationOptionCurveEaseIn")]
        const CurveEaseIn = 1<<16;
/// An ease-out curve causes the animation to begin quickly, and then slow as it completes.
        #[doc(alias = "UIViewAnimationOptionCurveEaseOut")]
        const CurveEaseOut = 2<<16;
/// A linear animation curve causes an animation to occur evenly over its duration.
        #[doc(alias = "UIViewAnimationOptionCurveLinear")]
        const CurveLinear = 3<<16;
/// No transition is specified.
        #[doc(alias = "UIViewAnimationOptionTransitionNone")]
        const TransitionNone = 0<<20;
/// A transition that flips a view around its vertical axis from left to right (the left side of the view moves toward the front and right side toward the back).
        #[doc(alias = "UIViewAnimationOptionTransitionFlipFromLeft")]
        const TransitionFlipFromLeft = 1<<20;
/// A transition that flips a view around its vertical axis from right to left (the right side of the view moves toward the front and left side toward the back).
        #[doc(alias = "UIViewAnimationOptionTransitionFlipFromRight")]
        const TransitionFlipFromRight = 2<<20;
/// A transition that curls a view up from the bottom.
        #[doc(alias = "UIViewAnimationOptionTransitionCurlUp")]
        const TransitionCurlUp = 3<<20;
/// A transition that curls a view down from the top.
        #[doc(alias = "UIViewAnimationOptionTransitionCurlDown")]
        const TransitionCurlDown = 4<<20;
/// A transition that dissolves from one view to the next.
        #[doc(alias = "UIViewAnimationOptionTransitionCrossDissolve")]
        const TransitionCrossDissolve = 5<<20;
/// A transition that flips a view around its horizontal axis from top to bottom (the top side of the view moves toward the front and the bottom side toward the back).
        #[doc(alias = "UIViewAnimationOptionTransitionFlipFromTop")]
        const TransitionFlipFromTop = 6<<20;
/// A transition that flips a view around its horizontal axis from bottom to top (the bottom side of the view moves toward the front and the top side toward the back).
        #[doc(alias = "UIViewAnimationOptionTransitionFlipFromBottom")]
        const TransitionFlipFromBottom = 7<<20;
/// The default number of frames per second.
///
/// ## Discussion
///
/// It’s recommended that you use the default value unless you have identified a specific need for an explicit rate.
///
///
        #[doc(alias = "UIViewAnimationOptionPreferredFramesPerSecondDefault")]
        const PreferredFramesPerSecondDefault = 0<<24;
/// A frame rate of 60 frames per second.
///
/// ## Discussion
///
/// Specify this value to request a preferred frame rate. It’s recommended that you use the default value unless you have identified a specific need for an explicit rate.
///
///
        #[doc(alias = "UIViewAnimationOptionPreferredFramesPerSecond60")]
        const PreferredFramesPerSecond60 = 3<<24;
/// A frame rate of 30 frames per second.
///
/// ## Discussion
///
/// Specify this value to request a preferred frame rate. It’s recommended that you use the default value unless you have identified a specific need for an explicit rate.
///
///
        #[doc(alias = "UIViewAnimationOptionPreferredFramesPerSecond30")]
        const PreferredFramesPerSecond30 = 7<<24;
/// Flush all pending updates (including traits, properties, and layout) whenever the animation context changes. This includes flushing updates:
///
/// ## Discussion
///
/// - Before entering an animation scope, for invalidations that happened previously without animation.
///
/// - Before entering a nested animation scope, for invalidations that happened in the outer animation scope.
///
/// - Before exiting any animation scope, for invalidations that happened in that animation scope.
///
/// - Before disabling animations, for invalidations that happened in the animation scope with animations enabled.
///
/// - Before re-enabling animations, for invalidations that happened in the scope with animations disabled. This animation option implicitly applies to any nested animation scopes, even if they don’t explicitly use this option.
///
///
/// Flush all pending updates (including traits, properties, and layout) whenever the animation context changes.
/// This includes flushing updates:
/// - Before entering an animation scope, for invalidations that happened previously without animation.
/// - Before entering a nested animation scope, for invalidations that happened in the outer animation scope.
/// - Before exiting any animation scope, for invalidations that happened in that animation scope.
/// - Before disabling animations, for invalidations that happened in the animation scope with animations enabled.
/// - Before re-enabling animations, for invalidations that happened in the scope with animations disabled.
/// This animation option implicitly applies to any nested animation scopes, even if they don't explicitly use this option.
        #[doc(alias = "UIViewAnimationOptionFlushUpdates")]
        const FlushUpdates = 1<<28;
    }
}

unsafe impl Encode for UIViewAnimationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIViewAnimationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for configuring keyframe-based animations.
///
/// ## Overview
///
/// Use these options with the [`animateKeyframesWithDuration:delay:options:animations:completion:`](https://developer.apple.com/documentation/uikit/uiview/animatekeyframes(withduration:delay:options:animations:completion:)) method.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewKeyframeAnimationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl UIViewKeyframeAnimationOptions: NSUInteger {
/// The option to lay out subviews at commit time so that they’re animated along with their parent.
        #[doc(alias = "UIViewKeyframeAnimationOptionLayoutSubviews")]
        const LayoutSubviews = UIViewAnimationOptions::LayoutSubviews.0;
/// The option that allows a person to interact with views while they’re being animated.
        #[doc(alias = "UIViewKeyframeAnimationOptionAllowUserInteraction")]
        const AllowUserInteraction = UIViewAnimationOptions::AllowUserInteraction.0;
/// The option to start an animation from the current setting associated with an already in-flight animation.
///
/// ## Discussion
///
/// If this option isn’t present, any in-flight animations are allowed to finish before the new animation is started. If another animation isn’t in flight, this option has no effect.
///
///
        #[doc(alias = "UIViewKeyframeAnimationOptionBeginFromCurrentState")]
        const BeginFromCurrentState = UIViewAnimationOptions::BeginFromCurrentState.0;
/// The option to repeat an animation indefinitely.
        #[doc(alias = "UIViewKeyframeAnimationOptionRepeat")]
        const Repeat = UIViewAnimationOptions::Repeat.0;
/// The option to run an animation backwards and forwards.
///
/// ## Discussion
///
/// This option must be combined with the [`UIViewKeyframeAnimationOptionRepeat`](https://developer.apple.com/documentation/uikit/uiview/keyframeanimationoptions/repeat) option.
///
///
        #[doc(alias = "UIViewKeyframeAnimationOptionAutoreverse")]
        const Autoreverse = UIViewAnimationOptions::Autoreverse.0;
/// The option to force an animation to use the original duration value specified when the animation was submitted.
///
/// ## Discussion
///
/// If this option isn’t present, the animation inherits the remaining duration of the in-flight animation, if any.
///
///
        #[doc(alias = "UIViewKeyframeAnimationOptionOverrideInheritedDuration")]
        const OverrideInheritedDuration = UIViewAnimationOptions::OverrideInheritedDuration.0;
/// The option to not inherit the animation type or any options.
        #[doc(alias = "UIViewKeyframeAnimationOptionOverrideInheritedOptions")]
        const OverrideInheritedOptions = UIViewAnimationOptions::OverrideInheritedOptions.0;
/// The option to use a simple linear calculation when interpolating between keyframe values.
        #[doc(alias = "UIViewKeyframeAnimationOptionCalculationModeLinear")]
        const CalculationModeLinear = 0<<10;
/// The option to not interpolate between keyframe values, but rather to jump directly to each new keyframe value.
        #[doc(alias = "UIViewKeyframeAnimationOptionCalculationModeDiscrete")]
        const CalculationModeDiscrete = 1<<10;
/// The option to compute intermediate keyframe values using a simple pacing algorithm.
///
/// ## Discussion
///
/// This option results in an evenly paced animation.
///
///
        #[doc(alias = "UIViewKeyframeAnimationOptionCalculationModePaced")]
        const CalculationModePaced = 2<<10;
/// The option to compute intermediate frames using a default Catmull-Rom spline that passes through the keyframe values.
///
/// ## Discussion
///
/// You can’t adjust the parameters of this algorithm.
///
///
        #[doc(alias = "UIViewKeyframeAnimationOptionCalculationModeCubic")]
        const CalculationModeCubic = 3<<10;
/// The option to compute intermediate frames using the cubic scheme while ignoring the timing properties of the animation.
///
/// ## Discussion
///
/// Instead, timing parameters are calculated implicitly to give the animation a constant velocity.
///
///
        #[doc(alias = "UIViewKeyframeAnimationOptionCalculationModeCubicPaced")]
        const CalculationModeCubicPaced = 4<<10;
    }
}

unsafe impl Encode for UIViewKeyframeAnimationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIViewKeyframeAnimationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Option to remove the views from the hierarchy when animation is complete.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UISystemAnimation(pub NSUInteger);
impl UISystemAnimation {
    /// Option to remove views from the view hierarchy when animation is complete.
    #[doc(alias = "UISystemAnimationDelete")]
    pub const Delete: Self = Self(0);
}

unsafe impl Encode for UISystemAnimation {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UISystemAnimation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The tint adjustment mode for the view.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIViewTintAdjustmentMode(pub NSInteger);
impl UIViewTintAdjustmentMode {
    /// The tint adjustment mode of the view is the same as its superview’s tint adjustment mode (or `UIViewTintAdjustmentModeNormal` if the view has no superview).
    #[doc(alias = "UIViewTintAdjustmentModeAutomatic")]
    pub const Automatic: Self = Self(0);
    /// The view’s tint color property returns the completely unmodified tint color of the view.
    #[doc(alias = "UIViewTintAdjustmentModeNormal")]
    pub const Normal: Self = Self(1);
    /// The view’s tint color property returns a desaturated, dimmed version of the view’s original tint color.
    #[doc(alias = "UIViewTintAdjustmentModeDimmed")]
    pub const Dimmed: Self = Self(2);
}

unsafe impl Encode for UIViewTintAdjustmentMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIViewTintAdjustmentMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A semantic description of the view’s contents, used to determine whether the view should be flipped when switching between left-to-right and right-to-left layouts.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UISemanticContentAttribute(pub NSInteger);
impl UISemanticContentAttribute {
    /// The default value for views.
    ///
    /// ## Discussion
    ///
    /// The view is flipped when switching between left-to-right and right-to-left layouts.
    ///
    ///
    #[doc(alias = "UISemanticContentAttributeUnspecified")]
    pub const Unspecified: Self = Self(0);
    /// A view representing the playback controls, such as Play, Rewind, or Fast Forward buttons or playhead scrubbers.
    ///
    /// ## Discussion
    ///
    /// These views aren’t flipped when switching between left-to-right and right-to-left layouts.
    ///
    ///
    #[doc(alias = "UISemanticContentAttributePlayback")]
    pub const Playback: Self = Self(1);
    /// A view representing a directional control, such as a segment control for text alignment, or a D-pad control for a game.
    ///
    /// ## Discussion
    ///
    /// These views aren’t flipped when switching between left-to-right and right-to-left layouts.
    ///
    ///
    #[doc(alias = "UISemanticContentAttributeSpatial")]
    pub const Spatial: Self = Self(2);
    /// A view that’s always displayed using a left-to-right layout.
    #[doc(alias = "UISemanticContentAttributeForceLeftToRight")]
    pub const ForceLeftToRight: Self = Self(3);
    /// A view that’s always displayed using a right-to-left layout.
    #[doc(alias = "UISemanticContentAttributeForceRightToLeft")]
    pub const ForceRightToLeft: Self = Self(4);
}

unsafe impl Encode for UISemanticContentAttribute {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UISemanticContentAttribute {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that manages the content for a rectangular area on the screen.
    ///
    /// ## Overview
    ///
    /// Views are the fundamental building blocks of your app’s user interface, and the [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class defines the behaviors that are common to all views. A view object renders content within its bounds rectangle, and handles any interactions with that content. The [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class is a concrete class that you can instantiate and use to display a fixed background color. You can also subclass it to draw more sophisticated content. To display labels, images, buttons, and other interface elements commonly found in apps, use the view subclasses that the UIKit framework provides rather than trying to define your own.
    ///
    /// Because view objects are the main way your application interacts with the user, they have a number of responsibilities. Here are just a few:
    ///
    /// - Drawing and animation
    ///
    ///   - Views draw content in their rectangular area using UIKit or Core Graphics.
    ///
    /// - You can animate some view properties to new values.
    ///
    /// - Layout and subview management
    ///
    ///   - Views may contain zero or more subviews.
    ///
    /// - Views can adjust the size and position of their subviews.
    ///
    /// - Use Auto Layout to define the rules for resizing and repositioning your views in response to changes in the view hierarchy.
    ///
    /// - Event handling
    ///
    ///   - A view is a subclass of [`UIResponder`](https://developer.apple.com/documentation/uikit/uiresponder) and can respond to touches and other types of events.
    ///
    /// - Views can install gesture recognizers to handle common gestures.
    ///
    /// Views can nest inside other views to create view hierarchies, which offer a convenient way to organize related content. Nesting a view creates a parent-child relationship between the nested child view (known as the _subview_) and the parent (known as the _superview_). A parent view may contain any number of subviews, but each subview has only one superview. By default, when a subview’s visible area extends outside of the bounds of its superview, no clipping of the subview’s content occurs. Use the [`clipsToBounds`](https://developer.apple.com/documentation/uikit/uiview/clipstobounds) property to change that behavior.
    ///
    /// The [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame) and [`bounds`](https://developer.apple.com/documentation/uikit/uiview/bounds) properties define the geometry of each view. The [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame) property defines the origin and dimensions of the view in the coordinate system of its superview. The [`bounds`](https://developer.apple.com/documentation/uikit/uiview/bounds) property defines the internal dimensions of the view as it sees them, and its use is almost exclusive to custom drawing code. The center property provides a convenient way to reposition a view without changing its [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame) or [`bounds`](https://developer.apple.com/documentation/uikit/uiview/bounds) properties directly.
    ///
    /// For detailed information about how to use the [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class, see [View Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503).
    ///
    /// ### Create a view
    ///
    /// Normally, you create views in your storyboards by dragging them from the library to your canvas. You can also create views programmatically. When creating a view, you typically specify its initial size and position relative to its future superview. For example, the following example creates a view and places its top-left corner at the point (10, 10) in the superview’s coordinate system (once it is added to that superview).
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let rect = CGRect(x: 10, y: 10, width: 100, height: 100)", "let myView = UIView(frame: rect)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["CGRect  viewRect = CGRectMake(10, 10, 100, 100);", "UIView* myView = [[UIView alloc] initWithFrame:viewRect];"], metadata: None }] }] })
    /// To add a subview to another view, call the [`addSubview:`](https://developer.apple.com/documentation/uikit/uiview/addsubview(_:)) method on the superview. You may add any number of subviews to a view, and sibling views may overlap each other without any issues in iOS. Each call to the [`addSubview:`](https://developer.apple.com/documentation/uikit/uiview/addsubview(_:)) method places the new view on top of all other siblings. You can specify the relative z-order of subview by adding it using the [`insertSubview:aboveSubview:`](https://developer.apple.com/documentation/uikit/uiview/insertsubview(_:abovesubview:)) and [`insertSubview:belowSubview:`](https://developer.apple.com/documentation/uikit/uiview/insertsubview(_:belowsubview:)) methods. You can also exchange the position of already added subviews using the [`exchangeSubviewAtIndex:withSubviewAtIndex:`](https://developer.apple.com/documentation/uikit/uiview/exchangesubview(at:withsubviewat:)) method.
    ///
    /// After creating a view, create Auto Layout rules to govern how the size and position of the view change in response to changes in the rest of the view hierarchy. For more information, see [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853).
    ///
    /// ### Draw views
    ///
    /// View drawing occurs on an as-needed basis. When a view is first shown, or when all or part of it becomes visible due to layout changes, the system asks the view to draw its contents. For views that contain custom content using UIKit or Core Graphics, the system calls the view’s [`drawRect:`](https://developer.apple.com/documentation/uikit/uiview/draw(_:)) method. Your implementation of this method is responsible for drawing the view’s content into the current graphics context, which is set up by the system automatically prior to calling this method. This creates a static visual representation of your view’s content that can then be displayed on the screen.
    ///
    /// When the actual content of your view changes, it’s your responsibility to notify the system that your view needs to be redrawn. You do this by calling your view’s [`setNeedsDisplay`](https://developer.apple.com/documentation/uikit/uiview/setneedsdisplay()) or [`setNeedsDisplayInRect:`](https://developer.apple.com/documentation/uikit/uiview/setneedsdisplay(_:)) method of the view. These methods let the system know that it should update the view during the next drawing cycle. Because it waits until the next drawing cycle to update the view, you can call these methods on multiple views to update them at the same time.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  If you’re using OpenGL ES to do your drawing, you should use the [`GLKView`](https://developer.apple.com/documentation/glkit/glkview) class instead of subclassing [`UIView`](https://developer.apple.com/documentation/uikit/uiview). For more information about how to draw using OpenGL ES, see [OpenGL ES Programming Guide](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793).
    ///
    ///
    ///
    /// </div>
    /// For detailed information about the view drawing cycle and the role your views have in this cycle, see [View Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009503).
    ///
    /// ### Animate views
    ///
    /// Changes to several view properties can be animated — that is, changing the property creates an animation starting at the current value and ending at the new value that you specify. The following properties of the [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class are animatable:
    ///
    /// - [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame)
    ///
    /// - [`bounds`](https://developer.apple.com/documentation/uikit/uiview/bounds)
    ///
    /// - [`center`](https://developer.apple.com/documentation/uikit/uiview/center)
    ///
    /// - [`transform`](https://developer.apple.com/documentation/uikit/uiview/transform)
    ///
    /// - [`alpha`](https://developer.apple.com/documentation/uikit/uiview/alpha)
    ///
    /// - [`backgroundColor`](https://developer.apple.com/documentation/uikit/uiview/backgroundcolor)
    ///
    /// To animate your changes, create a [`UIViewPropertyAnimator`](https://developer.apple.com/documentation/uikit/uiviewpropertyanimator) object and use its handler block to change the values of your view’s properties. The [`UIViewPropertyAnimator`](https://developer.apple.com/documentation/uikit/uiviewpropertyanimator) class lets you specify the duration and timing of your animations, but it performs the actual animations. You can pause a property-based animator that’s currently running to interrupt the animation and drive it interactively. For more information, see [`UIViewPropertyAnimator`](https://developer.apple.com/documentation/uikit/uiviewpropertyanimator).
    ///
    /// ### Threading considerations
    ///
    /// Manipulations to your app’s user interface must occur on the main thread. Thus, you should always call the methods of the [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class from code running in the main thread of your app. The only time this may not be strictly necessary is when creating the view object itself, but all other manipulations should occur on the main thread.
    ///
    /// ### Subclassing notes
    ///
    /// The [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class is a key subclassing point for visual content that also requires user interactions. Although there are many good reasons to subclass [`UIView`](https://developer.apple.com/documentation/uikit/uiview), it is recommended that you do so only when the basic [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class or the standard system views do not provide the capabilities that you need. Subclassing requires more work on your part to implement the view and to tune its performance.
    ///
    /// For information about ways to avoid subclassing, see [Alternatives to subclassing](https://developer.apple.com/documentation/uikit/uiview#alternatives-to-subclassing).
    ///
    /// #### Methods to override
    ///
    /// When subclassing [`UIView`](https://developer.apple.com/documentation/uikit/uiview), there are only a handful of methods you should override and many methods that you might override depending on your needs. Because [`UIView`](https://developer.apple.com/documentation/uikit/uiview) is a highly configurable class, there are also many ways to implement sophisticated view behaviors without overriding custom methods, which are discussed in the Alternatives to Subclassing section. In the meantime, the following list includes the methods you might consider overriding in your [`UIView`](https://developer.apple.com/documentation/uikit/uiview) subclasses:
    ///
    /// - Initialization:
    ///
    ///   - [`initWithFrame:`](https://developer.apple.com/documentation/uikit/uiview/init(frame:)) - It is recommended that you implement this method. You can also implement custom initialization methods in addition to, or instead of, this method.
    ///
    /// - [`initWithCoder:`](https://developer.apple.com/documentation/uikit/uiview/init(coder:)) - Implement this method if you load your view from storyboards or nib files and your view requires custom initialization.
    ///
    /// - [`layerClass`](https://developer.apple.com/documentation/uikit/uiview/layerclass) Use this property only if you want your view to use a different Core Animation layer for its backing store. For example, if your view uses tiling to display a large scrollable area, you might want to set the property to the [`CATiledLayer`](https://developer.apple.com/documentation/quartzcore/catiledlayer) class.
    ///
    /// - Drawing and printing:
    ///
    ///   - [`drawRect:`](https://developer.apple.com/documentation/uikit/uiview/draw(_:)) - Implement this method if your view draws custom content. If your view does not do any custom drawing, avoid overriding this method.
    ///
    /// - [`drawRect:forViewPrintFormatter:`](https://developer.apple.com/documentation/uikit/uiview/draw(_:for:)) - Implement this method only if you want to draw your view’s content differently during printing.
    ///
    /// - Layout and Constraints:
    ///
    ///   - [`requiresConstraintBasedLayout`](https://developer.apple.com/documentation/uikit/uiview/requiresconstraintbasedlayout) Use this property if your view class requires constraints to work properly.
    ///
    /// - [`updateConstraints`](https://developer.apple.com/documentation/uikit/uiview/updateconstraints()) - Implement this method if your view needs to create custom constraints between your subviews.
    ///
    /// - [`alignmentRectForFrame:`](https://developer.apple.com/documentation/uikit/uiview/alignmentrect(forframe:)), [`frameForAlignmentRect:`](https://developer.apple.com/documentation/uikit/uiview/frame(foralignmentrect:)) - Implement these methods to override how your views are aligned to other views.
    ///
    /// - [`didAddSubview:`](https://developer.apple.com/documentation/uikit/uiview/didaddsubview(_:)), [`willRemoveSubview:`](https://developer.apple.com/documentation/uikit/uiview/willremovesubview(_:)) - Implement these methods as needed to track the additions and removals of subviews.
    ///
    /// - [`willMoveToSuperview:`](https://developer.apple.com/documentation/uikit/uiview/willmove(tosuperview:)), [`didMoveToSuperview`](https://developer.apple.com/documentation/uikit/uiview/didmovetosuperview()) - Implement these methods as needed to track the movement of the current view in your view hierarchy.
    ///
    /// - Event Handling:
    ///
    ///   - [`gestureRecognizerShouldBegin:`](https://developer.apple.com/documentation/uikit/uiview/gesturerecognizershouldbegin(_:)) - Implement this method if your view handles touch events directly and might want to prevent attached gesture recognizers from triggering additional actions.
    ///
    /// - [`touchesBegan:withEvent:`](https://developer.apple.com/documentation/uikit/uiresponder/touchesbegan(_:with:)), [`touchesMoved:withEvent:`](https://developer.apple.com/documentation/uikit/uiresponder/touchesmoved(_:with:)), [`touchesEnded:withEvent:`](https://developer.apple.com/documentation/uikit/uiresponder/touchesended(_:with:)), [`touchesCancelled:withEvent:`](https://developer.apple.com/documentation/uikit/uiresponder/touchescancelled(_:with:)) - Implement these methods if you need to handle touch events directly. (For gesture-based input, use gesture recognizers.)
    ///
    /// #### Alternatives to subclassing
    ///
    /// Many view behaviors can be configured without the need for subclassing. Before you start overriding methods, consider whether modifying the following properties or behaviors would provide the behavior you need.
    ///
    /// - [`addConstraint:`](https://developer.apple.com/documentation/uikit/uiview/addconstraint(_:)) - Define automatic layout behavior for the view and its subviews.
    ///
    /// - [`autoresizingMask`](https://developer.apple.com/documentation/uikit/uiview/autoresizingmask-swift.property) - Provides automatic layout behavior when the superview’s frame changes. These behaviors can be combined with constraints.
    ///
    /// - [`contentMode`](https://developer.apple.com/documentation/uikit/uiview/contentmode-swift.property) - Provides layout behavior for the view’s content, as opposed to the [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame) of the view. This property also affects how the content is scaled to fit the view and whether it is cached or redrawn.
    ///
    /// - [`hidden`](https://developer.apple.com/documentation/uikit/uiview/ishidden) or [`alpha`](https://developer.apple.com/documentation/uikit/uiview/alpha) - Change the transparency of the view as a whole rather than hiding or applying alpha to your view’s rendered content.
    ///
    /// - [`backgroundColor`](https://developer.apple.com/documentation/uikit/uiview/backgroundcolor) - Set the view’s color rather than drawing that color yourself.
    ///
    /// - Subviews - Rather than draw your content using a [`drawRect:`](https://developer.apple.com/documentation/uikit/uiview/draw(_:)) method, embed image and label subviews with the content you want to present.
    ///
    /// - Gesture recognizers - Rather than subclass to intercept and handle touch events yourself, you can use gesture recognizers to send an action to a target object.
    ///
    /// - Animations - Use the built-in animation support rather than trying to animate changes yourself. The animation support provided by Core Animation is fast and easy to use.
    ///
    /// - Image-based backgrounds - For views that display relatively static content, consider using a [`UIImageView`](https://developer.apple.com/documentation/uikit/uiimageview) object with gesture recognizers instead of subclassing and drawing the image yourself. Alternatively, you can also use a generic [`UIView`](https://developer.apple.com/documentation/uikit/uiview) object and assign your image as the content of the view’s [`CALayer`](https://developer.apple.com/documentation/quartzcore/calayer) object.
    ///
    /// Animations are another way to make visible changes to a view without requiring you to subclass and implement complex drawing code. Many properties of the [`UIView`](https://developer.apple.com/documentation/uikit/uiview) class are animatable, which means changes to those properties can trigger system-generated animations. Starting animations requires as little as one line of code to indicate that any changes that follow should be animated. For more information about animation support for views, see [Animate views](https://developer.apple.com/documentation/uikit/uiview#animate-views).
    ///
    ///
    #[unsafe(super(UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "UIResponder")]
    pub struct UIView;
);

#[cfg(all(feature = "UIResponder", feature = "objc2-quartz-core"))]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl CALayerDelegate for UIView {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSCoding for UIView {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for UIView {}
);

#[cfg(all(feature = "UIAppearance", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIAppearance for UIView {}
);

#[cfg(all(feature = "UIAppearance", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UIView {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl UICoordinateSpace for UIView {}
);

#[cfg(all(feature = "UIDynamicBehavior", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIDynamicItem for UIView {}
);

#[cfg(all(feature = "UIFocus", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UIView {}
);

#[cfg(all(feature = "UIFocus", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIFocusItem for UIView {}
);

#[cfg(all(feature = "UIFocus", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIFocusItemContainer for UIView {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UIView {}
);

#[cfg(all(feature = "UIResponder", feature = "UITraitCollection"))]
extern_conformance!(
    unsafe impl UITraitEnvironment for UIView {}
);

#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(layerClass))]
        #[unsafe(method_family = none)]
        pub fn layerClass(mtm: MainThreadMarker) -> &'static AnyClass;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame(this: Allocated<Self>, frame: CGRect) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(isUserInteractionEnabled))]
        #[unsafe(method_family = none)]
        pub fn isUserInteractionEnabled(&self) -> bool;

        /// Setter for [`isUserInteractionEnabled`][Self::isUserInteractionEnabled].
        #[unsafe(method(setUserInteractionEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setUserInteractionEnabled(&self, user_interaction_enabled: bool);

        #[unsafe(method(tag))]
        #[unsafe(method_family = none)]
        pub fn tag(&self) -> NSInteger;

        /// Setter for [`tag`][Self::tag].
        #[unsafe(method(setTag:))]
        #[unsafe(method_family = none)]
        pub fn setTag(&self, tag: NSInteger);

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        pub fn layer(&self) -> Retained<CALayer>;

        #[unsafe(method(canBecomeFocused))]
        #[unsafe(method_family = none)]
        pub fn canBecomeFocused(&self) -> bool;

        #[unsafe(method(isFocused))]
        #[unsafe(method_family = none)]
        pub fn isFocused(&self) -> bool;

        /// The identifier of the focus group that this view belongs to. If this is nil, subviews inherit their superview's focus group.
        #[unsafe(method(focusGroupIdentifier))]
        #[unsafe(method_family = none)]
        pub fn focusGroupIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`focusGroupIdentifier`][Self::focusGroupIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFocusGroupIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setFocusGroupIdentifier(&self, focus_group_identifier: Option<&NSString>);

        #[cfg(feature = "UIFocus")]
        /// The priority this item has in its focus group. The higher the priority, the more likely it is to get picked when focus moves into this group.
        /// Note: this method can only be used to increase an item's priority, not decrease it. For example if an item is currently selected, the actual priority of this item will be determined by MAX(focusGroupPriority, UIFocusGroupPrioritySelected).
        #[unsafe(method(focusGroupPriority))]
        #[unsafe(method_family = none)]
        pub fn focusGroupPriority(&self) -> UIFocusGroupPriority;

        #[cfg(feature = "UIFocus")]
        /// Setter for [`focusGroupPriority`][Self::focusGroupPriority].
        #[unsafe(method(setFocusGroupPriority:))]
        #[unsafe(method_family = none)]
        pub fn setFocusGroupPriority(&self, focus_group_priority: UIFocusGroupPriority);

        #[cfg(feature = "UIFocusEffect")]
        /// Describes a visual effect to apply when this item is focused. If this property is nil no effect will be applied when this view becomes focused.
        #[unsafe(method(focusEffect))]
        #[unsafe(method_family = none)]
        pub fn focusEffect(&self) -> Option<Retained<UIFocusEffect>>;

        #[cfg(feature = "UIFocusEffect")]
        /// Setter for [`focusEffect`][Self::focusEffect].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFocusEffect:))]
        #[unsafe(method_family = none)]
        pub fn setFocusEffect(&self, focus_effect: Option<&UIFocusEffect>);

        #[unsafe(method(semanticContentAttribute))]
        #[unsafe(method_family = none)]
        pub fn semanticContentAttribute(&self) -> UISemanticContentAttribute;

        /// Setter for [`semanticContentAttribute`][Self::semanticContentAttribute].
        #[unsafe(method(setSemanticContentAttribute:))]
        #[unsafe(method_family = none)]
        pub fn setSemanticContentAttribute(
            &self,
            semantic_content_attribute: UISemanticContentAttribute,
        );

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(userInterfaceLayoutDirectionForSemanticContentAttribute:))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirectionForSemanticContentAttribute(
            attribute: UISemanticContentAttribute,
            mtm: MainThreadMarker,
        ) -> UIUserInterfaceLayoutDirection;

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(userInterfaceLayoutDirectionForSemanticContentAttribute:relativeToLayoutDirection:))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirectionForSemanticContentAttribute_relativeToLayoutDirection(
            semantic_content_attribute: UISemanticContentAttribute,
            layout_direction: UIUserInterfaceLayoutDirection,
            mtm: MainThreadMarker,
        ) -> UIUserInterfaceLayoutDirection;

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(effectiveUserInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn effectiveUserInterfaceLayoutDirection(&self) -> UIUserInterfaceLayoutDirection;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// UIViewGeometry.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        pub fn frame(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`frame`][Self::frame].
        #[unsafe(method(setFrame:))]
        #[unsafe(method_family = none)]
        pub fn setFrame(&self, frame: CGRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(bounds))]
        #[unsafe(method_family = none)]
        pub fn bounds(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`bounds`][Self::bounds].
        #[unsafe(method(setBounds:))]
        #[unsafe(method_family = none)]
        pub fn setBounds(&self, bounds: CGRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(center))]
        #[unsafe(method_family = none)]
        pub fn center(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`center`][Self::center].
        #[unsafe(method(setCenter:))]
        #[unsafe(method_family = none)]
        pub fn setCenter(&self, center: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(transform))]
        #[unsafe(method_family = none)]
        pub fn transform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`transform`][Self::transform].
        #[unsafe(method(setTransform:))]
        #[unsafe(method_family = none)]
        pub fn setTransform(&self, transform: CGAffineTransform);

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(transform3D))]
        #[unsafe(method_family = none)]
        pub fn transform3D(&self) -> CATransform3D;

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`transform3D`][Self::transform3D].
        #[unsafe(method(setTransform3D:))]
        #[unsafe(method_family = none)]
        pub fn setTransform3D(&self, transform3_d: CATransform3D);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentScaleFactor))]
        #[unsafe(method_family = none)]
        pub fn contentScaleFactor(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`contentScaleFactor`][Self::contentScaleFactor].
        #[unsafe(method(setContentScaleFactor:))]
        #[unsafe(method_family = none)]
        pub fn setContentScaleFactor(&self, content_scale_factor: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(anchorPoint))]
        #[unsafe(method_family = none)]
        pub fn anchorPoint(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`anchorPoint`][Self::anchorPoint].
        #[unsafe(method(setAnchorPoint:))]
        #[unsafe(method_family = none)]
        pub fn setAnchorPoint(&self, anchor_point: CGPoint);

        #[unsafe(method(isMultipleTouchEnabled))]
        #[unsafe(method_family = none)]
        pub fn isMultipleTouchEnabled(&self) -> bool;

        /// Setter for [`isMultipleTouchEnabled`][Self::isMultipleTouchEnabled].
        #[unsafe(method(setMultipleTouchEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setMultipleTouchEnabled(&self, multiple_touch_enabled: bool);

        #[unsafe(method(isExclusiveTouch))]
        #[unsafe(method_family = none)]
        pub fn isExclusiveTouch(&self) -> bool;

        /// Setter for [`isExclusiveTouch`][Self::isExclusiveTouch].
        #[unsafe(method(setExclusiveTouch:))]
        #[unsafe(method_family = none)]
        pub fn setExclusiveTouch(&self, exclusive_touch: bool);

        #[cfg(all(feature = "UIEvent", feature = "objc2-core-foundation"))]
        #[unsafe(method(hitTest:withEvent:))]
        #[unsafe(method_family = none)]
        pub fn hitTest_withEvent(
            &self,
            point: CGPoint,
            event: Option<&UIEvent>,
        ) -> Option<Retained<UIView>>;

        #[cfg(all(feature = "UIEvent", feature = "objc2-core-foundation"))]
        #[unsafe(method(pointInside:withEvent:))]
        #[unsafe(method_family = none)]
        pub fn pointInside_withEvent(&self, point: CGPoint, event: Option<&UIEvent>) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(convertPoint:toView:))]
        #[unsafe(method_family = none)]
        pub fn convertPoint_toView(&self, point: CGPoint, view: Option<&UIView>) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(convertPoint:fromView:))]
        #[unsafe(method_family = none)]
        pub fn convertPoint_fromView(&self, point: CGPoint, view: Option<&UIView>) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(convertRect:toView:))]
        #[unsafe(method_family = none)]
        pub fn convertRect_toView(&self, rect: CGRect, view: Option<&UIView>) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(convertRect:fromView:))]
        #[unsafe(method_family = none)]
        pub fn convertRect_fromView(&self, rect: CGRect, view: Option<&UIView>) -> CGRect;

        #[unsafe(method(autoresizesSubviews))]
        #[unsafe(method_family = none)]
        pub fn autoresizesSubviews(&self) -> bool;

        /// Setter for [`autoresizesSubviews`][Self::autoresizesSubviews].
        #[unsafe(method(setAutoresizesSubviews:))]
        #[unsafe(method_family = none)]
        pub fn setAutoresizesSubviews(&self, autoresizes_subviews: bool);

        #[unsafe(method(autoresizingMask))]
        #[unsafe(method_family = none)]
        pub fn autoresizingMask(&self) -> UIViewAutoresizing;

        /// Setter for [`autoresizingMask`][Self::autoresizingMask].
        #[unsafe(method(setAutoresizingMask:))]
        #[unsafe(method_family = none)]
        pub fn setAutoresizingMask(&self, autoresizing_mask: UIViewAutoresizing);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(sizeThatFits:))]
        #[unsafe(method_family = none)]
        pub fn sizeThatFits(&self, size: CGSize) -> CGSize;

        #[unsafe(method(sizeToFit))]
        #[unsafe(method_family = none)]
        pub fn sizeToFit(&self);
    );
}

/// UIViewHierarchy.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(superview))]
        #[unsafe(method_family = none)]
        pub fn superview(&self) -> Option<Retained<UIView>>;

        #[unsafe(method(subviews))]
        #[unsafe(method_family = none)]
        pub fn subviews(&self) -> Retained<NSArray<UIView>>;

        #[cfg(feature = "UIWindow")]
        #[unsafe(method(window))]
        #[unsafe(method_family = none)]
        pub fn window(&self) -> Option<Retained<UIWindow>>;

        #[unsafe(method(removeFromSuperview))]
        #[unsafe(method_family = none)]
        pub fn removeFromSuperview(&self);

        #[unsafe(method(insertSubview:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertSubview_atIndex(&self, view: &UIView, index: NSInteger);

        #[unsafe(method(exchangeSubviewAtIndex:withSubviewAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn exchangeSubviewAtIndex_withSubviewAtIndex(
            &self,
            index1: NSInteger,
            index2: NSInteger,
        );

        #[unsafe(method(addSubview:))]
        #[unsafe(method_family = none)]
        pub fn addSubview(&self, view: &UIView);

        #[unsafe(method(insertSubview:belowSubview:))]
        #[unsafe(method_family = none)]
        pub fn insertSubview_belowSubview(&self, view: &UIView, sibling_subview: &UIView);

        #[unsafe(method(insertSubview:aboveSubview:))]
        #[unsafe(method_family = none)]
        pub fn insertSubview_aboveSubview(&self, view: &UIView, sibling_subview: &UIView);

        #[unsafe(method(bringSubviewToFront:))]
        #[unsafe(method_family = none)]
        pub fn bringSubviewToFront(&self, view: &UIView);

        #[unsafe(method(sendSubviewToBack:))]
        #[unsafe(method_family = none)]
        pub fn sendSubviewToBack(&self, view: &UIView);

        #[unsafe(method(didAddSubview:))]
        #[unsafe(method_family = none)]
        pub fn didAddSubview(&self, subview: &UIView);

        #[unsafe(method(willRemoveSubview:))]
        #[unsafe(method_family = none)]
        pub fn willRemoveSubview(&self, subview: &UIView);

        #[unsafe(method(willMoveToSuperview:))]
        #[unsafe(method_family = none)]
        pub fn willMoveToSuperview(&self, new_superview: Option<&UIView>);

        #[unsafe(method(didMoveToSuperview))]
        #[unsafe(method_family = none)]
        pub fn didMoveToSuperview(&self);

        #[cfg(feature = "UIWindow")]
        #[unsafe(method(willMoveToWindow:))]
        #[unsafe(method_family = none)]
        pub fn willMoveToWindow(&self, new_window: Option<&UIWindow>);

        #[unsafe(method(didMoveToWindow))]
        #[unsafe(method_family = none)]
        pub fn didMoveToWindow(&self);

        #[unsafe(method(isDescendantOfView:))]
        #[unsafe(method_family = none)]
        pub fn isDescendantOfView(&self, view: &UIView) -> bool;

        #[unsafe(method(viewWithTag:))]
        #[unsafe(method_family = none)]
        pub fn viewWithTag(&self, tag: NSInteger) -> Option<Retained<UIView>>;

        /// Call to manually request a properties update for the view.
        /// Multiple requests may be coalesced into a single update alongside the next layout pass.
        #[unsafe(method(setNeedsUpdateProperties))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateProperties(&self);

        /// Override point for subclasses to update properties of this view.
        /// Never call this method directly; use `setNeedsUpdateProperties` to schedule an update.
        #[unsafe(method(updateProperties))]
        #[unsafe(method_family = none)]
        pub fn updateProperties(&self);

        /// Forces an immediate properties update for this view (and its view controller, if applicable)
        /// and any subviews, including any view controllers or views in its subtree.
        #[unsafe(method(updatePropertiesIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updatePropertiesIfNeeded(&self);

        #[unsafe(method(setNeedsLayout))]
        #[unsafe(method_family = none)]
        pub fn setNeedsLayout(&self);

        #[unsafe(method(layoutIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn layoutIfNeeded(&self);

        #[unsafe(method(layoutSubviews))]
        #[unsafe(method_family = none)]
        pub fn layoutSubviews(&self);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(layoutMargins))]
        #[unsafe(method_family = none)]
        pub fn layoutMargins(&self) -> UIEdgeInsets;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// Setter for [`layoutMargins`][Self::layoutMargins].
        #[unsafe(method(setLayoutMargins:))]
        #[unsafe(method_family = none)]
        pub fn setLayoutMargins(&self, layout_margins: UIEdgeInsets);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(directionalLayoutMargins))]
        #[unsafe(method_family = none)]
        pub fn directionalLayoutMargins(&self) -> NSDirectionalEdgeInsets;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// Setter for [`directionalLayoutMargins`][Self::directionalLayoutMargins].
        #[unsafe(method(setDirectionalLayoutMargins:))]
        #[unsafe(method_family = none)]
        pub fn setDirectionalLayoutMargins(
            &self,
            directional_layout_margins: NSDirectionalEdgeInsets,
        );

        #[unsafe(method(preservesSuperviewLayoutMargins))]
        #[unsafe(method_family = none)]
        pub fn preservesSuperviewLayoutMargins(&self) -> bool;

        /// Setter for [`preservesSuperviewLayoutMargins`][Self::preservesSuperviewLayoutMargins].
        #[unsafe(method(setPreservesSuperviewLayoutMargins:))]
        #[unsafe(method_family = none)]
        pub fn setPreservesSuperviewLayoutMargins(&self, preserves_superview_layout_margins: bool);

        #[unsafe(method(insetsLayoutMarginsFromSafeArea))]
        #[unsafe(method_family = none)]
        pub fn insetsLayoutMarginsFromSafeArea(&self) -> bool;

        /// Setter for [`insetsLayoutMarginsFromSafeArea`][Self::insetsLayoutMarginsFromSafeArea].
        #[unsafe(method(setInsetsLayoutMarginsFromSafeArea:))]
        #[unsafe(method_family = none)]
        pub fn setInsetsLayoutMarginsFromSafeArea(
            &self,
            insets_layout_margins_from_safe_area: bool,
        );

        #[unsafe(method(layoutMarginsDidChange))]
        #[unsafe(method_family = none)]
        pub fn layoutMarginsDidChange(&self);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(safeAreaInsets))]
        #[unsafe(method_family = none)]
        pub fn safeAreaInsets(&self) -> UIEdgeInsets;

        #[unsafe(method(safeAreaInsetsDidChange))]
        #[unsafe(method_family = none)]
        pub fn safeAreaInsetsDidChange(&self);

        #[cfg(feature = "UILayoutGuide")]
        #[unsafe(method(layoutMarginsGuide))]
        #[unsafe(method_family = none)]
        pub fn layoutMarginsGuide(&self) -> Retained<UILayoutGuide>;

        #[cfg(feature = "UILayoutGuide")]
        /// This content guide provides a layout area that you can use to place text and related content whose width should generally be constrained to a size that is easy for the user to read. This guide provides a centered region that you can place content within to get this behavior for this view.
        #[unsafe(method(readableContentGuide))]
        #[unsafe(method_family = none)]
        pub fn readableContentGuide(&self) -> Retained<UILayoutGuide>;

        #[cfg(feature = "UILayoutGuide")]
        #[unsafe(method(safeAreaLayoutGuide))]
        #[unsafe(method_family = none)]
        pub fn safeAreaLayoutGuide(&self) -> Retained<UILayoutGuide>;

        #[cfg(all(
            feature = "UIKeyboardLayoutGuide",
            feature = "UILayoutGuide",
            feature = "UITrackingLayoutGuide"
        ))]
        /// Follows the keyboard when on screen and docked. See UIKeyboardLayoutGuide.h for additional options.
        #[unsafe(method(keyboardLayoutGuide))]
        #[unsafe(method_family = none)]
        pub fn keyboardLayoutGuide(&self) -> Retained<UIKeyboardLayoutGuide>;
    );
}

/// UIViewRendering.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawRect:))]
        #[unsafe(method_family = none)]
        pub fn drawRect(&self, rect: CGRect);

        #[unsafe(method(setNeedsDisplay))]
        #[unsafe(method_family = none)]
        pub fn setNeedsDisplay(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(setNeedsDisplayInRect:))]
        #[unsafe(method_family = none)]
        pub fn setNeedsDisplayInRect(&self, rect: CGRect);

        #[unsafe(method(clipsToBounds))]
        #[unsafe(method_family = none)]
        pub fn clipsToBounds(&self) -> bool;

        /// Setter for [`clipsToBounds`][Self::clipsToBounds].
        #[unsafe(method(setClipsToBounds:))]
        #[unsafe(method_family = none)]
        pub fn setClipsToBounds(&self, clips_to_bounds: bool);

        #[cfg(feature = "UIColor")]
        #[unsafe(method(backgroundColor))]
        #[unsafe(method_family = none)]
        pub fn backgroundColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`backgroundColor`][Self::backgroundColor].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBackgroundColor:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundColor(&self, background_color: Option<&UIColor>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(alpha))]
        #[unsafe(method_family = none)]
        pub fn alpha(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`alpha`][Self::alpha].
        #[unsafe(method(setAlpha:))]
        #[unsafe(method_family = none)]
        pub fn setAlpha(&self, alpha: CGFloat);

        #[unsafe(method(isOpaque))]
        #[unsafe(method_family = none)]
        pub fn isOpaque(&self) -> bool;

        /// Setter for [`isOpaque`][Self::isOpaque].
        #[unsafe(method(setOpaque:))]
        #[unsafe(method_family = none)]
        pub fn setOpaque(&self, opaque: bool);

        #[unsafe(method(clearsContextBeforeDrawing))]
        #[unsafe(method_family = none)]
        pub fn clearsContextBeforeDrawing(&self) -> bool;

        /// Setter for [`clearsContextBeforeDrawing`][Self::clearsContextBeforeDrawing].
        #[unsafe(method(setClearsContextBeforeDrawing:))]
        #[unsafe(method_family = none)]
        pub fn setClearsContextBeforeDrawing(&self, clears_context_before_drawing: bool);

        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        pub fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        pub fn setHidden(&self, hidden: bool);

        #[unsafe(method(contentMode))]
        #[unsafe(method_family = none)]
        pub fn contentMode(&self) -> UIViewContentMode;

        /// Setter for [`contentMode`][Self::contentMode].
        #[unsafe(method(setContentMode:))]
        #[unsafe(method_family = none)]
        pub fn setContentMode(&self, content_mode: UIViewContentMode);

        #[cfg(feature = "objc2-core-foundation")]
        #[deprecated]
        #[unsafe(method(contentStretch))]
        #[unsafe(method_family = none)]
        pub fn contentStretch(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`contentStretch`][Self::contentStretch].
        #[deprecated]
        #[unsafe(method(setContentStretch:))]
        #[unsafe(method_family = none)]
        pub fn setContentStretch(&self, content_stretch: CGRect);

        #[unsafe(method(maskView))]
        #[unsafe(method_family = none)]
        pub fn maskView(&self) -> Option<Retained<UIView>>;

        /// Setter for [`maskView`][Self::maskView].
        #[unsafe(method(setMaskView:))]
        #[unsafe(method_family = none)]
        pub fn setMaskView(&self, mask_view: Option<&UIView>);

        #[cfg(feature = "UIColor")]
        #[unsafe(method(tintColor))]
        #[unsafe(method_family = none)]
        pub fn tintColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`tintColor`][Self::tintColor].
        ///
        /// # Safety
        ///
        /// `tint_color` might not allow `None`.
        #[unsafe(method(setTintColor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTintColor(&self, tint_color: Option<&UIColor>);

        #[unsafe(method(tintAdjustmentMode))]
        #[unsafe(method_family = none)]
        pub fn tintAdjustmentMode(&self) -> UIViewTintAdjustmentMode;

        /// Setter for [`tintAdjustmentMode`][Self::tintAdjustmentMode].
        #[unsafe(method(setTintAdjustmentMode:))]
        #[unsafe(method_family = none)]
        pub fn setTintAdjustmentMode(&self, tint_adjustment_mode: UIViewTintAdjustmentMode);

        #[unsafe(method(tintColorDidChange))]
        #[unsafe(method_family = none)]
        pub fn tintColorDidChange(&self);
    );
}

/// UIViewAnimation.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(setAnimationsEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationsEnabled(enabled: bool, mtm: MainThreadMarker);

        #[unsafe(method(areAnimationsEnabled))]
        #[unsafe(method_family = none)]
        pub fn areAnimationsEnabled(mtm: MainThreadMarker) -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(performWithoutAnimation:))]
        #[unsafe(method_family = none)]
        pub fn performWithoutAnimation(
            actions_without_animation: &block2::DynBlock<dyn Fn() + '_>,
            mtm: MainThreadMarker,
        );

        #[unsafe(method(inheritedAnimationDuration))]
        #[unsafe(method_family = none)]
        pub fn inheritedAnimationDuration(mtm: MainThreadMarker) -> NSTimeInterval;
    );
}

/// UIViewAnimationWithBlocks.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "block2")]
        #[unsafe(method(animateWithDuration:delay:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn animateWithDuration_delay_options_animations_completion(
            duration: NSTimeInterval,
            delay: NSTimeInterval,
            options: UIViewAnimationOptions,
            animations: &block2::DynBlock<dyn Fn()>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
            mtm: MainThreadMarker,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(animateWithDuration:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn animateWithDuration_animations_completion(
            duration: NSTimeInterval,
            animations: &block2::DynBlock<dyn Fn()>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
            mtm: MainThreadMarker,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(animateWithDuration:animations:))]
        #[unsafe(method_family = none)]
        pub fn animateWithDuration_animations(
            duration: NSTimeInterval,
            animations: &block2::DynBlock<dyn Fn()>,
            mtm: MainThreadMarker,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        #[unsafe(method(animateWithSpringDuration:bounce:initialSpringVelocity:delay:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn animateWithSpringDuration_bounce_initialSpringVelocity_delay_options_animations_completion(
            duration: NSTimeInterval,
            bounce: CGFloat,
            velocity: CGFloat,
            delay: NSTimeInterval,
            options: UIViewAnimationOptions,
            animations: &block2::DynBlock<dyn Fn() + '_>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
            mtm: MainThreadMarker,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        #[unsafe(method(animateWithDuration:delay:usingSpringWithDamping:initialSpringVelocity:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn animateWithDuration_delay_usingSpringWithDamping_initialSpringVelocity_options_animations_completion(
            duration: NSTimeInterval,
            delay: NSTimeInterval,
            damping_ratio: CGFloat,
            velocity: CGFloat,
            options: UIViewAnimationOptions,
            animations: &block2::DynBlock<dyn Fn()>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
            mtm: MainThreadMarker,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(transitionWithView:duration:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn transitionWithView_duration_options_animations_completion(
            view: &UIView,
            duration: NSTimeInterval,
            options: UIViewAnimationOptions,
            animations: Option<&block2::DynBlock<dyn Fn()>>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(transitionFromView:toView:duration:options:completion:))]
        #[unsafe(method_family = none)]
        pub fn transitionFromView_toView_duration_options_completion(
            from_view: &UIView,
            to_view: &UIView,
            duration: NSTimeInterval,
            options: UIViewAnimationOptions,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(performSystemAnimation:onViews:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn performSystemAnimation_onViews_options_animations_completion(
            animation: UISystemAnimation,
            views: &NSArray<UIView>,
            options: UIViewAnimationOptions,
            parallel_animations: Option<&block2::DynBlock<dyn Fn()>>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
            mtm: MainThreadMarker,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        #[unsafe(method(modifyAnimationsWithRepeatCount:autoreverses:animations:))]
        #[unsafe(method_family = none)]
        pub fn modifyAnimationsWithRepeatCount_autoreverses_animations(
            count: CGFloat,
            autoreverses: bool,
            animations: &block2::DynBlock<dyn Fn() + '_>,
            mtm: MainThreadMarker,
        );
    );
}

/// UIViewKeyframeAnimations.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "block2")]
        #[unsafe(method(animateKeyframesWithDuration:delay:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn animateKeyframesWithDuration_delay_options_animations_completion(
            duration: NSTimeInterval,
            delay: NSTimeInterval,
            options: UIViewKeyframeAnimationOptions,
            animations: &block2::DynBlock<dyn Fn()>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
            mtm: MainThreadMarker,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(addKeyframeWithRelativeStartTime:relativeDuration:animations:))]
        #[unsafe(method_family = none)]
        pub fn addKeyframeWithRelativeStartTime_relativeDuration_animations(
            frame_start_time: c_double,
            frame_duration: c_double,
            animations: &block2::DynBlock<dyn Fn()>,
            mtm: MainThreadMarker,
        );
    );
}

/// UIViewGestureRecognizers.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UIGestureRecognizer")]
        #[unsafe(method(gestureRecognizers))]
        #[unsafe(method_family = none)]
        pub fn gestureRecognizers(&self) -> Option<Retained<NSArray<UIGestureRecognizer>>>;

        #[cfg(feature = "UIGestureRecognizer")]
        /// Setter for [`gestureRecognizers`][Self::gestureRecognizers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setGestureRecognizers:))]
        #[unsafe(method_family = none)]
        pub fn setGestureRecognizers(
            &self,
            gesture_recognizers: Option<&NSArray<UIGestureRecognizer>>,
        );

        #[cfg(feature = "UIGestureRecognizer")]
        #[unsafe(method(addGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn addGestureRecognizer(&self, gesture_recognizer: &UIGestureRecognizer);

        #[cfg(feature = "UIGestureRecognizer")]
        #[unsafe(method(removeGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn removeGestureRecognizer(&self, gesture_recognizer: &UIGestureRecognizer);

        #[cfg(feature = "UIGestureRecognizer")]
        #[unsafe(method(gestureRecognizerShouldBegin:))]
        #[unsafe(method_family = none)]
        pub fn gestureRecognizerShouldBegin(
            &self,
            gesture_recognizer: &UIGestureRecognizer,
        ) -> bool;
    );
}

/// UIViewMotionEffects.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UIMotionEffect")]
        /// Begins applying `effect` to the receiver. The effect's emitted keyPath/value pairs will be
        /// applied to the view's presentation layer.
        ///
        /// Animates the transition to the motion effect's values using the present UIView animation
        /// context.
        #[unsafe(method(addMotionEffect:))]
        #[unsafe(method_family = none)]
        pub fn addMotionEffect(&self, effect: &UIMotionEffect);

        #[cfg(feature = "UIMotionEffect")]
        /// Stops applying `effect` to the receiver. Any affected presentation values will animate to
        /// their post-removal values using the present UIView animation context.
        #[unsafe(method(removeMotionEffect:))]
        #[unsafe(method_family = none)]
        pub fn removeMotionEffect(&self, effect: &UIMotionEffect);

        #[cfg(feature = "UIMotionEffect")]
        #[unsafe(method(motionEffects))]
        #[unsafe(method_family = none)]
        pub fn motionEffects(&self) -> Retained<NSArray<UIMotionEffect>>;

        #[cfg(feature = "UIMotionEffect")]
        /// Setter for [`motionEffects`][Self::motionEffects].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMotionEffects:))]
        #[unsafe(method_family = none)]
        pub fn setMotionEffects(&self, motion_effects: &NSArray<UIMotionEffect>);
    );
}

/// Keys that specify a horizontal or vertical layout constraint between objects.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UILayoutConstraintAxis(pub NSInteger);
impl UILayoutConstraintAxis {
    /// The constraint applied when laying out the horizontal relationship between objects.
    #[doc(alias = "UILayoutConstraintAxisHorizontal")]
    pub const Horizontal: Self = Self(0);
    /// The constraint applied when laying out the vertical relationship between objects.
    #[doc(alias = "UILayoutConstraintAxisVertical")]
    pub const Vertical: Self = Self(1);
}

unsafe impl Encode for UILayoutConstraintAxis {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UILayoutConstraintAxis {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// UIConstraintBasedLayoutInstallingConstraints.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(constraints))]
        #[unsafe(method_family = none)]
        pub fn constraints(&self) -> Retained<NSArray<NSLayoutConstraint>>;

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(addConstraint:))]
        #[unsafe(method_family = none)]
        pub fn addConstraint(&self, constraint: &NSLayoutConstraint);

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(addConstraints:))]
        #[unsafe(method_family = none)]
        pub fn addConstraints(&self, constraints: &NSArray<NSLayoutConstraint>);

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(removeConstraint:))]
        #[unsafe(method_family = none)]
        pub fn removeConstraint(&self, constraint: &NSLayoutConstraint);

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(removeConstraints:))]
        #[unsafe(method_family = none)]
        pub fn removeConstraints(&self, constraints: &NSArray<NSLayoutConstraint>);
    );
}

/// UIConstraintBasedLayoutCoreMethods.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(updateConstraintsIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updateConstraintsIfNeeded(&self);

        #[unsafe(method(updateConstraints))]
        #[unsafe(method_family = none)]
        pub fn updateConstraints(&self);

        #[unsafe(method(needsUpdateConstraints))]
        #[unsafe(method_family = none)]
        pub fn needsUpdateConstraints(&self) -> bool;

        #[unsafe(method(setNeedsUpdateConstraints))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateConstraints(&self);
    );
}

/// UIConstraintBasedCompatibility.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(translatesAutoresizingMaskIntoConstraints))]
        #[unsafe(method_family = none)]
        pub fn translatesAutoresizingMaskIntoConstraints(&self) -> bool;

        /// Setter for [`translatesAutoresizingMaskIntoConstraints`][Self::translatesAutoresizingMaskIntoConstraints].
        #[unsafe(method(setTranslatesAutoresizingMaskIntoConstraints:))]
        #[unsafe(method_family = none)]
        pub fn setTranslatesAutoresizingMaskIntoConstraints(
            &self,
            translates_autoresizing_mask_into_constraints: bool,
        );

        #[unsafe(method(requiresConstraintBasedLayout))]
        #[unsafe(method_family = none)]
        pub fn requiresConstraintBasedLayout(mtm: MainThreadMarker) -> bool;
    );
}

extern "C" {
    /// The absence of an intrinsic metric for a given numeric view property.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UIViewNoIntrinsicMetric: CGFloat;
}

/// UIConstraintBasedLayoutLayering.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(alignmentRectForFrame:))]
        #[unsafe(method_family = none)]
        pub fn alignmentRectForFrame(&self, frame: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frameForAlignmentRect:))]
        #[unsafe(method_family = none)]
        pub fn frameForAlignmentRect(&self, alignment_rect: CGRect) -> CGRect;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(alignmentRectInsets))]
        #[unsafe(method_family = none)]
        pub fn alignmentRectInsets(&self) -> UIEdgeInsets;

        #[deprecated = "Override -viewForFirstBaselineLayout or -viewForLastBaselineLayout as appropriate, instead"]
        #[unsafe(method(viewForBaselineLayout))]
        #[unsafe(method_family = none)]
        pub fn viewForBaselineLayout(&self) -> Retained<UIView>;

        #[unsafe(method(viewForFirstBaselineLayout))]
        #[unsafe(method_family = none)]
        pub fn viewForFirstBaselineLayout(&self) -> Retained<UIView>;

        #[unsafe(method(viewForLastBaselineLayout))]
        #[unsafe(method_family = none)]
        pub fn viewForLastBaselineLayout(&self) -> Retained<UIView>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(intrinsicContentSize))]
        #[unsafe(method_family = none)]
        pub fn intrinsicContentSize(&self) -> CGSize;

        #[unsafe(method(invalidateIntrinsicContentSize))]
        #[unsafe(method_family = none)]
        pub fn invalidateIntrinsicContentSize(&self);

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(contentHuggingPriorityForAxis:))]
        #[unsafe(method_family = none)]
        pub fn contentHuggingPriorityForAxis(
            &self,
            axis: UILayoutConstraintAxis,
        ) -> UILayoutPriority;

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(setContentHuggingPriority:forAxis:))]
        #[unsafe(method_family = none)]
        pub fn setContentHuggingPriority_forAxis(
            &self,
            priority: UILayoutPriority,
            axis: UILayoutConstraintAxis,
        );

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(contentCompressionResistancePriorityForAxis:))]
        #[unsafe(method_family = none)]
        pub fn contentCompressionResistancePriorityForAxis(
            &self,
            axis: UILayoutConstraintAxis,
        ) -> UILayoutPriority;

        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(setContentCompressionResistancePriority:forAxis:))]
        #[unsafe(method_family = none)]
        pub fn setContentCompressionResistancePriority_forAxis(
            &self,
            priority: UILayoutPriority,
            axis: UILayoutConstraintAxis,
        );
    );
}

extern "C" {
    /// The option to use the smallest possible size.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UILayoutFittingCompressedSize: CGSize;
}

extern "C" {
    /// The option to use the largest possible size.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UILayoutFittingExpandedSize: CGSize;
}

/// UIConstraintBasedLayoutFittingSize.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(systemLayoutSizeFittingSize:))]
        #[unsafe(method_family = none)]
        pub fn systemLayoutSizeFittingSize(&self, target_size: CGSize) -> CGSize;

        #[cfg(all(feature = "NSLayoutConstraint", feature = "objc2-core-foundation"))]
        #[unsafe(method(systemLayoutSizeFittingSize:withHorizontalFittingPriority:verticalFittingPriority:))]
        #[unsafe(method_family = none)]
        pub fn systemLayoutSizeFittingSize_withHorizontalFittingPriority_verticalFittingPriority(
            &self,
            target_size: CGSize,
            horizontal_fitting_priority: UILayoutPriority,
            vertical_fitting_priority: UILayoutPriority,
        ) -> CGSize;
    );
}

/// UILayoutGuideSupport.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UILayoutGuide")]
        #[unsafe(method(layoutGuides))]
        #[unsafe(method_family = none)]
        pub fn layoutGuides(&self) -> Retained<NSArray<UILayoutGuide>>;

        #[cfg(feature = "UILayoutGuide")]
        #[unsafe(method(addLayoutGuide:))]
        #[unsafe(method_family = none)]
        pub fn addLayoutGuide(&self, layout_guide: &UILayoutGuide);

        #[cfg(feature = "UILayoutGuide")]
        #[unsafe(method(removeLayoutGuide:))]
        #[unsafe(method_family = none)]
        pub fn removeLayoutGuide(&self, layout_guide: &UILayoutGuide);
    );
}

/// UIViewLayoutConstraintCreation.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(leadingAnchor))]
        #[unsafe(method_family = none)]
        pub fn leadingAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(trailingAnchor))]
        #[unsafe(method_family = none)]
        pub fn trailingAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(leftAnchor))]
        #[unsafe(method_family = none)]
        pub fn leftAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(rightAnchor))]
        #[unsafe(method_family = none)]
        pub fn rightAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(topAnchor))]
        #[unsafe(method_family = none)]
        pub fn topAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(bottomAnchor))]
        #[unsafe(method_family = none)]
        pub fn bottomAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(widthAnchor))]
        #[unsafe(method_family = none)]
        pub fn widthAnchor(&self) -> Retained<NSLayoutDimension>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(heightAnchor))]
        #[unsafe(method_family = none)]
        pub fn heightAnchor(&self) -> Retained<NSLayoutDimension>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(centerXAnchor))]
        #[unsafe(method_family = none)]
        pub fn centerXAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(centerYAnchor))]
        #[unsafe(method_family = none)]
        pub fn centerYAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(firstBaselineAnchor))]
        #[unsafe(method_family = none)]
        pub fn firstBaselineAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(lastBaselineAnchor))]
        #[unsafe(method_family = none)]
        pub fn lastBaselineAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;
    );
}

/// UIConstraintBasedLayoutDebugging.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(constraintsAffectingLayoutForAxis:))]
        #[unsafe(method_family = none)]
        pub fn constraintsAffectingLayoutForAxis(
            &self,
            axis: UILayoutConstraintAxis,
        ) -> Retained<NSArray<NSLayoutConstraint>>;

        #[unsafe(method(hasAmbiguousLayout))]
        #[unsafe(method_family = none)]
        pub fn hasAmbiguousLayout(&self) -> bool;

        #[unsafe(method(exerciseAmbiguityInLayout))]
        #[unsafe(method_family = none)]
        pub fn exerciseAmbiguityInLayout(&self);
    );
}

/// UIConstraintBasedLayoutDebugging.
#[cfg(feature = "UILayoutGuide")]
impl UILayoutGuide {
    extern_methods!(
        #[cfg(feature = "NSLayoutConstraint")]
        #[unsafe(method(constraintsAffectingLayoutForAxis:))]
        #[unsafe(method_family = none)]
        pub fn constraintsAffectingLayoutForAxis(
            &self,
            axis: UILayoutConstraintAxis,
        ) -> Retained<NSArray<NSLayoutConstraint>>;

        #[unsafe(method(hasAmbiguousLayout))]
        #[unsafe(method_family = none)]
        pub fn hasAmbiguousLayout(&self) -> bool;
    );
}

/// UIStateRestoration.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(restorationIdentifier))]
        #[unsafe(method_family = none)]
        pub fn restorationIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`restorationIdentifier`][Self::restorationIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRestorationIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setRestorationIdentifier(&self, restoration_identifier: Option<&NSString>);

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(decodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeRestorableStateWithCoder(&self, coder: &NSCoder);
    );
}

/// UISnapshotting.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[unsafe(method(snapshotViewAfterScreenUpdates:))]
        #[unsafe(method_family = none)]
        pub fn snapshotViewAfterScreenUpdates(
            &self,
            after_updates: bool,
        ) -> Option<Retained<UIView>>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(resizableSnapshotViewFromRect:afterScreenUpdates:withCapInsets:))]
        #[unsafe(method_family = none)]
        pub fn resizableSnapshotViewFromRect_afterScreenUpdates_withCapInsets(
            &self,
            rect: CGRect,
            after_updates: bool,
            cap_insets: UIEdgeInsets,
        ) -> Option<Retained<UIView>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawViewHierarchyInRect:afterScreenUpdates:))]
        #[unsafe(method_family = none)]
        pub fn drawViewHierarchyInRect_afterScreenUpdates(
            &self,
            rect: CGRect,
            after_updates: bool,
        ) -> bool;
    );
}

/// DeprecatedAnimations.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        /// # Safety
        ///
        /// `context` must be a valid pointer or null.
        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(beginAnimations:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginAnimations_context(
            animation_id: Option<&NSString>,
            context: *mut c_void,
            mtm: MainThreadMarker,
        );

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(commitAnimations))]
        #[unsafe(method_family = none)]
        pub fn commitAnimations(mtm: MainThreadMarker);

        /// # Safety
        ///
        /// `delegate` should be of the correct type.
        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnimationDelegate(delegate: Option<&AnyObject>, mtm: MainThreadMarker);

        /// # Safety
        ///
        /// `selector` must be a valid selector.
        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationWillStartSelector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnimationWillStartSelector(selector: Option<Sel>, mtm: MainThreadMarker);

        /// # Safety
        ///
        /// `selector` must be a valid selector.
        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationDidStopSelector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnimationDidStopSelector(selector: Option<Sel>, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationDuration:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationDuration(duration: NSTimeInterval, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationDelay:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationDelay(delay: NSTimeInterval, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationStartDate:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationStartDate(start_date: &NSDate, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationCurve:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationCurve(curve: UIViewAnimationCurve, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationRepeatCount:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationRepeatCount(repeat_count: c_float, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationRepeatAutoreverses:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationRepeatAutoreverses(repeat_autoreverses: bool, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationBeginsFromCurrentState:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationBeginsFromCurrentState(from_current_state: bool, mtm: MainThreadMarker);

        #[deprecated = "Use the block-based animation API instead"]
        #[unsafe(method(setAnimationTransition:forView:cache:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationTransition_forView_cache(
            transition: UIViewAnimationTransition,
            view: &UIView,
            cache: bool,
        );
    );
}

/// UserInterfaceStyle.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UIInterface")]
        #[unsafe(method(overrideUserInterfaceStyle))]
        #[unsafe(method_family = none)]
        pub fn overrideUserInterfaceStyle(&self) -> UIUserInterfaceStyle;

        #[cfg(feature = "UIInterface")]
        /// Setter for [`overrideUserInterfaceStyle`][Self::overrideUserInterfaceStyle].
        #[unsafe(method(setOverrideUserInterfaceStyle:))]
        #[unsafe(method_family = none)]
        pub fn setOverrideUserInterfaceStyle(
            &self,
            override_user_interface_style: UIUserInterfaceStyle,
        );
    );
}

/// UIContentSizeCategoryLimit.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UIContentSizeCategory")]
        /// Specify content size category limits. Setting one or both of these properties will limit the
        /// content size category for this view (and its subviews) to a minimum or a maximum value.
        /// You can use this to limit the support content size categories on part of your view hierarchy.
        /// Setting this to nil removes the limit on the minimum or maximum.
        /// Limits will be applied immediately and when future content size category updates occur.
        ///
        /// Specifying a minimum limit that is greater than the maximum limit (or vice versa) will effectively
        /// only use the maximum limit.
        ///
        /// Example:
        ///
        /// // limit the support content size categories between .medium and .accessibilityExtraLarge (included).
        /// view.minimumContentSizeCategory = UIContentSizeCategoryMedium;
        /// view.maximumContentSizeCategory = UIContentSizeCategoryAccessibilityExtraLarge;
        #[unsafe(method(minimumContentSizeCategory))]
        #[unsafe(method_family = none)]
        pub fn minimumContentSizeCategory(&self) -> Option<Retained<UIContentSizeCategory>>;

        #[cfg(feature = "UIContentSizeCategory")]
        /// Setter for [`minimumContentSizeCategory`][Self::minimumContentSizeCategory].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMinimumContentSizeCategory:))]
        #[unsafe(method_family = none)]
        pub fn setMinimumContentSizeCategory(
            &self,
            minimum_content_size_category: Option<&UIContentSizeCategory>,
        );

        #[cfg(feature = "UIContentSizeCategory")]
        #[unsafe(method(maximumContentSizeCategory))]
        #[unsafe(method_family = none)]
        pub fn maximumContentSizeCategory(&self) -> Option<Retained<UIContentSizeCategory>>;

        #[cfg(feature = "UIContentSizeCategory")]
        /// Setter for [`maximumContentSizeCategory`][Self::maximumContentSizeCategory].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMaximumContentSizeCategory:))]
        #[unsafe(method_family = none)]
        pub fn setMaximumContentSizeCategory(
            &self,
            maximum_content_size_category: Option<&UIContentSizeCategory>,
        );

        /// Will return a string with a log of all the superviews of this view, alongside with what
        /// content size category each view has and if that view has limits applied.
        /// This is for debugging purposes only.
        #[unsafe(method(appliedContentSizeCategoryLimitsDescription))]
        #[unsafe(method_family = none)]
        pub fn appliedContentSizeCategoryLimitsDescription(&self) -> Retained<NSString>;
    );
}

#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method(traitOverrides))]
        #[unsafe(method_family = none)]
        pub fn traitOverrides(&self) -> Retained<ProtocolObject<dyn UITraitOverrides>>;

        /// Forces an immediate trait update for this view (and its view controller, if applicable) and any subviews,
        /// including any view controllers or views in its subtree. Any trait change callbacks are sent synchronously.
        #[unsafe(method(updateTraitsIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updateTraitsIfNeeded(&self);
    );
}

#[cfg(all(feature = "UIResponder", feature = "UITraitCollection"))]
extern_conformance!(
    unsafe impl UITraitChangeObservable for UIView {}
);

/// LayoutRegions.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(all(feature = "UILayoutGuide", feature = "UIViewLayoutRegion"))]
        #[unsafe(method(layoutGuideForLayoutRegion:))]
        #[unsafe(method_family = none)]
        pub fn layoutGuideForLayoutRegion(
            &self,
            layout_region: &UIViewLayoutRegion,
        ) -> Retained<UILayoutGuide>;

        #[cfg(all(
            feature = "UIGeometry",
            feature = "UIViewLayoutRegion",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(edgeInsetsForLayoutRegion:))]
        #[unsafe(method_family = none)]
        pub fn edgeInsetsForLayoutRegion(&self, layout_region: &UIViewLayoutRegion)
            -> UIEdgeInsets;

        #[cfg(all(
            feature = "UIGeometry",
            feature = "UIViewLayoutRegion",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(directionalEdgeInsetsForLayoutRegion:))]
        #[unsafe(method_family = none)]
        pub fn directionalEdgeInsetsForLayoutRegion(
            &self,
            layout_region: &UIViewLayoutRegion,
        ) -> NSDirectionalEdgeInsets;
    );
}

/// CornerConfiguration.
#[cfg(feature = "UIResponder")]
impl UIView {
    extern_methods!(
        #[cfg(feature = "UICornerConfiguration")]
        /// A configuration that defines the corners of the view.
        #[unsafe(method(cornerConfiguration))]
        #[unsafe(method_family = none)]
        pub fn cornerConfiguration(&self) -> Retained<UICornerConfiguration>;

        #[cfg(feature = "UICornerConfiguration")]
        /// Setter for [`cornerConfiguration`][Self::cornerConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCornerConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn setCornerConfiguration(&self, corner_configuration: &UICornerConfiguration);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// Returns the effective radius for the given `corner`, calculated using the view's current `cornerConfiguration`.
        ///
        /// When invoked within ``UIView.layoutSubviews()``, ``UIView.updateProperties()``, or ``UIViewController.updateProperties()`` automatic invalidation will occur if the effective radius changes.
        /// If more than one `corner` is provided, the returned radius represents the maximum effective radius of those corners.
        ///
        /// - Parameter corner: The corner.
        /// - Returns: The effective radius.
        #[unsafe(method(effectiveRadiusForCorner:))]
        #[unsafe(method_family = none)]
        pub fn effectiveRadiusForCorner(&self, corner: UIRectCorner) -> CGFloat;
    );
}
