//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// The keys you use to identify the view controllers involved in a transition.
// NS_TYPED_ENUM
pub type UITransitionContextViewControllerKey = NSString;

/// The keys you use to identify the views involved in a transition.
// NS_TYPED_ENUM
pub type UITransitionContextViewKey = NSString;

extern_protocol!(
    /// A set of methods that provides information about an in-progress view controller transition.
    ///
    /// ## Overview
    ///
    /// Don’t adopt this protocol in your own classes. UIKit creates an object that adopts this protocol and makes it available to your code when you animate changes using a transition coordinator object.
    ///
    /// A transition coordinator context provides most of the same information as an object that adopts the [`UIViewControllerContextTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning) protocol. You use this contextual information to determine the animation parameters, such as the view in which the animations take place, whether the transition is interactive, or whether the transition was the result of an interface orientation change. You then apply that information to the animations you create.
    ///
    /// Most animations take place in the view returned by the [`containerView`](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioncoordinatorcontext/containerview) method. And at the time your animation blocks are executed, the view hierarchy already contains the view of the _from_ view controller. You can use your animation blocks to animate additional content in that same container view or you can animate content in an entirely different view.
    ///
    ///
    pub unsafe trait UIViewControllerTransitionCoordinatorContext:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(isAnimated))]
        #[unsafe(method_family = none)]
        fn isAnimated(&self) -> bool;

        #[cfg(feature = "UIViewController")]
        #[unsafe(method(presentationStyle))]
        #[unsafe(method_family = none)]
        fn presentationStyle(&self) -> UIModalPresentationStyle;

        /// initiallyInteractive indicates whether the transition was initiated as an interactive transition.
        /// It never changes during the course of a transition.
        /// It can only be YES if isAnimated is YES.
        /// If it is NO, then isInteractive can only be YES if isInterruptible is YES
        #[unsafe(method(initiallyInteractive))]
        #[unsafe(method_family = none)]
        fn initiallyInteractive(&self) -> bool;

        #[unsafe(method(isInterruptible))]
        #[unsafe(method_family = none)]
        fn isInterruptible(&self) -> bool;

        #[unsafe(method(isInteractive))]
        #[unsafe(method_family = none)]
        fn isInteractive(&self) -> bool;

        #[unsafe(method(isCancelled))]
        #[unsafe(method_family = none)]
        fn isCancelled(&self) -> bool;

        #[unsafe(method(transitionDuration))]
        #[unsafe(method_family = none)]
        fn transitionDuration(&self) -> NSTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(percentComplete))]
        #[unsafe(method_family = none)]
        fn percentComplete(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(completionVelocity))]
        #[unsafe(method_family = none)]
        fn completionVelocity(&self) -> CGFloat;

        #[cfg(feature = "UIView")]
        #[unsafe(method(completionCurve))]
        #[unsafe(method_family = none)]
        fn completionCurve(&self) -> UIViewAnimationCurve;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[unsafe(method(viewControllerForKey:))]
        #[unsafe(method_family = none)]
        fn viewControllerForKey(
            &self,
            key: &UITransitionContextViewControllerKey,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(viewForKey:))]
        #[unsafe(method_family = none)]
        fn viewForKey(&self, key: &UITransitionContextViewKey) -> Option<Retained<UIView>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(containerView))]
        #[unsafe(method_family = none)]
        fn containerView(&self) -> Retained<UIView>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(targetTransform))]
        #[unsafe(method_family = none)]
        fn targetTransform(&self) -> CGAffineTransform;
    }
);

extern_protocol!(
    /// A set of methods that provides support for animations associated with a view controller transition.
    ///
    /// ## Overview
    ///
    /// Typically, you don’t adopt this protocol in your own classes. When you present or dismiss a view controller, UIKit creates a transition coordinator object automatically and assigns it to the view controller’s [`transitionCoordinator`](https://developer.apple.com/documentation/uikit/uiviewcontroller/transitioncoordinator) property. That transition coordinator object is ephemeral and lasts for the duration of the transition animation.
    ///
    /// You can use a transition coordinator object to perform tasks that are related to a transition but that are separate from what the animator objects are doing. During a transition, the animator objects are responsible for putting the new view controller content onscreen, but there may be other visual elements that need to be displayed too. For example, a presentation controller might want to animate the appearance or disappearance of decoration views that are separate from the view controller content. In that case, it uses the transition coordinator to perform those animations.
    ///
    /// The transition coordinator works with the animator objects to ensure that any extra animations are performed in the same animation group as the transition animations. Having the animations in the same group means that they execute at the same time and can all respond to timing changes provided by an interactive animator object. These timing adjustments happen automatically and don’t require any extra code on your part.
    ///
    /// Using the transition coordinator to handle view hierarchy animations is preferred over making those same changes in the [`viewWillAppear:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwillappear(_:)) or similar methods of your view controllers. The blocks you register with the methods of this protocol are guaranteed to execute at the same time as the transition animations. More importantly, the transition coordinator provides important information about the state of the transition, such as whether it was canceled, to your animation blocks through the [`UIViewControllerTransitionCoordinatorContext`](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioncoordinatorcontext) object.
    ///
    /// In addition to registering animations to perform during the transition, you can call the [`notifyWhenInteractionEndsUsingBlock:`](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioncoordinator/notifywheninteractionends(_:)) method to register a block to clean up animations associated with an interactive transition. Cleaning up is particularly important when the user cancels a transition interactively. When a cancellation occurs, you need to return to the original view hierarchy state as it existed before the transition.
    ///
    /// Because the transition coordinator is in effect only during a transition, UIKit releases the object when the transition finishes and the final callback is made.
    ///
    ///
    pub unsafe trait UIViewControllerTransitionCoordinator:
        UIViewControllerTransitionCoordinatorContext + MainThreadOnly
    {
        #[cfg(feature = "block2")]
        #[unsafe(method(animateAlongsideTransition:completion:))]
        #[unsafe(method_family = none)]
        fn animateAlongsideTransition_completion(
            &self,
            animation: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn UIViewControllerTransitionCoordinatorContext>>,
                    ),
                >,
            >,
            completion: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn UIViewControllerTransitionCoordinatorContext>>,
                    ),
                >,
            >,
        ) -> bool;

        #[cfg(all(feature = "UIResponder", feature = "UIView", feature = "block2"))]
        #[unsafe(method(animateAlongsideTransitionInView:animation:completion:))]
        #[unsafe(method_family = none)]
        fn animateAlongsideTransitionInView_animation_completion(
            &self,
            view: Option<&UIView>,
            animation: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn UIViewControllerTransitionCoordinatorContext>>,
                    ),
                >,
            >,
            completion: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn UIViewControllerTransitionCoordinatorContext>>,
                    ),
                >,
            >,
        ) -> bool;

        #[cfg(feature = "block2")]
        #[deprecated]
        #[unsafe(method(notifyWhenInteractionEndsUsingBlock:))]
        #[unsafe(method_family = none)]
        fn notifyWhenInteractionEndsUsingBlock(
            &self,
            handler: &block2::DynBlock<
                dyn Fn(NonNull<ProtocolObject<dyn UIViewControllerTransitionCoordinatorContext>>),
            >,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(notifyWhenInteractionChangesUsingBlock:))]
        #[unsafe(method_family = none)]
        fn notifyWhenInteractionChangesUsingBlock(
            &self,
            handler: &block2::DynBlock<
                dyn Fn(NonNull<ProtocolObject<dyn UIViewControllerTransitionCoordinatorContext>>),
            >,
        );
    }
);

/// UIViewControllerTransitionCoordinator.
#[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(transitionCoordinator))]
        #[unsafe(method_family = none)]
        pub fn transitionCoordinator(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerTransitionCoordinator>>>;
    );
}
