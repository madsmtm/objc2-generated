//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A rectangular area that can interact with Auto Layout.
    ///
    /// ## Overview
    ///
    /// Use layout guides to replace the placeholder views you may have created to represent inter-view spaces or encapsulation in your user interface. Traditionally, there were a number of Auto Layout techniques that required placeholder views. A placeholder view is an empty view that does not have any visual elements of its own and serves only to define a rectangular region in the view hierarchy. For example, if you wanted to use constraints to define the size or location of an empty space between views, you needed to use a placeholder view to represent that space. If you wanted to center a group of objects, you needed a placeholder view to contain those objects. Similarly, placeholder views could be used to contain and encapsulate part of your user interface. Placeholder views let you break up a large, complex user interface into self-contained, modular chunks. When used properly, they could greatly simplify your Auto Layout constraint logic.
    ///
    /// There are a number of costs associated with adding placeholder views to your view hierarchy. First, there is the cost of creating and maintaining the view itself. Second, the placeholder view is a full member of the view hierarchy, which means that it adds overhead to every task the hierarchy performs. Worst of all, the invisible placeholder view can intercept messages that are intended for other views, causing problems that are very difficult to find.
    ///
    /// The [`UILayoutGuide`](https://developer.apple.com/documentation/uikit/uilayoutguide) class is designed to perform all the tasks previously performed by placeholder views, but to do it in a safer, more efficient manner. Layout guides do not define a new view. They do not participate in the view hierarchy. Instead, they simply define a rectangular region in their owning view’s coordinate system that can interact with Auto Layout.
    ///
    /// ### Creating Layout Guides
    ///
    /// To create a layout guide, you must perform the following steps:
    ///
    /// 1. Instantiate a new layout guide.
    ///
    /// 2. Add the layout guide to a view by calling the view’s [`addLayoutGuide:`](https://developer.apple.com/documentation/uikit/uiview/addlayoutguide(_:)) method.
    ///
    /// 3. Define the position and size of the layout guide using Auto Layout.
    ///
    /// You can use these guides to define the space between elements in your layout. The following example shows layout guides used to define an equal spacing between a series of views.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let space1 = UILayoutGuide()", "view.addLayoutGuide(space1)", " ", "let space2 = UILayoutGuide()", "view.addLayoutGuide(space2)", " ", "space1.widthAnchor.constraintEqualToAnchor(space2.widthAnchor).active = true", "saveButton.trailingAnchor.constraintEqualToAnchor(space1.leadingAnchor).active = true", "cancelButton.leadingAnchor.constraintEqualToAnchor(space1.trailingAnchor).active = true", "cancelButton.trailingAnchor.constraintEqualToAnchor(space2.leadingAnchor).active = true", "clearButton.leadingAnchor.constraintEqualToAnchor(space2.trailingAnchor).active = true"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UILayoutGuide *space1 = [[UILayoutGuide alloc] init];", "[self.view addLayoutGuide:space1];", " ", "UILayoutGuide *space2 = [[UILayoutGuide alloc] init];", "[self.view addLayoutGuide:space2];", " ", "[space1.widthAnchor constraintEqualToAnchor:space2.widthAnchor].active = YES;", "[self.saveButton.trailingAnchor constraintEqualToAnchor:space1.leadingAnchor].active = YES;", "[self.cancelButton.leadingAnchor constraintEqualToAnchor:space1.trailingAnchor].active = YES;", "[self.cancelButton.trailingAnchor constraintEqualToAnchor:space2.leadingAnchor].active = YES;", "[self.clearButton.leadingAnchor constraintEqualToAnchor:space2.trailingAnchor].active = YES;"], metadata: None }] }] })
    /// A layout guide can also act as an opaque box that contains other views and controls, letting you encapsulate parts of your view and break up your layout into modular chunks.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let container = UILayoutGuide()", "view.addLayoutGuide(container)", " ", "// Set interior constraints", "label.lastBaselineAnchor.constraintEqualToAnchor(textField.lastBaselineAnchor).active = true", "label.leadingAnchor.constraintEqualToAnchor(container.leadingAnchor).active = true", "textField.leadingAnchor.constraintEqualToAnchor(label.trailingAnchor, constant: 8.0).active = true", "textField.trailingAnchor.constraintEqualToAnchor(container.trailingAnchor).active = true", "textField.topAnchor.constraintEqualToAnchor(container.topAnchor).active = true", "textField.bottomAnchor.constraintEqualToAnchor(container.bottomAnchor).active = true", " ", "// Set exterior constraints", "// The contents of the container can be treated as an opaque box", "let margins = view.layoutMarginsGuide", " ", "container.leadingAnchor.constraintEqualToAnchor(margins.leadingAnchor).active = true", "container.trailingAnchor.constraintEqualToAnchor(margins.trailingAnchor).active = true", "container.topAnchor.constraintEqualToAnchor(topLayoutGuide.bottomAnchor, constant: 20.0).active = true"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UILayoutGuide *container = [[UILayoutGuide alloc] init];", "[self.view addLayoutGuide:container];", " ", "// Layout the contents of the container", "[self.label.lastBaselineAnchor constraintEqualToAnchor:self.textField.lastBaselineAnchor].active = YES;", "[self.label.leadingAnchor constraintEqualToAnchor:container.leadingAnchor].active = YES;", "[self.textField.leadingAnchor constraintEqualToAnchor:self.label.trailingAnchor constant:8.0].active = YES;", "[self.textField.trailingAnchor constraintEqualToAnchor:container.trailingAnchor].active = YES;", "[self.textField.topAnchor constraintEqualToAnchor:container.topAnchor].active = YES;", "[self.textField.bottomAnchor constraintEqualToAnchor:container.bottomAnchor].active = YES;", " ", "// Set exterior constraints.", "UILayoutGuide *margins = self.view.layoutMarginsGuide;", " ", "[container.leadingAnchor constraintEqualToAnchor:margins.leadingAnchor].active = YES;", "[container.trailingAnchor constraintEqualToAnchor:margins.trailingAnchor].active = YES;", "[container.topAnchor constraintEqualToAnchor:self.topLayoutGuide.bottomAnchor constant:20.0].active = YES;"], metadata: None }] }] })
    /// <div class="warning">
    ///
    /// ### Note
    ///  Layout guides provides a lightweight method for encapsulating part of your layout. Note that this technique only affects how Auto Layout interacts with the encapsulated views. It does not change the view hierarchy in any way. However, this is not the only way to create modular user interfaces. Container views and container view controllers provide an even greater degree of encapsulation, letting you separate the layout, the view hierarchy and even the related view controller code. For more information, see [Adaptivity and Size Changes](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/TheAdaptiveModel.html#//apple_ref/doc/uid/TP40007457-CH18) in [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).
    ///
    /// Additionally, layout constraints do not fully encapsulate their contents. The system still compares the priority of optional constraints inside the layout guide with the priority of optional constraints outside the guide.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UILayoutGuide;
);

extern_conformance!(
    unsafe impl NSCoding for UILayoutGuide {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UILayoutGuide {}
);

impl UILayoutGuide {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(layoutFrame))]
        #[unsafe(method_family = none)]
        pub fn layoutFrame(&self) -> CGRect;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(owningView))]
        #[unsafe(method_family = none)]
        pub fn owningView(&self) -> Option<Retained<UIView>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        /// Setter for [`owningView`][Self::owningView].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setOwningView:))]
        #[unsafe(method_family = none)]
        pub fn setOwningView(&self, owning_view: Option<&UIView>);

        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub fn identifier(&self) -> Retained<NSString>;

        /// Setter for [`identifier`][Self::identifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setIdentifier(&self, identifier: &NSString);

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(leadingAnchor))]
        #[unsafe(method_family = none)]
        pub fn leadingAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(trailingAnchor))]
        #[unsafe(method_family = none)]
        pub fn trailingAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(leftAnchor))]
        #[unsafe(method_family = none)]
        pub fn leftAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(rightAnchor))]
        #[unsafe(method_family = none)]
        pub fn rightAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(topAnchor))]
        #[unsafe(method_family = none)]
        pub fn topAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(bottomAnchor))]
        #[unsafe(method_family = none)]
        pub fn bottomAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(widthAnchor))]
        #[unsafe(method_family = none)]
        pub fn widthAnchor(&self) -> Retained<NSLayoutDimension>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(heightAnchor))]
        #[unsafe(method_family = none)]
        pub fn heightAnchor(&self) -> Retained<NSLayoutDimension>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(centerXAnchor))]
        #[unsafe(method_family = none)]
        pub fn centerXAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(centerYAnchor))]
        #[unsafe(method_family = none)]
        pub fn centerYAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UILayoutGuide {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
