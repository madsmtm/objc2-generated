//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// A reference to the storyboard that contains the view controller.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`UIStoryboard`](https://developer.apple.com/documentation/uikit/uistoryboard) object representing the storyboard from which a view controller was initially obtained. You don’t need to write this key to the coder yourself. Each [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) class automatically writes this key to the coder during the state preservation process.
    ///
    ///
    pub static UIStateRestorationViewControllerStoryboardKey: &'static NSString;
}

extern "C" {
    /// The version of your app responsible for creating the restoration archive.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object that identifies the version of your app (as obtained from the `CFBundleVersion` key of your app’s `Info.plist` file) that was present when the state information was saved. You can use the value of this key to help make choices about how to proceed during state restoration. For example, if the key indicates that the state is associated with an older version of your app, you might want to avoid restoring the previous state altogether or modify the restoration process more significantly.
    ///
    ///
    pub static UIApplicationStateRestorationBundleVersionKey: &'static NSString;
}

extern "C" {
    /// The user interface idiom that was in effect when your app created the restoration archive.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing one of the values for the [`UIUserInterfaceIdiom`](https://developer.apple.com/documentation/uikit/uiuserinterfaceidiom) enum. This value reflects whether the interface that was saved was targeting the iPad or iPhone idiom.
    ///
    ///
    pub static UIApplicationStateRestorationUserInterfaceIdiomKey: &'static NSString;
}

extern "C" {
    /// The time your app created the restoration archive.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) object containing the date when the restoration archive was saved. The date is specified using coordinated universal time (UTC).
    ///
    ///
    pub static UIApplicationStateRestorationTimestampKey: &'static NSString;
}

extern "C" {
    /// The version of the system on which your app created the restoration archive.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object containing the iOS system version that was installed when the archive was saved. The format of this string matches the format of the value in the [`systemVersion`](https://developer.apple.com/documentation/uikit/uidevice/systemversion) property of the [`UIDevice`](https://developer.apple.com/documentation/uikit/uidevice) class.
    ///
    ///
    pub static UIApplicationStateRestorationSystemVersionKey: &'static NSString;
}

extern_protocol!(
    /// The methods that objects adopt so that they can act as a restoration class for view controllers during state restoration.
    ///
    /// ## Overview
    ///
    /// To use a class that adopts this protocol, you must assign that class to the [`restorationClass`](https://developer.apple.com/documentation/uikit/uiviewcontroller/restorationclass) property of one of your app’s view controllers. The method in this protocol should be used to create the view controller, if it doesn’t yet exist, or return an existing view controller object, if one does exist.
    ///
    ///
    pub unsafe trait UIViewControllerRestoration: MainThreadOnly {
        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(viewControllerWithRestorationIdentifierPath:coder:))]
        #[unsafe(method_family = none)]
        unsafe fn viewControllerWithRestorationIdentifierPath_coder(
            identifier_components: &NSArray<NSString>,
            coder: &NSCoder,
            mtm: MainThreadMarker,
        ) -> Option<Retained<UIViewController>>;
    }
);

extern_protocol!(
    /// A set of methods that defines an interface for providing persistent references to data objects in your app.
    ///
    /// ## Overview
    ///
    /// Your data source objects can adopt this protocol to assist a corresponding table or collection view during the state restoration process. Those classes use the methods of this protocol to ensure that the same data objects (and not just the same row indexes) are scrolled into view and selected.
    ///
    /// Before you can implement this protocol, your app must be able to identify data objects consistently between app launches. This requires being able to take some identifying marker of the object and convert that marker into a string that can then be saved with the rest of the app state. For example, a Core Data app could convert a managed object’s ID into a URI that it could then convert into a string.
    ///
    /// Currently, only the [`UITableView`](https://developer.apple.com/documentation/uikit/uitableview) and [`UICollectionView`](https://developer.apple.com/documentation/uikit/uicollectionview) classes support this protocol. You’d implement this protocol in any objects you use as the data source for those classes. If you don’t adopt the protocol in your data source, the views don’t attempt to restore the selected and visible rows.
    ///
    ///
    pub unsafe trait UIDataSourceModelAssociation: MainThreadOnly {
        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(modelIdentifierForElementAtIndexPath:inView:))]
        #[unsafe(method_family = none)]
        fn modelIdentifierForElementAtIndexPath_inView(
            &self,
            idx: &NSIndexPath,
            view: &UIView,
        ) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(indexPathForElementWithModelIdentifier:inView:))]
        #[unsafe(method_family = none)]
        fn indexPathForElementWithModelIdentifier_inView(
            &self,
            identifier: &NSString,
            view: &UIView,
        ) -> Option<Retained<NSIndexPath>>;
    }
);

extern_protocol!(
    /// Methods for adding objects to your state restoration archives.
    ///
    /// ## Overview
    ///
    /// You can add state restoring objects to an archive directly or by referencing them from another object that’s preserved, such as a view controller. The methods of the protocol let you save enough information about the object to find or recreate it during the next launch cycle.
    ///
    /// When adopting this protocol in your custom objects, you must also remember to register those objects using the [`registerObjectForStateRestoration:restorationIdentifier:`](https://developer.apple.com/documentation/uikit/uiapplication/registerobject(forstaterestoration:restorationidentifier:)) method of the [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) class. You don’t need to register views or view controllers explicitly because UIKit registers those objects automatically. View controllers adopt this protocol so that they may be used as the restoration parent of one of your custom objects.
    ///
    ///
    pub unsafe trait UIStateRestoring: NSObjectProtocol + MainThreadOnly {
        #[optional]
        #[unsafe(method(restorationParent))]
        #[unsafe(method_family = none)]
        fn restorationParent(&self) -> Option<Retained<ProtocolObject<dyn UIStateRestoring>>>;

        #[optional]
        #[unsafe(method(objectRestorationClass))]
        #[unsafe(method_family = none)]
        fn objectRestorationClass(&self) -> Option<&'static AnyClass>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(decodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn decodeRestorableStateWithCoder(&self, coder: &NSCoder);

        #[optional]
        #[unsafe(method(applicationFinishedRestoringState))]
        #[unsafe(method_family = none)]
        fn applicationFinishedRestoringState(&self);
    }
);

extern_protocol!(
    /// The interface that restoration classes use to restore preserved objects.
    ///
    /// ## Overview
    ///
    /// A restorable object must set its [`objectRestorationClass`](https://developer.apple.com/documentation/uikit/uistaterestoring/objectrestorationclass) property to the class that adopts this protocol. The method in this protocol should be used to return the object if it already exists or create it if needed.
    ///
    ///
    pub unsafe trait UIObjectRestoration: MainThreadOnly {
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(objectWithRestorationIdentifierPath:coder:))]
        #[unsafe(method_family = none)]
        unsafe fn objectWithRestorationIdentifierPath_coder(
            identifier_components: &NSArray<NSString>,
            coder: &NSCoder,
            mtm: MainThreadMarker,
        ) -> Option<Retained<ProtocolObject<dyn UIStateRestoring>>>;
    }
);
