//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A special type of layout object that lets you implement behaviors when changing from one layout to another in your collection view.
    ///
    /// ## Overview
    ///
    /// You can use [`UICollectionViewTransitionLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewtransitionlayout) as-is or subclass it to provide specialized behavior for your app. A common use for transition layouts is to create interactive transitions, such as those that are driven by gesture recognizers or touch events.
    ///
    /// During a layout change, the collection view installs this layout object temporarily to manage the changeover. This layout object determines the layout of each item by interpolating between the layout values in the current and new layout objects. The interpolation is driven by the value in the [`transitionProgress`](https://developer.apple.com/documentation/uikit/uicollectionviewtransitionlayout/transitionprogress) property, which you update periodically from your code to drive the transition. For example, if you use this class in conjunction with a gesture recognizer, the handler for your gesture recognizer would update that property and invalidate the layout.
    ///
    /// If you want to provide more than just a linear transition from the old to new layout over time, you need to subclass and provide the layout attributes for items yourself. Subclassing requires you to override all of the same methods you would override when subclassing [`UICollectionViewLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout). The difference is that your custom methods can work with your gesture recognizers or touch event code to change the layout based on input from the user. For example, you could use a custom layout object in conjunction with a gesture recognizer to make items track the location of the userâ€™s finger on the screen. You also need to implement the [`collectionView:transitionLayoutForOldLayout:newLayout:`](https://developer.apple.com/documentation/uikit/uicollectionviewdelegate/collectionview(_:transitionlayoutforoldlayout:newlayout:)) method of your collection view delegate and return your custom layout object when asked for it.
    ///
    ///
    #[unsafe(super(UICollectionViewLayout, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "UICollectionViewLayout")]
    pub struct UICollectionViewTransitionLayout;
);

#[cfg(feature = "UICollectionViewLayout")]
extern_conformance!(
    unsafe impl NSCoding for UICollectionViewTransitionLayout {}
);

#[cfg(feature = "UICollectionViewLayout")]
extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionViewTransitionLayout {}
);

#[cfg(feature = "UICollectionViewLayout")]
impl UICollectionViewTransitionLayout {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(transitionProgress))]
        #[unsafe(method_family = none)]
        pub fn transitionProgress(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`transitionProgress`][Self::transitionProgress].
        #[unsafe(method(setTransitionProgress:))]
        #[unsafe(method_family = none)]
        pub fn setTransitionProgress(&self, transition_progress: CGFloat);

        #[unsafe(method(currentLayout))]
        #[unsafe(method_family = none)]
        pub fn currentLayout(&self) -> Retained<UICollectionViewLayout>;

        #[unsafe(method(nextLayout))]
        #[unsafe(method_family = none)]
        pub fn nextLayout(&self) -> Retained<UICollectionViewLayout>;

        #[unsafe(method(initWithCurrentLayout:nextLayout:))]
        #[unsafe(method_family = init)]
        pub fn initWithCurrentLayout_nextLayout(
            this: Allocated<Self>,
            current_layout: &UICollectionViewLayout,
            new_layout: &UICollectionViewLayout,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(updateValue:forAnimatedKey:))]
        #[unsafe(method_family = none)]
        pub fn updateValue_forAnimatedKey(&self, value: CGFloat, key: &NSString);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(valueForAnimatedKey:))]
        #[unsafe(method_family = none)]
        pub fn valueForAnimatedKey(&self, key: &NSString) -> CGFloat;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "UICollectionViewLayout")]
impl UICollectionViewTransitionLayout {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
