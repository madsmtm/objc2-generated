//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A representation of the state of the data in a view at a specific point in time.
    ///
    /// ## Overview
    ///
    /// Diffable data sources use _snapshots_ to provide data for collection views and table views. You use a snapshot to set up the initial state of the data that a view displays, and you use snapshots to reflect changes to the data that the view displays.
    ///
    /// The data in a snapshot is made up of the sections and items you want to display, in the order that you determine. You configure what to display by adding, deleting, or moving the sections and items.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Each of your sections and items must have unique identifiers that conform to the [`Hashable`](https://developer.apple.com/documentation/swift/hashable) protocol. Use `struct` or `enum` Swift value types for your identifiers, including built-in types such as `Int`, `String`, or `UUID`. If you use a Swift `class` for your identifiers, your `class` must be a subclass of `NSObject`.
    ///
    ///
    ///
    /// </div>
    /// To display data in a view using a snapshot:
    ///
    /// 1. Create a snapshot and populate it with the state of the data you want to display.
    ///
    /// 2. Apply the snapshot to reflect the changes in the UI.
    ///
    /// You can create and configure a snapshot in one of these ways:
    ///
    /// - Create an empty snapshot, then append sections and items to it.
    ///
    /// - Get the current snapshot by calling the diffable data source’s [`snapshot()`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasource-9tqpa/snapshot()) method, then modify that snapshot to reflect the new state of the data that you want to display.
    ///
    /// For example, the following code creates an empty snapshot and populates it with a single section with three items. Then, the code applies the snapshot, animating the UI updates between the previous state and the new state.
    ///
    /// ```objc
    /// // Create a snapshot.
    /// NSDiffableDataSourceSnapshot<NSNumber *, NSUUID *> *snapshot = [[NSDiffableDataSourceSnapshot alloc] init];
    ///
    ///
    /// // Populate the snapshot.
    /// [snapshot appendSectionsWithIdentifiers:@[@0]];
    /// [snapshot appendItemsWithIdentifiers:@[[NSUUID UUID], [NSUUID UUID], [NSUUID UUID]]];
    ///
    ///
    /// // Apply the snapshot.
    /// [self.dataSource applySnapshot:snapshot animatingDifferences:YES];
    /// ```
    ///
    /// For more information, see the diffable data source types:
    ///
    /// - [`UICollectionViewDiffableDataSource`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasourcereference)
    ///
    /// - [`UITableViewDiffableDataSource`](https://developer.apple.com/documentation/uikit/uitableviewdiffabledatasourcereference)
    ///
    /// - [`NSCollectionViewDiffableDataSource`](https://developer.apple.com/documentation/appkit/nscollectionviewdiffabledatasource-axww)
    ///
    /// <div class="warning">
    ///
    /// ### Important
    /// If you’re working in a Swift codebase, always use [`NSDiffableDataSourceSnapshot`](https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshot-swift.struct) instead.
    ///
    ///
    ///
    /// </div>
    /// Avoid using this type in Swift code. Only use this type to bridge from Objective-C code to Swift code by typecasting from a snapshot reference to a snapshot:
    ///
    /// ```swift
    /// let snapshot = snapshotReference as NSDiffableDataSourceSnapshot<Int, UUID>
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSDiffableDataSourceSnapshot<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &NSDiffableDataSourceSnapshot<NewSectionIdentifierType, NewItemIdentifierType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSCopying
        for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

unsafe impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    CopyingHelper for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    type Result = Self;
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(numberOfItems))]
        #[unsafe(method_family = none)]
        pub fn numberOfItems(&self) -> NSInteger;

        #[unsafe(method(numberOfSections))]
        #[unsafe(method_family = none)]
        pub fn numberOfSections(&self) -> NSInteger;

        #[unsafe(method(sectionIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn sectionIdentifiers(&self) -> Retained<NSArray<SectionIdentifierType>>;

        #[unsafe(method(itemIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifiers(&self) -> Retained<NSArray<ItemIdentifierType>>;

        #[unsafe(method(reloadedSectionIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn reloadedSectionIdentifiers(&self) -> Retained<NSArray<SectionIdentifierType>>;

        #[unsafe(method(reloadedItemIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn reloadedItemIdentifiers(&self) -> Retained<NSArray<ItemIdentifierType>>;

        #[unsafe(method(reconfiguredItemIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn reconfiguredItemIdentifiers(&self) -> Retained<NSArray<ItemIdentifierType>>;

        #[unsafe(method(numberOfItemsInSection:))]
        #[unsafe(method_family = none)]
        pub fn numberOfItemsInSection(
            &self,
            section_identifier: &SectionIdentifierType,
        ) -> NSInteger;

        #[unsafe(method(itemIdentifiersInSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifiersInSectionWithIdentifier(
            &self,
            section_identifier: &SectionIdentifierType,
        ) -> Retained<NSArray<ItemIdentifierType>>;

        #[unsafe(method(sectionIdentifierForSectionContainingItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn sectionIdentifierForSectionContainingItemIdentifier(
            &self,
            item_identifier: &ItemIdentifierType,
        ) -> Option<Retained<SectionIdentifierType>>;

        #[unsafe(method(indexOfItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexOfItemIdentifier(&self, item_identifier: &ItemIdentifierType) -> NSInteger;

        #[unsafe(method(indexOfSectionIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexOfSectionIdentifier(
            &self,
            section_identifier: &SectionIdentifierType,
        ) -> NSInteger;

        #[unsafe(method(appendItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn appendItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(appendItemsWithIdentifiers:intoSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn appendItemsWithIdentifiers_intoSectionWithIdentifier(
            &self,
            identifiers: &NSArray<ItemIdentifierType>,
            section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(insertItemsWithIdentifiers:beforeItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertItemsWithIdentifiers_beforeItemWithIdentifier(
            &self,
            identifiers: &NSArray<ItemIdentifierType>,
            item_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(insertItemsWithIdentifiers:afterItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertItemsWithIdentifiers_afterItemWithIdentifier(
            &self,
            identifiers: &NSArray<ItemIdentifierType>,
            item_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(deleteItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn deleteItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(deleteAllItems))]
        #[unsafe(method_family = none)]
        pub fn deleteAllItems(&self);

        #[unsafe(method(moveItemWithIdentifier:beforeItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveItemWithIdentifier_beforeItemWithIdentifier(
            &self,
            from_identifier: &ItemIdentifierType,
            to_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(moveItemWithIdentifier:afterItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveItemWithIdentifier_afterItemWithIdentifier(
            &self,
            from_identifier: &ItemIdentifierType,
            to_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(reloadItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn reloadItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(reconfigureItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn reconfigureItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(appendSectionsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn appendSectionsWithIdentifiers(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
        );

        #[unsafe(method(insertSectionsWithIdentifiers:beforeSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertSectionsWithIdentifiers_beforeSectionWithIdentifier(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(insertSectionsWithIdentifiers:afterSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertSectionsWithIdentifiers_afterSectionWithIdentifier(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(deleteSectionsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn deleteSectionsWithIdentifiers(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
        );

        #[unsafe(method(moveSectionWithIdentifier:beforeSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveSectionWithIdentifier_beforeSectionWithIdentifier(
            &self,
            from_section_identifier: &SectionIdentifierType,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(moveSectionWithIdentifier:afterSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveSectionWithIdentifier_afterSectionWithIdentifier(
            &self,
            from_section_identifier: &SectionIdentifierType,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(reloadSectionsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn reloadSectionsWithIdentifiers(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<SectionIdentifierType: Message, ItemIdentifierType: Message> DefaultRetained
    for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// A closure that configures and returns a cell for a collection view from its diffable data source.
///
/// Parameters:
/// - collectionView: The collection view to configure this cell for.
///
/// - indexPath: The index path that specifies the location of the cell in the collection view.
///
/// - identifier: The identifier of the item for this cell.
///
///
/// ## Return Value
///
/// A non-`nil` configured cell object. The cell provider must return a valid cell object to the collection view.
///
///
#[cfg(all(
    feature = "UICollectionView",
    feature = "UICollectionViewCell",
    feature = "UIResponder",
    feature = "UIScrollView",
    feature = "UIView",
    feature = "block2"
))]
pub type UICollectionViewDiffableDataSourceCellProvider = *mut block2::DynBlock<
    dyn Fn(
        NonNull<UICollectionView>,
        NonNull<NSIndexPath>,
        NonNull<AnyObject>,
    ) -> *mut UICollectionViewCell,
>;

/// A closure that configures and returns a collection view’s supplementary view, such as a header or footer, from a diffable data source.
///
/// Parameters:
/// - collectionView: The collection view to configure this supplementary view for.
///
/// - kind: The kind of supplementary view to provide. The layout object that supports the supplementary view defines the value of this string.
///
/// - indexPath: The index path that specifies the location of the supplementary view in the collection view.
///
///
/// ## Return Value
///
/// A non-`nil` configured supplementary view object. The supplementary view provider must return a valid view object to the collection view.
///
///
#[cfg(all(
    feature = "UICollectionView",
    feature = "UICollectionViewCell",
    feature = "UIResponder",
    feature = "UIScrollView",
    feature = "UIView",
    feature = "block2"
))]
pub type UICollectionViewDiffableDataSourceSupplementaryViewProvider = *mut block2::DynBlock<
    dyn Fn(
        NonNull<UICollectionView>,
        NonNull<NSString>,
        NonNull<NSIndexPath>,
    ) -> *mut UICollectionReusableView,
>;

extern_class!(
    /// A transaction that describes the changes after reordering the items in a section.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSDiffableDataSourceSectionTransaction<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &NSDiffableDataSourceSectionTransaction<NewSectionIdentifierType, NewItemIdentifierType>
    {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(sectionIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn sectionIdentifier(&self) -> Retained<SectionIdentifierType>;

        #[cfg(feature = "NSDiffableDataSourceSectionSnapshot")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(initialSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn initialSnapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>>;

        #[cfg(feature = "NSDiffableDataSourceSectionSnapshot")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(finalSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn finalSnapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(difference))]
        #[unsafe(method_family = none)]
        pub unsafe fn difference(
            &self,
        ) -> Retained<NSOrderedCollectionDifference<ItemIdentifierType>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<SectionIdentifierType: Message, ItemIdentifierType: Message> DefaultRetained
    for NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>
{
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A transaction that describes the changes after reordering the items in the view.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSDiffableDataSourceTransaction<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &NSDiffableDataSourceTransaction<NewSectionIdentifierType, NewItemIdentifierType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(initialSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn initialSnapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(finalSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn finalSnapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(difference))]
        #[unsafe(method_family = none)]
        pub unsafe fn difference(
            &self,
        ) -> Retained<NSOrderedCollectionDifference<ItemIdentifierType>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(sectionTransactions))]
        #[unsafe(method_family = none)]
        pub unsafe fn sectionTransactions(
            &self,
        ) -> Retained<
            NSArray<
                NSDiffableDataSourceSectionTransaction<SectionIdentifierType, ItemIdentifierType>,
            >,
        >;
    );
}

/// Methods declared on superclass `NSObject`.
impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<SectionIdentifierType: Message, ItemIdentifierType: Message> DefaultRetained
    for NSDiffableDataSourceTransaction<SectionIdentifierType, ItemIdentifierType>
{
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// Handlers for reordering items.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewDiffableDataSourceReorderingHandlers<
        SectionType: ?Sized = AnyObject,
        ItemType: ?Sized = AnyObject,
    >;
);

impl<SectionType: ?Sized + Message, ItemType: ?Sized + Message>
    UICollectionViewDiffableDataSourceReorderingHandlers<SectionType, ItemType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionType: ?Sized + Message,
        NewItemType: ?Sized + Message,
    >(
        &self,
    ) -> &UICollectionViewDiffableDataSourceReorderingHandlers<NewSectionType, NewItemType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionType: ?Sized, ItemType: ?Sized> NSCopying
        for UICollectionViewDiffableDataSourceReorderingHandlers<SectionType, ItemType>
    {
    }
);

unsafe impl<SectionType: ?Sized + Message, ItemType: ?Sized + Message> CopyingHelper
    for UICollectionViewDiffableDataSourceReorderingHandlers<SectionType, ItemType>
{
    type Result = Self;
}

extern_conformance!(
    unsafe impl<SectionType: ?Sized, ItemType: ?Sized> NSObjectProtocol
        for UICollectionViewDiffableDataSourceReorderingHandlers<SectionType, ItemType>
    {
    }
);

impl<SectionType: Message, ItemType: Message>
    UICollectionViewDiffableDataSourceReorderingHandlers<SectionType, ItemType>
{
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(canReorderItemHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn canReorderItemHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<ItemType>) -> Bool>;

        #[cfg(feature = "block2")]
        /// Setter for [`canReorderItemHandler`][Self::canReorderItemHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCanReorderItemHandler:))]
        #[unsafe(method_family = none)]
        pub fn setCanReorderItemHandler(
            &self,
            can_reorder_item_handler: Option<&block2::DynBlock<dyn Fn(NonNull<ItemType>) -> Bool>>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(willReorderHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn willReorderHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(NonNull<NSDiffableDataSourceTransaction<SectionType, ItemType>>),
        >;

        #[cfg(feature = "block2")]
        /// Setter for [`willReorderHandler`][Self::willReorderHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWillReorderHandler:))]
        #[unsafe(method_family = none)]
        pub fn setWillReorderHandler(
            &self,
            will_reorder_handler: Option<
                &block2::DynBlock<
                    dyn Fn(NonNull<NSDiffableDataSourceTransaction<SectionType, ItemType>>),
                >,
            >,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(didReorderHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn didReorderHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(NonNull<NSDiffableDataSourceTransaction<SectionType, ItemType>>),
        >;

        #[cfg(feature = "block2")]
        /// Setter for [`didReorderHandler`][Self::didReorderHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDidReorderHandler:))]
        #[unsafe(method_family = none)]
        pub fn setDidReorderHandler(
            &self,
            did_reorder_handler: Option<
                &block2::DynBlock<
                    dyn Fn(NonNull<NSDiffableDataSourceTransaction<SectionType, ItemType>>),
                >,
            >,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl<SectionType: Message, ItemType: Message>
    UICollectionViewDiffableDataSourceReorderingHandlers<SectionType, ItemType>
{
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// Handlers for expanding and collapsing items.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewDiffableDataSourceSectionSnapshotHandlers<
        ItemType: ?Sized = AnyObject,
    >;
);

impl<ItemType: ?Sized + Message>
    UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType>
{
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewItemType: ?Sized + Message>(
        &self,
    ) -> &UICollectionViewDiffableDataSourceSectionSnapshotHandlers<NewItemType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<ItemType: ?Sized> NSCopying
        for UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType>
    {
    }
);

unsafe impl<ItemType: ?Sized + Message> CopyingHelper
    for UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType>
{
    type Result = Self;
}

extern_conformance!(
    unsafe impl<ItemType: ?Sized> NSObjectProtocol
        for UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType>
    {
    }
);

impl<ItemType: Message> UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType> {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(shouldExpandItemHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldExpandItemHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<ItemType>) -> Bool>;

        #[cfg(feature = "block2")]
        /// Setter for [`shouldExpandItemHandler`][Self::shouldExpandItemHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setShouldExpandItemHandler:))]
        #[unsafe(method_family = none)]
        pub fn setShouldExpandItemHandler(
            &self,
            should_expand_item_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<ItemType>) -> Bool>,
            >,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(willExpandItemHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn willExpandItemHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<ItemType>)>;

        #[cfg(feature = "block2")]
        /// Setter for [`willExpandItemHandler`][Self::willExpandItemHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWillExpandItemHandler:))]
        #[unsafe(method_family = none)]
        pub fn setWillExpandItemHandler(
            &self,
            will_expand_item_handler: Option<&block2::DynBlock<dyn Fn(NonNull<ItemType>)>>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(shouldCollapseItemHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldCollapseItemHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<ItemType>) -> Bool>;

        #[cfg(feature = "block2")]
        /// Setter for [`shouldCollapseItemHandler`][Self::shouldCollapseItemHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setShouldCollapseItemHandler:))]
        #[unsafe(method_family = none)]
        pub fn setShouldCollapseItemHandler(
            &self,
            should_collapse_item_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<ItemType>) -> Bool>,
            >,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(willCollapseItemHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn willCollapseItemHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<ItemType>)>;

        #[cfg(feature = "block2")]
        /// Setter for [`willCollapseItemHandler`][Self::willCollapseItemHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWillCollapseItemHandler:))]
        #[unsafe(method_family = none)]
        pub fn setWillCollapseItemHandler(
            &self,
            will_collapse_item_handler: Option<&block2::DynBlock<dyn Fn(NonNull<ItemType>)>>,
        );

        #[cfg(all(feature = "NSDiffableDataSourceSectionSnapshot", feature = "block2"))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(snapshotForExpandingParentItemHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn snapshotForExpandingParentItemHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(
                NonNull<ItemType>,
                NonNull<NSDiffableDataSourceSectionSnapshot<ItemType>>,
            ) -> NonNull<NSDiffableDataSourceSectionSnapshot<ItemType>>,
        >;

        #[cfg(all(feature = "NSDiffableDataSourceSectionSnapshot", feature = "block2"))]
        /// Setter for [`snapshotForExpandingParentItemHandler`][Self::snapshotForExpandingParentItemHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `snapshot_for_expanding_parent_item_handler` block's return must be a valid pointer.
        #[unsafe(method(setSnapshotForExpandingParentItemHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSnapshotForExpandingParentItemHandler(
            &self,
            snapshot_for_expanding_parent_item_handler: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ItemType>,
                        NonNull<NSDiffableDataSourceSectionSnapshot<ItemType>>,
                    )
                        -> NonNull<NSDiffableDataSourceSectionSnapshot<ItemType>>,
                >,
            >,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl<ItemType: Message> UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// The object you use to manage data and provide cells for a collection view.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    /// If you’re working in a Swift codebase, always use [`UICollectionViewDiffableDataSource`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasource-9tqpa) instead.
    ///
    ///
    ///
    /// </div>
    /// A _diffable data source_ object is a specialized type of data source that works together with your collection view object. It provides the behavior you need to manage updates to your collection view’s data and UI in a simple, efficient way. It also conforms to the [`UICollectionViewDataSource`](https://developer.apple.com/documentation/uikit/uicollectionviewdatasource) protocol and provides implementations for all of the protocol’s methods.
    ///
    /// To fill a collection view with data:
    ///
    /// 1. Connect a diffable data source to your collection view.
    ///
    /// 2. Implement a cell provider to configure your collection view’s cells.
    ///
    /// 3. Generate the current state of the data.
    ///
    /// 4. Display the data in the UI.
    ///
    /// To connect a diffable data source to a collection view, you create the diffable data source using its [`initWithCollectionView:cellProvider:`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasourcereference/init(collectionview:cellprovider:)) initializer, passing in the collection view you want to associate with that data source. You also pass in a cell provider, where you configure each of your cells to determine how to display your data in the UI.
    ///
    /// ```objc
    /// self.dataSource = [[UICollectionViewDiffableDataSource alloc] initWithCollectionView:self.collectionView cellProvider:^UICollectionViewCell *(UICollectionView *collectionView, NSIndexPath *indexPath, id item) {
    ///     // Configure and return cell.
    /// }];
    /// ```
    ///
    /// Then, you generate the current state of the data and display the data in the UI by constructing and applying a snapshot. For more information, see [`NSDiffableDataSourceSnapshot`](https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshotreference).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t change the [`dataSource`](https://developer.apple.com/documentation/uikit/uicollectionview/datasource) on the collection view after you configure it with a diffable data source. If the collection view needs a new data source after you configure it initially, create and configure a new collection view and diffable data source.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewDiffableDataSource<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &UICollectionViewDiffableDataSource<NewSectionIdentifierType, NewItemIdentifierType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

#[cfg(feature = "UICollectionView")]
extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
        UICollectionViewDataSource
        for UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    UICollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[cfg(all(
            feature = "UICollectionView",
            feature = "UICollectionViewCell",
            feature = "UIResponder",
            feature = "UIScrollView",
            feature = "UIView",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `cell_provider` must be a valid pointer.
        #[unsafe(method(initWithCollectionView:cellProvider:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCollectionView_cellProvider(
            this: Allocated<Self>,
            collection_view: &UICollectionView,
            cell_provider: UICollectionViewDiffableDataSourceCellProvider,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(all(
            feature = "UICollectionView",
            feature = "UICollectionViewCell",
            feature = "UIResponder",
            feature = "UIScrollView",
            feature = "UIView",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        /// - The returned block's argument 3 must be a valid pointer.
        #[unsafe(method(supplementaryViewProvider))]
        #[unsafe(method_family = none)]
        pub unsafe fn supplementaryViewProvider(
            &self,
        ) -> UICollectionViewDiffableDataSourceSupplementaryViewProvider;

        #[cfg(all(
            feature = "UICollectionView",
            feature = "UICollectionViewCell",
            feature = "UIResponder",
            feature = "UIScrollView",
            feature = "UIView",
            feature = "block2"
        ))]
        /// Setter for [`supplementaryViewProvider`][Self::supplementaryViewProvider].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `supplementary_view_provider` must be a valid pointer or null.
        #[unsafe(method(setSupplementaryViewProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupplementaryViewProvider(
            &self,
            supplementary_view_provider: UICollectionViewDiffableDataSourceSupplementaryViewProvider,
        );

        #[unsafe(method(snapshot))]
        #[unsafe(method_family = none)]
        pub fn snapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>>;

        #[unsafe(method(applySnapshot:animatingDifferences:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_animatingDifferences(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            animating_differences: bool,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(applySnapshot:animatingDifferences:completion:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_animatingDifferences_completion(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            animating_differences: bool,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[unsafe(method(applySnapshotUsingReloadData:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshotUsingReloadData(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(applySnapshotUsingReloadData:completion:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshotUsingReloadData_completion(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[unsafe(method(sectionIdentifierForIndex:))]
        #[unsafe(method_family = none)]
        pub fn sectionIdentifierForIndex(
            &self,
            index: NSInteger,
        ) -> Option<Retained<SectionIdentifierType>>;

        #[unsafe(method(indexForSectionIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexForSectionIdentifier(&self, identifier: &SectionIdentifierType) -> NSInteger;

        #[unsafe(method(itemIdentifierForIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifierForIndexPath(
            &self,
            index_path: &NSIndexPath,
        ) -> Option<Retained<ItemIdentifierType>>;

        #[unsafe(method(indexPathForItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexPathForItemIdentifier(
            &self,
            identifier: &ItemIdentifierType,
        ) -> Option<Retained<NSIndexPath>>;

        #[unsafe(method(reorderingHandlers))]
        #[unsafe(method_family = none)]
        pub fn reorderingHandlers(
            &self,
        ) -> Retained<
            UICollectionViewDiffableDataSourceReorderingHandlers<
                SectionIdentifierType,
                ItemIdentifierType,
            >,
        >;

        /// Setter for [`reorderingHandlers`][Self::reorderingHandlers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setReorderingHandlers:))]
        #[unsafe(method_family = none)]
        pub fn setReorderingHandlers(
            &self,
            reordering_handlers: &UICollectionViewDiffableDataSourceReorderingHandlers<
                SectionIdentifierType,
                ItemIdentifierType,
            >,
        );

        #[cfg(feature = "NSDiffableDataSourceSectionSnapshot")]
        #[unsafe(method(applySnapshot:toSection:animatingDifferences:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_toSection_animatingDifferences(
            &self,
            snapshot: &NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>,
            section_identifier: &SectionIdentifierType,
            animating_differences: bool,
        );

        #[cfg(all(feature = "NSDiffableDataSourceSectionSnapshot", feature = "block2"))]
        #[unsafe(method(applySnapshot:toSection:animatingDifferences:completion:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_toSection_animatingDifferences_completion(
            &self,
            snapshot: &NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>,
            section_identifier: &SectionIdentifierType,
            animating_differences: bool,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "NSDiffableDataSourceSectionSnapshot")]
        #[unsafe(method(snapshotForSection:))]
        #[unsafe(method_family = none)]
        pub fn snapshotForSection(
            &self,
            section: &SectionIdentifierType,
        ) -> Retained<NSDiffableDataSourceSectionSnapshot<ItemIdentifierType>>;

        #[unsafe(method(sectionSnapshotHandlers))]
        #[unsafe(method_family = none)]
        pub fn sectionSnapshotHandlers(
            &self,
        ) -> Retained<UICollectionViewDiffableDataSourceSectionSnapshotHandlers<ItemIdentifierType>>;

        /// Setter for [`sectionSnapshotHandlers`][Self::sectionSnapshotHandlers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSectionSnapshotHandlers:))]
        #[unsafe(method_family = none)]
        pub fn setSectionSnapshotHandlers(
            &self,
            section_snapshot_handlers: &UICollectionViewDiffableDataSourceSectionSnapshotHandlers<
                ItemIdentifierType,
            >,
        );
    );
}

/// A closure that configures and returns a cell for a table view from its diffable data source.
///
/// Parameters:
/// - tableView: The table view to configure this cell for.
///
/// - indexPath: The index path that specifies the location of the cell in the table view.
///
/// - itemIdentifier: The identifier of the item for this cell.
///
///
/// ## Return Value
///
/// A non-`nil` configured cell object. The cell provider must return a valid cell object to the table view.
///
///
#[cfg(all(
    feature = "UIResponder",
    feature = "UIScrollView",
    feature = "UITableView",
    feature = "UITableViewCell",
    feature = "UIView",
    feature = "block2"
))]
pub type UITableViewDiffableDataSourceCellProvider = *mut block2::DynBlock<
    dyn Fn(NonNull<UITableView>, NonNull<NSIndexPath>, NonNull<AnyObject>) -> *mut UITableViewCell,
>;

extern_class!(
    /// The object you use to manage data and provide cells for a table view.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    /// If you’re working in a Swift codebase, always use [`UITableViewDiffableDataSource`](https://developer.apple.com/documentation/uikit/uitableviewdiffabledatasource-2euir) instead.
    ///
    ///
    ///
    /// </div>
    /// A _diffable data source_ object is a specialized type of data source that works together with your table view object. It provides the behavior you need to manage updates to your table view’s data and UI in a simple, efficient way. It also conforms to the [`UITableViewDataSource`](https://developer.apple.com/documentation/uikit/uitableviewdatasource) protocol and provides implementations for all of the protocol’s methods.
    ///
    /// To fill a table view with data:
    ///
    /// 1. Connect a diffable data source to your table view.
    ///
    /// 2. Implement a cell provider to configure your table view’s cells.
    ///
    /// 3. Generate the current state of the data.
    ///
    /// 4. Display the data in the UI.
    ///
    /// To connect a diffable data source to a table view, you create the diffable data source using its [`initWithTableView:cellProvider:`](https://developer.apple.com/documentation/uikit/uitableviewdiffabledatasourcereference/init(tableview:cellprovider:)) initializer, passing in the table view you want to associate with that data source. You also pass in a cell provider, where you configure each of your cells to determine how to display your data in the UI.
    ///
    /// ```swift
    /// self.dataSource = [[UITableViewDiffableDataSource alloc] initWithTableView:self.tableView cellProvider:^UITableViewCell *(UITableView *tableView, NSIndexPath *indexPath, id itemIdentifier) {
    ///     // configure and return cell
    /// }];
    /// ```
    ///
    /// Then, you generate the current state of the data and display the data in the UI by constructing and applying a snapshot. For more information, see [`NSDiffableDataSourceSnapshot`](https://developer.apple.com/documentation/uikit/nsdiffabledatasourcesnapshotreference).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Do not change the [`dataSource`](https://developer.apple.com/documentation/uikit/uitableview/datasource) on the table view after you configure it with a diffable data source. If the table view needs a new data source after you configure it initially, create and configure a new table view and diffable data source.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITableViewDiffableDataSource<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &UITableViewDiffableDataSource<NewSectionIdentifierType, NewItemIdentifierType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

#[cfg(feature = "UITableView")]
extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
        UITableViewDataSource
        for UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    UITableViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[cfg(all(
            feature = "UIResponder",
            feature = "UIScrollView",
            feature = "UITableView",
            feature = "UITableViewCell",
            feature = "UIView",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `cell_provider` must be a valid pointer.
        #[unsafe(method(initWithTableView:cellProvider:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTableView_cellProvider(
            this: Allocated<Self>,
            table_view: &UITableView,
            cell_provider: UITableViewDiffableDataSourceCellProvider,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(snapshot))]
        #[unsafe(method_family = none)]
        pub fn snapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>>;

        #[unsafe(method(applySnapshot:animatingDifferences:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_animatingDifferences(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            animating_differences: bool,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(applySnapshot:animatingDifferences:completion:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_animatingDifferences_completion(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            animating_differences: bool,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[unsafe(method(applySnapshotUsingReloadData:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshotUsingReloadData(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(applySnapshotUsingReloadData:completion:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshotUsingReloadData_completion(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[unsafe(method(sectionIdentifierForIndex:))]
        #[unsafe(method_family = none)]
        pub fn sectionIdentifierForIndex(
            &self,
            index: NSInteger,
        ) -> Option<Retained<SectionIdentifierType>>;

        #[unsafe(method(indexForSectionIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexForSectionIdentifier(&self, identifier: &SectionIdentifierType) -> NSInteger;

        #[unsafe(method(itemIdentifierForIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifierForIndexPath(
            &self,
            index_path: &NSIndexPath,
        ) -> Option<Retained<ItemIdentifierType>>;

        #[unsafe(method(indexPathForItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexPathForItemIdentifier(
            &self,
            identifier: &ItemIdentifierType,
        ) -> Option<Retained<NSIndexPath>>;

        #[cfg(feature = "UITableView")]
        #[unsafe(method(defaultRowAnimation))]
        #[unsafe(method_family = none)]
        pub fn defaultRowAnimation(&self) -> UITableViewRowAnimation;

        #[cfg(feature = "UITableView")]
        /// Setter for [`defaultRowAnimation`][Self::defaultRowAnimation].
        #[unsafe(method(setDefaultRowAnimation:))]
        #[unsafe(method_family = none)]
        pub fn setDefaultRowAnimation(&self, default_row_animation: UITableViewRowAnimation);
    );
}
