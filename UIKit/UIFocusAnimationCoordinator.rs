//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// Information about focusing animations being performed by the system.
    ///
    /// ## Overview
    ///
    /// You don’t adopt this protocol in your custom classes. When a focus update occurs and the system provides you with a [`UIFocusAnimationCoordinator`](https://developer.apple.com/documentation/uikit/uifocusanimationcoordinator) object, you can use that object to specify custom focus-related animations. When the time comes for the system to execute your animations, it delivers an object that adopts this protocol to your animation block. The context object contains information about the system animations that you can use to configure the behavior of your own animations. For example, you might configure your animations to be exactly half the duration of the system animations.
    ///
    ///
    /// UIFocusAnimationContext is used to provide UIKit-determined context about animations that are related to a focus update.
    pub unsafe trait UIFocusAnimationContext: NSObjectProtocol + MainThreadOnly {
        /// The duration of the main animations in seconds.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        fn duration(&self) -> NSTimeInterval;
    }
);

extern_class!(
    /// A coordinator of focus-related animations during a focus update.
    ///
    /// ## Overview
    ///
    /// [`UIFocusAnimationCoordinator`](https://developer.apple.com/documentation/uikit/uifocusanimationcoordinator) instances are always created by the system and vended to your app during a focus update, and are typically discarded after the update is complete; it is not useful to instantiate [`UIFocusAnimationCoordinator`](https://developer.apple.com/documentation/uikit/uifocusanimationcoordinator) objects yourself. The `UIFocus.h` header file, including its related classes and its protocol, creates a single high-level software interface for controlling focus in apps that use focus-based input. This programming interface also helps to control focus behavior on the screen.
    ///
    /// When a focus update occurs, two main animations happen: the previously focused view animates to an unfocused state, and the next focused view animates to a focused state. The purpose of the animation coordinator is to allow other views to coordinate their animations along with the primary animations of the previously or next focused views. Every animation added to the coordinator will run together in the same animation block, with the same timing, and options.
    ///
    /// For example, suppose a user interface consists of an focusable image with a title underneath. When the image is focused, it will animate expanding its size to a larger, focused state, so it schedules an animation using the [`UIFocusAnimationCoordinator`](https://developer.apple.com/documentation/uikit/uifocusanimationcoordinator) instance provided during the focus update. Since the image is expanding, the title should also animate its position to stay a fixed length from the expanding bottom edge of the image, so it also schedules this animation using the coordinator. Since both animations were scheduled using the coordinator, they will be run together at the end of the update to ensure they are correctly synchronized.
    ///
    /// It is important to schedule animations using [`UIFocusAnimationCoordinator`](https://developer.apple.com/documentation/uikit/uifocusanimationcoordinator) because the properties of the animation are defined by the system to achieve certain system-level behaviors. For example, when focus is moving quickly, the timing of the animations are sped up to keep up with the user’s movement. In addition, _focusing_ animations typically run faster than _unfocusing_ animations, to create a trail effect as the user moves. As such, you should never assume a fixed duration across multiple focus updates, nor should you that timing of animations for different views in different branches of the view hierarchy is the same.
    ///
    /// If you need more control over the timing of focus-related animations, you can add a nested animation block inside the coordinated animation. This follows all the same rules as regular nested animations, meaning that the animation duration and properties are inherited. Use [`UIViewAnimationOptions`](https://developer.apple.com/documentation/uikit/uiview/animationoptions)– set of options- to edit as necessary. If you want to change the timing of the animation, it is recommended that you specify a duration relative to the inherited duration in [`inheritedAnimationDuration`](https://developer.apple.com/documentation/uikit/uiview/inheritedanimationduration) method, so that your application still benefits from the timing behaviors.
    ///
    /// For example, in the below code listing it shows how to add a coordinated animation that should run at half the system-defined duration:
    ///
    /// ```objc
    ///  override func didUpdateFocusInContext(context: UIFocusUpdateContext, withAnimationCoordinator coordinator: UIFocusAnimationCoordinator) {
    ///  coordinator.addCoordinatedAnimations({
    ///             let duration : NSTimeInterval = UIView.inheritedAnimationDuration();
    ///             UIView.animateWithDuration((0.5*duration), delay: 0.0, options: UIViewAnimationOptions.OverrideInheritedDuration, animations: {
    ///                 //add your animations
    ///                 }, completion: nil)
    ///             }, completion: nil)
    /// ```
    ///
    /// However, if you nest animations with different durations, note that the completion block of the [`addCoordinatedAnimations:completion:`](https://developer.apple.com/documentation/uikit/uifocusanimationcoordinator/addcoordinatedanimations(_:completion:)) method is run only after the main (inherited) animation is complete.
    ///
    ///
    /// UIFocusAnimationCoordinator is used to coordinate disparate animations that are related to a focus update.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIFocusAnimationCoordinator;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UIFocusAnimationCoordinator {}
);

impl UIFocusAnimationCoordinator {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Specifies focus-related animations that should be coordinated with the animations of the focusing or un-focusing view.
        ///
        /// Any animations specified will be run in the same animation context as the main animation. The completion block is invoked after the main animation completes.
        /// (Note that this may not be after all the coordinated animations specified by the call complete if the duration is not inherited.)
        ///
        /// It is perfectly legitimate to only specify a completion block.
        #[unsafe(method(addCoordinatedAnimations:completion:))]
        #[unsafe(method_family = none)]
        pub fn addCoordinatedAnimations_completion(
            &self,
            animations: Option<&block2::DynBlock<dyn Fn()>>,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        /// Specifies focus-related animations that should be coordinated with the animations of the focusing item.
        ///
        /// Any animations specified will be run in the same animation context as the main animation. The completion block is invoked after the UIKit-defined animations complete.
        ///
        /// It is perfectly legitimate to only specify a completion block.
        ///
        /// A context object is provided in the animation block with details of the UIKit-defined animations being run for the focusing item.
        #[unsafe(method(addCoordinatedFocusingAnimations:completion:))]
        #[unsafe(method_family = none)]
        pub fn addCoordinatedFocusingAnimations_completion(
            &self,
            animations: Option<
                &block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn UIFocusAnimationContext>>)>,
            >,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        /// Specifies focus-related animations that should be coordinated with the animations of the un-focusing item.
        ///
        /// Any animations specified will be run in the same animation context as the main animation. The completion block is invoked after the UIKit-defined animations complete.
        ///
        /// It is perfectly legitimate to only specify a completion block.
        ///
        /// A context object is provided in the animation block with details of the UIKit-defined animations being run for the un-focusing item.
        #[unsafe(method(addCoordinatedUnfocusingAnimations:completion:))]
        #[unsafe(method_family = none)]
        pub fn addCoordinatedUnfocusingAnimations_completion(
            &self,
            animations: Option<
                &block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn UIFocusAnimationContext>>)>,
            >,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl UIFocusAnimationCoordinator {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
