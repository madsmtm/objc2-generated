//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontextfromviewcontrollerkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextFromViewControllerKey:
        &'static UITransitionContextViewControllerKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontexttoviewcontrollerkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextToViewControllerKey:
        &'static UITransitionContextViewControllerKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontextfromviewkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextFromViewKey: &'static UITransitionContextViewKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitransitioncontexttoviewkey?language=objc)
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextToViewKey: &'static UITransitionContextViewKey;
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning?language=objc)
    pub unsafe trait UIViewControllerContextTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(containerView))]
        #[unsafe(method_family = none)]
        fn containerView(&self) -> Retained<UIView>;

        #[unsafe(method(isAnimated))]
        #[unsafe(method_family = none)]
        fn isAnimated(&self) -> bool;

        #[unsafe(method(isInteractive))]
        #[unsafe(method_family = none)]
        fn isInteractive(&self) -> bool;

        #[unsafe(method(transitionWasCancelled))]
        #[unsafe(method_family = none)]
        fn transitionWasCancelled(&self) -> bool;

        #[cfg(feature = "UIViewController")]
        #[unsafe(method(presentationStyle))]
        #[unsafe(method_family = none)]
        fn presentationStyle(&self) -> UIModalPresentationStyle;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(updateInteractiveTransition:))]
        #[unsafe(method_family = none)]
        fn updateInteractiveTransition(&self, percent_complete: CGFloat);

        #[unsafe(method(finishInteractiveTransition))]
        #[unsafe(method_family = none)]
        fn finishInteractiveTransition(&self);

        #[unsafe(method(cancelInteractiveTransition))]
        #[unsafe(method_family = none)]
        fn cancelInteractiveTransition(&self);

        #[unsafe(method(pauseInteractiveTransition))]
        #[unsafe(method_family = none)]
        fn pauseInteractiveTransition(&self);

        #[unsafe(method(completeTransition:))]
        #[unsafe(method_family = none)]
        fn completeTransition(&self, did_complete: bool);

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[unsafe(method(viewControllerForKey:))]
        #[unsafe(method_family = none)]
        fn viewControllerForKey(
            &self,
            key: &UITransitionContextViewControllerKey,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIView",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[unsafe(method(viewForKey:))]
        #[unsafe(method_family = none)]
        fn viewForKey(&self, key: &UITransitionContextViewKey) -> Option<Retained<UIView>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(targetTransform))]
        #[unsafe(method_family = none)]
        fn targetTransform(&self) -> CGAffineTransform;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(initialFrameForViewController:))]
        #[unsafe(method_family = none)]
        fn initialFrameForViewController(&self, vc: &UIViewController) -> CGRect;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(finalFrameForViewController:))]
        #[unsafe(method_family = none)]
        fn finalFrameForViewController(&self, vc: &UIViewController) -> CGRect;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning?language=objc)
    pub unsafe trait UIViewControllerAnimatedTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(transitionDuration:))]
        #[unsafe(method_family = none)]
        fn transitionDuration(
            &self,
            transition_context: Option<&ProtocolObject<dyn UIViewControllerContextTransitioning>>,
        ) -> NSTimeInterval;

        #[unsafe(method(animateTransition:))]
        #[unsafe(method_family = none)]
        fn animateTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        );

        #[cfg(feature = "UIViewAnimating")]
        /// A conforming object implements this method if the transition it creates can
        /// be interrupted. For example, it could return an instance of a
        /// UIViewPropertyAnimator. It is expected that this method will return the same
        /// instance for the life of a transition.
        #[optional]
        #[unsafe(method(interruptibleAnimatorForTransition:))]
        #[unsafe(method_family = none)]
        fn interruptibleAnimatorForTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        ) -> Retained<ProtocolObject<dyn UIViewImplicitlyAnimating>>;

        #[optional]
        #[unsafe(method(animationEnded:))]
        #[unsafe(method_family = none)]
        fn animationEnded(&self, transition_completed: bool);
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning?language=objc)
    pub unsafe trait UIViewControllerInteractiveTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(startInteractiveTransition:))]
        #[unsafe(method_family = none)]
        fn startInteractiveTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(completionSpeed))]
        #[unsafe(method_family = none)]
        fn completionSpeed(&self) -> CGFloat;

        #[cfg(feature = "UIView")]
        #[optional]
        #[unsafe(method(completionCurve))]
        #[unsafe(method_family = none)]
        fn completionCurve(&self) -> UIViewAnimationCurve;

        /// In 10.0, if an object conforming to UIViewControllerAnimatedTransitioning is
        /// known to be interruptible, it is possible to start it as if it was not
        /// interactive and then interrupt the transition and interact with it. In this
        /// case, implement this method and return NO. If an interactor does not
        /// implement this method, YES is assumed.
        #[optional]
        #[unsafe(method(wantsInteractiveStart))]
        #[unsafe(method_family = none)]
        fn wantsInteractiveStart(&self) -> bool;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioningdelegate?language=objc)
    pub unsafe trait UIViewControllerTransitioningDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(animationControllerForPresentedController:presentingController:sourceController:))]
        #[unsafe(method_family = none)]
        fn animationControllerForPresentedController_presentingController_sourceController(
            &self,
            presented: &UIViewController,
            presenting: &UIViewController,
            source: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(animationControllerForDismissedController:))]
        #[unsafe(method_family = none)]
        fn animationControllerForDismissedController(
            &self,
            dismissed: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;

        #[optional]
        #[unsafe(method(interactionControllerForPresentation:))]
        #[unsafe(method_family = none)]
        fn interactionControllerForPresentation(
            &self,
            animator: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[optional]
        #[unsafe(method(interactionControllerForDismissal:))]
        #[unsafe(method_family = none)]
        fn interactionControllerForDismissal(
            &self,
            animator: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[cfg(all(
            feature = "UIPresentationController",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[unsafe(method(presentationControllerForPresentedViewController:presentingViewController:sourceViewController:))]
        #[unsafe(method_family = none)]
        fn presentationControllerForPresentedViewController_presentingViewController_sourceViewController(
            &self,
            presented: &UIViewController,
            presenting: Option<&UIViewController>,
            source: &UIViewController,
        ) -> Option<Retained<UIPresentationController>>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uipercentdriveninteractivetransition?language=objc)
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIPercentDrivenInteractiveTransition;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UIPercentDrivenInteractiveTransition {}
);

extern_conformance!(
    unsafe impl UIViewControllerInteractiveTransitioning for UIPercentDrivenInteractiveTransition {}
);

impl UIPercentDrivenInteractiveTransition {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// This is the non-interactive duration that was returned when the
        /// animators transitionDuration: method was called when the transition started.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub fn duration(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// The last percentComplete value specified by updateInteractiveTransition:
        #[unsafe(method(percentComplete))]
        #[unsafe(method_family = none)]
        pub fn percentComplete(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// completionSpeed defaults to 1.0 which corresponds to a completion duration of
        /// (1 - percentComplete)*duration.  It must be greater than 0.0. The actual
        /// completion is inversely proportional to the completionSpeed.  This can be set
        /// before cancelInteractiveTransition or finishInteractiveTransition is called
        /// in order to speed up or slow down the non interactive part of the
        /// transition.
        #[unsafe(method(completionSpeed))]
        #[unsafe(method_family = none)]
        pub fn completionSpeed(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`completionSpeed`][Self::completionSpeed].
        #[unsafe(method(setCompletionSpeed:))]
        #[unsafe(method_family = none)]
        pub fn setCompletionSpeed(&self, completion_speed: CGFloat);

        #[cfg(feature = "UIView")]
        /// When the interactive part of the transition has completed, this property can
        /// be set to indicate a different animation curve. It defaults to UIViewAnimationCurveEaseInOut.
        /// Note that during the interactive portion of the animation the timing curve is linear.
        #[unsafe(method(completionCurve))]
        #[unsafe(method_family = none)]
        pub fn completionCurve(&self) -> UIViewAnimationCurve;

        #[cfg(feature = "UIView")]
        /// Setter for [`completionCurve`][Self::completionCurve].
        #[unsafe(method(setCompletionCurve:))]
        #[unsafe(method_family = none)]
        pub fn setCompletionCurve(&self, completion_curve: UIViewAnimationCurve);

        #[cfg(feature = "UITimingCurveProvider")]
        /// For an interruptible animator, one can specify a different timing curve provider to use when the
        /// transition is continued. This property is ignored if the animated transitioning object does not
        /// vend an interruptible animator.
        #[unsafe(method(timingCurve))]
        #[unsafe(method_family = none)]
        pub fn timingCurve(&self) -> Option<Retained<ProtocolObject<dyn UITimingCurveProvider>>>;

        #[cfg(feature = "UITimingCurveProvider")]
        /// Setter for [`timingCurve`][Self::timingCurve].
        #[unsafe(method(setTimingCurve:))]
        #[unsafe(method_family = none)]
        pub fn setTimingCurve(
            &self,
            timing_curve: Option<&ProtocolObject<dyn UITimingCurveProvider>>,
        );

        /// Set this to NO in order to start an interruptible transition non
        /// interactively. By default this is YES, which is consistent with the behavior
        /// before 10.0.
        #[unsafe(method(wantsInteractiveStart))]
        #[unsafe(method_family = none)]
        pub fn wantsInteractiveStart(&self) -> bool;

        /// Setter for [`wantsInteractiveStart`][Self::wantsInteractiveStart].
        #[unsafe(method(setWantsInteractiveStart:))]
        #[unsafe(method_family = none)]
        pub fn setWantsInteractiveStart(&self, wants_interactive_start: bool);

        /// Use this method to pause a running interruptible animator. This will ensure that all blocks
        /// provided by a transition coordinator's notifyWhenInteractionChangesUsingBlock: method
        /// are executed when a transition moves in and out of an interactive mode.
        #[unsafe(method(pauseInteractiveTransition))]
        #[unsafe(method_family = none)]
        pub fn pauseInteractiveTransition(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(updateInteractiveTransition:))]
        #[unsafe(method_family = none)]
        pub fn updateInteractiveTransition(&self, percent_complete: CGFloat);

        #[unsafe(method(cancelInteractiveTransition))]
        #[unsafe(method_family = none)]
        pub fn cancelInteractiveTransition(&self);

        #[unsafe(method(finishInteractiveTransition))]
        #[unsafe(method_family = none)]
        pub fn finishInteractiveTransition(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl UIPercentDrivenInteractiveTransition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
