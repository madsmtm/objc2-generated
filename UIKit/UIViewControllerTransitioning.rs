//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// A key that identifies the view controller that’s visible at the beginning of the transition, or at the end of a canceled transition.
    ///
    /// ## Discussion
    ///
    /// This view controller is typically the one presenting the “to” view controller or is the one being replaced by the “to” view controller.
    ///
    ///
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextFromViewControllerKey:
        &'static UITransitionContextViewControllerKey;
}

extern "C" {
    /// A key that identifies the view controller that’s visible at the end of a completed transition.
    ///
    /// ## Discussion
    ///
    /// This view controller is the one being presented.
    ///
    ///
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextToViewControllerKey:
        &'static UITransitionContextViewControllerKey;
}

extern "C" {
    /// A key that identifies the view shown at the beginning of the transition, or at the end of a canceled transition.
    ///
    /// ## Discussion
    ///
    /// This view is typically the presenting view controller’s view.
    ///
    ///
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextFromViewKey: &'static UITransitionContextViewKey;
}

extern "C" {
    /// A key that identifies the view shown at the end of a completed transition.
    ///
    /// ## Discussion
    ///
    /// This view is typically the presented view controller’s view but may also be an ancestor of that view.
    ///
    ///
    #[cfg(feature = "UIViewControllerTransitionCoordinator")]
    pub static UITransitionContextToViewKey: &'static UITransitionContextViewKey;
}

extern_protocol!(
    /// A set of methods that provide contextual information for transition animations between view controllers.
    ///
    /// ## Overview
    ///
    /// Don’t adopt this protocol in your own classes, nor should you directly create objects that adopt this protocol. During a transition, the animator objects involved in that transition receive a fully configured context object from UIKit. Custom animator objects — objects that adopt the [`UIViewControllerAnimatedTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning) or [`UIViewControllerInteractiveTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning) protocol — should simply retrieve the information they need from the provided object.
    ///
    /// A context object encapsulates information about the views and view controllers involved in the transition. It also contains details about the how to execute the transition. For interactive transitions, the interactive animator object uses the methods of this protocol to report the animation’s progress. When the animation starts, the interactive animator object must save a pointer to the context object. Based on user interactions, the animator object then calls the [`updateInteractiveTransition:`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning/updateinteractivetransition(_:)), [`finishInteractiveTransition`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning/finishinteractivetransition()), or [`cancelInteractiveTransition`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning/cancelinteractivetransition()) methods to report the progress toward completing the animation. Those methods send that information to UIKit so that it can drive the timing of the animations.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  When defining custom animator objects, always check the value returned by the [`animated`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning/isanimated) method to determine whether you should create animations at all. And when you do create transition animations, always call the [`completeTransition:`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning/completetransition(_:)) method from an appropriate completion block to let UIKit know when all of your animations have finished.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait UIViewControllerContextTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(containerView))]
        #[unsafe(method_family = none)]
        fn containerView(&self) -> Retained<UIView>;

        #[unsafe(method(isAnimated))]
        #[unsafe(method_family = none)]
        fn isAnimated(&self) -> bool;

        #[unsafe(method(isInteractive))]
        #[unsafe(method_family = none)]
        fn isInteractive(&self) -> bool;

        #[unsafe(method(transitionWasCancelled))]
        #[unsafe(method_family = none)]
        fn transitionWasCancelled(&self) -> bool;

        #[cfg(feature = "UIViewController")]
        #[unsafe(method(presentationStyle))]
        #[unsafe(method_family = none)]
        fn presentationStyle(&self) -> UIModalPresentationStyle;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(updateInteractiveTransition:))]
        #[unsafe(method_family = none)]
        fn updateInteractiveTransition(&self, percent_complete: CGFloat);

        #[unsafe(method(finishInteractiveTransition))]
        #[unsafe(method_family = none)]
        fn finishInteractiveTransition(&self);

        #[unsafe(method(cancelInteractiveTransition))]
        #[unsafe(method_family = none)]
        fn cancelInteractiveTransition(&self);

        #[unsafe(method(pauseInteractiveTransition))]
        #[unsafe(method_family = none)]
        fn pauseInteractiveTransition(&self);

        #[unsafe(method(completeTransition:))]
        #[unsafe(method_family = none)]
        fn completeTransition(&self, did_complete: bool);

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[unsafe(method(viewControllerForKey:))]
        #[unsafe(method_family = none)]
        fn viewControllerForKey(
            &self,
            key: &UITransitionContextViewControllerKey,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIView",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[unsafe(method(viewForKey:))]
        #[unsafe(method_family = none)]
        fn viewForKey(&self, key: &UITransitionContextViewKey) -> Option<Retained<UIView>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(targetTransform))]
        #[unsafe(method_family = none)]
        fn targetTransform(&self) -> CGAffineTransform;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(initialFrameForViewController:))]
        #[unsafe(method_family = none)]
        fn initialFrameForViewController(&self, vc: &UIViewController) -> CGRect;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIViewController",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(finalFrameForViewController:))]
        #[unsafe(method_family = none)]
        fn finalFrameForViewController(&self, vc: &UIViewController) -> CGRect;
    }
);

extern_protocol!(
    /// A set of methods for implementing the animations for a custom view controller transition.
    ///
    /// ## Overview
    ///
    /// The methods in this protocol let you define an animator object, which creates the animations for transitioning a view controller on or off screen in a fixed amount of time. The animations you create using this protocol must not be interactive. To create interactive transitions, you must combine your animator object with another object that controls the timing of your animations.
    ///
    /// In your animator object, implement the [`transitionDuration:`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning/transitionduration(using:)) method to specify the duration of your transition and implement the [`animateTransition:`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning/animatetransition(using:)) method to create the animations themselves. Information about the objects involved in the transition is passed to your [`animateTransition:`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning/animatetransition(using:)) method in the form of a context object. Use the information provided by that object to move the target view controller’s view on or off screen over the specified duration.
    ///
    /// Create your animator object from a transitioning delegate — an object that conforms to the [`UIViewControllerTransitioningDelegate`](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioningdelegate) protocol. When presenting a view controller, set the presentation style to [`UIModalPresentationCustom`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/custom) and assign your transitioning delegate to the view controller’s [`transitioningDelegate`](https://developer.apple.com/documentation/uikit/uiviewcontroller/transitioningdelegate) property. The view controller retrieves your animator object from the transitioning delegate and uses it to perform the animations. You can provide separate animator objects for presenting and dismissing the view controller.
    ///
    /// To add user interaction to a view controller transition, you must use an animator object together with an _interactive animator object_** **— a custom object that adopts the [`UIViewControllerInteractiveTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning) protocol. For more on defining interactive transitions, see [`UIViewControllerInteractiveTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning).
    ///
    ///
    pub unsafe trait UIViewControllerAnimatedTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(transitionDuration:))]
        #[unsafe(method_family = none)]
        fn transitionDuration(
            &self,
            transition_context: Option<&ProtocolObject<dyn UIViewControllerContextTransitioning>>,
        ) -> NSTimeInterval;

        #[unsafe(method(animateTransition:))]
        #[unsafe(method_family = none)]
        fn animateTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        );

        #[cfg(feature = "UIViewAnimating")]
        /// A conforming object implements this method if the transition it creates can
        /// be interrupted. For example, it could return an instance of a
        /// UIViewPropertyAnimator. It is expected that this method will return the same
        /// instance for the life of a transition.
        #[optional]
        #[unsafe(method(interruptibleAnimatorForTransition:))]
        #[unsafe(method_family = none)]
        fn interruptibleAnimatorForTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        ) -> Retained<ProtocolObject<dyn UIViewImplicitlyAnimating>>;

        #[optional]
        #[unsafe(method(animationEnded:))]
        #[unsafe(method_family = none)]
        fn animationEnded(&self, transition_completed: bool);
    }
);

extern_protocol!(
    /// A set of methods that enable an object (such as a navigation controller) to drive a view controller transition.
    ///
    /// ## Overview
    ///
    /// An _interactive transition delegate_ (which is the term for an object that supports this protocol) can respond to touch events, or to time-varying programmatic input, by speeding up, slowing down, or even reversing the progress of a view controller transition. For example, an interactive transition on a navigation controller could respond to a swipe gesture by moving a view controller onto or off of the navigation stack.
    ///
    /// To support an interactive view controller transition, you must also provide a transition animator delegate, which is a custom object that adopts the [`UIViewControllerAnimatedTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning) protocol. The transition delegate and the transition animator can, if you wish, be defined within a single custom class, but the class must adopt both protocols.
    ///
    /// If you instead want to provide a fixed-duration animated view controller transition — one that doesn’t support user interaction — use a transition animator delegate on its own. Refer to [`UIViewControllerAnimatedTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning).
    ///
    /// For the methods you can call to retrieve view transition context information from within your [`startInteractiveTransition:`](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning/startinteractivetransition(_:)) method, refer to [`UIViewControllerContextTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrollercontexttransitioning).
    ///
    ///
    pub unsafe trait UIViewControllerInteractiveTransitioning:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(startInteractiveTransition:))]
        #[unsafe(method_family = none)]
        fn startInteractiveTransition(
            &self,
            transition_context: &ProtocolObject<dyn UIViewControllerContextTransitioning>,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(completionSpeed))]
        #[unsafe(method_family = none)]
        fn completionSpeed(&self) -> CGFloat;

        #[cfg(feature = "UIView")]
        #[optional]
        #[unsafe(method(completionCurve))]
        #[unsafe(method_family = none)]
        fn completionCurve(&self) -> UIViewAnimationCurve;

        /// In 10.0, if an object conforming to UIViewControllerAnimatedTransitioning is
        /// known to be interruptible, it is possible to start it as if it was not
        /// interactive and then interrupt the transition and interact with it. In this
        /// case, implement this method and return NO. If an interactor does not
        /// implement this method, YES is assumed.
        #[optional]
        #[unsafe(method(wantsInteractiveStart))]
        #[unsafe(method_family = none)]
        fn wantsInteractiveStart(&self) -> bool;
    }
);

extern_protocol!(
    /// A set of methods that vend objects used to manage a fixed-length or interactive transition between view controllers.
    ///
    /// ## Overview
    ///
    /// When you want to present a view controller using a custom modal presentation type, set its [`modalPresentationStyle`](https://developer.apple.com/documentation/uikit/uiviewcontroller/modalpresentationstyle) property to `custom` and assign an object that conforms to this protocol to its [`transitioningDelegate`](https://developer.apple.com/documentation/uikit/uiviewcontroller/transitioningdelegate) property. When you present that view controller, UIKit queries your transitioning delegate for the objects to use when animating the view controller into position.
    ///
    /// When implementing your transitioning delegate object, you can return different animator objects depending on whether a view controller is being presented or dismissed. All transitions use a _transition animator object_—an object that conforms to the [`UIViewControllerAnimatedTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning) protocol—to implement the basic animations. A transition animator object performs a set of animations over a finite period of time. If you want to use touch input or other user interactions to control the timing of the animation, you can also provide an _interactive animator object_—an object that conforms to the [`UIViewControllerInteractiveTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrollerinteractivetransitioning) protocol—to update the progress of the animations. You can provide separate animator objects for presenting and dismissing the view controller.
    ///
    /// For custom modal transition styles, you can provide a [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller) object in addition to the animator objects. The system creates your presentation controller before presenting the view controller and keeps a reference to that object until the view controller is dismissed. Because its existence extends beyond the lifespan of either animator object, you can use the presentation controller to coordinate aspects of the presentation or dismissal process that would be difficult to do otherwise. For example, if your custom transition style involves displaying a separate shadow view as a backdrop to the view controller’s content, the presentation controller can create the shadow view and show it and hide it at the appropriate times.
    ///
    ///
    pub unsafe trait UIViewControllerTransitioningDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(animationControllerForPresentedController:presentingController:sourceController:))]
        #[unsafe(method_family = none)]
        fn animationControllerForPresentedController_presentingController_sourceController(
            &self,
            presented: &UIViewController,
            presenting: &UIViewController,
            source: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(animationControllerForDismissedController:))]
        #[unsafe(method_family = none)]
        fn animationControllerForDismissedController(
            &self,
            dismissed: &UIViewController,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerAnimatedTransitioning>>>;

        #[optional]
        #[unsafe(method(interactionControllerForPresentation:))]
        #[unsafe(method_family = none)]
        fn interactionControllerForPresentation(
            &self,
            animator: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[optional]
        #[unsafe(method(interactionControllerForDismissal:))]
        #[unsafe(method_family = none)]
        fn interactionControllerForDismissal(
            &self,
            animator: &ProtocolObject<dyn UIViewControllerAnimatedTransitioning>,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerInteractiveTransitioning>>>;

        #[cfg(all(
            feature = "UIPresentationController",
            feature = "UIResponder",
            feature = "UIViewController"
        ))]
        #[optional]
        #[unsafe(method(presentationControllerForPresentedViewController:presentingViewController:sourceViewController:))]
        #[unsafe(method_family = none)]
        fn presentationControllerForPresentedViewController_presentingViewController_sourceViewController(
            &self,
            presented: &UIViewController,
            presenting: Option<&UIViewController>,
            source: &UIViewController,
        ) -> Option<Retained<UIPresentationController>>;
    }
);

extern_class!(
    /// An object that drives an interactive animation between one view controller and another.
    ///
    /// ## Overview
    ///
    /// A percent-driven interactive transition object relies on a transition animator delegate—a custom object that adopts the [`UIViewControllerAnimatedTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning) protocol—to set up and perform the animations.
    ///
    /// To use this concrete class, return an instance of it from your view controller delegate when asked for an interactive transition controller. As user events arrive that would affect the progress of a transition, call the [`updateInteractiveTransition:`](https://developer.apple.com/documentation/uikit/uipercentdriveninteractivetransition/update(_:)), [`cancelInteractiveTransition`](https://developer.apple.com/documentation/uikit/uipercentdriveninteractivetransition/cancel()), and [`finishInteractiveTransition`](https://developer.apple.com/documentation/uikit/uipercentdriveninteractivetransition/finish()) methods to reflect the current progress. For example, you might call these methods from a gesture recognizer to reflect how much of the gesture is completed.
    ///
    /// You can subclass [`UIPercentDrivenInteractiveTransition`](https://developer.apple.com/documentation/uikit/uipercentdriveninteractivetransition), but if you do so you must start each of your method overrides with a call to the `super` implementation of the method.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIPercentDrivenInteractiveTransition;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UIPercentDrivenInteractiveTransition {}
);

extern_conformance!(
    unsafe impl UIViewControllerInteractiveTransitioning for UIPercentDrivenInteractiveTransition {}
);

impl UIPercentDrivenInteractiveTransition {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// This is the non-interactive duration that was returned when the
        /// animators transitionDuration: method was called when the transition started.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub fn duration(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// The last percentComplete value specified by updateInteractiveTransition:
        #[unsafe(method(percentComplete))]
        #[unsafe(method_family = none)]
        pub fn percentComplete(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// completionSpeed defaults to 1.0 which corresponds to a completion duration of
        /// (1 - percentComplete)*duration.  It must be greater than 0.0. The actual
        /// completion is inversely proportional to the completionSpeed.  This can be set
        /// before cancelInteractiveTransition or finishInteractiveTransition is called
        /// in order to speed up or slow down the non interactive part of the
        /// transition.
        #[unsafe(method(completionSpeed))]
        #[unsafe(method_family = none)]
        pub fn completionSpeed(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`completionSpeed`][Self::completionSpeed].
        #[unsafe(method(setCompletionSpeed:))]
        #[unsafe(method_family = none)]
        pub fn setCompletionSpeed(&self, completion_speed: CGFloat);

        #[cfg(feature = "UIView")]
        /// When the interactive part of the transition has completed, this property can
        /// be set to indicate a different animation curve. It defaults to UIViewAnimationCurveEaseInOut.
        /// Note that during the interactive portion of the animation the timing curve is linear.
        #[unsafe(method(completionCurve))]
        #[unsafe(method_family = none)]
        pub fn completionCurve(&self) -> UIViewAnimationCurve;

        #[cfg(feature = "UIView")]
        /// Setter for [`completionCurve`][Self::completionCurve].
        #[unsafe(method(setCompletionCurve:))]
        #[unsafe(method_family = none)]
        pub fn setCompletionCurve(&self, completion_curve: UIViewAnimationCurve);

        #[cfg(feature = "UITimingCurveProvider")]
        /// For an interruptible animator, one can specify a different timing curve provider to use when the
        /// transition is continued. This property is ignored if the animated transitioning object does not
        /// vend an interruptible animator.
        #[unsafe(method(timingCurve))]
        #[unsafe(method_family = none)]
        pub fn timingCurve(&self) -> Option<Retained<ProtocolObject<dyn UITimingCurveProvider>>>;

        #[cfg(feature = "UITimingCurveProvider")]
        /// Setter for [`timingCurve`][Self::timingCurve].
        #[unsafe(method(setTimingCurve:))]
        #[unsafe(method_family = none)]
        pub fn setTimingCurve(
            &self,
            timing_curve: Option<&ProtocolObject<dyn UITimingCurveProvider>>,
        );

        /// Set this to NO in order to start an interruptible transition non
        /// interactively. By default this is YES, which is consistent with the behavior
        /// before 10.0.
        #[unsafe(method(wantsInteractiveStart))]
        #[unsafe(method_family = none)]
        pub fn wantsInteractiveStart(&self) -> bool;

        /// Setter for [`wantsInteractiveStart`][Self::wantsInteractiveStart].
        #[unsafe(method(setWantsInteractiveStart:))]
        #[unsafe(method_family = none)]
        pub fn setWantsInteractiveStart(&self, wants_interactive_start: bool);

        /// Use this method to pause a running interruptible animator. This will ensure that all blocks
        /// provided by a transition coordinator's notifyWhenInteractionChangesUsingBlock: method
        /// are executed when a transition moves in and out of an interactive mode.
        #[unsafe(method(pauseInteractiveTransition))]
        #[unsafe(method_family = none)]
        pub fn pauseInteractiveTransition(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(updateInteractiveTransition:))]
        #[unsafe(method_family = none)]
        pub fn updateInteractiveTransition(&self, percent_complete: CGFloat);

        #[unsafe(method(cancelInteractiveTransition))]
        #[unsafe(method_family = none)]
        pub fn cancelInteractiveTransition(&self);

        #[unsafe(method(finishInteractiveTransition))]
        #[unsafe(method_family = none)]
        pub fn finishInteractiveTransition(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl UIPercentDrivenInteractiveTransition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
