//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
use objc2_quartz_core::*;

use crate::*;

extern "C" {
    /// A constant that specifies a default value for a particular dimension.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UICollectionViewLayoutAutomaticDimension: CGFloat;
}

extern "C" {
    /// A supplementary view that identifies the header for a given section.
    pub static UICollectionElementKindSectionHeader: &'static NSString;
}

extern "C" {
    /// A supplementary view that identifies the footer for a given section.
    pub static UICollectionElementKindSectionFooter: &'static NSString;
}

/// Constants that indicate the direction of scrolling for the layout.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UICollectionViewScrollDirection(pub NSInteger);
impl UICollectionViewScrollDirection {
    /// The layout scrolls content vertically.
    #[doc(alias = "UICollectionViewScrollDirectionVertical")]
    pub const Vertical: Self = Self(0);
    /// The layout scrolls content horizontally.
    #[doc(alias = "UICollectionViewScrollDirectionHorizontal")]
    pub const Horizontal: Self = Self(1);
}

unsafe impl Encode for UICollectionViewScrollDirection {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UICollectionViewScrollDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants specifying the type of view.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UICollectionElementCategory(pub NSUInteger);
impl UICollectionElementCategory {
    /// The view is a cell.
    #[doc(alias = "UICollectionElementCategoryCell")]
    pub const Cell: Self = Self(0);
    /// The view is a supplementary view.
    #[doc(alias = "UICollectionElementCategorySupplementaryView")]
    pub const SupplementaryView: Self = Self(1);
    /// The view is a decoration view.
    #[doc(alias = "UICollectionElementCategoryDecorationView")]
    pub const DecorationView: Self = Self(2);
}

unsafe impl Encode for UICollectionElementCategory {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UICollectionElementCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A layout object that manages the layout-related attributes for a given item in a collection view.
    ///
    /// ## Overview
    ///
    /// Layout objects create instances of this class when asked to do so by the collection view. In turn, the collection view uses the layout information to position cells and supplementary views inside its bounds.
    ///
    /// ### Subclassing notes
    ///
    /// In most cases, you use this class as-is. If you want to supplement the base layout attributes with custom layout attributes, you can subclass and define whatever properties you want to store the additional layout data. Because layout attribute objects may be copied by the collection view, make sure your subclass conforms to the [`NSCopying`](https://developer.apple.com/documentation/foundation/nscopying) protocol by implementing any methods appropriate for copying your custom attributes to new instances of your subclass. In addition to defining your subclass, your [`UICollectionReusableView`](https://developer.apple.com/documentation/uikit/uicollectionreusableview) objects need to implement the [`applyLayoutAttributes:`](https://developer.apple.com/documentation/uikit/uicollectionreusableview/apply(_:)) method so that they can apply any custom attributes at layout time.
    ///
    /// If you subclass and implement any custom layout attributes, you must also override the inherited `isEqual:` method to compare the values of your properties. In iOS 7 and later, the collection view doesn’t apply layout attributes if those attributes have not changed. It determines whether the attributes have changed by comparing the old and new attribute objects using the `isEqual:` method. Because the default implementation of this method checks only the existing properties of this class, you must implement your own version of the method to compare any additional properties. If your custom properties are all equal, call `super` and return the resulting value at the end of your implementation.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewLayoutAttributes;
);

extern_conformance!(
    unsafe impl NSCopying for UICollectionViewLayoutAttributes {}
);

unsafe impl CopyingHelper for UICollectionViewLayoutAttributes {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionViewLayoutAttributes {}
);

#[cfg(feature = "UIDynamicBehavior")]
extern_conformance!(
    unsafe impl UIDynamicItem for UICollectionViewLayoutAttributes {}
);

impl UICollectionViewLayoutAttributes {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        pub fn frame(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`frame`][Self::frame].
        #[unsafe(method(setFrame:))]
        #[unsafe(method_family = none)]
        pub fn setFrame(&self, frame: CGRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(center))]
        #[unsafe(method_family = none)]
        pub fn center(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`center`][Self::center].
        #[unsafe(method(setCenter:))]
        #[unsafe(method_family = none)]
        pub fn setCenter(&self, center: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(size))]
        #[unsafe(method_family = none)]
        pub fn size(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`size`][Self::size].
        #[unsafe(method(setSize:))]
        #[unsafe(method_family = none)]
        pub fn setSize(&self, size: CGSize);

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(transform3D))]
        #[unsafe(method_family = none)]
        pub fn transform3D(&self) -> CATransform3D;

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`transform3D`][Self::transform3D].
        #[unsafe(method(setTransform3D:))]
        #[unsafe(method_family = none)]
        pub fn setTransform3D(&self, transform3_d: CATransform3D);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(bounds))]
        #[unsafe(method_family = none)]
        pub fn bounds(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`bounds`][Self::bounds].
        #[unsafe(method(setBounds:))]
        #[unsafe(method_family = none)]
        pub fn setBounds(&self, bounds: CGRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(transform))]
        #[unsafe(method_family = none)]
        pub fn transform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`transform`][Self::transform].
        #[unsafe(method(setTransform:))]
        #[unsafe(method_family = none)]
        pub fn setTransform(&self, transform: CGAffineTransform);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(alpha))]
        #[unsafe(method_family = none)]
        pub fn alpha(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`alpha`][Self::alpha].
        #[unsafe(method(setAlpha:))]
        #[unsafe(method_family = none)]
        pub fn setAlpha(&self, alpha: CGFloat);

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        pub fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        pub fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        pub fn setHidden(&self, hidden: bool);

        #[unsafe(method(indexPath))]
        #[unsafe(method_family = none)]
        pub fn indexPath(&self) -> Retained<NSIndexPath>;

        /// Setter for [`indexPath`][Self::indexPath].
        #[unsafe(method(setIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn setIndexPath(&self, index_path: &NSIndexPath);

        #[unsafe(method(representedElementCategory))]
        #[unsafe(method_family = none)]
        pub fn representedElementCategory(&self) -> UICollectionElementCategory;

        #[unsafe(method(representedElementKind))]
        #[unsafe(method_family = none)]
        pub fn representedElementKind(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(layoutAttributesForCellWithIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForCellWithIndexPath(
            index_path: &NSIndexPath,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(layoutAttributesForSupplementaryViewOfKind:withIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForSupplementaryViewOfKind_withIndexPath(
            element_kind: &NSString,
            index_path: &NSIndexPath,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(layoutAttributesForDecorationViewOfKind:withIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForDecorationViewOfKind_withIndexPath(
            decoration_view_kind: &NSString,
            index_path: &NSIndexPath,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UICollectionViewLayoutAttributes {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// A context object that declares which parts of your layout need to be updated when the layout is invalidated.
    ///
    /// ## Overview
    ///
    /// Layout objects that are designed to support invalidation contexts can use the information in a [`UICollectionViewLayoutInvalidationContext`](https://developer.apple.com/documentation/uikit/uicollectionviewlayoutinvalidationcontext) object to optimize their behavior during the invalidation cycle. You can create an invalidation context object as a precursor to invalidating a layout object. After configuring the invalidation context object, pass it to the layout object’s [`invalidateLayoutWithContext:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/invalidatelayout(with:)) method, which is responsible for using the context object to update the layout efficiently. The collection view also creates invalidation contexts in response to specific changes. For example, it creates an invalidation context when you change the layout or data source object, when you insert or delete items, and when you call the [`reloadData`](https://developer.apple.com/documentation/uikit/uicollectionview/reloaddata()) method.
    ///
    /// ### Subclassing Notes
    ///
    /// If you create your own custom layout objects, you can subclass `UICollectionViewLayoutInvalidationContext` and add properties to specify which aspects of your layout data can be invalidated separately. You must then design your layout object to check for these properties and update the layout appropriately.
    ///
    /// For more information about how to support custom invalidation contexts in your layout objects, see [`UICollectionViewLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewLayoutInvalidationContext;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionViewLayoutInvalidationContext {}
);

impl UICollectionViewLayoutInvalidationContext {
    extern_methods!(
        #[unsafe(method(invalidateEverything))]
        #[unsafe(method_family = none)]
        pub fn invalidateEverything(&self) -> bool;

        #[unsafe(method(invalidateDataSourceCounts))]
        #[unsafe(method_family = none)]
        pub fn invalidateDataSourceCounts(&self) -> bool;

        #[unsafe(method(invalidateItemsAtIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn invalidateItemsAtIndexPaths(&self, index_paths: &NSArray<NSIndexPath>);

        #[unsafe(method(invalidateSupplementaryElementsOfKind:atIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn invalidateSupplementaryElementsOfKind_atIndexPaths(
            &self,
            element_kind: &NSString,
            index_paths: &NSArray<NSIndexPath>,
        );

        #[unsafe(method(invalidateDecorationElementsOfKind:atIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn invalidateDecorationElementsOfKind_atIndexPaths(
            &self,
            element_kind: &NSString,
            index_paths: &NSArray<NSIndexPath>,
        );

        #[unsafe(method(invalidatedItemIndexPaths))]
        #[unsafe(method_family = none)]
        pub fn invalidatedItemIndexPaths(&self) -> Option<Retained<NSArray<NSIndexPath>>>;

        #[unsafe(method(invalidatedSupplementaryIndexPaths))]
        #[unsafe(method_family = none)]
        pub fn invalidatedSupplementaryIndexPaths(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, NSArray<NSIndexPath>>>>;

        #[unsafe(method(invalidatedDecorationIndexPaths))]
        #[unsafe(method_family = none)]
        pub fn invalidatedDecorationIndexPaths(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, NSArray<NSIndexPath>>>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentOffsetAdjustment))]
        #[unsafe(method_family = none)]
        pub fn contentOffsetAdjustment(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`contentOffsetAdjustment`][Self::contentOffsetAdjustment].
        #[unsafe(method(setContentOffsetAdjustment:))]
        #[unsafe(method_family = none)]
        pub fn setContentOffsetAdjustment(&self, content_offset_adjustment: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentSizeAdjustment))]
        #[unsafe(method_family = none)]
        pub fn contentSizeAdjustment(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`contentSizeAdjustment`][Self::contentSizeAdjustment].
        #[unsafe(method(setContentSizeAdjustment:))]
        #[unsafe(method_family = none)]
        pub fn setContentSizeAdjustment(&self, content_size_adjustment: CGSize);

        #[unsafe(method(previousIndexPathsForInteractivelyMovingItems))]
        #[unsafe(method_family = none)]
        pub fn previousIndexPathsForInteractivelyMovingItems(
            &self,
        ) -> Option<Retained<NSArray<NSIndexPath>>>;

        #[unsafe(method(targetIndexPathsForInteractivelyMovingItems))]
        #[unsafe(method_family = none)]
        pub fn targetIndexPathsForInteractivelyMovingItems(
            &self,
        ) -> Option<Retained<NSArray<NSIndexPath>>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(interactiveMovementTarget))]
        #[unsafe(method_family = none)]
        pub fn interactiveMovementTarget(&self) -> CGPoint;
    );
}

/// Methods declared on superclass `NSObject`.
impl UICollectionViewLayoutInvalidationContext {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// An abstract base class for generating layout information for a collection view.
    ///
    /// ## Overview
    ///
    /// A layout object determines the placement of cells, supplementary views, and decoration views inside the collection view’s bounds and reports that information to the collection view. The collection view then applies the provided layout information to the corresponding views so that they can be presented onscreen.
    ///
    /// You must subclass [`UICollectionViewLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout) in order to use it. Before you consider subclassing, however, consider whether you can adapt [`UICollectionViewCompositionalLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout) to your layout needs.
    ///
    /// ### Subclassing notes
    ///
    /// The layout object defines the position, size, and visual state of items in the collection view, based on the design of the layout. The views for the layout are created by the collection view’s data source.
    ///
    /// You lay out three types of visual elements in a collection view:
    ///
    /// - _Cells_ are the main elements positioned by the layout. Each cell represents a single data item in the collection. You can make cells interactive so that a user can perform actions like selecting, dragging, and reordering the cells. A collection view can have a single group of cells, or you can divide those cells into multiple sections. The layout object arranges the cells in the collection view’s content area.
    ///
    /// - _Supplementary views_ present data but can’t be selected by the user. You use supplementary views to implement things like header and footer views for a given section or for the entire collection view. Supplementary views are optional and their use and placement is defined by the layout object.
    ///
    /// - _Decoration views_ are visual adornments, like badges, that can’t be selected and aren’t inherently tied to the data of the collection view. Decoration views are another type of supplementary view. Like supplementary views, they’re optional and their use and placement is defined by the layout object.
    ///
    /// The collection view asks its layout object to provide layout information for these elements at many different times. Every cell and view that appears on screen is positioned using information from the layout object. Similarly, every time items are inserted into or deleted from the collection view, an additional layout pass occurs for the items being added or removed. However, the collection view always limits layout to the objects that are visible onscreen.
    ///
    /// #### Methods to override
    ///
    /// Every layout object should implement the following methods:
    ///
    /// - [`collectionViewContentSize`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/collectionviewcontentsize)
    ///
    /// - [`layoutAttributesForElementsInRect:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/layoutattributesforelements(in:))
    ///
    /// - [`layoutAttributesForItemAtIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/layoutattributesforitem(at:))
    ///
    /// - [`layoutAttributesForSupplementaryViewOfKind:atIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/layoutattributesforsupplementaryview(ofkind:at:)) (if your layout supports supplementary views)
    ///
    /// - [`layoutAttributesForDecorationViewOfKind:atIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/layoutattributesfordecorationview(ofkind:at:)) (if your layout supports decoration views)
    ///
    /// - [`shouldInvalidateLayoutForBoundsChange:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/shouldinvalidatelayout(forboundschange:))
    ///
    /// These methods provide the fundamental layout information that the collection view needs to place contents on the screen. If your layout doesn’t support supplementary or decoration views, don’t implement the corresponding methods.
    ///
    /// When the data in the collection view changes and items are to be inserted or deleted, the collection view asks its layout object to update the layout information. Specifically, any item that’s moved, added, or deleted must have its layout information updated to reflect its new location. For moved items, the collection view uses the standard methods to retrieve the item’s updated layout attributes. For items being inserted or deleted, the collection view calls some different methods, which you should override to provide the appropriate layout information:
    ///
    /// - [`initialLayoutAttributesForAppearingItemAtIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/initiallayoutattributesforappearingitem(at:))
    ///
    /// - [`initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/initiallayoutattributesforappearingsupplementaryelement(ofkind:at:))
    ///
    /// - [`initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/initiallayoutattributesforappearingdecorationelement(ofkind:at:))
    ///
    /// - [`finalLayoutAttributesForDisappearingItemAtIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/finallayoutattributesfordisappearingitem(at:))
    ///
    /// - [`finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/finallayoutattributesfordisappearingsupplementaryelement(ofkind:at:))
    ///
    /// - [`finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/finallayoutattributesfordisappearingdecorationelement(ofkind:at:))
    ///
    /// In addition to these methods, you can also override the [`prepareForCollectionViewUpdates:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/prepare(forcollectionviewupdates:)) to handle any layout-related preparation. You can also override the [`finalizeCollectionViewUpdates`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/finalizecollectionviewupdates()) method and use it to add animations to the overall animation block or to implement any final layout-related tasks.
    ///
    /// #### Optimizing layout performance using invalidation contexts
    ///
    /// When designing your custom layouts, you can improve performance by invalidating only those parts of your layout that actually changed. When you change items, calling the [`invalidateLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/invalidatelayout()) method forces the collection view to recompute all of its layout information and reapply it. A better solution is to recompute only the layout information that changed, which is exactly what invalidation contexts allow you to do. An invalidation context lets you specify which parts of the layout changed. The layout object can then use that information to minimize the amount of data it recomputes.
    ///
    /// To define a custom invalidation context for your layout, subclass the [`UICollectionViewLayoutInvalidationContext`](https://developer.apple.com/documentation/uikit/uicollectionviewlayoutinvalidationcontext) class. In your subclass, define custom properties that represent the parts of your layout data that can be recomputed independently. When you need to invalidate your layout at runtime, create an instance of your invalidation context subclass, configure the custom properties based on what layout information changed, and pass that object to your layout’s [`invalidateLayoutWithContext:`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/invalidatelayout(with:)) method. Your custom implementation of that method can use the information in the invalidation context to recompute only the portions of your layout that changed.
    ///
    /// If you define a custom invalidation context class for your layout object, you should also override the [`invalidationContextClass`](https://developer.apple.com/documentation/uikit/uicollectionviewlayout/invalidationcontextclass) method and return your custom class. The collection view always creates an instance of the class you specify when it needs an invalidation context. Returning your custom subclass from this method ensures that your layout object always has the invalidation context it expects.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewLayout;
);

extern_conformance!(
    unsafe impl NSCoding for UICollectionViewLayout {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionViewLayout {}
);

impl UICollectionViewLayout {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "UICollectionView",
            feature = "UIResponder",
            feature = "UIScrollView",
            feature = "UIView"
        ))]
        #[unsafe(method(collectionView))]
        #[unsafe(method_family = none)]
        pub fn collectionView(&self) -> Option<Retained<UICollectionView>>;

        #[unsafe(method(invalidateLayout))]
        #[unsafe(method_family = none)]
        pub fn invalidateLayout(&self);

        #[unsafe(method(invalidateLayoutWithContext:))]
        #[unsafe(method_family = none)]
        pub fn invalidateLayoutWithContext(
            &self,
            context: &UICollectionViewLayoutInvalidationContext,
        );

        /// # Safety
        ///
        /// `view_class` probably has further requirements.
        #[unsafe(method(registerClass:forDecorationViewOfKind:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerClass_forDecorationViewOfKind(
            &self,
            view_class: Option<&AnyClass>,
            element_kind: &NSString,
        );

        #[cfg(feature = "UINib")]
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(registerNib:forDecorationViewOfKind:))]
        #[unsafe(method_family = none)]
        pub fn registerNib_forDecorationViewOfKind(
            &self,
            nib: Option<&UINib>,
            element_kind: &NSString,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl UICollectionViewLayout {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// UISubclassingHooks.
impl UICollectionViewLayout {
    extern_methods!(
        #[unsafe(method(layoutAttributesClass))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesClass(mtm: MainThreadMarker) -> &'static AnyClass;

        #[unsafe(method(invalidationContextClass))]
        #[unsafe(method_family = none)]
        pub fn invalidationContextClass(mtm: MainThreadMarker) -> &'static AnyClass;

        #[unsafe(method(prepareLayout))]
        #[unsafe(method_family = none)]
        pub fn prepareLayout(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(layoutAttributesForElementsInRect:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForElementsInRect(
            &self,
            rect: CGRect,
        ) -> Option<Retained<NSArray<UICollectionViewLayoutAttributes>>>;

        #[unsafe(method(layoutAttributesForItemAtIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForItemAtIndexPath(
            &self,
            index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(layoutAttributesForSupplementaryViewOfKind:atIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForSupplementaryViewOfKind_atIndexPath(
            &self,
            element_kind: &NSString,
            index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(layoutAttributesForDecorationViewOfKind:atIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForDecorationViewOfKind_atIndexPath(
            &self,
            element_kind: &NSString,
            index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(shouldInvalidateLayoutForBoundsChange:))]
        #[unsafe(method_family = none)]
        pub fn shouldInvalidateLayoutForBoundsChange(&self, new_bounds: CGRect) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(invalidationContextForBoundsChange:))]
        #[unsafe(method_family = none)]
        pub fn invalidationContextForBoundsChange(
            &self,
            new_bounds: CGRect,
        ) -> Retained<UICollectionViewLayoutInvalidationContext>;

        #[unsafe(method(shouldInvalidateLayoutForPreferredLayoutAttributes:withOriginalAttributes:))]
        #[unsafe(method_family = none)]
        pub fn shouldInvalidateLayoutForPreferredLayoutAttributes_withOriginalAttributes(
            &self,
            preferred_attributes: &UICollectionViewLayoutAttributes,
            original_attributes: &UICollectionViewLayoutAttributes,
        ) -> bool;

        #[unsafe(method(invalidationContextForPreferredLayoutAttributes:withOriginalAttributes:))]
        #[unsafe(method_family = none)]
        pub fn invalidationContextForPreferredLayoutAttributes_withOriginalAttributes(
            &self,
            preferred_attributes: &UICollectionViewLayoutAttributes,
            original_attributes: &UICollectionViewLayoutAttributes,
        ) -> Retained<UICollectionViewLayoutInvalidationContext>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(targetContentOffsetForProposedContentOffset:withScrollingVelocity:))]
        #[unsafe(method_family = none)]
        pub fn targetContentOffsetForProposedContentOffset_withScrollingVelocity(
            &self,
            proposed_content_offset: CGPoint,
            velocity: CGPoint,
        ) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(targetContentOffsetForProposedContentOffset:))]
        #[unsafe(method_family = none)]
        pub fn targetContentOffsetForProposedContentOffset(
            &self,
            proposed_content_offset: CGPoint,
        ) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(collectionViewContentSize))]
        #[unsafe(method_family = none)]
        pub fn collectionViewContentSize(&self) -> CGSize;

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(developmentLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn developmentLayoutDirection(&self) -> UIUserInterfaceLayoutDirection;

        #[unsafe(method(flipsHorizontallyInOppositeLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn flipsHorizontallyInOppositeLayoutDirection(&self) -> bool;
    );
}

/// UIUpdateSupportHooks.
impl UICollectionViewLayout {
    extern_methods!(
        #[cfg(feature = "UICollectionViewUpdateItem")]
        #[unsafe(method(prepareForCollectionViewUpdates:))]
        #[unsafe(method_family = none)]
        pub fn prepareForCollectionViewUpdates(
            &self,
            update_items: &NSArray<UICollectionViewUpdateItem>,
        );

        #[unsafe(method(finalizeCollectionViewUpdates))]
        #[unsafe(method_family = none)]
        pub fn finalizeCollectionViewUpdates(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(prepareForAnimatedBoundsChange:))]
        #[unsafe(method_family = none)]
        pub fn prepareForAnimatedBoundsChange(&self, old_bounds: CGRect);

        #[unsafe(method(finalizeAnimatedBoundsChange))]
        #[unsafe(method_family = none)]
        pub fn finalizeAnimatedBoundsChange(&self);

        #[unsafe(method(prepareForTransitionToLayout:))]
        #[unsafe(method_family = none)]
        pub fn prepareForTransitionToLayout(&self, new_layout: &UICollectionViewLayout);

        #[unsafe(method(prepareForTransitionFromLayout:))]
        #[unsafe(method_family = none)]
        pub fn prepareForTransitionFromLayout(&self, old_layout: &UICollectionViewLayout);

        #[unsafe(method(finalizeLayoutTransition))]
        #[unsafe(method_family = none)]
        pub fn finalizeLayoutTransition(&self);

        #[unsafe(method(initialLayoutAttributesForAppearingItemAtIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn initialLayoutAttributesForAppearingItemAtIndexPath(
            &self,
            item_index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(finalLayoutAttributesForDisappearingItemAtIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn finalLayoutAttributesForDisappearingItemAtIndexPath(
            &self,
            item_index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn initialLayoutAttributesForAppearingSupplementaryElementOfKind_atIndexPath(
            &self,
            element_kind: &NSString,
            element_index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn finalLayoutAttributesForDisappearingSupplementaryElementOfKind_atIndexPath(
            &self,
            element_kind: &NSString,
            element_index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn initialLayoutAttributesForAppearingDecorationElementOfKind_atIndexPath(
            &self,
            element_kind: &NSString,
            decoration_index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn finalLayoutAttributesForDisappearingDecorationElementOfKind_atIndexPath(
            &self,
            element_kind: &NSString,
            decoration_index_path: &NSIndexPath,
        ) -> Option<Retained<UICollectionViewLayoutAttributes>>;

        #[unsafe(method(indexPathsToDeleteForSupplementaryViewOfKind:))]
        #[unsafe(method_family = none)]
        pub fn indexPathsToDeleteForSupplementaryViewOfKind(
            &self,
            element_kind: &NSString,
        ) -> Retained<NSArray<NSIndexPath>>;

        #[unsafe(method(indexPathsToDeleteForDecorationViewOfKind:))]
        #[unsafe(method_family = none)]
        pub fn indexPathsToDeleteForDecorationViewOfKind(
            &self,
            element_kind: &NSString,
        ) -> Retained<NSArray<NSIndexPath>>;

        #[unsafe(method(indexPathsToInsertForSupplementaryViewOfKind:))]
        #[unsafe(method_family = none)]
        pub fn indexPathsToInsertForSupplementaryViewOfKind(
            &self,
            element_kind: &NSString,
        ) -> Retained<NSArray<NSIndexPath>>;

        #[unsafe(method(indexPathsToInsertForDecorationViewOfKind:))]
        #[unsafe(method_family = none)]
        pub fn indexPathsToInsertForDecorationViewOfKind(
            &self,
            element_kind: &NSString,
        ) -> Retained<NSArray<NSIndexPath>>;
    );
}

/// UIReorderingSupportHooks.
impl UICollectionViewLayout {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(targetIndexPathForInteractivelyMovingItem:withPosition:))]
        #[unsafe(method_family = none)]
        pub fn targetIndexPathForInteractivelyMovingItem_withPosition(
            &self,
            previous_index_path: &NSIndexPath,
            position: CGPoint,
        ) -> Retained<NSIndexPath>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(layoutAttributesForInteractivelyMovingItemAtIndexPath:withTargetPosition:))]
        #[unsafe(method_family = none)]
        pub fn layoutAttributesForInteractivelyMovingItemAtIndexPath_withTargetPosition(
            &self,
            index_path: &NSIndexPath,
            position: CGPoint,
        ) -> Retained<UICollectionViewLayoutAttributes>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(invalidationContextForInteractivelyMovingItems:withTargetPosition:previousIndexPaths:previousPosition:))]
        #[unsafe(method_family = none)]
        pub fn invalidationContextForInteractivelyMovingItems_withTargetPosition_previousIndexPaths_previousPosition(
            &self,
            target_index_paths: &NSArray<NSIndexPath>,
            target_position: CGPoint,
            previous_index_paths: &NSArray<NSIndexPath>,
            previous_position: CGPoint,
        ) -> Retained<UICollectionViewLayoutInvalidationContext>;

        #[unsafe(method(invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths:previousIndexPaths:movementCancelled:))]
        #[unsafe(method_family = none)]
        pub fn invalidationContextForEndingInteractiveMovementOfItemsToFinalIndexPaths_previousIndexPaths_movementCancelled(
            &self,
            index_paths: &NSArray<NSIndexPath>,
            previous_index_paths: &NSArray<NSIndexPath>,
            movement_cancelled: bool,
        ) -> Retained<UICollectionViewLayoutInvalidationContext>;
    );
}
