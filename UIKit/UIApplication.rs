//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-cloud-kit")]
use objc2_cloud_kit::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Constants that describe the style of the device’s status bar.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIStatusBarStyle(pub NSInteger);
impl UIStatusBarStyle {
    /// A style that automatically selects an appearance for the status bar and updates it dynamically to maintain contrast with the content below it.
    #[doc(alias = "UIStatusBarStyleDefault")]
    pub const Default: Self = Self(0);
    /// A light status bar, intended for use on dark backgrounds.
    #[doc(alias = "UIStatusBarStyleLightContent")]
    pub const LightContent: Self = Self(1);
    /// A dark status bar, intended for use on light backgrounds.
    #[doc(alias = "UIStatusBarStyleDarkContent")]
    pub const DarkContent: Self = Self(3);
    /// A transparent black style.
    #[doc(alias = "UIStatusBarStyleBlackTranslucent")]
    #[deprecated]
    pub const BlackTranslucent: Self = Self(1);
    /// An opaque black style.
    #[doc(alias = "UIStatusBarStyleBlackOpaque")]
    #[deprecated]
    pub const BlackOpaque: Self = Self(2);
}

unsafe impl Encode for UIStatusBarStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIStatusBarStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that specify the animation of the status bar as it’s hidden or made visible.
///
/// ## Overview
///
/// Constants of the [`UIStatusBarAnimation`](https://developer.apple.com/documentation/uikit/uistatusbaranimation) type are arguments of the [`setStatusBarHidden:withAnimation:`](https://developer.apple.com/documentation/uikit/uiapplication/setstatusbarhidden(_:with:)) method.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIStatusBarAnimation(pub NSInteger);
impl UIStatusBarAnimation {
    /// No animation is applied to the status bar as it is shown or hidden.
    #[doc(alias = "UIStatusBarAnimationNone")]
    pub const None: Self = Self(0);
    /// The status bar fades in and out as it is shown or hidden, respectively.
    #[doc(alias = "UIStatusBarAnimationFade")]
    pub const Fade: Self = Self(1);
    /// The status bar slides in or out as it is shown or hidden, respectively.
    #[doc(alias = "UIStatusBarAnimationSlide")]
    pub const Slide: Self = Self(2);
}

unsafe impl Encode for UIStatusBarAnimation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIStatusBarAnimation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// An exception that’s thrown if a view controller or the app returns an invalid set of supported interface orientations.
    ///
    /// ## Discussion
    ///
    /// This exception is thrown if a view controller or the app returns `0` instead of a valid set of supported interface orientation values. It is also thrown if the orientation returned by a view controller’s [`preferredInterfaceOrientationForPresentation`](https://developer.apple.com/documentation/uikit/uiviewcontroller/preferredinterfaceorientationforpresentation) method does not match one of the view controller’s supported orientations.
    ///
    ///
    pub static UIApplicationInvalidInterfaceOrientationException: &'static NSExceptionName;
}

/// Constants indicating the types of notifications the app may display to the user.
///
/// ## Overview
///
/// One or more of the values in the `UIRemoteNotificationType` bit mask are passed to iOS as the argument of the [`registerForRemoteNotificationTypes:`](https://developer.apple.com/documentation/uikit/uiapplication/registerforremotenotifications(matching:)) method. Thereafter, iOS filters notifications for the app based on these values. You can always get the current notification types by calling the [`enabledRemoteNotificationTypes`](https://developer.apple.com/documentation/uikit/uiapplication/enabledremotenotificationtypes()) method.
///
///
// NS_OPTIONS
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIRemoteNotificationType(pub NSUInteger);
bitflags::bitflags! {
    impl UIRemoteNotificationType: NSUInteger {
/// The app accepts no notifications.
        #[doc(alias = "UIRemoteNotificationTypeNone")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const None = 0;
/// The app accepts notifications that badge the app icon.
        #[doc(alias = "UIRemoteNotificationTypeBadge")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const Badge = 1<<0;
/// The app accepts alert sounds as notifications.
        #[doc(alias = "UIRemoteNotificationTypeSound")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const Sound = 1<<1;
/// The app accepts alert messages as notifications.
        #[doc(alias = "UIRemoteNotificationTypeAlert")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const Alert = 1<<2;
/// The app accepts notifications that start the downloading of issue assets for Newsstand apps.
        #[doc(alias = "UIRemoteNotificationTypeNewsstandContentAvailability")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const NewsstandContentAvailability = 1<<3;
    }
}

unsafe impl Encode for UIRemoteNotificationType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIRemoteNotificationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicate the result of a background fetch operation.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIBackgroundFetchResult(pub NSUInteger);
impl UIBackgroundFetchResult {
    /// New data was successfully downloaded.
    #[doc(alias = "UIBackgroundFetchResultNewData")]
    pub const NewData: Self = Self(0);
    /// There was no new data to download.
    #[doc(alias = "UIBackgroundFetchResultNoData")]
    pub const NoData: Self = Self(1);
    /// An attempt to download data was made but that attempt failed.
    #[doc(alias = "UIBackgroundFetchResultFailed")]
    pub const Failed: Self = Self(2);
}

unsafe impl Encode for UIBackgroundFetchResult {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIBackgroundFetchResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicate whether background execution is enabled for the app.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIBackgroundRefreshStatus(pub NSInteger);
impl UIBackgroundRefreshStatus {
    /// Background updates are unavailable and the user cannot enable them again.
    ///
    /// ## Discussion
    ///
    /// For example, this status can occur when parental controls are in effect for the current user.
    ///
    ///
    #[doc(alias = "UIBackgroundRefreshStatusRestricted")]
    pub const Restricted: Self = Self(0);
    /// The user explicitly disabled background behavior for this app or for the whole system.
    #[doc(alias = "UIBackgroundRefreshStatusDenied")]
    pub const Denied: Self = Self(1);
    /// Background updates are available for the app.
    #[doc(alias = "UIBackgroundRefreshStatusAvailable")]
    pub const Available: Self = Self(2);
}

unsafe impl Encode for UIBackgroundRefreshStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIBackgroundRefreshStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicate the running states of an app.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIApplicationState(pub NSInteger);
impl UIApplicationState {
    /// The app is running in the foreground and currently receiving events.
    #[doc(alias = "UIApplicationStateActive")]
    pub const Active: Self = Self(0);
    /// The app is running in the foreground but isn’t receiving events.
    ///
    /// ## Discussion
    ///
    /// This might happen as a result of an interruption or because the app is transitioning to or from the background.
    ///
    ///
    #[doc(alias = "UIApplicationStateInactive")]
    pub const Inactive: Self = Self(1);
    /// The app is running in the background.
    #[doc(alias = "UIApplicationStateBackground")]
    pub const Background: Self = Self(2);
}

unsafe impl Encode for UIApplicationState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A unique token that identifies a request to run in the background.
// NS_TYPED_ENUM
pub type UIBackgroundTaskIdentifier = NSUInteger;

extern "C" {
    /// A token that indicates an invalid task request.
    ///
    /// ## Discussion
    ///
    /// Use this constant to initialize variables or to check for errors.
    ///
    ///
    pub static UIBackgroundTaskInvalid: UIBackgroundTaskIdentifier;
}

extern "C" {
    /// The minimum amount of time (measured in seconds) an app may run a critical background task in the background.
    #[deprecated = "Please use PushKit for VoIP applications."]
    pub static UIMinimumKeepAliveTimeout: NSTimeInterval;
}

extern "C" {
    /// The smallest fetch interval supported by the system.
    pub static UIApplicationBackgroundFetchIntervalMinimum: NSTimeInterval;
}

extern "C" {
    /// A fetch interval large enough to prevent fetch operations from occurring.
    pub static UIApplicationBackgroundFetchIntervalNever: NSTimeInterval;
}

/// Options for opening a URL.
// NS_TYPED_ENUM
pub type UIApplicationOpenExternalURLOptionsKey = NSString;

extern_class!(
    /// The centralized point of control and coordination for apps running in iOS.
    ///
    /// ## Overview
    ///
    /// Every iOS app has exactly one instance of [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) (or, very rarely, a subclass of [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication)). When an app launches, the system calls the [`UIApplicationMain`](https://developer.apple.com/documentation/uikit/uiapplicationmain(_:_:_:_:)-1yub7) function. Among its other tasks, this function creates a singleton [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) object that you access using [`sharedApplication`](https://developer.apple.com/documentation/uikit/uiapplication/shared).
    ///
    /// Your app’s application object handles the initial routing of incoming user events. It dispatches action messages forwarded to it by control objects (instances of the [`UIControl`](https://developer.apple.com/documentation/uikit/uicontrol) class) to appropriate target objects. The application object maintains a list of open windows ([`UIWindow`](https://developer.apple.com/documentation/uikit/uiwindow) objects), which it can use to retrieve any of the app’s [`UIView`](https://developer.apple.com/documentation/uikit/uiview) objects.
    ///
    /// The [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) class defines a delegate that conforms to the [`UIApplicationDelegate`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate) protocol and must implement some of the protocol’s methods. The application object informs the delegate of significant runtime events—for example, app launch, low-memory warnings, and app termination—giving it an opportunity to respond appropriately.
    ///
    /// Apps can cooperatively handle a resource, such as an email or an image file, through the [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/open(_:options:completionhandler:)) method. For example, an app that calls this method with an email URL causes the Mail app to launch and display the message.
    ///
    /// The APIs in this class allow you to manage device-specific behavior. Use your [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) object to do the following:
    ///
    /// - Temporarily suspend incoming touch events ([`beginIgnoringInteractionEvents`](https://developer.apple.com/documentation/uikit/uiapplication/beginignoringinteractionevents()))
    ///
    /// - Register for remote notifications ([`registerForRemoteNotifications`](https://developer.apple.com/documentation/uikit/uiapplication/registerforremotenotifications()))
    ///
    /// - Trigger the undo-redo UI ([`applicationSupportsShakeToEdit`](https://developer.apple.com/documentation/uikit/uiapplication/applicationsupportsshaketoedit))
    ///
    /// - Determine whether there is an installed app registered to handle a URL scheme ([`canOpenURL:`](https://developer.apple.com/documentation/uikit/uiapplication/canopenurl(_:)))
    ///
    /// - Extend the execution of the app so that it can finish a task in the background ([`beginBackgroundTaskWithExpirationHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/beginbackgroundtask(expirationhandler:)) and [`beginBackgroundTaskWithName:expirationHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/beginbackgroundtask(withname:expirationhandler:)))
    ///
    /// - Schedule and cancel local notifications ([`scheduleLocalNotification:`](https://developer.apple.com/documentation/uikit/uiapplication/schedulelocalnotification(_:)) and [`cancelLocalNotification:`](https://developer.apple.com/documentation/uikit/uiapplication/cancellocalnotification(_:)))
    ///
    /// - Coordinate the reception of remote-control events ([`beginReceivingRemoteControlEvents`](https://developer.apple.com/documentation/uikit/uiapplication/beginreceivingremotecontrolevents()) and [`endReceivingRemoteControlEvents`](https://developer.apple.com/documentation/uikit/uiapplication/endreceivingremotecontrolevents()))
    ///
    /// - Perform app-level state restoration tasks (methods in the [Managing state restoration](https://developer.apple.com/documentation/uikit/uiapplication#managing-state-restoration) task group)
    ///
    /// ### Subclassing notes
    ///
    /// Most apps don’t need to subclass [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication). Instead, use an app delegate to manage interactions between the system and the app.
    ///
    /// If your app must handle incoming events before the system does—a very rare situation—you can implement a custom event or action dispatching mechanism. To do this, subclass [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) and override the [`sendEvent:`](https://developer.apple.com/documentation/uikit/uiapplication/sendevent(_:)) and/or the [`sendAction:to:from:forEvent:`](https://developer.apple.com/documentation/uikit/uiapplication/sendaction(_:to:from:for:)) methods. For every event you intercept, after you handle the event, dispatch it back to the system by calling:
    ///
    /// ```swift
    /// super.sendEvent(event)
    /// ```
    ///
    /// Intercepting events is only rarely required and you should avoid it if possible.
    ///
    ///
    #[unsafe(super(UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "UIResponder")]
    pub struct UIApplication;
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for UIApplication {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UIApplication {}
);

#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(sharedApplication))]
        #[unsafe(method_family = none)]
        pub fn sharedApplication(mtm: MainThreadMarker) -> Retained<UIApplication>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UIApplicationDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn UIApplicationDelegate>>,
        );

        #[deprecated = "Use UIView's userInteractionEnabled property instead"]
        #[unsafe(method(beginIgnoringInteractionEvents))]
        #[unsafe(method_family = none)]
        pub fn beginIgnoringInteractionEvents(&self);

        #[deprecated = "Use UIView's userInteractionEnabled property instead"]
        #[unsafe(method(endIgnoringInteractionEvents))]
        #[unsafe(method_family = none)]
        pub fn endIgnoringInteractionEvents(&self);

        #[deprecated = "Use UIView's userInteractionEnabled property instead"]
        #[unsafe(method(isIgnoringInteractionEvents))]
        #[unsafe(method_family = none)]
        pub fn isIgnoringInteractionEvents(&self) -> bool;

        #[unsafe(method(isIdleTimerDisabled))]
        #[unsafe(method_family = none)]
        pub fn isIdleTimerDisabled(&self) -> bool;

        /// Setter for [`isIdleTimerDisabled`][Self::isIdleTimerDisabled].
        #[unsafe(method(setIdleTimerDisabled:))]
        #[unsafe(method_family = none)]
        pub fn setIdleTimerDisabled(&self, idle_timer_disabled: bool);

        #[deprecated]
        #[unsafe(method(openURL:))]
        #[unsafe(method_family = none)]
        pub fn openURL(&self, url: &NSURL) -> bool;

        #[unsafe(method(canOpenURL:))]
        #[unsafe(method_family = none)]
        pub fn canOpenURL(&self, url: &NSURL) -> bool;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(openURL:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openURL_options_completionHandler(
            &self,
            url: &NSURL,
            options: &NSDictionary<UIApplicationOpenExternalURLOptionsKey, AnyObject>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "UIEvent")]
        #[unsafe(method(sendEvent:))]
        #[unsafe(method_family = none)]
        pub fn sendEvent(&self, event: &UIEvent);

        #[cfg(all(feature = "UIView", feature = "UIWindow"))]
        #[deprecated = "Should not be used for applications that support multiple scenes as it returns a key window across all connected scenes"]
        #[unsafe(method(keyWindow))]
        #[unsafe(method_family = none)]
        pub fn keyWindow(&self) -> Option<Retained<UIWindow>>;

        #[cfg(all(feature = "UIView", feature = "UIWindow"))]
        #[deprecated = "Use UIWindowScene.windows on a relevant window scene instead"]
        #[unsafe(method(windows))]
        #[unsafe(method_family = none)]
        pub fn windows(&self) -> Retained<NSArray<UIWindow>>;

        #[cfg(feature = "UIEvent")]
        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `target` should be of the correct type.
        /// - `sender` should be of the correct type.
        #[unsafe(method(sendAction:to:from:forEvent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendAction_to_from_forEvent(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
            event: Option<&UIEvent>,
        ) -> bool;

        #[deprecated = "Provide a custom network activity UI in your app if desired."]
        #[unsafe(method(isNetworkActivityIndicatorVisible))]
        #[unsafe(method_family = none)]
        pub fn isNetworkActivityIndicatorVisible(&self) -> bool;

        /// Setter for [`isNetworkActivityIndicatorVisible`][Self::isNetworkActivityIndicatorVisible].
        #[deprecated = "Provide a custom network activity UI in your app if desired."]
        #[unsafe(method(setNetworkActivityIndicatorVisible:))]
        #[unsafe(method_family = none)]
        pub fn setNetworkActivityIndicatorVisible(&self, network_activity_indicator_visible: bool);

        #[cfg(all(feature = "UIOrientation", feature = "UIView", feature = "UIWindow"))]
        #[unsafe(method(supportedInterfaceOrientationsForWindow:))]
        #[unsafe(method_family = none)]
        pub fn supportedInterfaceOrientationsForWindow(
            &self,
            window: Option<&UIWindow>,
        ) -> UIInterfaceOrientationMask;

        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[unsafe(method(statusBarOrientationAnimationDuration))]
        #[unsafe(method_family = none)]
        pub fn statusBarOrientationAnimationDuration(&self) -> NSTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[deprecated = "Use the statusBarManager property of the window scene instead."]
        #[unsafe(method(statusBarFrame))]
        #[unsafe(method_family = none)]
        pub fn statusBarFrame(&self) -> CGRect;

        #[deprecated = "Use -[UNUserNotificationCenter setBadgeCount:withCompletionHandler:] instead."]
        #[unsafe(method(applicationIconBadgeNumber))]
        #[unsafe(method_family = none)]
        pub fn applicationIconBadgeNumber(&self) -> NSInteger;

        /// Setter for [`applicationIconBadgeNumber`][Self::applicationIconBadgeNumber].
        #[deprecated = "Use -[UNUserNotificationCenter setBadgeCount:withCompletionHandler:] instead."]
        #[unsafe(method(setApplicationIconBadgeNumber:))]
        #[unsafe(method_family = none)]
        pub fn setApplicationIconBadgeNumber(&self, application_icon_badge_number: NSInteger);

        #[unsafe(method(applicationSupportsShakeToEdit))]
        #[unsafe(method_family = none)]
        pub fn applicationSupportsShakeToEdit(&self) -> bool;

        /// Setter for [`applicationSupportsShakeToEdit`][Self::applicationSupportsShakeToEdit].
        #[unsafe(method(setApplicationSupportsShakeToEdit:))]
        #[unsafe(method_family = none)]
        pub fn setApplicationSupportsShakeToEdit(&self, application_supports_shake_to_edit: bool);

        #[unsafe(method(applicationState))]
        #[unsafe(method_family = none)]
        pub fn applicationState(&self) -> UIApplicationState;

        #[unsafe(method(backgroundTimeRemaining))]
        #[unsafe(method_family = none)]
        pub fn backgroundTimeRemaining(&self) -> NSTimeInterval;

        #[cfg(feature = "block2")]
        #[unsafe(method(beginBackgroundTaskWithExpirationHandler:))]
        #[unsafe(method_family = none)]
        pub fn beginBackgroundTaskWithExpirationHandler(
            &self,
            handler: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> UIBackgroundTaskIdentifier;

        #[cfg(feature = "block2")]
        #[unsafe(method(beginBackgroundTaskWithName:expirationHandler:))]
        #[unsafe(method_family = none)]
        pub fn beginBackgroundTaskWithName_expirationHandler(
            &self,
            task_name: Option<&NSString>,
            handler: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> UIBackgroundTaskIdentifier;

        #[unsafe(method(endBackgroundTask:))]
        #[unsafe(method_family = none)]
        pub fn endBackgroundTask(&self, identifier: UIBackgroundTaskIdentifier);

        /// The system guarantees that it will not wake up your application for a background fetch more
        /// frequently than the interval provided. Set to UIApplicationBackgroundFetchIntervalMinimum to be
        /// woken as frequently as the system desires, or to UIApplicationBackgroundFetchIntervalNever (the
        /// default) to never be woken for a background fetch.
        ///
        /// This setter will have no effect unless your application has the "fetch"
        /// UIBackgroundMode. See the UIApplicationDelegate method
        /// `application:performFetchWithCompletionHandler:` for more.
        #[deprecated = "Use a BGAppRefreshTask in the BackgroundTasks framework instead"]
        #[unsafe(method(setMinimumBackgroundFetchInterval:))]
        #[unsafe(method_family = none)]
        pub fn setMinimumBackgroundFetchInterval(
            &self,
            minimum_background_fetch_interval: NSTimeInterval,
        );

        /// When background refresh is available for an application, it may launched or resumed in the background to handle significant
        /// location changes, remote notifications, background fetches, etc. Observe UIApplicationBackgroundRefreshStatusDidChangeNotification to
        /// be notified of changes.
        #[unsafe(method(backgroundRefreshStatus))]
        #[unsafe(method_family = none)]
        pub fn backgroundRefreshStatus(&self) -> UIBackgroundRefreshStatus;

        #[unsafe(method(isProtectedDataAvailable))]
        #[unsafe(method_family = none)]
        pub fn isProtectedDataAvailable(&self) -> bool;

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(userInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirection(&self) -> UIUserInterfaceLayoutDirection;

        #[cfg(feature = "UIContentSizeCategory")]
        #[unsafe(method(preferredContentSizeCategory))]
        #[unsafe(method_family = none)]
        pub fn preferredContentSizeCategory(&self) -> Retained<UIContentSizeCategory>;

        #[cfg(feature = "UIScene")]
        #[unsafe(method(connectedScenes))]
        #[unsafe(method_family = none)]
        pub fn connectedScenes(&self) -> Retained<NSSet<UIScene>>;

        #[cfg(feature = "UISceneSession")]
        #[unsafe(method(openSessions))]
        #[unsafe(method_family = none)]
        pub fn openSessions(&self) -> Retained<NSSet<UISceneSession>>;

        #[unsafe(method(supportsMultipleScenes))]
        #[unsafe(method_family = none)]
        pub fn supportsMultipleScenes(&self) -> bool;

        #[cfg(all(feature = "UISceneSessionActivationRequest", feature = "block2"))]
        /// Asks the system to activate an existing scene, or create a new scene and associate it with your app.
        /// - Parameters:
        /// - request: The activation request.
        /// - errorHandler: A handler to be called if the request fails.
        #[unsafe(method(activateSceneSessionForRequest:errorHandler:))]
        #[unsafe(method_family = none)]
        pub fn activateSceneSessionForRequest_errorHandler(
            &self,
            request: &UISceneSessionActivationRequest,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(all(
            feature = "UISceneOptions",
            feature = "UISceneSession",
            feature = "block2"
        ))]
        #[deprecated = "Please use activateSceneSessionForRequest:errorHandler:"]
        #[unsafe(method(requestSceneSessionActivation:userActivity:options:errorHandler:))]
        #[unsafe(method_family = none)]
        pub fn requestSceneSessionActivation_userActivity_options_errorHandler(
            &self,
            scene_session: Option<&UISceneSession>,
            user_activity: Option<&NSUserActivity>,
            options: Option<&UISceneActivationRequestOptions>,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(all(
            feature = "UISceneOptions",
            feature = "UISceneSession",
            feature = "block2"
        ))]
        #[unsafe(method(requestSceneSessionDestruction:options:errorHandler:))]
        #[unsafe(method_family = none)]
        pub fn requestSceneSessionDestruction_options_errorHandler(
            &self,
            scene_session: &UISceneSession,
            options: Option<&UISceneDestructionRequestOptions>,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(feature = "UISceneSession")]
        #[unsafe(method(requestSceneSessionRefresh:))]
        #[unsafe(method_family = none)]
        pub fn requestSceneSessionRefresh(&self, scene_session: &UISceneSession);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// UIRemoteNotifications.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(registerForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub fn registerForRemoteNotifications(&self);

        #[unsafe(method(unregisterForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub fn unregisterForRemoteNotifications(&self);

        #[unsafe(method(isRegisteredForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub fn isRegisteredForRemoteNotifications(&self) -> bool;

        #[deprecated = "Use -[UIApplication registerForRemoteNotifications] and UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]"]
        #[unsafe(method(registerForRemoteNotificationTypes:))]
        #[unsafe(method_family = none)]
        pub fn registerForRemoteNotificationTypes(&self, types: UIRemoteNotificationType);

        #[deprecated = "Use -[UIApplication isRegisteredForRemoteNotifications] and UserNotifications Framework's -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] to retrieve user-enabled remote notification and user notification settings"]
        #[unsafe(method(enabledRemoteNotificationTypes))]
        #[unsafe(method_family = none)]
        pub fn enabledRemoteNotificationTypes(&self) -> UIRemoteNotificationType;
    );
}

/// UILocalNotifications.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]"]
        #[unsafe(method(presentLocalNotificationNow:))]
        #[unsafe(method_family = none)]
        pub fn presentLocalNotificationNow(&self, notification: &UILocalNotification);

        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]"]
        #[unsafe(method(scheduleLocalNotification:))]
        #[unsafe(method_family = none)]
        pub fn scheduleLocalNotification(&self, notification: &UILocalNotification);

        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter removePendingNotificationRequestsWithIdentifiers:]"]
        #[unsafe(method(cancelLocalNotification:))]
        #[unsafe(method_family = none)]
        pub fn cancelLocalNotification(&self, notification: &UILocalNotification);

        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter removeAllPendingNotificationRequests]"]
        #[unsafe(method(cancelAllLocalNotifications))]
        #[unsafe(method_family = none)]
        pub fn cancelAllLocalNotifications(&self);

        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter getPendingNotificationRequestsWithCompletionHandler:]"]
        #[unsafe(method(scheduledLocalNotifications))]
        #[unsafe(method_family = none)]
        pub fn scheduledLocalNotifications(&self)
            -> Option<Retained<NSArray<UILocalNotification>>>;

        #[cfg(feature = "UILocalNotification")]
        /// Setter for [`scheduledLocalNotifications`][Self::scheduledLocalNotifications].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter getPendingNotificationRequestsWithCompletionHandler:]"]
        #[unsafe(method(setScheduledLocalNotifications:))]
        #[unsafe(method_family = none)]
        pub fn setScheduledLocalNotifications(
            &self,
            scheduled_local_notifications: Option<&NSArray<UILocalNotification>>,
        );
    );
}

/// UIUserNotificationSettings.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UIUserNotificationSettings")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:] and -[UNUserNotificationCenter setNotificationCategories:]"]
        #[unsafe(method(registerUserNotificationSettings:))]
        #[unsafe(method_family = none)]
        pub fn registerUserNotificationSettings(
            &self,
            notification_settings: &UIUserNotificationSettings,
        );

        #[cfg(feature = "UIUserNotificationSettings")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] and -[UNUserNotificationCenter getNotificationCategoriesWithCompletionHandler:]"]
        #[unsafe(method(currentUserNotificationSettings))]
        #[unsafe(method_family = none)]
        pub fn currentUserNotificationSettings(
            &self,
        ) -> Option<Retained<UIUserNotificationSettings>>;
    );
}

/// UIRemoteControlEvents.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(beginReceivingRemoteControlEvents))]
        #[unsafe(method_family = none)]
        pub fn beginReceivingRemoteControlEvents(&self);

        #[unsafe(method(endReceivingRemoteControlEvents))]
        #[unsafe(method_family = none)]
        pub fn endReceivingRemoteControlEvents(&self);
    );
}

/// UINewsstand.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UIImage")]
        #[deprecated = "Newsstand apps now behave like normal apps on SpringBoard"]
        #[unsafe(method(setNewsstandIconImage:))]
        #[unsafe(method_family = none)]
        pub fn setNewsstandIconImage(&self, image: Option<&UIImage>);
    );
}

/// UIShortcutItems.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UIApplicationShortcutItem")]
        #[unsafe(method(shortcutItems))]
        #[unsafe(method_family = none)]
        pub fn shortcutItems(&self) -> Option<Retained<NSArray<UIApplicationShortcutItem>>>;

        #[cfg(feature = "UIApplicationShortcutItem")]
        /// Setter for [`shortcutItems`][Self::shortcutItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setShortcutItems:))]
        #[unsafe(method_family = none)]
        pub fn setShortcutItems(&self, shortcut_items: Option<&NSArray<UIApplicationShortcutItem>>);
    );
}

/// UIAlternateApplicationIcons.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(supportsAlternateIcons))]
        #[unsafe(method_family = none)]
        pub fn supportsAlternateIcons(&self) -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(setAlternateIconName:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn setAlternateIconName_completionHandler(
            &self,
            alternate_icon_name: Option<&NSString>,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[unsafe(method(alternateIconName))]
        #[unsafe(method_family = none)]
        pub fn alternateIconName(&self) -> Option<Retained<NSString>>;
    );
}

/// UIStateRestoration.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(extendStateRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendStateRestoration(&self);

        #[unsafe(method(completeStateRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn completeStateRestoration(&self);

        #[unsafe(method(ignoreSnapshotOnNextApplicationLaunch))]
        #[unsafe(method_family = none)]
        pub fn ignoreSnapshotOnNextApplicationLaunch(&self);

        #[cfg(feature = "UIStateRestoration")]
        #[unsafe(method(registerObjectForStateRestoration:restorationIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn registerObjectForStateRestoration_restorationIdentifier(
            object: &ProtocolObject<dyn UIStateRestoring>,
            restoration_identifier: &NSString,
        );
    );
}

/// Constants that describe the types of apps in the system.
///
/// ## Overview
///
/// Use the values in this enumeration with [`isDefault(_:)`](https://developer.apple.com/documentation/uikit/uiapplication/isdefault(_:)) (or, in Objective-C, [`defaultStatusForCategory:error:`](https://developer.apple.com/documentation/uikit/uiapplication/defaultstatusforcategory:error:)) to find if your app is the person’s default for a category.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIApplicationCategory(pub NSInteger);
impl UIApplicationCategory {
    /// The app is a web browser.
    #[doc(alias = "UIApplicationCategoryWebBrowser")]
    pub const WebBrowser: Self = Self(1);
}

unsafe impl Encode for UIApplicationCategory {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The default status of an application for some category.
/// The default status of an application for some category.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIApplicationCategoryDefaultStatus(pub NSInteger);
impl UIApplicationCategoryDefaultStatus {
    /// The status was not available. This is an error condition and the returned error object has more information.
    /// The status was not available. This is an error condition and the returned error object has more information.
    #[doc(alias = "UIApplicationCategoryDefaultStatusUnavailable")]
    pub const Unavailable: Self = Self(0);
    /// The application is the default for the category.
    /// The application is the default for the category.
    #[doc(alias = "UIApplicationCategoryDefaultStatusIsDefault")]
    pub const IsDefault: Self = Self(1);
    /// The application is not the default for the category.
    /// The application is not the default for the category.
    #[doc(alias = "UIApplicationCategoryDefaultStatusNotDefault")]
    pub const NotDefault: Self = Self(2);
}

unsafe impl Encode for UIApplicationCategoryDefaultStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationCategoryDefaultStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A string that identifies errors the system encounters when it determines if your app is the default in a category.
    pub static UIApplicationCategoryDefaultErrorDomain: &'static NSErrorDomain;
}

/// An enumeration of reasons an error happens when the system discovers whether your app is the default in a category.
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIApplicationCategoryDefaultErrorCode(pub NSInteger);
impl UIApplicationCategoryDefaultErrorCode {
    /// The system didn’t determine if your app is the default in a category because the app made the request too many times.
    ///
    /// ## Discussion
    ///
    /// When you receive an error with this code, the error’s user info dictionary contains these keys:
    ///
    /// - [`statusLastProvidedDateErrorKey`](https://developer.apple.com/documentation/uikit/uiapplication/categorydefaulterror/statuslastprovideddateerrorkey): The date at which the app most recently received a result indicating whether it’s the default app in a category.
    ///
    /// - [`retryAvailableDateErrorKey`](https://developer.apple.com/documentation/uikit/uiapplication/categorydefaulterror/retryavailabledateerrorkey): The date at which the app can next request an updated response.
    ///
    ///
    /// The application is rate-limited.
    #[doc(alias = "UIApplicationCategoryDefaultErrorRateLimited")]
    pub const RateLimited: Self = Self(1);
}

unsafe impl Encode for UIApplicationCategoryDefaultErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationCategoryDefaultErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A dictionary key, with a value that’s the date your app last received a successful result.
    /// Supplied in userInfo when the application is rate-limited: the last date on which data was
    /// retrieved.
    pub static UIApplicationCategoryDefaultStatusLastProvidedDateErrorKey:
        &'static NSErrorUserInfoKey;
}

extern "C" {
    /// A dictionary key, with a value that’s a date when a result is next available.
    /// Supplied in userInfo when the application is rate-limited: the date after which the app will no
    /// longer be rate-limited
    pub static UIApplicationCategoryDefaultRetryAvailabilityDateErrorKey:
        &'static NSErrorUserInfoKey;
}

/// DefaultApplication.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!();
}

/// The keys you use to access values in the launch options dictionary that the system passes to your app at initialization.
///
/// ## Overview
///
/// These keys are passed to the options dictionary that’s passed to the [`application:willFinishLaunchingWithOptions:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:willfinishlaunchingwithoptions:)) and [`application:didFinishLaunchingWithOptions:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didfinishlaunchingwithoptions:)) methods of the app delegate.
///
///
// NS_TYPED_ENUM
pub type UIApplicationLaunchOptionsKey = NSString;

/// Keys you use to access values in the options dictionary when opening a URL.
///
/// ## Overview
///
/// Use these keys to retrieve options in the [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:open:options:)) method of your app delegate.
///
///
#[deprecated = "Use UIScene lifecycle and equivalent properties on UISceneOpenURLOptions from a UIOpenURLContext in UIScene.ConnectionOptions.URLContexts instead."]
// NS_TYPED_ENUM
pub type UIApplicationOpenURLOptionsKey = NSString;

/// A structure that identifies types of extensions.
// NS_TYPED_ENUM
pub type UIApplicationExtensionPointIdentifier = NSString;

extern_protocol!(
    /// A set of methods to manage shared behaviors for your app.
    ///
    /// ## Overview
    ///
    /// Your app delegate object manages your app’s shared behaviors. The app delegate is effectively the root object of your app, and it works in conjunction with [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) to manage some interactions with the system. Like the [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) object, UIKit creates your app delegate object early in your app’s launch cycle so it’s always present.
    ///
    /// Use your app delegate object to handle the following tasks:
    ///
    /// - Initializing your app’s central data structures
    ///
    /// - Configuring your app’s scenes
    ///
    /// - Responding to notifications originating from outside the app, such as low-memory warnings, download completion notifications, and more
    ///
    /// - Responding to events that target the app itself, and aren’t specific to your app’s scenes, views, or view controllers
    ///
    /// - Registering for any required services at launch time, such as Apple Push Notification service
    ///
    /// For more information about how you use the app delegate object to initialize your app at launch time, see [Responding to the launch of your app](https://developer.apple.com/documentation/uikit/responding-to-the-launch-of-your-app).
    ///
    /// ### Life-cycle management in iOS 12 and earlier
    ///
    /// In iOS 12 and earlier, you use your app delegate to manage major life cycle events in your app. Specifically, you use methods of the app delegate to update the state of your app when it enters the foreground or moves to the background.
    ///
    /// - For information on what to do when your app enters the foreground, see [Preparing your UI to run in the foreground](https://developer.apple.com/documentation/uikit/preparing-your-ui-to-run-in-the-foreground).
    ///
    /// - For information on what to do when your app enters the background, see [Preparing your UI to run in the background](https://developer.apple.com/documentation/uikit/preparing-your-ui-to-run-in-the-background).
    ///
    /// - For general information about the life cycle of your app, see [Managing your app’s life cycle](https://developer.apple.com/documentation/uikit/managing-your-app-s-life-cycle).
    ///
    ///
    pub unsafe trait UIApplicationDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationDidFinishLaunching:))]
        #[unsafe(method_family = none)]
        fn applicationDidFinishLaunching(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `launch_options` generic should be of the correct type.
        #[optional]
        #[unsafe(method(application:willFinishLaunchingWithOptions:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willFinishLaunchingWithOptions(
            &self,
            application: &UIApplication,
            launch_options: Option<&NSDictionary<UIApplicationLaunchOptionsKey, AnyObject>>,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `launch_options` generic should be of the correct type.
        #[optional]
        #[unsafe(method(application:didFinishLaunchingWithOptions:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didFinishLaunchingWithOptions(
            &self,
            application: &UIApplication,
            launch_options: Option<&NSDictionary<UIApplicationLaunchOptionsKey, AnyObject>>,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// Tells the delegate that the application has become active
        /// - Note: This method is not called if `UIScene` lifecycle has been adopted.
        #[deprecated = "Use UIScene lifecycle and sceneDidBecomeActive(_:) from UISceneDelegate or the UIApplication.didBecomeActiveNotification instead."]
        #[optional]
        #[unsafe(method(applicationDidBecomeActive:))]
        #[unsafe(method_family = none)]
        fn applicationDidBecomeActive(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        /// Tells the delegate that the application is about to become inactive
        /// - Note: This method is not called if `UIScene` lifecycle has been adopted.
        #[deprecated = "Use UIScene lifecycle and sceneWillResignActive(_:) from UISceneDelegate or the UIApplication.willResignActiveNotification instead."]
        #[optional]
        #[unsafe(method(applicationWillResignActive:))]
        #[unsafe(method_family = none)]
        fn applicationWillResignActive(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        /// Tells the delegate that the application is now in the background
        /// - Note: This method is not called if `UIScene` lifecycle has been adopted.
        #[deprecated = "Use UIScene lifecycle and sceneDidEnterBackground(_:) from UISceneDelegate or the UIApplication.didEnterBackgroundNotification instead."]
        #[optional]
        #[unsafe(method(applicationDidEnterBackground:))]
        #[unsafe(method_family = none)]
        fn applicationDidEnterBackground(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        /// Tells the delegate that the application is about to enter the foreground
        /// - Note: This method is not called if `UIScene` lifecycle has been adopted.
        #[deprecated = "Use UIScene lifecycle and sceneWillEnterForeground(_:) from UISceneDelegate or the UIApplication.willEnterForegroundNotification instead."]
        #[optional]
        #[unsafe(method(applicationWillEnterForeground:))]
        #[unsafe(method_family = none)]
        fn applicationWillEnterForeground(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[deprecated]
        #[optional]
        #[unsafe(method(application:handleOpenURL:))]
        #[unsafe(method_family = none)]
        fn application_handleOpenURL(&self, application: &UIApplication, url: &NSURL) -> bool;

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `annotation` should be of the correct type.
        #[deprecated]
        #[optional]
        #[unsafe(method(application:openURL:sourceApplication:annotation:))]
        #[unsafe(method_family = none)]
        unsafe fn application_openURL_sourceApplication_annotation(
            &self,
            application: &UIApplication,
            url: &NSURL,
            source_application: Option<&NSString>,
            annotation: &AnyObject,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// Return NO if the application can't open the `url` for some reason
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[deprecated = "Use UIScene lifecycle and scene(_:openURLContexts:) from UISceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:openURL:options:))]
        #[unsafe(method_family = none)]
        unsafe fn application_openURL_options(
            &self,
            app: &UIApplication,
            url: &NSURL,
            options: &NSDictionary<UIApplicationOpenURLOptionsKey, AnyObject>,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationDidReceiveMemoryWarning:))]
        #[unsafe(method_family = none)]
        fn applicationDidReceiveMemoryWarning(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationWillTerminate:))]
        #[unsafe(method_family = none)]
        fn applicationWillTerminate(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationSignificantTimeChange:))]
        #[unsafe(method_family = none)]
        fn applicationSignificantTimeChange(&self, application: &UIApplication);

        #[cfg(all(feature = "UIOrientation", feature = "UIResponder"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:willChangeStatusBarOrientation:duration:))]
        #[unsafe(method_family = none)]
        fn application_willChangeStatusBarOrientation_duration(
            &self,
            application: &UIApplication,
            new_status_bar_orientation: UIInterfaceOrientation,
            duration: NSTimeInterval,
        );

        #[cfg(all(feature = "UIOrientation", feature = "UIResponder"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:didChangeStatusBarOrientation:))]
        #[unsafe(method_family = none)]
        fn application_didChangeStatusBarOrientation(
            &self,
            application: &UIApplication,
            old_status_bar_orientation: UIInterfaceOrientation,
        );

        #[cfg(all(feature = "UIResponder", feature = "objc2-core-foundation"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:willChangeStatusBarFrame:))]
        #[unsafe(method_family = none)]
        fn application_willChangeStatusBarFrame(
            &self,
            application: &UIApplication,
            new_status_bar_frame: CGRect,
        );

        #[cfg(all(feature = "UIResponder", feature = "objc2-core-foundation"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:didChangeStatusBarFrame:))]
        #[unsafe(method_family = none)]
        fn application_didChangeStatusBarFrame(
            &self,
            application: &UIApplication,
            old_status_bar_frame: CGRect,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIUserNotificationSettings"))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]"]
        #[optional]
        #[unsafe(method(application:didRegisterUserNotificationSettings:))]
        #[unsafe(method_family = none)]
        fn application_didRegisterUserNotificationSettings(
            &self,
            application: &UIApplication,
            notification_settings: &UIUserNotificationSettings,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didRegisterForRemoteNotificationsWithDeviceToken:))]
        #[unsafe(method_family = none)]
        fn application_didRegisterForRemoteNotificationsWithDeviceToken(
            &self,
            application: &UIApplication,
            device_token: &NSData,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didFailToRegisterForRemoteNotificationsWithError:))]
        #[unsafe(method_family = none)]
        fn application_didFailToRegisterForRemoteNotificationsWithError(
            &self,
            application: &UIApplication,
            error: &NSError,
        );

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:] for user visible notifications and -[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:] for silent remote notifications"]
        #[optional]
        #[unsafe(method(application:didReceiveRemoteNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didReceiveRemoteNotification(
            &self,
            application: &UIApplication,
            user_info: &NSDictionary,
        );

        #[cfg(all(feature = "UILocalNotification", feature = "UIResponder"))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:didReceiveLocalNotification:))]
        #[unsafe(method_family = none)]
        fn application_didReceiveLocalNotification(
            &self,
            application: &UIApplication,
            notification: &UILocalNotification,
        );

        #[cfg(all(
            feature = "UILocalNotification",
            feature = "UIResponder",
            feature = "block2"
        ))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forLocalNotification:completionHandler:))]
        #[unsafe(method_family = none)]
        fn application_handleActionWithIdentifier_forLocalNotification_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            notification: &UILocalNotification,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// # Safety
        ///
        /// - `user_info` generic should be of the correct type.
        /// - `response_info` generic should be of the correct type.
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forRemoteNotification_withResponseInfo_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            user_info: &NSDictionary,
            response_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forRemoteNotification:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forRemoteNotification_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            user_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(
            feature = "UILocalNotification",
            feature = "UIResponder",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `response_info` generic should be of the correct type.
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forLocalNotification:withResponseInfo:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forLocalNotification_withResponseInfo_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            notification: &UILocalNotification,
            response_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// This delegate method offers an opportunity for applications with the "remote-notification" background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.
        ///
        /// This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[optional]
        #[unsafe(method(application:didReceiveRemoteNotification:fetchCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didReceiveRemoteNotification_fetchCompletionHandler(
            &self,
            application: &UIApplication,
            user_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn(UIBackgroundFetchResult)>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// Applications with the "fetch" background mode may be given opportunities to fetch updated content in the background or when it is convenient for the system. This method will be called in these situations. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.
        #[deprecated = "Use a BGAppRefreshTask in the BackgroundTasks framework instead"]
        #[optional]
        #[unsafe(method(application:performFetchWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        fn application_performFetchWithCompletionHandler(
            &self,
            application: &UIApplication,
            completion_handler: &block2::DynBlock<dyn Fn(UIBackgroundFetchResult)>,
        );

        #[cfg(all(
            feature = "UIApplicationShortcutItem",
            feature = "UIResponder",
            feature = "block2"
        ))]
        /// Called when the user activates your application by selecting a shortcut on the home screen, except when `application(_:willFinishLaunchingWithOptions:)`
        /// or `application(_:didFinishLaunchingWithOptions:)` returns `false`.
        #[deprecated = "Use UIScene lifecycle and windowScene(_:performActionFor:completionHandler:) from UIWindowSceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:performActionForShortcutItem:completionHandler:))]
        #[unsafe(method_family = none)]
        fn application_performActionForShortcutItem_completionHandler(
            &self,
            application: &UIApplication,
            shortcut_item: &UIApplicationShortcutItem,
            completion_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        #[optional]
        #[unsafe(method(application:handleEventsForBackgroundURLSession:completionHandler:))]
        #[unsafe(method_family = none)]
        fn application_handleEventsForBackgroundURLSession_completionHandler(
            &self,
            application: &UIApplication,
            identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[optional]
        #[unsafe(method(application:handleWatchKitExtensionRequest:reply:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleWatchKitExtensionRequest_reply(
            &self,
            application: &UIApplication,
            user_info: Option<&NSDictionary>,
            reply: &block2::DynBlock<dyn Fn(*mut NSDictionary)>,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationShouldRequestHealthAuthorization:))]
        #[unsafe(method_family = none)]
        fn applicationShouldRequestHealthAuthorization(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationProtectedDataWillBecomeUnavailable:))]
        #[unsafe(method_family = none)]
        fn applicationProtectedDataWillBecomeUnavailable(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationProtectedDataDidBecomeAvailable:))]
        #[unsafe(method_family = none)]
        fn applicationProtectedDataDidBecomeAvailable(&self, application: &UIApplication);

        #[cfg(all(feature = "UIResponder", feature = "UIView", feature = "UIWindow"))]
        #[optional]
        #[unsafe(method(window))]
        #[unsafe(method_family = none)]
        fn window(&self) -> Option<Retained<UIWindow>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView", feature = "UIWindow"))]
        /// Setter for [`window`][Self::window].
        #[optional]
        #[unsafe(method(setWindow:))]
        #[unsafe(method_family = none)]
        fn setWindow(&self, window: Option<&UIWindow>);

        #[cfg(all(
            feature = "UIOrientation",
            feature = "UIResponder",
            feature = "UIView",
            feature = "UIWindow"
        ))]
        #[optional]
        #[unsafe(method(application:supportedInterfaceOrientationsForWindow:))]
        #[unsafe(method_family = none)]
        fn application_supportedInterfaceOrientationsForWindow(
            &self,
            application: &UIApplication,
            window: Option<&UIWindow>,
        ) -> UIInterfaceOrientationMask;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:shouldAllowExtensionPointIdentifier:))]
        #[unsafe(method_family = none)]
        fn application_shouldAllowExtensionPointIdentifier(
            &self,
            application: &UIApplication,
            extension_point_identifier: &UIApplicationExtensionPointIdentifier,
        ) -> bool;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:viewControllerWithRestorationIdentifierPath:coder:))]
        #[unsafe(method_family = none)]
        unsafe fn application_viewControllerWithRestorationIdentifierPath_coder(
            &self,
            application: &UIApplication,
            identifier_components: &NSArray<NSString>,
            coder: &NSCoder,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:shouldSaveSecureApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldSaveSecureApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:shouldRestoreSecureApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldRestoreSecureApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:willEncodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willEncodeRestorableStateWithCoder(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:didDecodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didDecodeRestorableStateWithCoder(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[deprecated = "Use application:shouldSaveSecureApplicationState: instead"]
        #[optional]
        #[unsafe(method(application:shouldSaveApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldSaveApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[deprecated = "Use application:shouldRestoreSecureApplicationState: instead"]
        #[optional]
        #[unsafe(method(application:shouldRestoreApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldRestoreApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// Called on the main thread as soon as the user indicates they want to continue an activity in your application. The ``NSUserActivity`` object may not be available
        /// instantly, so use this as an opportunity to show the user that an activity will be continued shortly.
        ///
        /// For each `application(_:willContinueUserActivityWithType:)` invocation, you are guaranteed to get exactly one invocation of `application(_:continue:restorationHandler:)`
        /// on success, or `application(_:didFailToContinueUserActivityWithType:error:)` if an error was encountered.
        #[deprecated = "Use UIScene lifecycle and scene(_:willContinueUserActivityWithType:) from UISceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:willContinueUserActivityWithType:))]
        #[unsafe(method_family = none)]
        fn application_willContinueUserActivityWithType(
            &self,
            application: &UIApplication,
            user_activity_type: &NSString,
        ) -> bool;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIUserActivity",
            feature = "block2"
        ))]
        /// Called on the main thread after the ``NSUserActivity`` object is available. Use the data you stored in the ``NSUserActivity`` object to re-create what the user
        /// was doing. You can create/fetch any restorable objects associated with the user activity, and pass them to the `restorationHandler`. They will then have the
        /// `UIResponder` `restoreUserActivityState:` method invoked with the user activity. Invoking the `restorationHandler` is optional. It may be copied and
        /// invoked later, and it will bounce to the main thread to complete its work and call `restoreUserActivityState` on all objects.
        #[deprecated = "Use UIScene lifecycle and scene(_:continue:) from UISceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:continueUserActivity:restorationHandler:))]
        #[unsafe(method_family = none)]
        fn application_continueUserActivity_restorationHandler(
            &self,
            application: &UIApplication,
            user_activity: &NSUserActivity,
            restoration_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<ProtocolObject<dyn UIUserActivityRestoring>>),
            >,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        /// If the user activity cannot be fetched after `application(_:willContinueUserActivityWithType:)` is called, this will be called on the main thread when implemented.
        #[deprecated = "Use UIScene lifecycle and scene(_:didFailToContinueUserActivityWithType:error:) from UISceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:didFailToContinueUserActivityWithType:error:))]
        #[unsafe(method_family = none)]
        fn application_didFailToContinueUserActivityWithType_error(
            &self,
            application: &UIApplication,
            user_activity_type: &NSString,
            error: &NSError,
        );

        #[cfg(feature = "UIResponder")]
        /// This is called on the main thread when a user activity managed by UIKit has been updated. You can use this as a last chance to add additional data to the userActivity.
        #[deprecated = "Use UIScene lifecycle and scene(_:didUpdate) from UISceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:didUpdateUserActivity:))]
        #[unsafe(method_family = none)]
        fn application_didUpdateUserActivity(
            &self,
            application: &UIApplication,
            user_activity: &NSUserActivity,
        );

        #[cfg(all(feature = "UIResponder", feature = "objc2-cloud-kit"))]
        /// This will be called on the main thread after the user indicates they want to accept a CloudKit sharing invitation in your application.
        /// You should use the `CKShareMetadata` object's `shareURL` and `containerIdentifier` to schedule a `CKAcceptSharesOperation`, then start using
        /// the resulting `CKShare` and its associated record(s), which will appear in the `CKContainer`'s shared database in a zone matching that of the record's owner.
        #[deprecated = "Use UIScene lifecycle and windowScene(_:userDidAcceptCloudKitShareWith:) from UIWindowSceneDelegate instead."]
        #[optional]
        #[unsafe(method(application:userDidAcceptCloudKitShareWithMetadata:))]
        #[unsafe(method_family = none)]
        fn application_userDidAcceptCloudKitShareWithMetadata(
            &self,
            application: &UIApplication,
            cloud_kit_share_metadata: &CKShareMetadata,
        );

        #[cfg(all(
            feature = "UIResponder",
            feature = "UISceneConfiguration",
            feature = "UISceneOptions",
            feature = "UISceneSession"
        ))]
        #[optional]
        #[unsafe(method(application:configurationForConnectingSceneSession:options:))]
        #[unsafe(method_family = none)]
        fn application_configurationForConnectingSceneSession_options(
            &self,
            application: &UIApplication,
            connecting_scene_session: &UISceneSession,
            options: &UISceneConnectionOptions,
        ) -> Retained<UISceneConfiguration>;

        #[cfg(all(feature = "UIResponder", feature = "UISceneSession"))]
        #[optional]
        #[unsafe(method(application:didDiscardSceneSessions:))]
        #[unsafe(method_family = none)]
        fn application_didDiscardSceneSessions(
            &self,
            application: &UIApplication,
            scene_sessions: &NSSet<UISceneSession>,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationShouldAutomaticallyLocalizeKeyCommands:))]
        #[unsafe(method_family = none)]
        fn applicationShouldAutomaticallyLocalizeKeyCommands(
            &self,
            application: &UIApplication,
        ) -> bool;
    }
);

/// UIApplicationDeprecated.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(isProximitySensingEnabled))]
        #[unsafe(method_family = none)]
        pub fn isProximitySensingEnabled(&self) -> bool;

        /// Setter for [`isProximitySensingEnabled`][Self::isProximitySensingEnabled].
        #[deprecated]
        #[unsafe(method(setProximitySensingEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setProximitySensingEnabled(&self, proximity_sensing_enabled: bool);

        #[deprecated = "Use -[UIViewController prefersStatusBarHidden]"]
        #[unsafe(method(setStatusBarHidden:animated:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarHidden_animated(&self, hidden: bool, animated: bool);

        #[cfg(feature = "UIOrientation")]
        /// Setter for [`statusBarOrientation`][Self::statusBarOrientation].
        #[deprecated = "Explicit setting of the status bar orientation is more limited in iOS 6.0 and later"]
        #[unsafe(method(setStatusBarOrientation:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarOrientation(&self, status_bar_orientation: UIInterfaceOrientation);

        #[cfg(feature = "UIOrientation")]
        #[deprecated = "Explicit setting of the status bar orientation is more limited in iOS 6.0 and later"]
        #[unsafe(method(setStatusBarOrientation:animated:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarOrientation_animated(
            &self,
            interface_orientation: UIInterfaceOrientation,
            animated: bool,
        );

        /// Setter for [`statusBarStyle`][Self::statusBarStyle].
        #[deprecated = "Use -[UIViewController preferredStatusBarStyle]"]
        #[unsafe(method(setStatusBarStyle:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarStyle(&self, status_bar_style: UIStatusBarStyle);

        #[deprecated = "Use -[UIViewController preferredStatusBarStyle]"]
        #[unsafe(method(setStatusBarStyle:animated:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarStyle_animated(
            &self,
            status_bar_style: UIStatusBarStyle,
            animated: bool,
        );

        /// Setter for [`isStatusBarHidden`][Self::isStatusBarHidden].
        #[deprecated = "Use -[UIViewController prefersStatusBarHidden]"]
        #[unsafe(method(setStatusBarHidden:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarHidden(&self, status_bar_hidden: bool);

        #[deprecated = "Use -[UIViewController prefersStatusBarHidden]"]
        #[unsafe(method(setStatusBarHidden:withAnimation:))]
        #[unsafe(method_family = none)]
        pub fn setStatusBarHidden_withAnimation(
            &self,
            hidden: bool,
            animation: UIStatusBarAnimation,
        );

        #[cfg(feature = "block2")]
        #[deprecated = "Please use PushKit for VoIP applications instead of calling this method"]
        #[unsafe(method(setKeepAliveTimeout:handler:))]
        #[unsafe(method_family = none)]
        pub fn setKeepAliveTimeout_handler(
            &self,
            timeout: NSTimeInterval,
            keep_alive_handler: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> bool;

        #[deprecated = "Please use PushKit for VoIP applications instead of calling this method"]
        #[unsafe(method(clearKeepAliveTimeout))]
        #[unsafe(method_family = none)]
        pub fn clearKeepAliveTimeout(&self);
    );
}

#[cfg(feature = "UIResponder")]
impl UIApplication {
    /// Creates the application object and the application delegate and sets up the event cycle.
    ///
    /// Parameters:
    /// - argc: The count of arguments in `argv`; this usually is the corresponding parameter to `main`.
    ///
    /// - argv: A variable list of arguments; this usually is the corresponding parameter to `main`.
    ///
    /// - principalClassName: The name of the [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) class or subclass. If you specify `nil`, `UIApplication` is assumed.
    ///
    /// - delegateClassName: The name of the class from which the application delegate is instantiated. If `principalClassName` designates a subclass of [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication), you may designate the subclass as the delegate; the subclass instance receives the application-delegate messages. Specify `nil` if you load the delegate object from your application’s main nib file.
    ///
    ///
    /// ## Return Value
    ///
    /// Even though an integer return type is specified, this function never returns. When users exits an iOS app by pressing the Home button, the application moves to the background.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function instantiates the application object from the principal class and instantiates the delegate (if any) from the given class and sets the delegate for the application. It also sets up the main event loop, including the application’s run loop, and begins processing events. If the application’s `Info.plist` file specifies a main nib file to be loaded, by including the [`NSMainNibFile`](https://developer.apple.com/documentation/bundleresources/information-property-list/nsmainnibfile) key and a valid nib file name for the value, this function loads that nib file.
    ///
    /// Despite the declared return type, this function never returns.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `argv` must be a valid pointer.
    #[doc(alias = "UIApplicationMain")]
    #[inline]
    pub(crate) unsafe fn __main(
        argc: c_int,
        argv: NonNull<*mut c_char>,
        principal_class_name: Option<&NSString>,
        delegate_class_name: Option<&NSString>,
    ) -> c_int {
        extern "C-unwind" {
            fn UIApplicationMain(
                argc: c_int,
                argv: NonNull<*mut c_char>,
                principal_class_name: Option<&NSString>,
                delegate_class_name: Option<&NSString>,
            ) -> c_int;
        }
        unsafe { UIApplicationMain(argc, argv, principal_class_name, delegate_class_name) }
    }
}

extern "C" {
    /// The mode set while tracking in controls takes place.
    ///
    /// ## Discussion
    ///
    /// You can use this mode to add timers that fire during tracking.
    ///
    ///
    pub static UITrackingRunLoopMode: &'static NSRunLoopMode;
}

extern "C" {
    /// A notification that posts when the app enters the background.
    ///
    /// ## Discussion
    ///
    /// The `object` of the notification is the [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) object. There is no `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationDidEnterBackgroundNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts shortly before an app leaves the background state on its way to becoming the active app.
    ///
    /// ## Discussion
    ///
    /// The `object` of the notification is the [`UIApplication`](https://developer.apple.com/documentation/uikit/uiapplication) object. There is no `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationWillEnterForegroundNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts immediately after the app finishes launching.
    ///
    /// ## Discussion
    ///
    /// If the app was launched as a result of in remote notification targeted at it or because another app opened a URL resource claimed the posting app (the notification `object`), this notification contains a `userInfo` dictionary. You can access the contents of the dictionary using the [`UIApplicationLaunchOptionsURLKey`](https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/url) and [`UIApplicationLaunchOptionsSourceApplicationKey`](https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/sourceapplication) constants (for URLs), the [`UIApplicationLaunchOptionsRemoteNotificationKey`](https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/remotenotification) constant (for remote notifications), and the [`UIApplicationLaunchOptionsLocalNotificationKey`](https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/localnotification) constant (for local notifications). If the notification was posted for a normal app launch, there is no `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationDidFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when the app becomes active.
    ///
    /// ## Discussion
    ///
    /// An app is active when it is receiving events. An active app can be said to have focus. It gains focus after being launched, loses focus when an overlay window pops up or when the device is locked, and gains focus when the device is unlocked.
    ///
    ///
    pub static UIApplicationDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when the app is no longer active and loses focus.
    ///
    /// ## Discussion
    ///
    /// An app is active when it is receiving events. An active app can be said to have focus. It gains focus after being launched, loses focus when an overlay window pops up or when the device is locked, and gains focus when the device is unlocked.
    ///
    ///
    pub static UIApplicationWillResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when the app receives a warning from the operating system about low memory availability.
    ///
    /// ## Discussion
    ///
    /// This notification does not contain a `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationDidReceiveMemoryWarningNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when the app is about to terminate.
    ///
    /// ## Discussion
    ///
    /// This notification is associated with the delegate [`applicationWillTerminate:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/applicationwillterminate(_:)) method. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationWillTerminateNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when there’s a significant change in time.
    ///
    /// ## Discussion
    ///
    /// The system posts this notification when, for example, there’s a change to a new day (midnight), a carrier time update, or a change to, or from, daylight savings time. The notification doesn’t contain a user info dictionary.
    ///
    ///
    pub static UIApplicationSignificantTimeChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted when the app is about to change the orientation of its interface.
    ///
    /// ## Discussion
    ///
    /// The userInfo dictionary contains an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) that encapsulates a `UIInterfaceOrientation` value (see [`UIInterfaceOrientation`](https://developer.apple.com/documentation/uikit/uiinterfaceorientation)). Use [`UIApplicationStatusBarOrientationUserInfoKey`](https://developer.apple.com/documentation/uikit/uiapplication/statusbarorientationuserinfokey) to access this value.
    ///
    ///
    #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
    pub static UIApplicationWillChangeStatusBarOrientationNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted when the orientation of the app’s user interface changes.
    ///
    /// ## Discussion
    ///
    /// The `userInfo` dictionary contains an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that encapsulates a `UIInterfaceOrientation` value (see [`UIInterfaceOrientation`](https://developer.apple.com/documentation/uikit/uiinterfaceorientation)). Use [`UIApplicationStatusBarOrientationUserInfoKey`](https://developer.apple.com/documentation/uikit/uiapplication/statusbarorientationuserinfokey) to access this value
    ///
    ///
    #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
    pub static UIApplicationDidChangeStatusBarOrientationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A key whose value indicates the current interface orientation.
    ///
    /// ## Discussion
    ///
    /// The key’s value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that encapsulates a [`UIInterfaceOrientation`](https://developer.apple.com/documentation/uikit/uiinterfaceorientation) value indicating the current orientation.  This key is used with [`UIApplicationDidChangeStatusBarOrientationNotification`](https://developer.apple.com/documentation/uikit/uiapplication/didchangestatusbarorientationnotification) and [`UIApplicationWillChangeStatusBarOrientationNotification`](https://developer.apple.com/documentation/uikit/uiapplication/willchangestatusbarorientationnotification) notifications.
    ///
    ///
    #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
    pub static UIApplicationStatusBarOrientationUserInfoKey: &'static NSString;
}

extern "C" {
    /// Posted when the app is about to change the frame of the status bar.
    ///
    /// ## Discussion
    ///
    /// The `userInfo` dictionary contains an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) object that encapsulates a [`CGRect`](https://developer.apple.com/documentation/corefoundation/cgrect) structure expressing the location and size of the new status bar frame. Use [`UIApplicationStatusBarFrameUserInfoKey`](https://developer.apple.com/documentation/uikit/uiapplication/statusbarframeuserinfokey) to access this value.
    ///
    ///
    #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
    pub static UIApplicationWillChangeStatusBarFrameNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted when the frame of the status bar changes.
    ///
    /// ## Discussion
    ///
    /// The `userInfo` dictionary contains an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) object that encapsulates a [`CGRect`](https://developer.apple.com/documentation/corefoundation/cgrect) structure expressing the location and size of the new status bar frame. Use [`UIApplicationStatusBarFrameUserInfoKey`](https://developer.apple.com/documentation/uikit/uiapplication/statusbarframeuserinfokey) to access this value.
    ///
    ///
    #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
    pub static UIApplicationDidChangeStatusBarFrameNotification: &'static NSNotificationName;
}

extern "C" {
    /// A key whose value indicates the new status bar frame.
    ///
    /// ## Discussion
    ///
    /// The key’s value is an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) object that encapsulates a [`CGRect`](https://developer.apple.com/documentation/corefoundation/cgrect) structure expressing the location and size of the new status bar frame. This key is used with [`UIApplicationDidChangeStatusBarFrameNotification`](https://developer.apple.com/documentation/uikit/uiapplication/didchangestatusbarframenotification) and [`UIApplicationWillChangeStatusBarFrameNotification`](https://developer.apple.com/documentation/uikit/uiapplication/willchangestatusbarframenotification) notifications.
    ///
    ///
    #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
    pub static UIApplicationStatusBarFrameUserInfoKey: &'static NSString;
}

extern "C" {
    /// A notification that posts when the app’s status for downloading content in the background changes.
    ///
    /// ## Discussion
    ///
    /// The system sends this notification when the [`backgroundRefreshStatus`](https://developer.apple.com/documentation/uikit/uiapplication/backgroundrefreshstatus) property of the app object changes. That property can change in response to the user disabling multitasking support for the app. The `object` of the notification is the `UIApplication` object. There is no `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationBackgroundRefreshStatusDidChangeNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts shortly before protected files are locked down and become inaccessible.
    ///
    /// ## Discussion
    ///
    /// Upon receiving this notification, clients should release any references to protected files. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationProtectedDataWillBecomeUnavailable: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when the protected files become available for your code to access.
    ///
    /// ## Discussion
    ///
    /// This notification does not contain a `userInfo` dictionary.
    ///
    ///
    pub static UIApplicationProtectedDataDidBecomeAvailable: &'static NSNotificationName;
}

extern "C" {
    /// A key indicating that the app was launched so that it could open the specified URL.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) object containing the URL to open. This key is also used to access the same value in the `userInfo` dictionary of the notification named [`UIApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/uikit/uiapplication/didfinishlaunchingnotification).
    ///
    ///
    /// UserInfo contains a ``NSURL`` with launch URL to open
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.URLContexts instead."]
    pub static UIApplicationLaunchOptionsURLKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that another app requested the launch of your app.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object containing the bundle ID of the app that made the request. If the request originated from another app belonging to your team, UIKit sets the value of this key to the ID of that app. If the team identifier of the originating app is different than the team identifier of the current app, the value of the key is `nil`.
    ///
    /// This key is also used to access the same value in the `userInfo` dictionary of the notification named  [`UIApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/uikit/uiapplication/didfinishlaunchingnotification).
    ///
    ///
    /// UserInfo contains a ``NSString`` with the bundle ID of the originating application; non-nil if the originating application and this application share the same team identifier
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.sourceApplication instead."]
    pub static UIApplicationLaunchOptionsSourceApplicationKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that a remote notification is available for the app to process.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSDictionary`](https://developer.apple.com/documentation/foundation/nsdictionary) containing the payload of the remote notification. See the description of [`application:didReceiveRemoteNotification:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didreceiveremotenotification:)) for further information about handling remote notifications.
    ///
    /// This key is also used to access the same value in the `userInfo` dictionary of the notification named [`UIApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/uikit/uiapplication/didfinishlaunchingnotification).
    ///
    ///
    /// UserInfo contains a ``NSDictionary`` notification payload with property-list objects plus ``NSNull``
    #[deprecated = "Continue using UIApplicationDelegate's application(_:didReceiveRemoteNotification:fetchCompletionHandler:) to process silent remote notifications after scene connection."]
    pub static UIApplicationLaunchOptionsRemoteNotificationKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app was launched to handle a local notification.
    ///
    /// ## Discussion
    ///
    /// The value of this key is the [`UILocalNotification`](https://developer.apple.com/documentation/uikit/uilocalnotification) object that was triggered. For additional information about handling local notifications, see the [`application:didReceiveLocalNotification:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didreceive:)) method.
    ///
    /// This key is also used to access the same value in the `userInfo` dictionary of the notification named [`UIApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/uikit/uiapplication/didfinishlaunchingnotification).
    ///
    ///
    /// UserInfo contains a ``UILocalNotification``
    #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
    pub static UIApplicationLaunchOptionsLocalNotificationKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the URL passed to your app contained custom annotation data from the source app.
    ///
    /// ## Discussion
    ///
    /// The presence of this key indicates that custom data was provided by the app that requested the opening of the URL. The value of this key is a property-list object containing the custom data. The same object is also passed to the annotation parameter of the  [`application:openURL:sourceApplication:annotation:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:open:sourceapplication:annotation:)) method. The contents of this property-list object are specific to the app that made the request.
    ///
    ///
    /// UserInfo contains a property list annotation object
    #[deprecated = "This dictionary key is no longer used."]
    pub static UIApplicationLaunchOptionsAnnotationKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app was launched to handle an incoming location event.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value. You should use the presence of this key as a signal to create a [`CLLocationManager`](https://developer.apple.com/documentation/corelocation/cllocationmanager) object and start location services again. Location data is delivered only to the location manager delegate and not using this key.
    ///
    ///
    /// The app was launched in response to a CoreLocation event
    #[deprecated = "Adopt CLLocationUpdate or CLMonitor, or use CLLocationManagerDelegate from CoreLocation to handle expected location events after scene connection."]
    pub static UIApplicationLaunchOptionsLocationKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app was launched to process newly downloaded Newsstand assets.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an array of string identifiers that identify the `NKAssetDownload` objects corresponding to the assets. Although you can use the identifiers for cross-checking purposes, you should obtain the definitive array of `NKAssetDownload` objects (representing asset downloads in progress or in error) through the `downloadingAssets` property of the `NKLibrary` object representing the Newsstand app’s library.
    ///
    ///
    /// UserInfo contains an ``NSArray`` of ``NKAssetDownload`` identifiers
    #[deprecated = "This dictionary key is no longer used."]
    pub static UIApplicationLaunchOptionsNewsstandDownloadsKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app was relaunched to handle Bluetooth-related events.
    ///
    /// ## Discussion
    ///
    /// The presence of this key indicates that the app previously had one or more [`CBCentralManager`](https://developer.apple.com/documentation/corebluetooth/cbcentralmanager) objects and was relaunched by the Bluetooth system to continue actions associated with those objects. The value of this key is an [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray) object containing one or more [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) objects.
    ///
    /// Each string in the array represents the restoration identifier for a central manager object. This is the same string you assigned to the [`CBCentralManagerOptionRestoreIdentifierKey`](https://developer.apple.com/documentation/corebluetooth/cbcentralmanageroptionrestoreidentifierkey) key when you initialized the central manager object previously. The system provides the restoration identifiers only for central managers that had active or pending peripheral connections or were scanning for peripherals.
    ///
    ///
    /// UserInfo contains an ``NSArray`` of ``CBCentralManager`` restore identifiers
    #[deprecated = "Store restoration identifiers and reinstantiate central managers with those identifiers on app launch to resume previous functionality."]
    pub static UIApplicationLaunchOptionsBluetoothCentralsKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app should continue actions associated with its Bluetooth peripheral objects.
    ///
    /// ## Discussion
    ///
    /// The presence of this key indicates that the app previously had one or more [`CBPeripheralManager`](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanager) objects and was relaunched by the Bluetooth system to continue actions associated with those objects. The value of this key is an [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray) object containing one or more [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) objects.
    ///
    /// Each string in the array represents the restoration identifier for a peripheral manager object. This is the same string you assigned to the [`CBPeripheralManagerOptionRestoreIdentifierKey`](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanageroptionrestoreidentifierkey) key when you initialized the peripheral manager object previously. The system provides the restoration identifiers only for peripheral managers that had published or advertised services.
    ///
    ///
    /// UserInfo contains an ``NSArray`` of ``CBPeripheralManager`` restore identifiers
    #[deprecated = "Store restoration identifiers and reinstantiate peripheral managers with those identifiers on app launch to resume previous functionality."]
    pub static UIApplicationLaunchOptionsBluetoothPeripheralsKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app was launched in response to the user selecting a Home screen quick action.
    ///
    /// ## Discussion
    ///
    /// The value of this key is the [`UIApplicationShortcutItem`](https://developer.apple.com/documentation/uikit/uiapplicationshortcutitem) object representing the action that the user selected.
    ///
    ///
    /// UserInfo contains the ``UIApplicationShortcutItem`` used to launch the app
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.shortcutItem instead."]
    pub static UIApplicationLaunchOptionsShortcutItemKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// UserInfo contains a ``UIEventAttribution`` to go along with a URL open on launch
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.eventAttribution instead."]
    pub static UIApplicationLaunchOptionsEventAttributionKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating a dictionary associated with an activity that the user wants to continue.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSDictionary`](https://developer.apple.com/documentation/foundation/nsdictionary) object containing the key [`UIApplicationLaunchOptionsUserActivityTypeKey`](https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/useractivitytype), whose value is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object identifying the activity type.
    ///
    ///
    /// Key in options dictionary passed to `application(_:willFinishLaunchingWithOptions:)` and `application(_:didFinishLaunchingWithOptions:)`
    /// and info for `UIApplication.didFinishLaunchingNotification`. Sub-Dictionary present in launch options when user activity is present.
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.userActivities instead."]
    pub static UIApplicationLaunchOptionsUserActivityDictionaryKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating the type of user activity that the user wants to continue.
    ///
    /// ## Discussion
    ///
    /// This key is used in the subdictionary which is the value of [`UIApplicationLaunchOptionsShortcutItemKey`](https://developer.apple.com/documentation/uikit/uiapplication/launchoptionskey/shortcutitem). The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object identifying the activity type.
    ///
    ///
    /// Key in user activity dictionary for the activity type
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.handoffUserActivityType instead."]
    pub static UIApplicationLaunchOptionsUserActivityTypeKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// A key indicating that the app received a CloudKit share invitation.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CKShareMetadata`](https://developer.apple.com/documentation/cloudkit/ckshare/metadata) object. Schedule a [`CKAcceptSharesOperation`](https://developer.apple.com/documentation/cloudkit/ckacceptsharesoperation) task with the provided metadata object.
    ///
    ///
    /// The presence of this key indicates that the app was launched in order to handle a CloudKit sharing invitation. The value of this key is a ``CKShareMetadata`` object.
    #[deprecated = "Use UIScene lifecycle and UIScene.ConnectionOptions.cloudKitShareMetadata instead."]
    pub static UIApplicationLaunchOptionsCloudKitShareMetadataKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// The URL string you use to deep link to your app’s custom settings in the Settings app.
    ///
    /// ## Discussion
    ///
    /// Create a URL from this value and pass it to the [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/open(_:options:completionhandler:)) method to launch the Settings app and display your app’s custom settings, if it has any.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Create the URL that deep links to your app's custom settings.", "if let url = URL(string: UIApplication.openSettingsURLString) {", "    // Ask the system to open that URL.", "    await UIApplication.shared.open(url)", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Create the URL that deep links to your app's custom settings.", "NSURL *url = [[NSURL alloc] initWithString:UIApplicationOpenSettingsURLString];", "// Ask the system to open that URL.", "[[UIApplication sharedApplication] openURL:url", "                                   options:@{}", "                         completionHandler:nil];"], metadata: None }] }] })
    /// For design guidance, see [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/settings/).
    ///
    ///
    pub static UIApplicationOpenSettingsURLString: &'static NSString;
}

extern "C" {
    /// The URL string used to select a default app in the Settings app.
    ///
    /// ## Discussion
    ///
    /// Create a URL from this value and pass it to the [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/open(_:options:completionhandler:)) method to launch the Settings app and display your app’s custom settings, if it has any:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Create the URL that links to the Settings app for default app selection.", "if let url = URL(string: UIApplication.openDefaultApplicationsSettingsURLString) {", "    // Ask the system to open that URL.", "    await UIApplication.shared.open(url)", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Create the URL that links to the Settings app for default app selection.", "NSURL *url = [[NSURL alloc] initWithString:UIApplicationOpenDefaultApplicationsSettingsURLString];", "// Ask the system to open that URL.", "[[UIApplication sharedApplication] openURL:url", "                                   options:@{}", "                         completionHandler:nil];"], metadata: None }] }] })
    /// For design guidance, see Human Interface Guidelines > [Settings](https://developer.apple.com/design/human-interface-guidelines/).
    ///
    ///
    /// The URL string you use to deep link to settings for default app selection in the Settings app.
    pub static UIApplicationOpenDefaultApplicationsSettingsURLString: &'static NSString;
}

extern "C" {
    /// A constant that provides the URL string you use to deep link to your app’s notification settings in the Settings app.
    ///
    /// ## Discussion
    ///
    /// Create a URL from this value and pass it to the [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/open(_:options:completionhandler:)) method to launch the Settings app and display your app’s notification settings, if it has any.
    ///
    /// ```objc
    /// // Create the URL that deep links to your app's notification settings.
    /// NSURL *url = [[NSURL alloc] initWithString:UIApplicationOpenNotificationSettingsURLString];
    /// // Ask the system to open that URL.
    /// [[UIApplication sharedApplication] openURL:url
    ///                                    options:@{}
    ///                          completionHandler:nil];
    /// ```
    ///
    ///
    pub static UIApplicationOpenNotificationSettingsURLString: &'static NSString;
}

extern "C" {
    /// A key containing the bundle ID of the app that sent the open-URL request to your app.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object containing the bundle ID of the app that made the request. If the request originated from another app belonging to your team, UIKit sets the value of this key to the ID of that app. If the team identifier of the originating app is different than the team identifier of the current app, the value of the key is `nil`.
    ///
    ///
    /// An options key for `application(_:open:options:)`. The value is an ``NSString`` containing the bundle ID of the originating application; non-nil if the originating
    /// application and this application share the same team identifier.
    #[deprecated = "Use UIScene lifecycle and UISceneOpenURLOptions.sourceApplication from a UIOpenURLContext in UIScene.ConnectionOptions.URLContexts instead."]
    pub static UIApplicationOpenURLOptionsSourceApplicationKey:
        &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// A key containing the information passed to a document interaction controller object’s annotation property.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a property list-typed object.
    ///
    ///
    /// An options key for `application(_:open:options:)`. The value is a property-list typed object corresponding to what the originating application passed in
    /// `UIDocumentInteractionController`'s annotation property.
    #[deprecated = "Use UIScene lifecycle and UISceneOpenURLOptions.annotation from a UIOpenURLContext in UIScene.ConnectionOptions.URLContexts instead."]
    pub static UIApplicationOpenURLOptionsAnnotationKey: &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// A key containing a flag that indicates whether a document must be copied before you use it.
    ///
    /// ## Discussion
    ///
    /// When the value of this property is [`false`](https://developer.apple.com/documentation/swift/false), you must copy the document to maintain access to it. If the flag is not set, you also must copy the document before you can use it.
    ///
    /// If the document does not need to be copied, you can open it in place in your implementation of the [`application:openURL:options:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:open:options:)) method. For information about declaring whether your app wants the ability to open iCloud Drive documents in place, see the description of the [LSSupportsOpeningDocumentsInPlace](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-SW13) information property list key. For an example of an app that opens iCloud Drive documents in place, see [ShapeEdit: Building a Simple iCloud Document App](https://developer.apple.com/library/archive/samplecode/ShapeEdit/Introduction/Intro.html#//apple_ref/doc/uid/TP40016100).
    ///
    ///
    /// An options key for `application(_:open:options:)`. The value is a bool `NSNumber`. Copy the file before use if this value is NO, or is not present.
    #[deprecated = "Use UIScene lifecycle and UISceneOpenURLOptions.openInPlace from a UIOpenURLContext in UIScene.ConnectionOptions.URLContexts instead."]
    pub static UIApplicationOpenURLOptionsOpenInPlaceKey: &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// An options key for `application(_:open:options:)`. The value is a `UIEventAttribution` to go along with the URL to open.
    #[deprecated = "Use UIScene lifecycle and UISceneOpenURLOptions.eventAttribution from a UIOpenURLContext in UIScene.ConnectionOptions.URLContexts instead."]
    pub static UIApplicationOpenURLOptionsEventAttributionKey:
        &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// A notification that posts when a person takes a screenshot on the device.
    ///
    /// ## Discussion
    ///
    /// This notification doesn’t contain a `userInfo` dictionary. This notification posts after the screenshot is taken.
    ///
    ///
    pub static UIApplicationUserDidTakeScreenshotNotification: &'static NSNotificationName;
}

extern "C" {
    /// The identifier for custom keyboards.
    ///
    /// ## Discussion
    ///
    /// To reject the use of custom keyboards in your app, specify this constant in your implementation of the [`application:shouldAllowExtensionPointIdentifier:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:shouldallowextensionpointidentifier:)) delegate method.
    ///
    ///
    pub static UIApplicationKeyboardExtensionPointIdentifier:
        &'static UIApplicationExtensionPointIdentifier;
}

extern "C" {
    /// URLs must be universal links and have an app configured to open them.
    ///
    /// ## Discussion
    ///
    /// When you include this key in the options dictionary of the [`openURL:options:completionHandler:`](https://developer.apple.com/documentation/uikit/uiapplication/open(_:options:completionhandler:)) method, the method opens the URL only if the URL is a valid universal link and there is an installed app capable of opening that URL. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value.
    ///
    ///
    pub static UIApplicationOpenURLOptionUniversalLinksOnly:
        &'static UIApplicationOpenExternalURLOptionsKey;
}

extern "C" {
    /// An object you use to send tap event attribution data to the browser for Private Click Measurement.
    pub static UIApplicationOpenExternalURLOptionsEventAttributionKey:
        &'static UIApplicationOpenExternalURLOptionsKey;
}

extern "C-unwind" {
    #[deprecated = "renamed to `UIApplication::__main`"]
    pub fn UIApplicationMain(
        argc: c_int,
        argv: NonNull<*mut c_char>,
        principal_class_name: Option<&NSString>,
        delegate_class_name: Option<&NSString>,
    ) -> c_int;
}
