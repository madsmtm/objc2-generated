//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-cloud-kit")]
use objc2_cloud_kit::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uistatusbarstyle?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIStatusBarStyle(pub NSInteger);
impl UIStatusBarStyle {
    #[doc(alias = "UIStatusBarStyleDefault")]
    pub const Default: Self = Self(0);
    #[doc(alias = "UIStatusBarStyleLightContent")]
    pub const LightContent: Self = Self(1);
    #[doc(alias = "UIStatusBarStyleDarkContent")]
    pub const DarkContent: Self = Self(3);
    #[doc(alias = "UIStatusBarStyleBlackTranslucent")]
    #[deprecated]
    pub const BlackTranslucent: Self = Self(1);
    #[doc(alias = "UIStatusBarStyleBlackOpaque")]
    #[deprecated]
    pub const BlackOpaque: Self = Self(2);
}

unsafe impl Encode for UIStatusBarStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIStatusBarStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uistatusbaranimation?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIStatusBarAnimation(pub NSInteger);
impl UIStatusBarAnimation {
    #[doc(alias = "UIStatusBarAnimationNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "UIStatusBarAnimationFade")]
    pub const Fade: Self = Self(1);
    #[doc(alias = "UIStatusBarAnimationSlide")]
    pub const Slide: Self = Self(2);
}

unsafe impl Encode for UIStatusBarAnimation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIStatusBarAnimation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationinvalidinterfaceorientationexception?language=objc)
    pub static UIApplicationInvalidInterfaceOrientationException: &'static NSExceptionName;
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiremotenotificationtype?language=objc)
// NS_OPTIONS
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIRemoteNotificationType(pub NSUInteger);
bitflags::bitflags! {
    impl UIRemoteNotificationType: NSUInteger {
        #[doc(alias = "UIRemoteNotificationTypeNone")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const None = 0;
        #[doc(alias = "UIRemoteNotificationTypeBadge")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const Badge = 1<<0;
        #[doc(alias = "UIRemoteNotificationTypeSound")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const Sound = 1<<1;
        #[doc(alias = "UIRemoteNotificationTypeAlert")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const Alert = 1<<2;
        #[doc(alias = "UIRemoteNotificationTypeNewsstandContentAvailability")]
#[deprecated = "Use UserNotifications Framework's UNAuthorizationOptions for user notifications and registerForRemoteNotifications for receiving remote notifications instead."]
        const NewsstandContentAvailability = 1<<3;
    }
}

unsafe impl Encode for UIRemoteNotificationType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIRemoteNotificationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uibackgroundfetchresult?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIBackgroundFetchResult(pub NSUInteger);
impl UIBackgroundFetchResult {
    #[doc(alias = "UIBackgroundFetchResultNewData")]
    pub const NewData: Self = Self(0);
    #[doc(alias = "UIBackgroundFetchResultNoData")]
    pub const NoData: Self = Self(1);
    #[doc(alias = "UIBackgroundFetchResultFailed")]
    pub const Failed: Self = Self(2);
}

unsafe impl Encode for UIBackgroundFetchResult {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UIBackgroundFetchResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uibackgroundrefreshstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIBackgroundRefreshStatus(pub NSInteger);
impl UIBackgroundRefreshStatus {
    #[doc(alias = "UIBackgroundRefreshStatusRestricted")]
    pub const Restricted: Self = Self(0);
    #[doc(alias = "UIBackgroundRefreshStatusDenied")]
    pub const Denied: Self = Self(1);
    #[doc(alias = "UIBackgroundRefreshStatusAvailable")]
    pub const Available: Self = Self(2);
}

unsafe impl Encode for UIBackgroundRefreshStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIBackgroundRefreshStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIApplicationState(pub NSInteger);
impl UIApplicationState {
    #[doc(alias = "UIApplicationStateActive")]
    pub const Active: Self = Self(0);
    #[doc(alias = "UIApplicationStateInactive")]
    pub const Inactive: Self = Self(1);
    #[doc(alias = "UIApplicationStateBackground")]
    pub const Background: Self = Self(2);
}

unsafe impl Encode for UIApplicationState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uibackgroundtaskidentifier?language=objc)
// NS_TYPED_ENUM
pub type UIBackgroundTaskIdentifier = NSUInteger;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uibackgroundtaskinvalid?language=objc)
    pub static UIBackgroundTaskInvalid: UIBackgroundTaskIdentifier;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiminimumkeepalivetimeout?language=objc)
    pub static UIMinimumKeepAliveTimeout: NSTimeInterval;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationbackgroundfetchintervalminimum?language=objc)
    pub static UIApplicationBackgroundFetchIntervalMinimum: NSTimeInterval;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationbackgroundfetchintervalnever?language=objc)
    pub static UIApplicationBackgroundFetchIntervalNever: NSTimeInterval;
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenexternalurloptionskey?language=objc)
// NS_TYPED_ENUM
pub type UIApplicationOpenExternalURLOptionsKey = NSString;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplication?language=objc)
    #[unsafe(super(UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "UIResponder")]
    pub struct UIApplication;
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for UIApplication {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UIApplication {}
);

#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(sharedApplication))]
        #[unsafe(method_family = none)]
        pub fn sharedApplication(mtm: MainThreadMarker) -> Retained<UIApplication>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UIApplicationDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn UIApplicationDelegate>>,
        );

        #[deprecated = "Use UIView's userInteractionEnabled property instead"]
        #[unsafe(method(beginIgnoringInteractionEvents))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginIgnoringInteractionEvents(&self);

        #[deprecated = "Use UIView's userInteractionEnabled property instead"]
        #[unsafe(method(endIgnoringInteractionEvents))]
        #[unsafe(method_family = none)]
        pub unsafe fn endIgnoringInteractionEvents(&self);

        #[deprecated = "Use UIView's userInteractionEnabled property instead"]
        #[unsafe(method(isIgnoringInteractionEvents))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIgnoringInteractionEvents(&self) -> bool;

        #[unsafe(method(isIdleTimerDisabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIdleTimerDisabled(&self) -> bool;

        /// Setter for [`isIdleTimerDisabled`][Self::isIdleTimerDisabled].
        #[unsafe(method(setIdleTimerDisabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdleTimerDisabled(&self, idle_timer_disabled: bool);

        #[deprecated]
        #[unsafe(method(openURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openURL(&self, url: &NSURL) -> bool;

        #[unsafe(method(canOpenURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canOpenURL(&self, url: &NSURL) -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(openURL:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openURL_options_completionHandler(
            &self,
            url: &NSURL,
            options: &NSDictionary<UIApplicationOpenExternalURLOptionsKey, AnyObject>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "UIEvent")]
        #[unsafe(method(sendEvent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendEvent(&self, event: &UIEvent);

        #[cfg(all(feature = "UIView", feature = "UIWindow"))]
        #[deprecated = "Should not be used for applications that support multiple scenes as it returns a key window across all connected scenes"]
        #[unsafe(method(keyWindow))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyWindow(&self) -> Option<Retained<UIWindow>>;

        #[cfg(all(feature = "UIView", feature = "UIWindow"))]
        #[deprecated = "Use UIWindowScene.windows on a relevant window scene instead"]
        #[unsafe(method(windows))]
        #[unsafe(method_family = none)]
        pub fn windows(&self) -> Retained<NSArray<UIWindow>>;

        #[cfg(feature = "UIEvent")]
        #[unsafe(method(sendAction:to:from:forEvent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendAction_to_from_forEvent(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
            event: Option<&UIEvent>,
        ) -> bool;

        #[deprecated = "Provide a custom network activity UI in your app if desired."]
        #[unsafe(method(isNetworkActivityIndicatorVisible))]
        #[unsafe(method_family = none)]
        pub unsafe fn isNetworkActivityIndicatorVisible(&self) -> bool;

        /// Setter for [`isNetworkActivityIndicatorVisible`][Self::isNetworkActivityIndicatorVisible].
        #[deprecated = "Provide a custom network activity UI in your app if desired."]
        #[unsafe(method(setNetworkActivityIndicatorVisible:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNetworkActivityIndicatorVisible(
            &self,
            network_activity_indicator_visible: bool,
        );

        #[cfg(all(feature = "UIOrientation", feature = "UIView", feature = "UIWindow"))]
        #[unsafe(method(supportedInterfaceOrientationsForWindow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedInterfaceOrientationsForWindow(
            &self,
            window: Option<&UIWindow>,
        ) -> UIInterfaceOrientationMask;

        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[unsafe(method(statusBarOrientationAnimationDuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn statusBarOrientationAnimationDuration(&self) -> NSTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[deprecated = "Use the statusBarManager property of the window scene instead."]
        #[unsafe(method(statusBarFrame))]
        #[unsafe(method_family = none)]
        pub fn statusBarFrame(&self) -> CGRect;

        #[deprecated = "Use -[UNUserNotificationCenter setBadgeCount:withCompletionHandler:] instead."]
        #[unsafe(method(applicationIconBadgeNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn applicationIconBadgeNumber(&self) -> NSInteger;

        /// Setter for [`applicationIconBadgeNumber`][Self::applicationIconBadgeNumber].
        #[deprecated = "Use -[UNUserNotificationCenter setBadgeCount:withCompletionHandler:] instead."]
        #[unsafe(method(setApplicationIconBadgeNumber:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setApplicationIconBadgeNumber(
            &self,
            application_icon_badge_number: NSInteger,
        );

        #[unsafe(method(applicationSupportsShakeToEdit))]
        #[unsafe(method_family = none)]
        pub unsafe fn applicationSupportsShakeToEdit(&self) -> bool;

        /// Setter for [`applicationSupportsShakeToEdit`][Self::applicationSupportsShakeToEdit].
        #[unsafe(method(setApplicationSupportsShakeToEdit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setApplicationSupportsShakeToEdit(
            &self,
            application_supports_shake_to_edit: bool,
        );

        #[unsafe(method(applicationState))]
        #[unsafe(method_family = none)]
        pub unsafe fn applicationState(&self) -> UIApplicationState;

        #[unsafe(method(backgroundTimeRemaining))]
        #[unsafe(method_family = none)]
        pub unsafe fn backgroundTimeRemaining(&self) -> NSTimeInterval;

        #[cfg(feature = "block2")]
        #[unsafe(method(beginBackgroundTaskWithExpirationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginBackgroundTaskWithExpirationHandler(
            &self,
            handler: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> UIBackgroundTaskIdentifier;

        #[cfg(feature = "block2")]
        #[unsafe(method(beginBackgroundTaskWithName:expirationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginBackgroundTaskWithName_expirationHandler(
            &self,
            task_name: Option<&NSString>,
            handler: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> UIBackgroundTaskIdentifier;

        #[unsafe(method(endBackgroundTask:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endBackgroundTask(&self, identifier: UIBackgroundTaskIdentifier);

        /// The system guarantees that it will not wake up your application for a background fetch more
        /// frequently than the interval provided. Set to UIApplicationBackgroundFetchIntervalMinimum to be
        /// woken as frequently as the system desires, or to UIApplicationBackgroundFetchIntervalNever (the
        /// default) to never be woken for a background fetch.
        ///
        /// This setter will have no effect unless your application has the "fetch"
        /// UIBackgroundMode. See the UIApplicationDelegate method
        /// `application:performFetchWithCompletionHandler:` for more.
        #[deprecated = "Use a BGAppRefreshTask in the BackgroundTasks framework instead"]
        #[unsafe(method(setMinimumBackgroundFetchInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumBackgroundFetchInterval(
            &self,
            minimum_background_fetch_interval: NSTimeInterval,
        );

        /// When background refresh is available for an application, it may launched or resumed in the background to handle significant
        /// location changes, remote notifications, background fetches, etc. Observe UIApplicationBackgroundRefreshStatusDidChangeNotification to
        /// be notified of changes.
        #[unsafe(method(backgroundRefreshStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn backgroundRefreshStatus(&self) -> UIBackgroundRefreshStatus;

        #[unsafe(method(isProtectedDataAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isProtectedDataAvailable(&self) -> bool;

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(userInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInterfaceLayoutDirection(&self) -> UIUserInterfaceLayoutDirection;

        #[cfg(feature = "UIContentSizeCategory")]
        #[unsafe(method(preferredContentSizeCategory))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredContentSizeCategory(&self) -> Retained<UIContentSizeCategory>;

        #[cfg(feature = "UIScene")]
        #[unsafe(method(connectedScenes))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectedScenes(&self) -> Retained<NSSet<UIScene>>;

        #[cfg(feature = "UISceneSession")]
        #[unsafe(method(openSessions))]
        #[unsafe(method_family = none)]
        pub unsafe fn openSessions(&self) -> Retained<NSSet<UISceneSession>>;

        #[unsafe(method(supportsMultipleScenes))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsMultipleScenes(&self) -> bool;

        #[cfg(all(feature = "UISceneSessionActivationRequest", feature = "block2"))]
        /// Asks the system to activate an existing scene, or create a new scene and associate it with your app.
        /// - Parameters:
        /// - request: The activation request.
        /// - errorHandler: A handler to be called if the request fails.
        #[unsafe(method(activateSceneSessionForRequest:errorHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activateSceneSessionForRequest_errorHandler(
            &self,
            request: &UISceneSessionActivationRequest,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(all(
            feature = "UISceneOptions",
            feature = "UISceneSession",
            feature = "block2"
        ))]
        #[deprecated = "Please use activateSceneSessionForRequest:errorHandler:"]
        #[unsafe(method(requestSceneSessionActivation:userActivity:options:errorHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestSceneSessionActivation_userActivity_options_errorHandler(
            &self,
            scene_session: Option<&UISceneSession>,
            user_activity: Option<&NSUserActivity>,
            options: Option<&UISceneActivationRequestOptions>,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(all(
            feature = "UISceneOptions",
            feature = "UISceneSession",
            feature = "block2"
        ))]
        #[unsafe(method(requestSceneSessionDestruction:options:errorHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestSceneSessionDestruction_options_errorHandler(
            &self,
            scene_session: &UISceneSession,
            options: Option<&UISceneDestructionRequestOptions>,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(feature = "UISceneSession")]
        #[unsafe(method(requestSceneSessionRefresh:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestSceneSessionRefresh(&self, scene_session: &UISceneSession);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// UIRemoteNotifications.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(registerForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForRemoteNotifications(&self);

        #[unsafe(method(unregisterForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn unregisterForRemoteNotifications(&self);

        #[unsafe(method(isRegisteredForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRegisteredForRemoteNotifications(&self) -> bool;

        #[deprecated = "Use -[UIApplication registerForRemoteNotifications] and UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]"]
        #[unsafe(method(registerForRemoteNotificationTypes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForRemoteNotificationTypes(&self, types: UIRemoteNotificationType);

        #[deprecated = "Use -[UIApplication isRegisteredForRemoteNotifications] and UserNotifications Framework's -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] to retrieve user-enabled remote notification and user notification settings"]
        #[unsafe(method(enabledRemoteNotificationTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn enabledRemoteNotificationTypes(&self) -> UIRemoteNotificationType;
    );
}

/// UILocalNotifications.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]"]
        #[unsafe(method(presentLocalNotificationNow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentLocalNotificationNow(&self, notification: &UILocalNotification);

        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter addNotificationRequest:withCompletionHandler:]"]
        #[unsafe(method(scheduleLocalNotification:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleLocalNotification(&self, notification: &UILocalNotification);

        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter removePendingNotificationRequestsWithIdentifiers:]"]
        #[unsafe(method(cancelLocalNotification:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelLocalNotification(&self, notification: &UILocalNotification);

        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter removeAllPendingNotificationRequests]"]
        #[unsafe(method(cancelAllLocalNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelAllLocalNotifications(&self);

        #[cfg(feature = "UILocalNotification")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter getPendingNotificationRequestsWithCompletionHandler:]"]
        #[unsafe(method(scheduledLocalNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduledLocalNotifications(
            &self,
        ) -> Option<Retained<NSArray<UILocalNotification>>>;

        #[cfg(feature = "UILocalNotification")]
        /// Setter for [`scheduledLocalNotifications`][Self::scheduledLocalNotifications].
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter getPendingNotificationRequestsWithCompletionHandler:]"]
        #[unsafe(method(setScheduledLocalNotifications:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setScheduledLocalNotifications(
            &self,
            scheduled_local_notifications: Option<&NSArray<UILocalNotification>>,
        );
    );
}

/// UIUserNotificationSettings.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UIUserNotificationSettings")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:] and -[UNUserNotificationCenter setNotificationCategories:]"]
        #[unsafe(method(registerUserNotificationSettings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerUserNotificationSettings(
            &self,
            notification_settings: &UIUserNotificationSettings,
        );

        #[cfg(feature = "UIUserNotificationSettings")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter getNotificationSettingsWithCompletionHandler:] and -[UNUserNotificationCenter getNotificationCategoriesWithCompletionHandler:]"]
        #[unsafe(method(currentUserNotificationSettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentUserNotificationSettings(
            &self,
        ) -> Option<Retained<UIUserNotificationSettings>>;
    );
}

/// UIRemoteControlEvents.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(beginReceivingRemoteControlEvents))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginReceivingRemoteControlEvents(&self);

        #[unsafe(method(endReceivingRemoteControlEvents))]
        #[unsafe(method_family = none)]
        pub unsafe fn endReceivingRemoteControlEvents(&self);
    );
}

/// UINewsstand.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UIImage")]
        #[deprecated = "Newsstand apps now behave like normal apps on SpringBoard"]
        #[unsafe(method(setNewsstandIconImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNewsstandIconImage(&self, image: Option<&UIImage>);
    );
}

/// UIShortcutItems.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[cfg(feature = "UIApplicationShortcutItem")]
        #[unsafe(method(shortcutItems))]
        #[unsafe(method_family = none)]
        pub unsafe fn shortcutItems(&self) -> Option<Retained<NSArray<UIApplicationShortcutItem>>>;

        #[cfg(feature = "UIApplicationShortcutItem")]
        /// Setter for [`shortcutItems`][Self::shortcutItems].
        #[unsafe(method(setShortcutItems:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setShortcutItems(
            &self,
            shortcut_items: Option<&NSArray<UIApplicationShortcutItem>>,
        );
    );
}

/// UIAlternateApplicationIcons.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(supportsAlternateIcons))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsAlternateIcons(&self) -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(setAlternateIconName:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAlternateIconName_completionHandler(
            &self,
            alternate_icon_name: Option<&NSString>,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[unsafe(method(alternateIconName))]
        #[unsafe(method_family = none)]
        pub unsafe fn alternateIconName(&self) -> Option<Retained<NSString>>;
    );
}

/// UIStateRestoration.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[unsafe(method(extendStateRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendStateRestoration(&self);

        #[unsafe(method(completeStateRestoration))]
        #[unsafe(method_family = none)]
        pub unsafe fn completeStateRestoration(&self);

        #[unsafe(method(ignoreSnapshotOnNextApplicationLaunch))]
        #[unsafe(method_family = none)]
        pub unsafe fn ignoreSnapshotOnNextApplicationLaunch(&self);

        #[cfg(feature = "UIStateRestoration")]
        #[unsafe(method(registerObjectForStateRestoration:restorationIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerObjectForStateRestoration_restorationIdentifier(
            object: &ProtocolObject<dyn UIStateRestoring>,
            restoration_identifier: &NSString,
        );
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationcategory?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIApplicationCategory(pub NSInteger);
impl UIApplicationCategory {
    #[doc(alias = "UIApplicationCategoryWebBrowser")]
    pub const WebBrowser: Self = Self(1);
}

unsafe impl Encode for UIApplicationCategory {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The default status of an application for some category.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationcategorydefaultstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIApplicationCategoryDefaultStatus(pub NSInteger);
impl UIApplicationCategoryDefaultStatus {
    /// The status was not available. This is an error condition and the returned error object has more information.
    #[doc(alias = "UIApplicationCategoryDefaultStatusUnavailable")]
    pub const Unavailable: Self = Self(0);
    /// The application is the default for the category.
    #[doc(alias = "UIApplicationCategoryDefaultStatusIsDefault")]
    pub const IsDefault: Self = Self(1);
    /// The application is not the default for the category.
    #[doc(alias = "UIApplicationCategoryDefaultStatusNotDefault")]
    pub const NotDefault: Self = Self(2);
}

unsafe impl Encode for UIApplicationCategoryDefaultStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationCategoryDefaultStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationcategorydefaulterrordomain?language=objc)
    pub static UIApplicationCategoryDefaultErrorDomain: &'static NSErrorDomain;
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationcategorydefaulterrorcode?language=objc)
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UIApplicationCategoryDefaultErrorCode(pub NSInteger);
impl UIApplicationCategoryDefaultErrorCode {
    /// The application is rate-limited.
    #[doc(alias = "UIApplicationCategoryDefaultErrorRateLimited")]
    pub const RateLimited: Self = Self(1);
}

unsafe impl Encode for UIApplicationCategoryDefaultErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIApplicationCategoryDefaultErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// Supplied in userInfo when the application is rate-limited: the last date on which data was
    /// retrieved.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationcategorydefaultstatuslastprovideddateerrorkey?language=objc)
    pub static UIApplicationCategoryDefaultStatusLastProvidedDateErrorKey:
        &'static NSErrorUserInfoKey;
}

extern "C" {
    /// Supplied in userInfo when the application is rate-limited: the date after which the app will no
    /// longer be rate-limited
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationcategorydefaultretryavailabilitydateerrorkey?language=objc)
    pub static UIApplicationCategoryDefaultRetryAvailabilityDateErrorKey:
        &'static NSErrorUserInfoKey;
}

/// DefaultApplication.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!();
}

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionskey?language=objc)
// NS_TYPED_ENUM
pub type UIApplicationLaunchOptionsKey = NSString;

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionskey?language=objc)
// NS_TYPED_ENUM
pub type UIApplicationOpenURLOptionsKey = NSString;

/// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationextensionpointidentifier?language=objc)
// NS_TYPED_ENUM
pub type UIApplicationExtensionPointIdentifier = NSString;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdelegate?language=objc)
    pub unsafe trait UIApplicationDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationDidFinishLaunching:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidFinishLaunching(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:willFinishLaunchingWithOptions:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willFinishLaunchingWithOptions(
            &self,
            application: &UIApplication,
            launch_options: Option<&NSDictionary<UIApplicationLaunchOptionsKey, AnyObject>>,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didFinishLaunchingWithOptions:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didFinishLaunchingWithOptions(
            &self,
            application: &UIApplication,
            launch_options: Option<&NSDictionary<UIApplicationLaunchOptionsKey, AnyObject>>,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationDidBecomeActive:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidBecomeActive(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationWillResignActive:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationWillResignActive(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[deprecated]
        #[optional]
        #[unsafe(method(application:handleOpenURL:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleOpenURL(
            &self,
            application: &UIApplication,
            url: &NSURL,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[deprecated]
        #[optional]
        #[unsafe(method(application:openURL:sourceApplication:annotation:))]
        #[unsafe(method_family = none)]
        unsafe fn application_openURL_sourceApplication_annotation(
            &self,
            application: &UIApplication,
            url: &NSURL,
            source_application: Option<&NSString>,
            annotation: &AnyObject,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:openURL:options:))]
        #[unsafe(method_family = none)]
        unsafe fn application_openURL_options(
            &self,
            app: &UIApplication,
            url: &NSURL,
            options: &NSDictionary<UIApplicationOpenURLOptionsKey, AnyObject>,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationDidReceiveMemoryWarning:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidReceiveMemoryWarning(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationWillTerminate:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationWillTerminate(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationSignificantTimeChange:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationSignificantTimeChange(&self, application: &UIApplication);

        #[cfg(all(feature = "UIOrientation", feature = "UIResponder"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:willChangeStatusBarOrientation:duration:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willChangeStatusBarOrientation_duration(
            &self,
            application: &UIApplication,
            new_status_bar_orientation: UIInterfaceOrientation,
            duration: NSTimeInterval,
        );

        #[cfg(all(feature = "UIOrientation", feature = "UIResponder"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:didChangeStatusBarOrientation:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didChangeStatusBarOrientation(
            &self,
            application: &UIApplication,
            old_status_bar_orientation: UIInterfaceOrientation,
        );

        #[cfg(all(feature = "UIResponder", feature = "objc2-core-foundation"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:willChangeStatusBarFrame:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willChangeStatusBarFrame(
            &self,
            application: &UIApplication,
            new_status_bar_frame: CGRect,
        );

        #[cfg(all(feature = "UIResponder", feature = "objc2-core-foundation"))]
        #[deprecated = "Use viewWillTransitionToSize:withTransitionCoordinator: instead."]
        #[optional]
        #[unsafe(method(application:didChangeStatusBarFrame:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didChangeStatusBarFrame(
            &self,
            application: &UIApplication,
            old_status_bar_frame: CGRect,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIUserNotificationSettings"))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenter requestAuthorizationWithOptions:completionHandler:]"]
        #[optional]
        #[unsafe(method(application:didRegisterUserNotificationSettings:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didRegisterUserNotificationSettings(
            &self,
            application: &UIApplication,
            notification_settings: &UIUserNotificationSettings,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didRegisterForRemoteNotificationsWithDeviceToken:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didRegisterForRemoteNotificationsWithDeviceToken(
            &self,
            application: &UIApplication,
            device_token: &NSData,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didFailToRegisterForRemoteNotificationsWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didFailToRegisterForRemoteNotificationsWithError(
            &self,
            application: &UIApplication,
            error: &NSError,
        );

        #[cfg(feature = "UIResponder")]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:] for user visible notifications and -[UIApplicationDelegate application:didReceiveRemoteNotification:fetchCompletionHandler:] for silent remote notifications"]
        #[optional]
        #[unsafe(method(application:didReceiveRemoteNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didReceiveRemoteNotification(
            &self,
            application: &UIApplication,
            user_info: &NSDictionary,
        );

        #[cfg(all(feature = "UILocalNotification", feature = "UIResponder"))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate willPresentNotification:withCompletionHandler:] or -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:didReceiveLocalNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didReceiveLocalNotification(
            &self,
            application: &UIApplication,
            notification: &UILocalNotification,
        );

        #[cfg(all(
            feature = "UILocalNotification",
            feature = "UIResponder",
            feature = "block2"
        ))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forLocalNotification:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forLocalNotification_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            notification: &UILocalNotification,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forRemoteNotification:withResponseInfo:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forRemoteNotification_withResponseInfo_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            user_info: &NSDictionary,
            response_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forRemoteNotification:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forRemoteNotification_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            user_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(
            feature = "UILocalNotification",
            feature = "UIResponder",
            feature = "block2"
        ))]
        #[deprecated = "Use UserNotifications Framework's -[UNUserNotificationCenterDelegate didReceiveNotificationResponse:withCompletionHandler:]"]
        #[optional]
        #[unsafe(method(application:handleActionWithIdentifier:forLocalNotification:withResponseInfo:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleActionWithIdentifier_forLocalNotification_withResponseInfo_completionHandler(
            &self,
            application: &UIApplication,
            identifier: Option<&NSString>,
            notification: &UILocalNotification,
            response_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// This delegate method offers an opportunity for applications with the "remote-notification" background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.
        ///
        /// This method will be invoked even if the application was launched or resumed because of the remote notification. The respective delegate methods will be invoked first. Note that this behavior is in contrast to application:didReceiveRemoteNotification:, which is not called in those cases, and which will not be invoked if this method is implemented. !
        #[optional]
        #[unsafe(method(application:didReceiveRemoteNotification:fetchCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didReceiveRemoteNotification_fetchCompletionHandler(
            &self,
            application: &UIApplication,
            user_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn(UIBackgroundFetchResult)>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// Applications with the "fetch" background mode may be given opportunities to fetch updated content in the background or when it is convenient for the system. This method will be called in these situations. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.
        #[deprecated = "Use a BGAppRefreshTask in the BackgroundTasks framework instead"]
        #[optional]
        #[unsafe(method(application:performFetchWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_performFetchWithCompletionHandler(
            &self,
            application: &UIApplication,
            completion_handler: &block2::DynBlock<dyn Fn(UIBackgroundFetchResult)>,
        );

        #[cfg(all(
            feature = "UIApplicationShortcutItem",
            feature = "UIResponder",
            feature = "block2"
        ))]
        #[optional]
        #[unsafe(method(application:performActionForShortcutItem:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_performActionForShortcutItem_completionHandler(
            &self,
            application: &UIApplication,
            shortcut_item: &UIApplicationShortcutItem,
            completion_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        #[optional]
        #[unsafe(method(application:handleEventsForBackgroundURLSession:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleEventsForBackgroundURLSession_completionHandler(
            &self,
            application: &UIApplication,
            identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        #[optional]
        #[unsafe(method(application:handleWatchKitExtensionRequest:reply:))]
        #[unsafe(method_family = none)]
        unsafe fn application_handleWatchKitExtensionRequest_reply(
            &self,
            application: &UIApplication,
            user_info: Option<&NSDictionary>,
            reply: &block2::DynBlock<dyn Fn(*mut NSDictionary)>,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationShouldRequestHealthAuthorization:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationShouldRequestHealthAuthorization(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationDidEnterBackground:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidEnterBackground(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationWillEnterForeground:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationWillEnterForeground(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationProtectedDataWillBecomeUnavailable:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationProtectedDataWillBecomeUnavailable(&self, application: &UIApplication);

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationProtectedDataDidBecomeAvailable:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationProtectedDataDidBecomeAvailable(&self, application: &UIApplication);

        #[cfg(all(feature = "UIResponder", feature = "UIView", feature = "UIWindow"))]
        #[optional]
        #[unsafe(method(window))]
        #[unsafe(method_family = none)]
        unsafe fn window(&self) -> Option<Retained<UIWindow>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView", feature = "UIWindow"))]
        /// Setter for [`window`][Self::window].
        #[optional]
        #[unsafe(method(setWindow:))]
        #[unsafe(method_family = none)]
        unsafe fn setWindow(&self, window: Option<&UIWindow>);

        #[cfg(all(
            feature = "UIOrientation",
            feature = "UIResponder",
            feature = "UIView",
            feature = "UIWindow"
        ))]
        #[optional]
        #[unsafe(method(application:supportedInterfaceOrientationsForWindow:))]
        #[unsafe(method_family = none)]
        unsafe fn application_supportedInterfaceOrientationsForWindow(
            &self,
            application: &UIApplication,
            window: Option<&UIWindow>,
        ) -> UIInterfaceOrientationMask;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:shouldAllowExtensionPointIdentifier:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldAllowExtensionPointIdentifier(
            &self,
            application: &UIApplication,
            extension_point_identifier: &UIApplicationExtensionPointIdentifier,
        ) -> bool;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(application:viewControllerWithRestorationIdentifierPath:coder:))]
        #[unsafe(method_family = none)]
        unsafe fn application_viewControllerWithRestorationIdentifierPath_coder(
            &self,
            application: &UIApplication,
            identifier_components: &NSArray<NSString>,
            coder: &NSCoder,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:shouldSaveSecureApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldSaveSecureApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:shouldRestoreSecureApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldRestoreSecureApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:willEncodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willEncodeRestorableStateWithCoder(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didDecodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didDecodeRestorableStateWithCoder(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "UIResponder")]
        #[deprecated = "Use application:shouldSaveSecureApplicationState: instead"]
        #[optional]
        #[unsafe(method(application:shouldSaveApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldSaveApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[deprecated = "Use application:shouldRestoreSecureApplicationState: instead"]
        #[optional]
        #[unsafe(method(application:shouldRestoreApplicationState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_shouldRestoreApplicationState(
            &self,
            application: &UIApplication,
            coder: &NSCoder,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:willContinueUserActivityWithType:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willContinueUserActivityWithType(
            &self,
            application: &UIApplication,
            user_activity_type: &NSString,
        ) -> bool;

        #[cfg(all(
            feature = "UIResponder",
            feature = "UIUserActivity",
            feature = "block2"
        ))]
        #[optional]
        #[unsafe(method(application:continueUserActivity:restorationHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn application_continueUserActivity_restorationHandler(
            &self,
            application: &UIApplication,
            user_activity: &NSUserActivity,
            restoration_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<ProtocolObject<dyn UIUserActivityRestoring>>),
            >,
        ) -> bool;

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didFailToContinueUserActivityWithType:error:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didFailToContinueUserActivityWithType_error(
            &self,
            application: &UIApplication,
            user_activity_type: &NSString,
            error: &NSError,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(application:didUpdateUserActivity:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didUpdateUserActivity(
            &self,
            application: &UIApplication,
            user_activity: &NSUserActivity,
        );

        #[cfg(all(feature = "UIResponder", feature = "objc2-cloud-kit"))]
        #[optional]
        #[unsafe(method(application:userDidAcceptCloudKitShareWithMetadata:))]
        #[unsafe(method_family = none)]
        unsafe fn application_userDidAcceptCloudKitShareWithMetadata(
            &self,
            application: &UIApplication,
            cloud_kit_share_metadata: &CKShareMetadata,
        );

        #[cfg(all(
            feature = "UIResponder",
            feature = "UISceneOptions",
            feature = "UISceneSession"
        ))]
        #[optional]
        #[unsafe(method(application:configurationForConnectingSceneSession:options:))]
        #[unsafe(method_family = none)]
        unsafe fn application_configurationForConnectingSceneSession_options(
            &self,
            application: &UIApplication,
            connecting_scene_session: &UISceneSession,
            options: &UISceneConnectionOptions,
        ) -> Retained<UISceneConfiguration>;

        #[cfg(all(feature = "UIResponder", feature = "UISceneSession"))]
        #[optional]
        #[unsafe(method(application:didDiscardSceneSessions:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didDiscardSceneSessions(
            &self,
            application: &UIApplication,
            scene_sessions: &NSSet<UISceneSession>,
        );

        #[cfg(feature = "UIResponder")]
        #[optional]
        #[unsafe(method(applicationShouldAutomaticallyLocalizeKeyCommands:))]
        #[unsafe(method_family = none)]
        unsafe fn applicationShouldAutomaticallyLocalizeKeyCommands(
            &self,
            application: &UIApplication,
        ) -> bool;
    }
);

/// UIApplicationDeprecated.
#[cfg(feature = "UIResponder")]
impl UIApplication {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(isProximitySensingEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isProximitySensingEnabled(&self) -> bool;

        /// Setter for [`isProximitySensingEnabled`][Self::isProximitySensingEnabled].
        #[deprecated]
        #[unsafe(method(setProximitySensingEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProximitySensingEnabled(&self, proximity_sensing_enabled: bool);

        #[deprecated = "Use -[UIViewController prefersStatusBarHidden]"]
        #[unsafe(method(setStatusBarHidden:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarHidden_animated(&self, hidden: bool, animated: bool);

        #[cfg(feature = "UIOrientation")]
        /// Setter for [`statusBarOrientation`][Self::statusBarOrientation].
        #[deprecated = "Explicit setting of the status bar orientation is more limited in iOS 6.0 and later"]
        #[unsafe(method(setStatusBarOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarOrientation(
            &self,
            status_bar_orientation: UIInterfaceOrientation,
        );

        #[cfg(feature = "UIOrientation")]
        #[deprecated = "Explicit setting of the status bar orientation is more limited in iOS 6.0 and later"]
        #[unsafe(method(setStatusBarOrientation:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarOrientation_animated(
            &self,
            interface_orientation: UIInterfaceOrientation,
            animated: bool,
        );

        /// Setter for [`statusBarStyle`][Self::statusBarStyle].
        #[deprecated = "Use -[UIViewController preferredStatusBarStyle]"]
        #[unsafe(method(setStatusBarStyle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarStyle(&self, status_bar_style: UIStatusBarStyle);

        #[deprecated = "Use -[UIViewController preferredStatusBarStyle]"]
        #[unsafe(method(setStatusBarStyle:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarStyle_animated(
            &self,
            status_bar_style: UIStatusBarStyle,
            animated: bool,
        );

        /// Setter for [`isStatusBarHidden`][Self::isStatusBarHidden].
        #[deprecated = "Use -[UIViewController prefersStatusBarHidden]"]
        #[unsafe(method(setStatusBarHidden:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarHidden(&self, status_bar_hidden: bool);

        #[deprecated = "Use -[UIViewController prefersStatusBarHidden]"]
        #[unsafe(method(setStatusBarHidden:withAnimation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatusBarHidden_withAnimation(
            &self,
            hidden: bool,
            animation: UIStatusBarAnimation,
        );

        #[cfg(feature = "block2")]
        #[deprecated = "Please use PushKit for VoIP applications instead of calling this method"]
        #[unsafe(method(setKeepAliveTimeout:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setKeepAliveTimeout_handler(
            &self,
            timeout: NSTimeInterval,
            keep_alive_handler: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> bool;

        #[deprecated = "Please use PushKit for VoIP applications instead of calling this method"]
        #[unsafe(method(clearKeepAliveTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearKeepAliveTimeout(&self);
    );
}

#[cfg(feature = "UIResponder")]
impl UIApplication {
    #[doc(alias = "UIApplicationMain")]
    #[inline]
    pub(crate) unsafe fn __main(
        argc: c_int,
        argv: NonNull<*mut c_char>,
        principal_class_name: Option<&NSString>,
        delegate_class_name: Option<&NSString>,
    ) -> c_int {
        extern "C-unwind" {
            fn UIApplicationMain(
                argc: c_int,
                argv: NonNull<*mut c_char>,
                principal_class_name: Option<&NSString>,
                delegate_class_name: Option<&NSString>,
            ) -> c_int;
        }
        unsafe { UIApplicationMain(argc, argv, principal_class_name, delegate_class_name) }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uitrackingrunloopmode?language=objc)
    pub static UITrackingRunLoopMode: &'static NSRunLoopMode;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdidenterbackgroundnotification?language=objc)
    pub static UIApplicationDidEnterBackgroundNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationwillenterforegroundnotification?language=objc)
    pub static UIApplicationWillEnterForegroundNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdidfinishlaunchingnotification?language=objc)
    pub static UIApplicationDidFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdidbecomeactivenotification?language=objc)
    pub static UIApplicationDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationwillresignactivenotification?language=objc)
    pub static UIApplicationWillResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdidreceivememorywarningnotification?language=objc)
    pub static UIApplicationDidReceiveMemoryWarningNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationwillterminatenotification?language=objc)
    pub static UIApplicationWillTerminateNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationsignificanttimechangenotification?language=objc)
    pub static UIApplicationSignificantTimeChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationwillchangestatusbarorientationnotification?language=objc)
    pub static UIApplicationWillChangeStatusBarOrientationNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdidchangestatusbarorientationnotification?language=objc)
    pub static UIApplicationDidChangeStatusBarOrientationNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationstatusbarorientationuserinfokey?language=objc)
    pub static UIApplicationStatusBarOrientationUserInfoKey: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationwillchangestatusbarframenotification?language=objc)
    pub static UIApplicationWillChangeStatusBarFrameNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationdidchangestatusbarframenotification?language=objc)
    pub static UIApplicationDidChangeStatusBarFrameNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationstatusbarframeuserinfokey?language=objc)
    pub static UIApplicationStatusBarFrameUserInfoKey: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationbackgroundrefreshstatusdidchangenotification?language=objc)
    pub static UIApplicationBackgroundRefreshStatusDidChangeNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationprotecteddatawillbecomeunavailable?language=objc)
    pub static UIApplicationProtectedDataWillBecomeUnavailable: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationprotecteddatadidbecomeavailable?language=objc)
    pub static UIApplicationProtectedDataDidBecomeAvailable: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsurlkey?language=objc)
    pub static UIApplicationLaunchOptionsURLKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionssourceapplicationkey?language=objc)
    pub static UIApplicationLaunchOptionsSourceApplicationKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsremotenotificationkey?language=objc)
    pub static UIApplicationLaunchOptionsRemoteNotificationKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionslocalnotificationkey?language=objc)
    pub static UIApplicationLaunchOptionsLocalNotificationKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsannotationkey?language=objc)
    pub static UIApplicationLaunchOptionsAnnotationKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionslocationkey?language=objc)
    pub static UIApplicationLaunchOptionsLocationKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsnewsstanddownloadskey?language=objc)
    pub static UIApplicationLaunchOptionsNewsstandDownloadsKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsbluetoothcentralskey?language=objc)
    pub static UIApplicationLaunchOptionsBluetoothCentralsKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsbluetoothperipheralskey?language=objc)
    pub static UIApplicationLaunchOptionsBluetoothPeripheralsKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsshortcutitemkey?language=objc)
    pub static UIApplicationLaunchOptionsShortcutItemKey: &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionseventattributionkey?language=objc)
    pub static UIApplicationLaunchOptionsEventAttributionKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsuseractivitydictionarykey?language=objc)
    pub static UIApplicationLaunchOptionsUserActivityDictionaryKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionsuseractivitytypekey?language=objc)
    pub static UIApplicationLaunchOptionsUserActivityTypeKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationlaunchoptionscloudkitsharemetadatakey?language=objc)
    pub static UIApplicationLaunchOptionsCloudKitShareMetadataKey:
        &'static UIApplicationLaunchOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopensettingsurlstring?language=objc)
    pub static UIApplicationOpenSettingsURLString: &'static NSString;
}

extern "C" {
    /// The URL string you use to deep link to settings for default app selection in the Settings app.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopendefaultapplicationssettingsurlstring?language=objc)
    pub static UIApplicationOpenDefaultApplicationsSettingsURLString: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopennotificationsettingsurlstring?language=objc)
    pub static UIApplicationOpenNotificationSettingsURLString: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionssourceapplicationkey?language=objc)
    pub static UIApplicationOpenURLOptionsSourceApplicationKey:
        &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionsannotationkey?language=objc)
    pub static UIApplicationOpenURLOptionsAnnotationKey: &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionsopeninplacekey?language=objc)
    pub static UIApplicationOpenURLOptionsOpenInPlaceKey: &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionseventattributionkey?language=objc)
    pub static UIApplicationOpenURLOptionsEventAttributionKey:
        &'static UIApplicationOpenURLOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationuserdidtakescreenshotnotification?language=objc)
    pub static UIApplicationUserDidTakeScreenshotNotification: &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationkeyboardextensionpointidentifier?language=objc)
    pub static UIApplicationKeyboardExtensionPointIdentifier:
        &'static UIApplicationExtensionPointIdentifier;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionuniversallinksonly?language=objc)
    pub static UIApplicationOpenURLOptionUniversalLinksOnly:
        &'static UIApplicationOpenExternalURLOptionsKey;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/uikit/uiapplicationopenexternalurloptionseventattributionkey?language=objc)
    pub static UIApplicationOpenExternalURLOptionsEventAttributionKey:
        &'static UIApplicationOpenExternalURLOptionsKey;
}

extern "C-unwind" {
    #[deprecated = "renamed to `UIApplication::__main`"]
    pub fn UIApplicationMain(
        argc: c_int,
        argv: NonNull<*mut c_char>,
        principal_class_name: Option<&NSString>,
        delegate_class_name: Option<&NSString>,
    ) -> c_int;
}
