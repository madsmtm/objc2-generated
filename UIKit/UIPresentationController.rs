//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

extern_protocol!(
    /// A set of methods that, in conjunction with a presentation controller, determine how to respond to trait changes in your app.
    ///
    /// ## Overview
    ///
    /// After implementing an object that conforms to this protocol, assign that object to the [`delegate`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/delegate) property of an appropriate [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller) object. Your delegate can suggest a new presentation style or an entirely new view controller for displaying content. For more information about using the delegate to respond to size class changes, see [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller).
    ///
    ///
    pub unsafe trait UIAdaptivePresentationControllerDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(feature = "UIViewController")]
        #[optional]
        #[unsafe(method(adaptivePresentationStyleForPresentationController:))]
        #[unsafe(method_family = none)]
        fn adaptivePresentationStyleForPresentationController(
            &self,
            controller: &UIPresentationController,
        ) -> UIModalPresentationStyle;

        #[cfg(all(feature = "UITraitCollection", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(adaptivePresentationStyleForPresentationController:traitCollection:))]
        #[unsafe(method_family = none)]
        fn adaptivePresentationStyleForPresentationController_traitCollection(
            &self,
            controller: &UIPresentationController,
            trait_collection: &UITraitCollection,
        ) -> UIModalPresentationStyle;

        #[optional]
        #[unsafe(method(presentationController:prepareAdaptivePresentationController:))]
        #[unsafe(method_family = none)]
        fn presentationController_prepareAdaptivePresentationController(
            &self,
            presentation_controller: &UIPresentationController,
            adaptive_presentation_controller: &UIPresentationController,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[optional]
        #[unsafe(method(presentationController:viewControllerForAdaptivePresentationStyle:))]
        #[unsafe(method_family = none)]
        fn presentationController_viewControllerForAdaptivePresentationStyle(
            &self,
            controller: &UIPresentationController,
            style: UIModalPresentationStyle,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(all(
            feature = "UIViewController",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[optional]
        #[unsafe(method(presentationController:willPresentWithAdaptiveStyle:transitionCoordinator:))]
        #[unsafe(method_family = none)]
        fn presentationController_willPresentWithAdaptiveStyle_transitionCoordinator(
            &self,
            presentation_controller: &UIPresentationController,
            style: UIModalPresentationStyle,
            transition_coordinator: Option<
                &ProtocolObject<dyn UIViewControllerTransitionCoordinator>,
            >,
        );

        #[optional]
        #[unsafe(method(presentationControllerShouldDismiss:))]
        #[unsafe(method_family = none)]
        fn presentationControllerShouldDismiss(
            &self,
            presentation_controller: &UIPresentationController,
        ) -> bool;

        #[optional]
        #[unsafe(method(presentationControllerWillDismiss:))]
        #[unsafe(method_family = none)]
        fn presentationControllerWillDismiss(
            &self,
            presentation_controller: &UIPresentationController,
        );

        #[optional]
        #[unsafe(method(presentationControllerDidDismiss:))]
        #[unsafe(method_family = none)]
        fn presentationControllerDidDismiss(
            &self,
            presentation_controller: &UIPresentationController,
        );

        #[optional]
        #[unsafe(method(presentationControllerDidAttemptToDismiss:))]
        #[unsafe(method_family = none)]
        fn presentationControllerDidAttemptToDismiss(
            &self,
            presentation_controller: &UIPresentationController,
        );
    }
);

extern_class!(
    /// An object that manages the transition animations and the presentation of view controllers onscreen.
    ///
    /// ## Overview
    ///
    /// From the time a view controller is presented until the time it’s dismissed, UIKit uses a presentation controller to manage various aspects of the presentation process for that view controller. The presentation controller can add its own animations on top of those provided by animator objects, it can respond to size changes, and it can manage other aspects of how the view controller is presented onscreen.
    ///
    /// When you present a view controller using the [`presentViewController:animated:completion:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/present(_:animated:completion:)) method, UIKit always manages the presentation process. Part of that process involves creating the presentation controller that’s appropriate for the given presentation style. For the built-in styles (such as the [`UIModalPresentationPageSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/pagesheet) style), UIKit defines and creates the needed presentation controller object. The only time your app can provide a custom presentation controller is when you set the [`modalPresentationStyle`](https://developer.apple.com/documentation/uikit/uiviewcontroller/modalpresentationstyle) property of your view controller [`UIModalPresentationCustom`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/custom). You might provide a custom presentation controller when you want to add a shadow view or decoration views underneath the view controller being presented or when you want to modify the presentation behavior in other ways.
    ///
    /// You vend your custom presentation controller object through your view controller’s transitioning delegate. UIKit maintains a reference to your presentation controller object while the presented view controller is onscreen. For information about the transitioning delegate and the objects it provides, see [`UIViewControllerTransitioningDelegate`](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioningdelegate).
    ///
    /// ### Understand the presentation process
    ///
    /// The presentation process managed by a presentation controller is divided into three phases:
    ///
    /// - The _presentation phase_ involves moving the new view controller onscreen through a series of transition animations.
    ///
    /// - The _management phase_ involves responding to environment changes (such as device rotations) while the new view controller is onscreen.
    ///
    /// - The _dismissal phase_ involves moving the new view controller off screen through a series of transition animations
    ///
    /// The presentation controller’s role during all of these phases is to manage its own custom views and state information. During the presentation and dismissal phases, the presentation controller adds its custom views (if any) to the view hierarchy and creates any appropriate transition animations for those views. The animation of the view controller’s view onto the screen is still managed by an animator object — that is, an object that adopts the [`UIViewControllerAnimatedTransitioning`](https://developer.apple.com/documentation/uikit/uiviewcontrolleranimatedtransitioning) protocol. UIKit calls separate presentation controller methods at the beginning and end of the presentation and dismissal phases so that the presentation controller can perform any needed cleanup.
    ///
    /// ### Add custom views to a presentation
    ///
    /// The [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller) class defines specific entry points for manipulating the view hierarchy when presenting a view controller. When a view controller is about to be presented, UIKit calls the presentation controller’s [`presentationTransitionWillBegin`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitionwillbegin()) method. You can use that method to add views to the view hierarchy and set up any animations related to those views. At the end of the presentation phase, UIKit calls the [`presentationTransitionDidEnd:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitiondidend(_:)) method to let you know that the transition finished.
    ///
    /// The following code shows a sample implementation of the [`presentationTransitionWillBegin`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitionwillbegin()) and [`presentationTransitionDidEnd:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitiondidend(_:)) methods for a custom presentation controller. In this example, the view controller adds a dimming view as a backdrop to the presented view controller. (The `_dimmingView` variable refers to a custom [`UIView`](https://developer.apple.com/documentation/uikit/uiview) object that you would provide.) When presenting the view controller, the [`presentationTransitionWillBegin`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitionwillbegin()) method adds the dimming view first and embeds the view controller content inside that dimming view. It then configures a fade-in animation to run alongside the other transition animations. If the user aborts the presentation process, perhaps through an interactive gesture, the [`presentationTransitionDidEnd:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitiondidend(_:)) removes the dimming view. If the presentation succeeds, both the dimming view and the presented view controller remain onscreen until they’re dismissed.
    ///
    /// ```objc
    /// - (void)presentationTransitionWillBegin {
    ///    // Add a custom dimming view behind the presented view controller's view.
    ///    [[self containerView] addSubview:_dimmingView];
    ///    [_dimmingView addSubview:[[self presentedViewController] view]];
    ///  
    ///    // Use the transition coordinator to set up the animations.
    ///     id <UIViewControllerTransitionCoordinator> transitionCoordinator =
    ///           [[self presentingViewController] transitionCoordinator];
    ///  
    ///    // Fade in the dimming view during the transition.
    ///     [_dimmingView setAlpha:0.0];
    ///     [transitionCoordinator animateAlongsideTransition:
    ///        ^(id<UIViewControllerTransitionCoordinatorContext> context) {
    ///           [_dimmingView setAlpha:1.0];
    ///        } completion:nil];
    /// }
    ///  
    /// - (void)presentationTransitionDidEnd:(BOOL)completed {
    ///    // Remove the dimming view if the presentation is terminated.
    ///    if (!completed) {
    ///       [_dimmingView removeFromSuperview];
    ///    }
    /// }
    /// ```
    ///
    /// When dismissing the view controller, use the [`dismissalTransitionWillBegin`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/dismissaltransitionwillbegin()) method to configure any animations and use the [`dismissalTransitionDidEnd:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/dismissaltransitiondidend(_:)) method to remove any custom views from the view hierarchy.
    ///
    /// ### Adapt to size class changes
    ///
    /// Size class changes signal large-scale changes to how your app should present its content. Presentation controllers manage size class changes by adjusting the presentation style (as needed) for their presented view controller. Adjustments are made only when the current presentation style doesn’t make sense in the new environment. For example, a popover becomes a full-screen presentation when the size class changes from horizontally regular to horizontally compact. For presentation styles that already make sense in the new environment, such as a full-screen presentation style, no adaptive change is made.
    ///
    /// When the size class of the presented view controller changes from horizontally regular to horizontally compact, the presentation controller calls its [`adaptivePresentationStyle`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/adaptivepresentationstyle) method to determine which new style (if any) to apply. When a new style is needed, the presentation controller initiates a transition to the new style, which may also involve replacing the current presentation controller object with a new object. Because the presentation controller object may change, always retrieve the presentation controller from [`presentationController`](https://developer.apple.com/documentation/uikit/uiviewcontroller/presentationcontroller) property of the presented view controller.
    ///
    /// When the presentation style changes, the presentation controller also gives you the opportunity to specify a new presented view controller. Before initiating the transition, the presentation controller calls the [`presentationController:viewControllerForAdaptivePresentationStyle:`](https://developer.apple.com/documentation/uikit/uiadaptivepresentationcontrollerdelegate/presentationcontroller(_:viewcontrollerforadaptivepresentationstyle:)) method of its delegate object. If you implement that method, you can use it to make major or minor adjustments to the presented content. A major adjustment would be to replace the current view controller with an entirely new view controller that was designed specifically for the given size class. A minor adjustment would be to install the current view controller inside a navigation controller to facilitate navigation in the new size class.
    ///
    /// ### Respond to size changes
    ///
    /// Size changes represent small changes to the width or height of a view controller’s view. Typically, these changes happen when the device rotates between portrait and landscape orientations. When a size change occurs, UIKit calls the presentation controller’s [`viewWillTransitionToSize:withTransitionCoordinator:`](https://developer.apple.com/documentation/uikit/uicontentcontainer/viewwilltransition(to:with:)) method. In a custom presentation, use that method to modify your presentation controller’s custom views or make changes to the view hierarchy. For example, you might swap out custom decoration views with ones that fit the new size better.
    ///
    /// After notifying your presentation controller of an impending size change, UIKit begins the normal view layout process. Apps that use auto layout shouldn’t need to do anything because the auto layout mechanism resizes views as needed. But if a custom presentation controller needs to make layout-specific changes, it can do so in its [`containerViewWillLayoutSubviews`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/containerviewwilllayoutsubviews()) and [`containerViewDidLayoutSubviews`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/containerviewdidlayoutsubviews()) methods. These methods are equivalent to the [`viewWillLayoutSubviews`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwilllayoutsubviews()) and [`viewDidLayoutSubviews`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewdidlayoutsubviews()) methods of the [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) class and used in the same way. UIKit calls them before and after it calls the [`layoutSubviews`](https://developer.apple.com/documentation/uikit/uiview/layoutsubviews()) methods of the views in the view hierarchy.
    ///
    /// ### Subclassing notes
    ///
    /// For custom presentation styles, you should subclass [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller) and override at least some of its methods to implement your custom presentation behaviors. Use your custom presentation controller to customize the presentation process.
    ///
    /// For custom presentation controllers, you must call the [`initWithPresentedViewController:presentingViewController:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/init(presentedviewcontroller:presenting:)) method during initialization. That method is the designated initializer of the class. UIKit uses it to perform required initialization for all presentation controller objects.
    ///
    /// #### Methods to override
    ///
    /// If your [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller) subclasses manages one or more custom views, you should consider overriding the following methods:
    ///
    /// - Use the [`presentationTransitionWillBegin`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitionwillbegin()) method to add your custom views to the view hierarchy and to animate the appearance of those views. If the view controller can’t be presented, you can remove those views in the [`presentationTransitionDidEnd:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/presentationtransitiondidend(_:)) method as needed.
    ///
    /// - Use the [`dismissalTransitionWillBegin`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/dismissaltransitionwillbegin()) method to perform animations related to the dismissal of the presented view controller. Don’t remove your custom views from the view hierarchy until the [`dismissalTransitionDidEnd:`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/dismissaltransitiondidend(_:)) method is called.
    ///
    /// - Use the [`viewWillTransitionToSize:withTransitionCoordinator:`](https://developer.apple.com/documentation/uikit/uicontentcontainer/viewwilltransition(to:with:)) method to make any size-related changes to your custom views.
    ///
    /// Subclasses may override other methods of this class as needed to provide custom behavior. For example, you might override the [`shouldPresentInFullscreen`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/shouldpresentinfullscreen) or [`frameOfPresentedViewInContainerView`](https://developer.apple.com/documentation/uikit/uipresentationcontroller/frameofpresentedviewincontainerview) methods and return different values than those provided by the default implementations.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIPresentationController;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UIPresentationController {}
);

#[cfg(feature = "UIAppearance")]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UIPresentationController {}
);

#[cfg(feature = "UIViewController")]
extern_conformance!(
    unsafe impl UIContentContainer for UIPresentationController {}
);

#[cfg(feature = "UIFocus")]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UIPresentationController {}
);

#[cfg(feature = "UITraitCollection")]
extern_conformance!(
    unsafe impl UITraitEnvironment for UIPresentationController {}
);

impl UIPresentationController {
    extern_methods!(
        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[unsafe(method(presentingViewController))]
        #[unsafe(method_family = none)]
        pub fn presentingViewController(&self) -> Retained<UIViewController>;

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[unsafe(method(presentedViewController))]
        #[unsafe(method_family = none)]
        pub fn presentedViewController(&self) -> Retained<UIViewController>;

        #[cfg(feature = "UIViewController")]
        #[unsafe(method(presentationStyle))]
        #[unsafe(method_family = none)]
        pub fn presentationStyle(&self) -> UIModalPresentationStyle;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(containerView))]
        #[unsafe(method_family = none)]
        pub fn containerView(&self) -> Option<Retained<UIView>>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UIAdaptivePresentationControllerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn UIAdaptivePresentationControllerDelegate>>,
        );

        #[cfg(all(feature = "UIResponder", feature = "UIViewController"))]
        #[unsafe(method(initWithPresentedViewController:presentingViewController:))]
        #[unsafe(method_family = init)]
        pub fn initWithPresentedViewController_presentingViewController(
            this: Allocated<Self>,
            presented_view_controller: &UIViewController,
            presenting_view_controller: Option<&UIViewController>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "UIViewController")]
        #[unsafe(method(adaptivePresentationStyle))]
        #[unsafe(method_family = none)]
        pub fn adaptivePresentationStyle(&self) -> UIModalPresentationStyle;

        #[cfg(all(feature = "UITraitCollection", feature = "UIViewController"))]
        #[unsafe(method(adaptivePresentationStyleForTraitCollection:))]
        #[unsafe(method_family = none)]
        pub fn adaptivePresentationStyleForTraitCollection(
            &self,
            trait_collection: &UITraitCollection,
        ) -> UIModalPresentationStyle;

        #[unsafe(method(containerViewWillLayoutSubviews))]
        #[unsafe(method_family = none)]
        pub fn containerViewWillLayoutSubviews(&self);

        #[unsafe(method(containerViewDidLayoutSubviews))]
        #[unsafe(method_family = none)]
        pub fn containerViewDidLayoutSubviews(&self);

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[unsafe(method(presentedView))]
        #[unsafe(method_family = none)]
        pub fn presentedView(&self) -> Option<Retained<UIView>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frameOfPresentedViewInContainerView))]
        #[unsafe(method_family = none)]
        pub fn frameOfPresentedViewInContainerView(&self) -> CGRect;

        #[unsafe(method(shouldPresentInFullscreen))]
        #[unsafe(method_family = none)]
        pub fn shouldPresentInFullscreen(&self) -> bool;

        #[unsafe(method(shouldRemovePresentersView))]
        #[unsafe(method_family = none)]
        pub fn shouldRemovePresentersView(&self) -> bool;

        #[unsafe(method(presentationTransitionWillBegin))]
        #[unsafe(method_family = none)]
        pub fn presentationTransitionWillBegin(&self);

        #[unsafe(method(presentationTransitionDidEnd:))]
        #[unsafe(method_family = none)]
        pub fn presentationTransitionDidEnd(&self, completed: bool);

        #[unsafe(method(dismissalTransitionWillBegin))]
        #[unsafe(method_family = none)]
        pub fn dismissalTransitionWillBegin(&self);

        #[unsafe(method(dismissalTransitionDidEnd:))]
        #[unsafe(method_family = none)]
        pub fn dismissalTransitionDidEnd(&self, completed: bool);

        #[cfg(feature = "UITraitCollection")]
        #[deprecated = "Use the traitOverrides property instead"]
        #[unsafe(method(overrideTraitCollection))]
        #[unsafe(method_family = none)]
        pub fn overrideTraitCollection(&self) -> Option<Retained<UITraitCollection>>;

        #[cfg(feature = "UITraitCollection")]
        /// Setter for [`overrideTraitCollection`][Self::overrideTraitCollection].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated = "Use the traitOverrides property instead"]
        #[unsafe(method(setOverrideTraitCollection:))]
        #[unsafe(method_family = none)]
        pub fn setOverrideTraitCollection(
            &self,
            override_trait_collection: Option<&UITraitCollection>,
        );

        #[cfg(feature = "UIVisualEffect")]
        #[unsafe(method(backgroundEffect))]
        #[unsafe(method_family = none)]
        pub fn backgroundEffect(&self) -> Option<Retained<UIVisualEffect>>;

        #[cfg(feature = "UIVisualEffect")]
        /// Setter for [`backgroundEffect`][Self::backgroundEffect].
        #[unsafe(method(setBackgroundEffect:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundEffect(&self, background_effect: Option<&UIVisualEffect>);
    );
}

/// Methods declared on superclass `NSObject`.
impl UIPresentationController {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

impl UIPresentationController {
    extern_methods!(
        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method(traitOverrides))]
        #[unsafe(method_family = none)]
        pub fn traitOverrides(&self) -> Retained<ProtocolObject<dyn UITraitOverrides>>;
    );
}

#[cfg(feature = "UITraitCollection")]
extern_conformance!(
    unsafe impl UITraitChangeObservable for UIPresentationController {}
);
