//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Transition styles available when presenting view controllers.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIModalTransitionStyle(pub NSInteger);
impl UIModalTransitionStyle {
    ///
    /// ## Discussion
    ///
    /// When the view controller is presented, its view slides up from the bottom of the screen. On dismissal, the view slides back down. This is the default transition style.
    ///
    ///
    #[doc(alias = "UIModalTransitionStyleCoverVertical")]
    pub const CoverVertical: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// When the view controller is presented, the current view initiates a horizontal 3D flip from right-to-left, resulting in the revealing of the new view as if it were on the back of the previous view. On dismissal, the flip occurs from left-to-right, returning to the original view.
    ///
    ///
    #[doc(alias = "UIModalTransitionStyleFlipHorizontal")]
    pub const FlipHorizontal: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// When the view controller is presented, the current view fades out while the new view fades in at the same time. On dismissal, a similar type of cross-fade is used to return to the original view.
    ///
    ///
    #[doc(alias = "UIModalTransitionStyleCrossDissolve")]
    pub const CrossDissolve: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// When the view controller is presented, one corner of the current view curls up to reveal the presented view underneath. On dismissal, the curled up page unfurls itself back on top of the presented view. A view controller presented using this transition is itself prevented from presenting any additional view controllers.
    ///
    /// This transition style is supported only if the parent view controller is presenting a full-screen view and you use the [`UIModalPresentationFullScreen`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/fullscreen) modal presentation style. Attempting to use a different form factor for the parent view or a different presentation style triggers an exception.
    ///
    ///
    #[doc(alias = "UIModalTransitionStylePartialCurl")]
    pub const PartialCurl: Self = Self(3);
}

unsafe impl Encode for UIModalTransitionStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIModalTransitionStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Modal presentation styles available when presenting view controllers.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIModalPresentationStyle(pub NSInteger);
impl UIModalPresentationStyle {
    /// A presentation style in which the presented view covers the screen.
    ///
    /// ## Discussion
    ///
    /// The views belonging to the presenting view controller are removed after the presentation completes.
    ///
    ///
    #[doc(alias = "UIModalPresentationFullScreen")]
    pub const FullScreen: Self = Self(0);
    /// A presentation style that partially covers the underlying content.
    ///
    /// ## Discussion
    ///
    /// In a regular-width, regular-height size class, the system adds a dimming layer over the background content and centers the view controller’s content on top of this layer. The content is roughly the size of a page, where the height is greater than the width. The actual dimensions vary depending on several factors including the device’s screen size and orientation. A part of the background content always remains visible.
    ///
    /// To provide a custom content size, use the [`UIModalPresentationFormSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/formsheet) style instead, and set the modal view controller’s [`preferredContentSize`](https://developer.apple.com/documentation/uikit/uiviewcontroller/preferredcontentsize) property.
    ///
    /// In a compact-width, regular-height size class, the system displays the view controller as a sheet with part of the background content visible near the top of the screen.
    ///
    /// In a compact-height size class, the behavior is the same as [`UIModalPresentationFullScreen`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/fullscreen).
    ///
    /// Where the background content remains visible, the system doesn’t call the presenting view controller’s [`viewWillDisappear:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwilldisappear(_:)) and [`viewDidDisappear:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewdiddisappear(_:)) methods.
    ///
    ///
    #[doc(alias = "UIModalPresentationPageSheet")]
    pub const PageSheet: Self = Self(1);
    /// A presentation style that displays the content centered in the screen.
    ///
    /// ## Discussion
    ///
    /// In a regular-width, regular-height size class, the system adds a layer with a Liquid Glass effect over the background content and centers the view controller’s content on top of this layer. The default content size is smaller than that of the [`UIModalPresentationPageSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/pagesheet) style. A part of the background content always remains visible.
    ///
    /// To provide a custom content size, use the modal view controller’s [`preferredContentSize`](https://developer.apple.com/documentation/uikit/uiviewcontroller/preferredcontentsize) property.
    ///
    /// In a compact-width, regular-height size class, the system displays the view controller as a sheet with part of the background content visible near the top of the screen.
    ///
    /// In a compact-height size class, the behavior is the same as [`UIModalPresentationFullScreen`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/fullscreen).
    ///
    /// Where the background content remains visible, the system doesn’t call the presenting view controller’s [`viewWillDisappear:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwilldisappear(_:)) and [`viewDidDisappear:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewdiddisappear(_:)) methods.
    ///
    ///
    #[doc(alias = "UIModalPresentationFormSheet")]
    pub const FormSheet: Self = Self(2);
    /// A presentation style where the content is displayed over another view controller’s content.
    ///
    /// ## Discussion
    ///
    /// Using this presentation style, the current view controller’s content is displayed over the view controller whose [`definesPresentationContext`](https://developer.apple.com/documentation/uikit/uiviewcontroller/definespresentationcontext) property is [`true`](https://developer.apple.com/documentation/swift/true). UIKit may walk up the view controller hierarchy to find a view controller that wants to define the presentation context. The views belonging to the presenting view controller are removed after the presentation completes.
    ///
    /// When presenting a view controller in a popover, this presentation style is supported only if the transition style is [`UIModalTransitionStyleCoverVertical`](https://developer.apple.com/documentation/uikit/uimodaltransitionstyle/coververtical). Attempting to use a different transition style triggers an exception. However, you may use other transition styles (except the partial curl transition) if the parent view controller is not in a popover.
    ///
    ///
    #[doc(alias = "UIModalPresentationCurrentContext")]
    pub const CurrentContext: Self = Self(3);
    /// A custom view presentation style that is managed by a custom presentation controller and one or more custom animator objects.
    ///
    /// ## Discussion
    ///
    /// All of these objects are provided by the presented view controller’s transitioning delegate, which is an object that conforms to the [`UIViewControllerTransitioningDelegate`](https://developer.apple.com/documentation/uikit/uiviewcontrollertransitioningdelegate) protocol. Before presenting a view controller using this style, set the view controller’s  [`transitioningDelegate`](https://developer.apple.com/documentation/uikit/uiviewcontroller/transitioningdelegate) property to your custom transitioning delegate.
    ///
    ///
    #[doc(alias = "UIModalPresentationCustom")]
    pub const Custom: Self = Self(4);
    /// A view presentation style in which the presented view covers the screen.
    ///
    /// ## Discussion
    ///
    /// The views beneath the presented content are not removed from the view hierarchy when the presentation finishes. So if the presented view controller does not fill the screen with opaque content, the underlying content shows through.
    ///
    ///
    #[doc(alias = "UIModalPresentationOverFullScreen")]
    pub const OverFullScreen: Self = Self(5);
    /// A presentation style where the content is displayed over another view controller’s content.
    ///
    /// ## Discussion
    ///
    /// Using this presentation style, the current view controller’s content is displayed over the view controller whose [`definesPresentationContext`](https://developer.apple.com/documentation/uikit/uiviewcontroller/definespresentationcontext) property is [`true`](https://developer.apple.com/documentation/swift/true). UIKit may walk up the view controller hierarchy to find a view controller that wants to define the presentation context. The views beneath the presented content are not removed from the view hierarchy when the presentation finishes. So if the presented view controller does not fill the screen with opaque content, the underlying content shows through.
    ///
    /// When presenting a view controller in a popover, this presentation style is supported only if the transition style is [`UIModalTransitionStyleCoverVertical`](https://developer.apple.com/documentation/uikit/uimodaltransitionstyle/coververtical). Attempting to use a different transition style triggers an exception. However, you may use other transition styles (except the partial curl transition) if the parent view controller is not in a popover.
    ///
    ///
    #[doc(alias = "UIModalPresentationOverCurrentContext")]
    pub const OverCurrentContext: Self = Self(6);
    /// A presentation style where the content is displayed in a popover view.
    ///
    /// ## Discussion
    ///
    /// In a horizontally regular environment, this style displays the view controller in a popover view. The background content is dimmed and taps outside the popover cause the popover to be dismissed. If you do not want taps to dismiss the popover, you can assign one or more views to the [`passthroughViews`](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller/passthroughviews) property of the associated [`UIPopoverPresentationController`](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller) object, which you can get from the [`popoverPresentationController`](https://developer.apple.com/documentation/uikit/uiviewcontroller/popoverpresentationcontroller) property.
    ///
    /// In iOS 13 and later, for horizontally or vertically compact environments, this option behaves the same as [`UIModalPresentationFormSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/formsheet).
    ///
    /// In iOS 12 and earlier:
    ///
    /// - For horizontally compact environments, this option behaves the same as [`UIModalPresentationFullScreen`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/fullscreen).
    ///
    /// - For horizontally regular and vertically compact environments, this option behaves the same as [`UIModalPresentationFormSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/formsheet).
    ///
    /// For more information about horizontal and vertical size classes, see [`UIUserInterfaceSizeClass`](https://developer.apple.com/documentation/uikit/uiuserinterfacesizeclass).
    ///
    ///
    #[doc(alias = "UIModalPresentationPopover")]
    pub const Popover: Self = Self(7);
    /// A presentation style that blurs the underlying content before displaying new content in a full-screen presentation.
    #[doc(alias = "UIModalPresentationBlurOverFullScreen")]
    pub const BlurOverFullScreen: Self = Self(8);
    /// A presentation style that indicates no adaptations should be made.
    ///
    /// ## Discussion
    ///
    /// Do not use this style to present a view controller. Instead, return it from the [`adaptivePresentationStyleForPresentationController:`](https://developer.apple.com/documentation/uikit/uiadaptivepresentationcontrollerdelegate/adaptivepresentationstyle(for:)) method of an adaptive delegate when you do not want a presentation controller to adapt the style of an already presented view controller.
    ///
    ///
    #[doc(alias = "UIModalPresentationNone")]
    pub const None: Self = Self(-1);
    /// The default presentation style chosen by the system.
    ///
    /// ## Discussion
    ///
    /// For most view controllers, UIKit maps this style to:
    ///
    /// - [`UIModalPresentationFormSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/formsheet) in iOS 18 and later
    ///
    /// - [`UIModalPresentationPageSheet`](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/pagesheet) in versions of iOS earlier than iOS 18
    ///
    /// Some system view controllers may map it to a different style.
    ///
    ///
    #[doc(alias = "UIModalPresentationAutomatic")]
    pub const Automatic: Self = Self(-2);
}

unsafe impl Encode for UIModalPresentationStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIModalPresentationStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A set of methods for adapting the contents of your view controllers to size and trait changes.
    ///
    /// ## Overview
    ///
    /// The methods of this protocol handle size-related transitions that are related to changes in the current trait environment or view controller hierarchy. When the parent view controller changes, or when trait changes occur that affect the size of a view controller, UIKit calls these methods to give the affected objects a chance to respond appropriately.
    ///
    /// All [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) and [`UIPresentationController`](https://developer.apple.com/documentation/uikit/uipresentationcontroller) objects provide default implementations for the methods of this protocol. When creating your own custom view controller or presentation controller, you can override the default implementations to make adjustments to your content. For example, you might use these methods to adjust the size or position of any child view controllers.
    ///
    /// When overriding the methods of this protocol, call `super` to let UIKit perform any default behaviors. View controllers and presentation controllers perform their own adjustments when these methods are called. Calling `super` ensures that UIKit is able to continue adjusting other parts of your user interface.
    ///
    ///
    pub unsafe trait UIContentContainer: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(preferredContentSize))]
        #[unsafe(method_family = none)]
        fn preferredContentSize(&self) -> CGSize;

        #[unsafe(method(preferredContentSizeDidChangeForChildContentContainer:))]
        #[unsafe(method_family = none)]
        fn preferredContentSizeDidChangeForChildContentContainer(
            &self,
            container: &ProtocolObject<dyn UIContentContainer>,
        );

        #[unsafe(method(systemLayoutFittingSizeDidChangeForChildContentContainer:))]
        #[unsafe(method_family = none)]
        fn systemLayoutFittingSizeDidChangeForChildContentContainer(
            &self,
            container: &ProtocolObject<dyn UIContentContainer>,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(sizeForChildContentContainer:withParentContainerSize:))]
        #[unsafe(method_family = none)]
        fn sizeForChildContentContainer_withParentContainerSize(
            &self,
            container: &ProtocolObject<dyn UIContentContainer>,
            parent_size: CGSize,
        ) -> CGSize;

        #[cfg(all(
            feature = "UIViewControllerTransitionCoordinator",
            feature = "objc2-core-foundation"
        ))]
        #[unsafe(method(viewWillTransitionToSize:withTransitionCoordinator:))]
        #[unsafe(method_family = none)]
        fn viewWillTransitionToSize_withTransitionCoordinator(
            &self,
            size: CGSize,
            coordinator: &ProtocolObject<dyn UIViewControllerTransitionCoordinator>,
        );

        #[cfg(all(
            feature = "UITraitCollection",
            feature = "UIViewControllerTransitionCoordinator"
        ))]
        #[unsafe(method(willTransitionToTraitCollection:withTransitionCoordinator:))]
        #[unsafe(method_family = none)]
        fn willTransitionToTraitCollection_withTransitionCoordinator(
            &self,
            new_collection: &UITraitCollection,
            coordinator: &ProtocolObject<dyn UIViewControllerTransitionCoordinator>,
        );
    }
);

extern "C" {
    /// Posted when a split view controller is expanded or collapsed.
    ///
    /// ## Discussion
    ///
    /// When a view controller is using [`showViewController:sender:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/show(_:sender:)) or [`showDetailViewController:sender:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/showdetailviewcontroller(_:sender:)), it may need to know when a split view controller higher in the view hierarchy has changed. This notification is sent when a split view controller expands or collapses. The object of this notification is the view controller that caused the change.
    ///
    ///
    pub static UIViewControllerShowDetailTargetDidChangeNotification: &'static NSNotificationName;
}

extern_class!(
    /// An object that manages a view hierarchy for your UIKit app.
    ///
    /// ## Overview
    ///
    /// The [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) class defines the shared behavior that’s common to all view controllers. You rarely create instances of the [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) class directly. Instead, you subclass [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) and add the methods and properties needed to manage the view controller’s view hierarchy.
    ///
    /// A view controller’s main responsibilities include the following:
    ///
    /// - Updating the contents of the views, usually in response to changes to the underlying data
    ///
    /// - Responding to user interactions with views
    ///
    /// - Resizing views and managing the layout of the overall interface
    ///
    /// - Coordinating with other objects — including other view controllers — in your app
    ///
    /// A view controller is tightly bound to the views it manages and takes part in handling events in its view hierarchy. Specifically, view controllers are [`UIResponder`](https://developer.apple.com/documentation/uikit/uiresponder) objects and are inserted into the responder chain between the view controller’s root view and that view’s superview, which typically belongs to a different view controller. If none of the view controller’s views handle an event, the view controller has the option of handling the event or passing it along to the superview.
    ///
    /// View controllers are rarely used in isolation. Instead, you often use multiple view controllers, each of which owns a portion of your app’s user interface. For example, one view controller might display a table of items while a different view controller displays the selected item from that table. Usually, only the views from one view controller are visible at a time. A view controller may present a different view controller to display a new set of views, or it may act as a container for other view controllers’ content and animate views however it wants.
    ///
    /// ### Subclassing notes
    ///
    /// Every app contains at least one custom subclass of [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller). More often, apps contain many custom view controllers. Custom view controllers define the overall behaviors of your app, including the app’s appearance and how it responds to user interactions. The following sections provide a brief overview of some of the tasks your custom subclass performs. For detailed information about using and implementing view controllers, see [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).
    ///
    /// #### Manage views
    ///
    /// Each view controller manages a view hierarchy, the root view of which is stored in the [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property of this class. The root view acts primarily as a container for the rest of the view hierarchy. The size and position of the root view is determined by the object that owns it, which is either a parent view controller or the app’s window. The view controller that’s owned by the window is the app’s root view controller and its view is sized to fill the window.
    ///
    /// View controllers load their views lazily. Accessing the [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property for the first time loads or creates the view controller’s views. There are several ways to specify the views for a view controller:
    ///
    /// - Specify the view controller and its views in your app’s storyboard. Storyboards are the preferred way to specify your views. With a storyboard, you specify the views and their connections to the view controller. You also specify the relationships and segues between your view controllers, which makes it easier to see and modify your app’s behavior.
    ///
    /// To load a view controller from a storyboard, call the [`instantiateViewControllerWithIdentifier:`](https://developer.apple.com/documentation/uikit/uistoryboard/instantiateviewcontroller(withidentifier:)) method of the appropriate [`UIStoryboard`](https://developer.apple.com/documentation/uikit/uistoryboard) object. The storyboard object creates the view controller and returns it to your code.
    ///
    /// - Specify the views for a view controller using a nib file. A nib file lets you specify the views of a single view controller but doesn’t let you define segues or relationships between view controllers. The nib file also stores only minimal information about the view controller itself.
    ///
    /// To initialize a view controller object using a nib file, create your view controller class programmatically and initialize it using the [`initWithNibName:bundle:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/init(nibname:bundle:)) method. When its views are requested, the view controller loads them from the nib file.
    ///
    /// - Specify the views for a view controller using the [`loadView`](https://developer.apple.com/documentation/uikit/uiviewcontroller/loadview()) method. In that method, create your view hierarchy programmatically and assign the root view of that hierarchy to the view controller’s [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property.
    ///
    /// All of these techniques have the same end result, which is to create the appropriate set of views and expose them through the [`view`](https://developer.apple.com/documentation/uikit/uiviewcontroller/view) property.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  A view controller is the sole owner of its view and any subviews it creates. It’s responsible for creating those views and for relinquishing ownership of them at the appropriate times such as when the view controller itself is released. If you use a storyboard or a nib file to store your view objects, each view controller object automatically gets its own copy of these views when the view controller asks for them. However, if you create your views manually, each view controller must have its own unique set of views. You can’t share views between view controllers.
    ///
    ///
    ///
    /// </div>
    /// A view controller’s root view is always sized to fit its assigned space. For other views in your view hierarchy, use Interface Builder to specify the Auto Layout constraints that govern how each view is positioned and sized within its superview’s bounds. You can also create constraints programmatically and add them to your views at appropriate times. For more information about how to create constraints, see [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853).
    ///
    /// ##### Handle view-related notifications
    ///
    /// When the visibility of its views changes, a view controller automatically calls its own methods so that subclasses can respond to the change. Use a method like [`viewIsAppearing:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewisappearing(_:)) to prepare your views to appear onscreen, and use [`viewWillDisappear:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwilldisappear(_:)) to save changes or other state information. Use other methods to make appropriate changes.
    ///
    /// The following image shows the possible visible states for a view controller’s views and the state transitions that can occur. Not all `will` callback methods are paired with only a `did` callback method. You need to ensure that if you start a process in a `will` callback method, you end the process in both the corresponding `did` and the opposite `will` callback method.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/7034ec4a62a026b24725e92aa23a4fa8/media-1965800~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/a941e6911051bdb9476e5c7b33a7eea2/media-1965800%402x.png 2x" />
    ///     <img alt="A diagram of four spheres arranged in a circle. The sphere on the right is labeled Appearing and has a clockwise arrow leading to the bottom sphere, which is labeled Appeared. A small dot on the arrow is labeled viewDidAppear. A clockwise arrow leads from the bottom sphere to the left sphere, which is labeled Disappearing. A small dot along the arrow is labeled viewWillDisappear. A clockwise arrow leads from the left sphere to the top sphere, which is labeled Disappeared. Two small dots along the arrow are labeled viewDidDisappear and View removed. A clockwise arrow leads from the top sphere to the right sphere. Three small dots along the arrow are labeled viewWillAppear, View added, and viewIsAppearing." src="https://docs-assets.developer.apple.com/published/a941e6911051bdb9476e5c7b33a7eea2/media-1965800%402x.png" />
    /// </picture>
    ///
    ///
    /// ##### Handle view rotations
    ///
    /// As of iOS 8, all rotation-related methods are deprecated. Instead, rotations are treated as a change in the size of the view controller’s view and are therefore reported using the [`viewWillTransitionToSize:withTransitionCoordinator:`](https://developer.apple.com/documentation/uikit/uicontentcontainer/viewwilltransition(to:with:)) method. When the interface orientation changes, UIKit calls this method on the window’s root view controller. That view controller then notifies its child view controllers, propagating the message throughout the view controller hierarchy.
    ///
    /// In iOS 6 and iOS 7, your app supports the interface orientations defined in your app’s `Info.plist` file. A view controller can override the [`supportedInterfaceOrientations`](https://developer.apple.com/documentation/uikit/uiviewcontroller/supportedinterfaceorientations) method to limit the list of supported orientations. Typically, the system calls this method only on the root view controller of the window or a view controller presented to fill the entire screen; child view controllers use the portion of the window provided for them by their parent view controller and no longer participate directly in decisions about what rotations are supported. The intersection of the app’s orientation mask and the view controller’s orientation mask is used to determine which orientations a view controller can be rotated into.
    ///
    /// You can override the [`preferredInterfaceOrientationForPresentation`](https://developer.apple.com/documentation/uikit/uiviewcontroller/preferredinterfaceorientationforpresentation) for a view controller that’s intended to be presented full screen in a specific orientation.
    ///
    /// When a rotation occurs for a visible view controller, the [`willRotateToInterfaceOrientation:duration:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/willrotate(to:duration:)), [`willAnimateRotationToInterfaceOrientation:duration:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/willanimaterotation(to:duration:)), and [`didRotateFromInterfaceOrientation:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/didrotate(from:)) methods are called during the rotation. The [`viewWillLayoutSubviews`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwilllayoutsubviews()) method is also called after the view is resized and positioned by its parent. If a view controller isn’t visible when an orientation change occurs, then the rotation methods are never called. However, the [`viewWillLayoutSubviews`](https://developer.apple.com/documentation/uikit/uiviewcontroller/viewwilllayoutsubviews()) method is called when the view becomes visible.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  At launch time, apps should always set up their interface in a portrait orientation. After the [`application:didFinishLaunchingWithOptions:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didfinishlaunchingwithoptions:)) method returns, the app uses the view controller rotation mechanism described above to rotate the views to the appropriate orientation prior to showing the window.
    ///
    ///
    ///
    /// </div>
    /// #### Implement a container view controller
    ///
    /// A custom [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) subclass can also act as a container view controller. A container view controller manages the presentation of content of other view controllers it owns, also known as its child view controllers. A child’s view can be presented as-is or in conjunction with views owned by the container view controller.
    ///
    /// Your container view controller subclass should declare a public interface to associate its children. The nature of these methods is up to you and depends on the semantics of the container you’re creating. You need to decide how many children can be displayed by your view controller at once, when those children are displayed, and where they appear in your view controller’s view hierarchy. Your view controller class defines what relationships, if any, are shared by the children. By establishing a clean public interface for your container, you ensure that children use its capabilities logically, without accessing too many private details about how your container implements the behavior.
    ///
    /// Your container view controller must associate a child view controller with itself before adding the child’s root view to the view hierarchy. This allows iOS to properly route events to child view controllers and the views those controllers manage. Likewise, after it removes a child’s root view from its view hierarchy, it should disconnect that child view controller from itself. To make or break these associations, your container calls specific methods defined by the base class. These methods aren’t intended to be called by clients of your container class; they are to be used only by your container’s implementation to provide the expected containment behavior.
    ///
    /// Here are the essential methods you might need to call:
    ///
    /// - [`addChildViewController:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/addchild(_:))
    ///
    /// - [`removeFromParentViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller/removefromparent())
    ///
    /// - [`willMoveToParentViewController:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/willmove(toparent:))
    ///
    /// - [`didMoveToParentViewController:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/didmove(toparent:))
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  You’re not required to override any methods when creating a container view controller.
    ///
    /// By default, rotation and appearance callbacks are automatically forwarded to children. You may optionally override the [`shouldAutomaticallyForwardRotationMethods`](https://developer.apple.com/documentation/uikit/uiviewcontroller/shouldautomaticallyforwardrotationmethods()) and [`shouldAutomaticallyForwardAppearanceMethods`](https://developer.apple.com/documentation/uikit/uiviewcontroller/shouldautomaticallyforwardappearancemethods) methods to take control of this behavior yourself.
    ///
    ///
    ///
    /// </div>
    /// #### Manage memory
    ///
    /// Memory is a critical resource in iOS, and view controllers provide built-in support for reducing their memory footprint at critical times. The [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) class provides some automatic handling of low-memory conditions through its [`didReceiveMemoryWarning`](https://developer.apple.com/documentation/uikit/uiviewcontroller/didreceivememorywarning()) method, which releases unneeded memory.
    ///
    /// #### Support state preservation and restoration
    ///
    /// If you assign a value to the view controller’s [`restorationIdentifier`](https://developer.apple.com/documentation/uikit/uiviewcontroller/restorationidentifier) property, the system may ask the view controller to encode itself when the app transitions to the background. When preserved, a view controller preserves the state of any views in its view hierarchy that also have restoration identifiers. View controllers don’t automatically save any other state. If you’re implementing a custom container view controller, you must encode any child view controllers yourself. Each child you encode must have a unique restoration identifier.
    ///
    /// For more information about how the system determines which view controllers to preserve and restore, see [App Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072). To see an example of state preservation and restoration, see [Restoring your app’s state](https://developer.apple.com/documentation/uikit/restoring-your-app-s-state).
    ///
    ///
    #[unsafe(super(UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "UIResponder")]
    pub struct UIViewController;
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSCoding for UIViewController {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for UIViewController {}
);

#[cfg(all(feature = "UIAppearance", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UIViewController {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl UIContentContainer for UIViewController {}
);

#[cfg(all(feature = "UIFocus", feature = "UIResponder"))]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UIViewController {}
);

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UIViewController {}
);

#[cfg(all(feature = "UIResponder", feature = "UITraitCollection"))]
extern_conformance!(
    unsafe impl UITraitEnvironment for UIViewController {}
);

#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(initWithNibName:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithNibName_bundle(
            this: Allocated<Self>,
            nib_name_or_nil: Option<&NSString>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "UIView")]
        #[unsafe(method(view))]
        #[unsafe(method_family = none)]
        pub fn view(&self) -> Option<Retained<UIView>>;

        #[cfg(feature = "UIView")]
        /// Setter for [`view`][Self::view].
        #[unsafe(method(setView:))]
        #[unsafe(method_family = none)]
        pub fn setView(&self, view: Option<&UIView>);

        #[unsafe(method(loadView))]
        #[unsafe(method_family = none)]
        pub fn loadView(&self);

        #[unsafe(method(loadViewIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn loadViewIfNeeded(&self);

        #[cfg(feature = "UIView")]
        #[unsafe(method(viewIfLoaded))]
        #[unsafe(method_family = none)]
        pub fn viewIfLoaded(&self) -> Option<Retained<UIView>>;

        #[deprecated]
        #[unsafe(method(viewWillUnload))]
        #[unsafe(method_family = none)]
        pub fn viewWillUnload(&self);

        #[deprecated]
        #[unsafe(method(viewDidUnload))]
        #[unsafe(method_family = none)]
        pub fn viewDidUnload(&self);

        #[unsafe(method(viewDidLoad))]
        #[unsafe(method_family = none)]
        pub fn viewDidLoad(&self);

        #[unsafe(method(isViewLoaded))]
        #[unsafe(method_family = none)]
        pub fn isViewLoaded(&self) -> bool;

        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(nibName))]
        #[unsafe(method_family = none)]
        pub fn nibName(&self) -> Option<Retained<NSString>>;

        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(nibBundle))]
        #[unsafe(method_family = none)]
        pub fn nibBundle(&self) -> Option<Retained<NSBundle>>;

        #[cfg(feature = "UIStoryboard")]
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(storyboard))]
        #[unsafe(method_family = none)]
        pub fn storyboard(&self) -> Option<Retained<UIStoryboard>>;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(performSegueWithIdentifier:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performSegueWithIdentifier_sender(
            &self,
            identifier: &NSString,
            sender: Option<&AnyObject>,
        );

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(shouldPerformSegueWithIdentifier:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldPerformSegueWithIdentifier_sender(
            &self,
            identifier: &NSString,
            sender: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "UIStoryboardSegue")]
        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(prepareForSegue:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn prepareForSegue_sender(
            &self,
            segue: &UIStoryboardSegue,
            sender: Option<&AnyObject>,
        );

        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `sender` should be of the correct type.
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(canPerformUnwindSegueAction:fromViewController:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canPerformUnwindSegueAction_fromViewController_sender(
            &self,
            action: Sel,
            from_view_controller: &UIViewController,
            sender: Option<&AnyObject>,
        ) -> bool;

        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `sender` should be of the correct type.
        #[deprecated]
        #[unsafe(method(canPerformUnwindSegueAction:fromViewController:withSender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canPerformUnwindSegueAction_fromViewController_withSender(
            &self,
            action: Sel,
            from_view_controller: &UIViewController,
            sender: &AnyObject,
        ) -> bool;

        #[cfg(feature = "UIStoryboardSegue")]
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(allowedChildViewControllersForUnwindingFromSource:))]
        #[unsafe(method_family = none)]
        pub fn allowedChildViewControllersForUnwindingFromSource(
            &self,
            source: &UIStoryboardUnwindSegueSource,
        ) -> Retained<NSArray<UIViewController>>;

        #[cfg(feature = "UIStoryboardSegue")]
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(childViewControllerContainingSegueSource:))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerContainingSegueSource(
            &self,
            source: &UIStoryboardUnwindSegueSource,
        ) -> Option<Retained<UIViewController>>;

        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `sender` should be of the correct type.
        #[deprecated]
        #[unsafe(method(viewControllerForUnwindSegueAction:fromViewController:withSender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn viewControllerForUnwindSegueAction_fromViewController_withSender(
            &self,
            action: Sel,
            from_view_controller: &UIViewController,
            sender: Option<&AnyObject>,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(feature = "UIStoryboardSegue")]
        #[deprecated = "Loading Interface Builder products will not be supported in a future version of visionOS."]
        #[unsafe(method(unwindForSegue:towardsViewController:))]
        #[unsafe(method_family = none)]
        pub fn unwindForSegue_towardsViewController(
            &self,
            unwind_segue: &UIStoryboardSegue,
            subsequent_vc: &UIViewController,
        );

        #[cfg(feature = "UIStoryboardSegue")]
        #[deprecated]
        #[unsafe(method(segueForUnwindingToViewController:fromViewController:identifier:))]
        #[unsafe(method_family = none)]
        pub fn segueForUnwindingToViewController_fromViewController_identifier(
            &self,
            to_view_controller: &UIViewController,
            from_view_controller: &UIViewController,
            identifier: Option<&NSString>,
        ) -> Option<Retained<UIStoryboardSegue>>;

        /// Called when the view is about to made visible, before it is added to the hierarchy.
        /// Because the view is not yet in the hierarchy at the time this method is called, it
        /// is too early in the appearance transition for many usages. Prefer -viewIsAppearing:
        /// instead of this method when possible. Only use this method when its exact timing
        /// before the appearance transition starts running is desired, such as to set up an
        /// alongside animation with a transition coordinator, or as a counterpart for paired
        /// code in a viewWillDisappear/viewDidDisappear callback that does not rely on the
        /// view or view controller's trait collection or the view hierarchy.
        #[unsafe(method(viewWillAppear:))]
        #[unsafe(method_family = none)]
        pub fn viewWillAppear(&self, animated: bool);

        /// Called when the view is becoming visible at the beginning of the appearance transition,
        /// after it has been added to the hierarchy and been laid out by its superview. This method
        /// is very similar to -viewWillAppear: and is always called shortly afterwards (so changes
        /// made in either callback will be visible to the user at the same time), but unlike
        /// -viewWillAppear:, at the time when -viewIsAppearing: is called all of the following are
        /// valid for the view controller and its own view:
        /// - View controller and view's trait collection
        /// - View's superview chain and window
        /// - View's geometry (e.g. frame/bounds, safe area insets, layout margins)
        /// Choose this method instead of -viewWillAppear: by default, as it is a direct replacement
        /// that provides equivalent or superior behavior in nearly all cases.
        #[unsafe(method(viewIsAppearing:))]
        #[unsafe(method_family = none)]
        pub fn viewIsAppearing(&self, animated: bool);

        /// Called after the view has fully transitioned to visible, when any transition animations have completed.
        #[unsafe(method(viewDidAppear:))]
        #[unsafe(method_family = none)]
        pub fn viewDidAppear(&self, animated: bool);

        /// Called when the view is about to be dismissed, covered, or otherwise hidden.
        #[unsafe(method(viewWillDisappear:))]
        #[unsafe(method_family = none)]
        pub fn viewWillDisappear(&self, animated: bool);

        /// Called after the view has fully been dismissed, covered, or otherwise hidden, when any transition animations have completed.
        #[unsafe(method(viewDidDisappear:))]
        #[unsafe(method_family = none)]
        pub fn viewDidDisappear(&self, animated: bool);

        /// Call to manually request a properties update for the view controller.
        /// Multiple requests may be coalesced into a single update alongside the next layout pass.
        #[unsafe(method(setNeedsUpdateProperties))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateProperties(&self);

        /// Override point for subclasses to update properties of this view controller or its view.
        /// Never call this method directly; use `setNeedsUpdateProperties` to schedule an update.
        #[unsafe(method(updateProperties))]
        #[unsafe(method_family = none)]
        pub fn updateProperties(&self);

        /// Forces an immediate properties update for this view controller and its view,
        /// including any view controllers and views in this subtree.
        #[unsafe(method(updatePropertiesIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updatePropertiesIfNeeded(&self);

        #[unsafe(method(viewWillLayoutSubviews))]
        #[unsafe(method_family = none)]
        pub fn viewWillLayoutSubviews(&self);

        #[unsafe(method(viewDidLayoutSubviews))]
        #[unsafe(method_family = none)]
        pub fn viewDidLayoutSubviews(&self);

        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Option<Retained<NSString>>;

        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub fn setTitle(&self, title: Option<&NSString>);

        #[unsafe(method(didReceiveMemoryWarning))]
        #[unsafe(method_family = none)]
        pub fn didReceiveMemoryWarning(&self);

        #[unsafe(method(parentViewController))]
        #[unsafe(method_family = none)]
        pub fn parentViewController(&self) -> Option<Retained<UIViewController>>;

        #[deprecated]
        #[unsafe(method(modalViewController))]
        #[unsafe(method_family = none)]
        pub fn modalViewController(&self) -> Option<Retained<UIViewController>>;

        #[unsafe(method(presentedViewController))]
        #[unsafe(method_family = none)]
        pub fn presentedViewController(&self) -> Option<Retained<UIViewController>>;

        #[unsafe(method(presentingViewController))]
        #[unsafe(method_family = none)]
        pub fn presentingViewController(&self) -> Option<Retained<UIViewController>>;

        #[unsafe(method(definesPresentationContext))]
        #[unsafe(method_family = none)]
        pub fn definesPresentationContext(&self) -> bool;

        /// Setter for [`definesPresentationContext`][Self::definesPresentationContext].
        #[unsafe(method(setDefinesPresentationContext:))]
        #[unsafe(method_family = none)]
        pub fn setDefinesPresentationContext(&self, defines_presentation_context: bool);

        #[unsafe(method(providesPresentationContextTransitionStyle))]
        #[unsafe(method_family = none)]
        pub fn providesPresentationContextTransitionStyle(&self) -> bool;

        /// Setter for [`providesPresentationContextTransitionStyle`][Self::providesPresentationContextTransitionStyle].
        #[unsafe(method(setProvidesPresentationContextTransitionStyle:))]
        #[unsafe(method_family = none)]
        pub fn setProvidesPresentationContextTransitionStyle(
            &self,
            provides_presentation_context_transition_style: bool,
        );

        #[unsafe(method(restoresFocusAfterTransition))]
        #[unsafe(method_family = none)]
        pub fn restoresFocusAfterTransition(&self) -> bool;

        /// Setter for [`restoresFocusAfterTransition`][Self::restoresFocusAfterTransition].
        #[unsafe(method(setRestoresFocusAfterTransition:))]
        #[unsafe(method_family = none)]
        pub fn setRestoresFocusAfterTransition(&self, restores_focus_after_transition: bool);

        /// The identifier of the focus group that this view controller belongs to. If this is nil, the view controller inherits the focus group of its parent focus environment.
        #[unsafe(method(focusGroupIdentifier))]
        #[unsafe(method_family = none)]
        pub fn focusGroupIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`focusGroupIdentifier`][Self::focusGroupIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFocusGroupIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setFocusGroupIdentifier(&self, focus_group_identifier: Option<&NSString>);

        /// The base name for tracking user interactions as activities hosted by this view controller.
        #[unsafe(method(interactionActivityTrackingBaseName))]
        #[unsafe(method_family = none)]
        pub fn interactionActivityTrackingBaseName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`interactionActivityTrackingBaseName`][Self::interactionActivityTrackingBaseName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInteractionActivityTrackingBaseName:))]
        #[unsafe(method_family = none)]
        pub fn setInteractionActivityTrackingBaseName(
            &self,
            interaction_activity_tracking_base_name: Option<&NSString>,
        );

        #[unsafe(method(isBeingPresented))]
        #[unsafe(method_family = none)]
        pub fn isBeingPresented(&self) -> bool;

        #[unsafe(method(isBeingDismissed))]
        #[unsafe(method_family = none)]
        pub fn isBeingDismissed(&self) -> bool;

        #[unsafe(method(isMovingToParentViewController))]
        #[unsafe(method_family = none)]
        pub fn isMovingToParentViewController(&self) -> bool;

        #[unsafe(method(isMovingFromParentViewController))]
        #[unsafe(method_family = none)]
        pub fn isMovingFromParentViewController(&self) -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(presentViewController:animated:completion:))]
        #[unsafe(method_family = none)]
        pub fn presentViewController_animated_completion(
            &self,
            view_controller_to_present: &UIViewController,
            flag: bool,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(dismissViewControllerAnimated:completion:))]
        #[unsafe(method_family = none)]
        pub fn dismissViewControllerAnimated_completion(
            &self,
            flag: bool,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[deprecated]
        #[unsafe(method(presentModalViewController:animated:))]
        #[unsafe(method_family = none)]
        pub fn presentModalViewController_animated(
            &self,
            modal_view_controller: &UIViewController,
            animated: bool,
        );

        #[deprecated]
        #[unsafe(method(dismissModalViewControllerAnimated:))]
        #[unsafe(method_family = none)]
        pub fn dismissModalViewControllerAnimated(&self, animated: bool);

        #[unsafe(method(modalTransitionStyle))]
        #[unsafe(method_family = none)]
        pub fn modalTransitionStyle(&self) -> UIModalTransitionStyle;

        /// Setter for [`modalTransitionStyle`][Self::modalTransitionStyle].
        #[unsafe(method(setModalTransitionStyle:))]
        #[unsafe(method_family = none)]
        pub fn setModalTransitionStyle(&self, modal_transition_style: UIModalTransitionStyle);

        #[cfg(feature = "UIViewControllerTransition")]
        /// Preferred system provided transition to use when displaying this
        /// view controller. Note that this only indicates a preference.
        /// The provided transition may be ignored if not supported by the
        /// current context. For example, `UINavigationController` supports
        /// the .zoom transition, but not the .coverVertical transition.
        #[unsafe(method(preferredTransition))]
        #[unsafe(method_family = none)]
        pub fn preferredTransition(&self) -> Option<Retained<UIViewControllerTransition>>;

        #[cfg(feature = "UIViewControllerTransition")]
        /// Setter for [`preferredTransition`][Self::preferredTransition].
        #[unsafe(method(setPreferredTransition:))]
        #[unsafe(method_family = none)]
        pub fn setPreferredTransition(
            &self,
            preferred_transition: Option<&UIViewControllerTransition>,
        );

        #[unsafe(method(modalPresentationStyle))]
        #[unsafe(method_family = none)]
        pub fn modalPresentationStyle(&self) -> UIModalPresentationStyle;

        /// Setter for [`modalPresentationStyle`][Self::modalPresentationStyle].
        #[unsafe(method(setModalPresentationStyle:))]
        #[unsafe(method_family = none)]
        pub fn setModalPresentationStyle(&self, modal_presentation_style: UIModalPresentationStyle);

        #[unsafe(method(modalPresentationCapturesStatusBarAppearance))]
        #[unsafe(method_family = none)]
        pub fn modalPresentationCapturesStatusBarAppearance(&self) -> bool;

        /// Setter for [`modalPresentationCapturesStatusBarAppearance`][Self::modalPresentationCapturesStatusBarAppearance].
        #[unsafe(method(setModalPresentationCapturesStatusBarAppearance:))]
        #[unsafe(method_family = none)]
        pub fn setModalPresentationCapturesStatusBarAppearance(
            &self,
            modal_presentation_captures_status_bar_appearance: bool,
        );

        #[unsafe(method(disablesAutomaticKeyboardDismissal))]
        #[unsafe(method_family = none)]
        pub fn disablesAutomaticKeyboardDismissal(&self) -> bool;

        #[deprecated]
        #[unsafe(method(wantsFullScreenLayout))]
        #[unsafe(method_family = none)]
        pub fn wantsFullScreenLayout(&self) -> bool;

        /// Setter for [`wantsFullScreenLayout`][Self::wantsFullScreenLayout].
        #[deprecated]
        #[unsafe(method(setWantsFullScreenLayout:))]
        #[unsafe(method_family = none)]
        pub fn setWantsFullScreenLayout(&self, wants_full_screen_layout: bool);

        #[cfg(feature = "UIGeometry")]
        #[unsafe(method(edgesForExtendedLayout))]
        #[unsafe(method_family = none)]
        pub fn edgesForExtendedLayout(&self) -> UIRectEdge;

        #[cfg(feature = "UIGeometry")]
        /// Setter for [`edgesForExtendedLayout`][Self::edgesForExtendedLayout].
        #[unsafe(method(setEdgesForExtendedLayout:))]
        #[unsafe(method_family = none)]
        pub fn setEdgesForExtendedLayout(&self, edges_for_extended_layout: UIRectEdge);

        #[unsafe(method(extendedLayoutIncludesOpaqueBars))]
        #[unsafe(method_family = none)]
        pub fn extendedLayoutIncludesOpaqueBars(&self) -> bool;

        /// Setter for [`extendedLayoutIncludesOpaqueBars`][Self::extendedLayoutIncludesOpaqueBars].
        #[unsafe(method(setExtendedLayoutIncludesOpaqueBars:))]
        #[unsafe(method_family = none)]
        pub fn setExtendedLayoutIncludesOpaqueBars(
            &self,
            extended_layout_includes_opaque_bars: bool,
        );

        #[deprecated = "Use UIScrollView's contentInsetAdjustmentBehavior instead"]
        #[unsafe(method(automaticallyAdjustsScrollViewInsets))]
        #[unsafe(method_family = none)]
        pub fn automaticallyAdjustsScrollViewInsets(&self) -> bool;

        /// Setter for [`automaticallyAdjustsScrollViewInsets`][Self::automaticallyAdjustsScrollViewInsets].
        #[deprecated = "Use UIScrollView's contentInsetAdjustmentBehavior instead"]
        #[unsafe(method(setAutomaticallyAdjustsScrollViewInsets:))]
        #[unsafe(method_family = none)]
        pub fn setAutomaticallyAdjustsScrollViewInsets(
            &self,
            automatically_adjusts_scroll_view_insets: bool,
        );

        #[cfg(all(feature = "UIGeometry", feature = "UIScrollView", feature = "UIView"))]
        /// Aggregate values (e.g., NSDirectionalRectEdgeAll) are accepted in the `edge` parameter; NSDirectionalRectEdgeLeading and Trailing are ignored on iOS 15.0
        #[unsafe(method(setContentScrollView:forEdge:))]
        #[unsafe(method_family = none)]
        pub fn setContentScrollView_forEdge(
            &self,
            scroll_view: Option<&UIScrollView>,
            edge: NSDirectionalRectEdge,
        );

        #[cfg(all(feature = "UIGeometry", feature = "UIScrollView", feature = "UIView"))]
        /// Pass only a single edge (e.g., NSDirectionalRectEdgeTop) in the `edge` parameter. Raises an exception when passed an aggregate edge (e.g., NSDirectionalRectEdgeAll)
        #[unsafe(method(contentScrollViewForEdge:))]
        #[unsafe(method_family = none)]
        pub fn contentScrollViewForEdge(
            &self,
            edge: NSDirectionalRectEdge,
        ) -> Option<Retained<UIScrollView>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(preferredContentSize))]
        #[unsafe(method_family = none)]
        pub fn preferredContentSize(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`preferredContentSize`][Self::preferredContentSize].
        #[unsafe(method(setPreferredContentSize:))]
        #[unsafe(method_family = none)]
        pub fn setPreferredContentSize(&self, preferred_content_size: CGSize);

        #[cfg(feature = "UIApplication")]
        #[deprecated = "Has no effect on visionOS"]
        #[unsafe(method(preferredStatusBarStyle))]
        #[unsafe(method_family = none)]
        pub fn preferredStatusBarStyle(&self) -> UIStatusBarStyle;

        #[deprecated = "Has no effect on visionOS"]
        #[unsafe(method(prefersStatusBarHidden))]
        #[unsafe(method_family = none)]
        pub fn prefersStatusBarHidden(&self) -> bool;

        #[cfg(feature = "UIApplication")]
        #[deprecated = "Has no effect on visionOS"]
        #[unsafe(method(preferredStatusBarUpdateAnimation))]
        #[unsafe(method_family = none)]
        pub fn preferredStatusBarUpdateAnimation(&self) -> UIStatusBarAnimation;

        #[unsafe(method(setNeedsStatusBarAppearanceUpdate))]
        #[unsafe(method_family = none)]
        pub fn setNeedsStatusBarAppearanceUpdate(&self);

        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `sender` should be of the correct type.
        #[unsafe(method(targetViewControllerForAction:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn targetViewControllerForAction_sender(
            &self,
            action: Sel,
            sender: Option<&AnyObject>,
        ) -> Option<Retained<UIViewController>>;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(showViewController:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showViewController_sender(
            &self,
            vc: &UIViewController,
            sender: Option<&AnyObject>,
        );

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(showDetailViewController:sender:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showDetailViewController_sender(
            &self,
            vc: &UIViewController,
            sender: Option<&AnyObject>,
        );

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(preferredUserInterfaceStyle))]
        #[unsafe(method_family = none)]
        pub fn preferredUserInterfaceStyle(&self) -> UIUserInterfaceStyle;

        #[unsafe(method(setNeedsUserInterfaceAppearanceUpdate))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUserInterfaceAppearanceUpdate(&self);

        #[cfg(feature = "UIInterface")]
        #[unsafe(method(overrideUserInterfaceStyle))]
        #[unsafe(method_family = none)]
        pub fn overrideUserInterfaceStyle(&self) -> UIUserInterfaceStyle;

        #[cfg(feature = "UIInterface")]
        /// Setter for [`overrideUserInterfaceStyle`][Self::overrideUserInterfaceStyle].
        #[unsafe(method(setOverrideUserInterfaceStyle:))]
        #[unsafe(method_family = none)]
        pub fn setOverrideUserInterfaceStyle(
            &self,
            override_user_interface_style: UIUserInterfaceStyle,
        );
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// UIViewControllerRotation.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[deprecated = "Please use instance method `setNeedsUpdateOfSupportedInterfaceOrientations`."]
        #[unsafe(method(attemptRotationToDeviceOrientation))]
        #[unsafe(method_family = none)]
        pub fn attemptRotationToDeviceOrientation(mtm: MainThreadMarker);

        #[cfg(feature = "UIOrientation")]
        #[deprecated]
        #[unsafe(method(shouldAutorotateToInterfaceOrientation:))]
        #[unsafe(method_family = none)]
        pub fn shouldAutorotateToInterfaceOrientation(
            &self,
            to_interface_orientation: UIInterfaceOrientation,
        ) -> bool;

        #[deprecated = "Update supported interface orientations and call setNeedsUpdateOfSupportedInterfaceOrientations to indicate a change."]
        #[unsafe(method(shouldAutorotate))]
        #[unsafe(method_family = none)]
        pub fn shouldAutorotate(&self) -> bool;

        #[cfg(feature = "UIOrientation")]
        #[unsafe(method(supportedInterfaceOrientations))]
        #[unsafe(method_family = none)]
        pub fn supportedInterfaceOrientations(&self) -> UIInterfaceOrientationMask;

        #[cfg(feature = "UIOrientation")]
        #[unsafe(method(preferredInterfaceOrientationForPresentation))]
        #[unsafe(method_family = none)]
        pub fn preferredInterfaceOrientationForPresentation(&self) -> UIInterfaceOrientation;

        /// Notifies the view controller that a change occurred that affects supported interface orientations or the preferred interface orientation for presentation.
        /// By default, this will animate any changes to orientation. To perform a non-animated update, call within `[UIView performWithoutAnimation:]`.
        #[unsafe(method(setNeedsUpdateOfSupportedInterfaceOrientations))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateOfSupportedInterfaceOrientations(&self);

        #[cfg(feature = "UIView")]
        #[deprecated = "Header views are animated along with the rest of the view hierarchy"]
        #[unsafe(method(rotatingHeaderView))]
        #[unsafe(method_family = none)]
        pub fn rotatingHeaderView(&self) -> Option<Retained<UIView>>;

        #[cfg(feature = "UIView")]
        #[deprecated = "Footer views are animated along with the rest of the view hierarchy"]
        #[unsafe(method(rotatingFooterView))]
        #[unsafe(method_family = none)]
        pub fn rotatingFooterView(&self) -> Option<Retained<UIView>>;

        #[cfg(feature = "UIOrientation")]
        #[deprecated]
        #[unsafe(method(interfaceOrientation))]
        #[unsafe(method_family = none)]
        pub fn interfaceOrientation(&self) -> UIInterfaceOrientation;

        #[cfg(feature = "UIOrientation")]
        #[deprecated = "Implement viewWillTransitionToSize:withTransitionCoordinator: instead"]
        #[unsafe(method(willRotateToInterfaceOrientation:duration:))]
        #[unsafe(method_family = none)]
        pub fn willRotateToInterfaceOrientation_duration(
            &self,
            to_interface_orientation: UIInterfaceOrientation,
            duration: NSTimeInterval,
        );

        #[cfg(feature = "UIOrientation")]
        #[deprecated]
        #[unsafe(method(didRotateFromInterfaceOrientation:))]
        #[unsafe(method_family = none)]
        pub fn didRotateFromInterfaceOrientation(
            &self,
            from_interface_orientation: UIInterfaceOrientation,
        );

        #[cfg(feature = "UIOrientation")]
        #[deprecated = "Implement viewWillTransitionToSize:withTransitionCoordinator: instead"]
        #[unsafe(method(willAnimateRotationToInterfaceOrientation:duration:))]
        #[unsafe(method_family = none)]
        pub fn willAnimateRotationToInterfaceOrientation_duration(
            &self,
            to_interface_orientation: UIInterfaceOrientation,
            duration: NSTimeInterval,
        );

        #[cfg(feature = "UIOrientation")]
        #[deprecated]
        #[unsafe(method(willAnimateFirstHalfOfRotationToInterfaceOrientation:duration:))]
        #[unsafe(method_family = none)]
        pub fn willAnimateFirstHalfOfRotationToInterfaceOrientation_duration(
            &self,
            to_interface_orientation: UIInterfaceOrientation,
            duration: NSTimeInterval,
        );

        #[cfg(feature = "UIOrientation")]
        #[deprecated]
        #[unsafe(method(didAnimateFirstHalfOfRotationToInterfaceOrientation:))]
        #[unsafe(method_family = none)]
        pub fn didAnimateFirstHalfOfRotationToInterfaceOrientation(
            &self,
            to_interface_orientation: UIInterfaceOrientation,
        );

        #[cfg(feature = "UIOrientation")]
        #[deprecated]
        #[unsafe(method(willAnimateSecondHalfOfRotationFromInterfaceOrientation:duration:))]
        #[unsafe(method_family = none)]
        pub fn willAnimateSecondHalfOfRotationFromInterfaceOrientation_duration(
            &self,
            from_interface_orientation: UIInterfaceOrientation,
            duration: NSTimeInterval,
        );
    );
}

/// UIViewControllerEditing.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(isEditing))]
        #[unsafe(method_family = none)]
        pub fn isEditing(&self) -> bool;

        /// Setter for [`isEditing`][Self::isEditing].
        #[unsafe(method(setEditing:))]
        #[unsafe(method_family = none)]
        pub fn setEditing(&self, editing: bool);

        #[unsafe(method(setEditing:animated:))]
        #[unsafe(method_family = none)]
        pub fn setEditing_animated(&self, editing: bool, animated: bool);

        #[cfg(all(feature = "UIBarButtonItem", feature = "UIBarItem"))]
        #[unsafe(method(editButtonItem))]
        #[unsafe(method_family = none)]
        pub fn editButtonItem(&self) -> Retained<UIBarButtonItem>;
    );
}

/// UISearchDisplayControllerSupport.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UISearchDisplayController")]
        #[deprecated]
        #[unsafe(method(searchDisplayController))]
        #[unsafe(method_family = none)]
        pub fn searchDisplayController(&self) -> Option<Retained<UISearchDisplayController>>;
    );
}

extern "C" {
    /// Raised if the view controller hierarchy is inconsistent with the view hierarchy.
    ///
    /// ## Discussion
    ///
    /// When a view controller’s view is added to the view hierarchy, the system walks up the view hierarchy to find the first parent view that has a view controller. That view controller must be the parent of the view controller whose view is being added. Otherwise, this exception is raised. This consistency check is also performed when a view controller is added as a child by calling the [`addChildViewController:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/addchild(_:)) method.
    ///
    /// It is also allowed for a view controller that has no parent to add its view to the view hierarchy. This is generally not recommended, but is useful in some special cases.
    ///
    ///
    pub static UIViewControllerHierarchyInconsistencyException: &'static NSExceptionName;
}

/// UIContainerViewControllerProtectedMethods.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(childViewControllers))]
        #[unsafe(method_family = none)]
        pub fn childViewControllers(&self) -> Retained<NSArray<UIViewController>>;

        #[unsafe(method(addChildViewController:))]
        #[unsafe(method_family = none)]
        pub fn addChildViewController(&self, child_controller: &UIViewController);

        #[unsafe(method(removeFromParentViewController))]
        #[unsafe(method_family = none)]
        pub fn removeFromParentViewController(&self);

        #[cfg(all(feature = "UIView", feature = "block2"))]
        #[unsafe(method(transitionFromViewController:toViewController:duration:options:animations:completion:))]
        #[unsafe(method_family = none)]
        pub fn transitionFromViewController_toViewController_duration_options_animations_completion(
            &self,
            from_view_controller: &UIViewController,
            to_view_controller: &UIViewController,
            duration: NSTimeInterval,
            options: UIViewAnimationOptions,
            animations: Option<&block2::DynBlock<dyn Fn()>>,
            completion: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[unsafe(method(beginAppearanceTransition:animated:))]
        #[unsafe(method_family = none)]
        pub fn beginAppearanceTransition_animated(&self, is_appearing: bool, animated: bool);

        #[unsafe(method(endAppearanceTransition))]
        #[unsafe(method_family = none)]
        pub fn endAppearanceTransition(&self);

        #[deprecated = "Has no effect on visionOS"]
        #[unsafe(method(childViewControllerForStatusBarStyle))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForStatusBarStyle(&self) -> Option<Retained<UIViewController>>;

        #[deprecated = "Has no effect on visionOS"]
        #[unsafe(method(childViewControllerForStatusBarHidden))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForStatusBarHidden(&self) -> Option<Retained<UIViewController>>;

        #[cfg(feature = "UITraitCollection")]
        #[deprecated = "Use the traitOverrides property on the child view controller instead"]
        #[unsafe(method(setOverrideTraitCollection:forChildViewController:))]
        #[unsafe(method_family = none)]
        pub fn setOverrideTraitCollection_forChildViewController(
            &self,
            collection: Option<&UITraitCollection>,
            child_view_controller: &UIViewController,
        );

        #[cfg(feature = "UITraitCollection")]
        #[deprecated = "Use the traitOverrides property on the child view controller instead"]
        #[unsafe(method(overrideTraitCollectionForChildViewController:))]
        #[unsafe(method_family = none)]
        pub fn overrideTraitCollectionForChildViewController(
            &self,
            child_view_controller: &UIViewController,
        ) -> Option<Retained<UITraitCollection>>;

        #[unsafe(method(childViewControllerForUserInterfaceStyle))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForUserInterfaceStyle(
            &self,
        ) -> Option<Retained<UIViewController>>;
    );
}

/// UIContainerViewControllerCallbacks.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers))]
        #[unsafe(method_family = none)]
        pub fn automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers(
            &self,
        ) -> bool;

        #[deprecated = "Manually forward viewWillTransitionToSize:withTransitionCoordinator: if necessary"]
        #[unsafe(method(shouldAutomaticallyForwardRotationMethods))]
        #[unsafe(method_family = none)]
        pub fn shouldAutomaticallyForwardRotationMethods(&self) -> bool;

        #[unsafe(method(shouldAutomaticallyForwardAppearanceMethods))]
        #[unsafe(method_family = none)]
        pub fn shouldAutomaticallyForwardAppearanceMethods(&self) -> bool;

        #[unsafe(method(willMoveToParentViewController:))]
        #[unsafe(method_family = none)]
        pub fn willMoveToParentViewController(&self, parent: Option<&UIViewController>);

        #[unsafe(method(didMoveToParentViewController:))]
        #[unsafe(method_family = none)]
        pub fn didMoveToParentViewController(&self, parent: Option<&UIViewController>);
    );
}

/// UIStateRestoration.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(restorationIdentifier))]
        #[unsafe(method_family = none)]
        pub fn restorationIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`restorationIdentifier`][Self::restorationIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRestorationIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setRestorationIdentifier(&self, restoration_identifier: Option<&NSString>);

        #[cfg(feature = "UIStateRestoration")]
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(restorationClass))]
        #[unsafe(method_family = none)]
        pub unsafe fn restorationClass(&self) -> Option<&'static AnyClass>;

        #[cfg(feature = "UIStateRestoration")]
        /// Setter for [`restorationClass`][Self::restorationClass].
        ///
        /// # Safety
        ///
        /// - `restoration_class` must implement UIViewControllerRestoration.
        /// - This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setRestorationClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRestorationClass(&self, restoration_class: Option<&AnyClass>);

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(decodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeRestorableStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(applicationFinishedRestoringState))]
        #[unsafe(method_family = none)]
        pub fn applicationFinishedRestoringState(&self);
    );
}

#[cfg(all(feature = "UIResponder", feature = "UIStateRestoration"))]
extern_conformance!(
    unsafe impl UIStateRestoring for UIViewController {}
);

/// UIConstraintBasedLayoutCoreMethods.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(updateViewConstraints))]
        #[unsafe(method_family = none)]
        pub fn updateViewConstraints(&self);
    );
}

/// UIViewControllerTransitioning.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UIViewControllerTransitioning")]
        #[unsafe(method(transitioningDelegate))]
        #[unsafe(method_family = none)]
        pub fn transitioningDelegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UIViewControllerTransitioningDelegate>>>;

        #[cfg(feature = "UIViewControllerTransitioning")]
        /// Setter for [`transitioningDelegate`][Self::transitioningDelegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setTransitioningDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setTransitioningDelegate(
            &self,
            transitioning_delegate: Option<
                &ProtocolObject<dyn UIViewControllerTransitioningDelegate>,
            >,
        );
    );
}

/// UILayoutSupport.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "NSLayoutConstraint")]
        #[deprecated = "Use view.safeAreaLayoutGuide.topAnchor instead of topLayoutGuide.bottomAnchor"]
        #[unsafe(method(topLayoutGuide))]
        #[unsafe(method_family = none)]
        pub fn topLayoutGuide(&self) -> Retained<ProtocolObject<dyn UILayoutSupport>>;

        #[cfg(feature = "NSLayoutConstraint")]
        #[deprecated = "Use view.safeAreaLayoutGuide.bottomAnchor instead of bottomLayoutGuide.topAnchor"]
        #[unsafe(method(bottomLayoutGuide))]
        #[unsafe(method_family = none)]
        pub fn bottomLayoutGuide(&self) -> Retained<ProtocolObject<dyn UILayoutSupport>>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(additionalSafeAreaInsets))]
        #[unsafe(method_family = none)]
        pub fn additionalSafeAreaInsets(&self) -> UIEdgeInsets;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// Setter for [`additionalSafeAreaInsets`][Self::additionalSafeAreaInsets].
        #[unsafe(method(setAdditionalSafeAreaInsets:))]
        #[unsafe(method_family = none)]
        pub fn setAdditionalSafeAreaInsets(&self, additional_safe_area_insets: UIEdgeInsets);

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(systemMinimumLayoutMargins))]
        #[unsafe(method_family = none)]
        pub fn systemMinimumLayoutMargins(&self) -> NSDirectionalEdgeInsets;

        #[unsafe(method(viewRespectsSystemMinimumLayoutMargins))]
        #[unsafe(method_family = none)]
        pub fn viewRespectsSystemMinimumLayoutMargins(&self) -> bool;

        /// Setter for [`viewRespectsSystemMinimumLayoutMargins`][Self::viewRespectsSystemMinimumLayoutMargins].
        #[unsafe(method(setViewRespectsSystemMinimumLayoutMargins:))]
        #[unsafe(method_family = none)]
        pub fn setViewRespectsSystemMinimumLayoutMargins(
            &self,
            view_respects_system_minimum_layout_margins: bool,
        );

        #[unsafe(method(viewLayoutMarginsDidChange))]
        #[unsafe(method_family = none)]
        pub fn viewLayoutMarginsDidChange(&self);

        #[unsafe(method(viewSafeAreaInsetsDidChange))]
        #[unsafe(method_family = none)]
        pub fn viewSafeAreaInsetsDidChange(&self);
    );
}

/// UIKeyCommand.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(all(
            feature = "UICommand",
            feature = "UIKeyCommand",
            feature = "UIMenuElement"
        ))]
        #[unsafe(method(addKeyCommand:))]
        #[unsafe(method_family = none)]
        pub fn addKeyCommand(&self, key_command: &UIKeyCommand);

        #[cfg(all(
            feature = "UICommand",
            feature = "UIKeyCommand",
            feature = "UIMenuElement"
        ))]
        #[unsafe(method(removeKeyCommand:))]
        #[unsafe(method_family = none)]
        pub fn removeKeyCommand(&self, key_command: &UIKeyCommand);
    );
}

/// UIPerformsActions.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        /// Determines whether the receiver continues to respond to actions while it is presenting a view controller modally.
        ///
        /// Defaults to YES. You can change the default return value by providing a value for UIViewControllerPerformsActionsWhilePresentingModally in your Info.plist file.
        #[unsafe(method(performsActionsWhilePresentingModally))]
        #[unsafe(method_family = none)]
        pub fn performsActionsWhilePresentingModally(&self) -> bool;
    );
}

/// NSExtensionAdditions.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(extensionContext))]
        #[unsafe(method_family = none)]
        pub fn extensionContext(&self) -> Option<Retained<NSExtensionContext>>;
    );
}

#[cfg(feature = "UIResponder")]
extern_conformance!(
    unsafe impl NSExtensionRequestHandling for UIViewController {}
);

/// UIPresentationController.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UIPresentationController")]
        #[unsafe(method(presentationController))]
        #[unsafe(method_family = none)]
        pub fn presentationController(&self) -> Option<Retained<UIPresentationController>>;

        #[cfg(all(
            feature = "UIPresentationController",
            feature = "UISheetPresentationController"
        ))]
        #[unsafe(method(sheetPresentationController))]
        #[unsafe(method_family = none)]
        pub fn sheetPresentationController(
            &self,
        ) -> Option<Retained<UISheetPresentationController>>;

        #[cfg(all(
            feature = "UIPopoverPresentationController",
            feature = "UIPresentationController"
        ))]
        #[unsafe(method(popoverPresentationController))]
        #[unsafe(method_family = none)]
        pub fn popoverPresentationController(
            &self,
        ) -> Option<Retained<UIPopoverPresentationController>>;

        #[cfg(feature = "UIPresentationController")]
        #[unsafe(method(activePresentationController))]
        #[unsafe(method_family = none)]
        pub fn activePresentationController(&self) -> Option<Retained<UIPresentationController>>;

        #[unsafe(method(isModalInPresentation))]
        #[unsafe(method_family = none)]
        pub fn isModalInPresentation(&self) -> bool;

        /// Setter for [`isModalInPresentation`][Self::isModalInPresentation].
        #[unsafe(method(setModalInPresentation:))]
        #[unsafe(method_family = none)]
        pub fn setModalInPresentation(&self, modal_in_presentation: bool);
    );
}

extern_protocol!(
    /// A set of methods that define the interface for configuring a previewing view controller on devices that support 3D Touch.
    ///
    /// ## Overview
    ///
    /// The system returns a context object conforming to this protocol when you call a view controller’s [`registerForPreviewingWithDelegate:sourceView:`](https://developer.apple.com/documentation/uikit/uiviewcontroller/registerforpreviewing(with:sourceview:)) method. This method registers the view controller to participate in 3D Touch preview (peek) and commit (pop) behaviors.
    ///
    /// <div class="warning">
    ///
    /// ### Terminology Note
    ///  The end-user terminology for the views presented during the phases of force-based touches includes _peek_ and _pop_. For clarity here, and to align with the API names, this document uses the corresponding terms _preview_ and _commit view_.
    ///
    ///
    ///
    /// </div>
    /// To learn about 3D Touch, read [Adopting 3D Touch on iPhone](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/index.html#//apple_ref/doc/uid/TP40016543).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t adopt this protocol in custom classes.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait UIViewControllerPreviewing: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "UIGestureRecognizer")]
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(previewingGestureRecognizerForFailureRelationship))]
        #[unsafe(method_family = none)]
        fn previewingGestureRecognizerForFailureRelationship(
            &self,
        ) -> Retained<UIGestureRecognizer>;

        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        fn delegate(&self) -> Retained<ProtocolObject<dyn UIViewControllerPreviewingDelegate>>;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(sourceView))]
        #[unsafe(method_family = none)]
        fn sourceView(&self) -> Retained<UIView>;

        #[cfg(feature = "objc2-core-foundation")]
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(sourceRect))]
        #[unsafe(method_family = none)]
        fn sourceRect(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`sourceRect`][Self::sourceRect].
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(setSourceRect:))]
        #[unsafe(method_family = none)]
        fn setSourceRect(&self, source_rect: CGRect);
    }
);

extern_protocol!(
    /// A set of methods used by the delegate to respond, with a preview view controller and a commit view controller, to the user pressing a view object on the screen of a device that supports 3D Touch.
    ///
    /// ## Overview
    ///
    /// To learn about 3D Touch, read [Adopting 3D Touch on iPhone](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Adopting3DTouchOniPhone/index.html#//apple_ref/doc/uid/TP40016543).
    ///
    /// <div class="warning">
    ///
    /// ### Terminology Note
    ///  The end-user terminology for the views presented during the phases of force-based touches includes _peek_ and _pop_. For clarity here, and to align with the API names, this document uses the corresponding terms _preview_ and _commit view_.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait UIViewControllerPreviewingDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(all(feature = "UIResponder", feature = "objc2-core-foundation"))]
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(previewingContext:viewControllerForLocation:))]
        #[unsafe(method_family = none)]
        fn previewingContext_viewControllerForLocation(
            &self,
            previewing_context: &ProtocolObject<dyn UIViewControllerPreviewing>,
            location: CGPoint,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(feature = "UIResponder")]
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(previewingContext:commitViewController:))]
        #[unsafe(method_family = none)]
        fn previewingContext_commitViewController(
            &self,
            previewing_context: &ProtocolObject<dyn UIViewControllerPreviewing>,
            view_controller_to_commit: &UIViewController,
        );
    }
);

/// UIViewControllerPreviewingRegistration.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UIView")]
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(registerForPreviewingWithDelegate:sourceView:))]
        #[unsafe(method_family = none)]
        pub fn registerForPreviewingWithDelegate_sourceView(
            &self,
            delegate: &ProtocolObject<dyn UIViewControllerPreviewingDelegate>,
            source_view: &UIView,
        ) -> Retained<ProtocolObject<dyn UIViewControllerPreviewing>>;

        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(unregisterForPreviewingWithContext:))]
        #[unsafe(method_family = none)]
        pub fn unregisterForPreviewingWithContext(
            &self,
            previewing: &ProtocolObject<dyn UIViewControllerPreviewing>,
        );
    );
}

/// UIScreenEdgesDeferringSystemGestures.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(childViewControllerForScreenEdgesDeferringSystemGestures))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForScreenEdgesDeferringSystemGestures(
            &self,
        ) -> Option<Retained<UIViewController>>;

        #[cfg(feature = "UIGeometry")]
        #[unsafe(method(preferredScreenEdgesDeferringSystemGestures))]
        #[unsafe(method_family = none)]
        pub fn preferredScreenEdgesDeferringSystemGestures(&self) -> UIRectEdge;

        #[unsafe(method(setNeedsUpdateOfScreenEdgesDeferringSystemGestures))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateOfScreenEdgesDeferringSystemGestures(&self);
    );
}

/// UIHomeIndicatorAutoHidden.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(childViewControllerForHomeIndicatorAutoHidden))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForHomeIndicatorAutoHidden(
            &self,
        ) -> Option<Retained<UIViewController>>;

        #[unsafe(method(prefersHomeIndicatorAutoHidden))]
        #[unsafe(method_family = none)]
        pub fn prefersHomeIndicatorAutoHidden(&self) -> bool;

        #[unsafe(method(setNeedsUpdateOfHomeIndicatorAutoHidden))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateOfHomeIndicatorAutoHidden(&self);
    );
}

/// UIPointerLockSupport.
#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(childViewControllerForPointerLock))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForPointerLock(&self) -> Option<Retained<UIViewController>>;

        #[unsafe(method(prefersPointerLocked))]
        #[unsafe(method_family = none)]
        pub fn prefersPointerLocked(&self) -> bool;

        #[unsafe(method(setNeedsUpdateOfPrefersPointerLocked))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateOfPrefersPointerLocked(&self);
    );
}

#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UIContentConfiguration")]
        /// Setting a content unavailable configuration replaces the existing content unavailable view of the view controller with a new content unavailable view instance from the configuration,
        /// or directly applies the configuration to the existing content unavailable view if the configuration is compatible with the existing content unavailable view type.
        /// The default value is nil.
        #[unsafe(method(contentUnavailableConfiguration))]
        #[unsafe(method_family = none)]
        pub fn contentUnavailableConfiguration(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn UIContentConfiguration>>>;

        #[cfg(feature = "UIContentConfiguration")]
        /// Setter for [`contentUnavailableConfiguration`][Self::contentUnavailableConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setContentUnavailableConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn setContentUnavailableConfiguration(
            &self,
            content_unavailable_configuration: Option<&ProtocolObject<dyn UIContentConfiguration>>,
        );

        #[cfg(feature = "UIContentUnavailableConfigurationState")]
        /// Returns the current content unavailable configuration state for the view.
        /// To add your own custom state(s), override the getter and call super to obtain an instance with the
        /// system properties set, then set your own custom states as desired.
        #[unsafe(method(contentUnavailableConfigurationState))]
        #[unsafe(method_family = none)]
        pub fn contentUnavailableConfigurationState(
            &self,
        ) -> Retained<UIContentUnavailableConfigurationState>;

        /// Requests the view update its content unavailable configuration for its current state. This method is called automatically
        /// when the view's `contentUnavailableConfigurationState` may have changed, as well as in other circumstances where an
        /// update may be required. Multiple requests may be coalesced into a single update at the appropriate time.
        #[unsafe(method(setNeedsUpdateContentUnavailableConfiguration))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateContentUnavailableConfiguration(&self);

        #[cfg(feature = "UIContentUnavailableConfigurationState")]
        /// Subclasses should override this method and update the content unavailable's configuration using the state provided.
        /// This method should not be called directly, use `setNeedsUpdateContentUnavailableConfiguration` to request an update.
        #[unsafe(method(updateContentUnavailableConfigurationUsingState:))]
        #[unsafe(method_family = none)]
        pub fn updateContentUnavailableConfigurationUsingState(
            &self,
            state: &UIContentUnavailableConfigurationState,
        );
    );
}

#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        /// A child view controller to query for the interface orientation lock preference.
        ///
        /// Override to return a child view controller or `nil`. If you return a view controller, the system uses that view controller’s preference for interface orientation lock. If you
        /// return `nil`, the system uses `self` to get the preference for interface orientation lock. Call ``UIViewController/setNeedsUpdateOfPrefersInterfaceOrientationLocked()``
        /// if the child view controller that the system needs to query for the interface orientation lock preference changes.
        #[unsafe(method(childViewControllerForInterfaceOrientationLock))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForInterfaceOrientationLock(
            &self,
        ) -> Option<Retained<UIViewController>>;

        /// A Boolean value that indicates whether the view controller prefers to lock the scene's interface orientation when the scene is visible.
        ///
        /// The default is
        /// <doc
        /// ://com.apple.documentation/documentation/swift/false>. Set this property to
        /// <doc
        /// ://com.apple.documentation/documentation/swift/true>
        /// to indicate the view controller's preference to lock the scene's interface orientation. Check ``UIWindowScene.effectiveGeometry.isInterfaceOrientationLocked``
        /// for the current state of the interface orientation lock. The system will consider locking the interface orientation when these conditions are true:
        ///
        /// - The scene is centered on the screen
        /// - The scene is the same size as the screen
        /// - The scene is not occluded by another scene
        ///
        /// The system continuously monitors the state and when the app no longer satisfies the requirements, it disables the interface orientation lock.
        ///
        /// If you change the value of `prefersInterfaceOrientationLocked`, call ``UIViewController/setNeedsUpdateOfPrefersInterfaceOrientationLocked()``.
        #[unsafe(method(prefersInterfaceOrientationLocked))]
        #[unsafe(method_family = none)]
        pub fn prefersInterfaceOrientationLocked(&self) -> bool;

        /// Indicates that the view controller changed the interface orientation lock preference.
        #[unsafe(method(setNeedsUpdateOfPrefersInterfaceOrientationLocked))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateOfPrefersInterfaceOrientationLocked(&self);
    );
}

#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[deprecated = "UIViewControllerPreviewing is deprecated. Please use UIContextMenuInteraction."]
        #[unsafe(method(previewActionItems))]
        #[unsafe(method_family = none)]
        pub fn previewActionItems(
            &self,
        ) -> Retained<NSArray<ProtocolObject<dyn UIPreviewActionItem>>>;
    );
}

#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method(traitOverrides))]
        #[unsafe(method_family = none)]
        pub fn traitOverrides(&self) -> Retained<ProtocolObject<dyn UITraitOverrides>>;

        /// Forces an immediate trait update for this view controller and its view, including any view
        /// controllers and views in this subtree. Any trait change callbacks are sent synchronously.
        #[unsafe(method(updateTraitsIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updateTraitsIfNeeded(&self);
    );
}

#[cfg(all(feature = "UIResponder", feature = "UITraitCollection"))]
extern_conformance!(
    unsafe impl UITraitChangeObservable for UIViewController {}
);

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIContainerBackgroundStyle(pub NSInteger);
impl UIContainerBackgroundStyle {
    #[doc(alias = "UIContainerBackgroundStyleAutomatic")]
    pub const Automatic: Self = Self(0);
    #[doc(alias = "UIContainerBackgroundStyleGlass")]
    pub const Glass: Self = Self(1);
    #[doc(alias = "UIContainerBackgroundStyleHidden")]
    pub const Hidden: Self = Self(2);
}

unsafe impl Encode for UIContainerBackgroundStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIContainerBackgroundStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "UIResponder")]
impl UIViewController {
    extern_methods!(
        #[unsafe(method(preferredContainerBackgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn preferredContainerBackgroundStyle(&self) -> UIContainerBackgroundStyle;

        #[unsafe(method(childViewControllerForPreferredContainerBackgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn childViewControllerForPreferredContainerBackgroundStyle(
            &self,
        ) -> Option<Retained<UIViewController>>;

        #[unsafe(method(setNeedsUpdateOfPreferredContainerBackgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateOfPreferredContainerBackgroundStyle(&self);
    );
}

extern_protocol!(
    /// A set of methods that defines the styles you can apply to peek quick actions and peek quick action groups, and defines a read-only accessor for the user-visible title of a peek quick action.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t adopt this protocol in custom classes.
    ///
    ///
    ///
    /// </div>
    /// The [`UIPreviewActionItem`](https://developer.apple.com/documentation/uikit/uipreviewactionitem) protocol is adopted by the [`UIPreviewAction`](https://developer.apple.com/documentation/uikit/uipreviewaction) and [`UIPreviewActionGroup`](https://developer.apple.com/documentation/uikit/uipreviewactiongroup) classes.
    ///
    ///
    pub unsafe trait UIPreviewActionItem: NSObjectProtocol + MainThreadOnly {
        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        fn title(&self) -> Retained<NSString>;
    }
);

/// The style for a peek quick action.
///
/// ## Overview
///
/// Use these styles with instances of the [`UIPreviewAction`](https://developer.apple.com/documentation/uikit/uipreviewaction) and [`UIPreviewActionGroup`](https://developer.apple.com/documentation/uikit/uipreviewactiongroup) classes.
///
///
// NS_ENUM
#[deprecated = "Please use UIContextMenuInteraction."]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIPreviewActionStyle(pub NSInteger);
impl UIPreviewActionStyle {
    /// The default style.
    #[doc(alias = "UIPreviewActionStyleDefault")]
    #[deprecated = "Please use UIContextMenuInteraction."]
    pub const Default: Self = Self(0);
    /// The style for a selected peek quick action.
    ///
    /// ## Discussion
    ///
    /// Use this style for the initially-selected item within a disclosed peek quick action group.
    ///
    ///
    #[doc(alias = "UIPreviewActionStyleSelected")]
    #[deprecated = "Please use UIContextMenuInteraction."]
    pub const Selected: Self = Self(1);
    /// The style for a peek quick action that changes or deletes data.
    #[doc(alias = "UIPreviewActionStyleDestructive")]
    #[deprecated = "Please use UIContextMenuInteraction."]
    pub const Destructive: Self = Self(2);
}

unsafe impl Encode for UIPreviewActionStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIPreviewActionStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A preview action, or _peek quick action_, that displays below a peek when a user swipes the peek upward.
    ///
    /// ## Overview
    ///
    /// A peek quick action typically selects a deep link to your app and has a title, a style, and a handler. Peeks and peek quick actions are available on devices that support 3D Touch.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Please use UIContextMenuInteraction."]
    pub struct UIPreviewAction;
);

extern_conformance!(
    unsafe impl NSCopying for UIPreviewAction {}
);

unsafe impl CopyingHelper for UIPreviewAction {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UIPreviewAction {}
);

extern_conformance!(
    unsafe impl UIPreviewActionItem for UIPreviewAction {}
);

impl UIPreviewAction {
    extern_methods!(
        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(handler))]
        #[unsafe(method_family = none)]
        pub unsafe fn handler(
            &self,
        ) -> NonNull<
            block2::DynBlock<
                dyn Fn(NonNull<ProtocolObject<dyn UIPreviewActionItem>>, NonNull<UIViewController>),
            >,
        >;

        #[cfg(all(feature = "UIResponder", feature = "block2"))]
        #[unsafe(method(actionWithTitle:style:handler:))]
        #[unsafe(method_family = none)]
        pub fn actionWithTitle_style_handler(
            title: &NSString,
            style: UIPreviewActionStyle,
            handler: &block2::DynBlock<dyn Fn(NonNull<UIPreviewAction>, NonNull<UIViewController>)>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UIPreviewAction {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// A group of one or more child quick actions, each an instance of the preview action class.
    ///
    /// ## Overview
    ///
    /// When first displayed, the group appears as a single option in a peek quick action sheet. If the user selects the group, a submenu opens, displaying the child quick actions.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Please use UIContextMenuInteraction."]
    pub struct UIPreviewActionGroup;
);

extern_conformance!(
    unsafe impl NSCopying for UIPreviewActionGroup {}
);

unsafe impl CopyingHelper for UIPreviewActionGroup {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UIPreviewActionGroup {}
);

extern_conformance!(
    unsafe impl UIPreviewActionItem for UIPreviewActionGroup {}
);

impl UIPreviewActionGroup {
    extern_methods!(
        #[unsafe(method(actionGroupWithTitle:style:actions:))]
        #[unsafe(method_family = none)]
        pub fn actionGroupWithTitle_style_actions(
            title: &NSString,
            style: UIPreviewActionStyle,
            actions: &NSArray<UIPreviewAction>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UIPreviewActionGroup {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
