//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
use objc2_quartz_core::*;

use crate::*;

/// The type of border around the text field.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITextBorderStyle(pub NSInteger);
impl UITextBorderStyle {
    /// The text field does not display a border.
    #[doc(alias = "UITextBorderStyleNone")]
    pub const None: Self = Self(0);
    /// Displays a thin rectangle around the text field.
    #[doc(alias = "UITextBorderStyleLine")]
    pub const Line: Self = Self(1);
    /// Displays a bezel-style border for the text field. This style is typically used for standard data-entry fields.
    #[doc(alias = "UITextBorderStyleBezel")]
    pub const Bezel: Self = Self(2);
    /// Displays a rounded-style border for the text field.
    #[doc(alias = "UITextBorderStyleRoundedRect")]
    pub const RoundedRect: Self = Self(3);
}

unsafe impl Encode for UITextBorderStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextBorderStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that define when overlay views appear in a text field.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITextFieldViewMode(pub NSInteger);
impl UITextFieldViewMode {
    /// The overlay view never appears.
    #[doc(alias = "UITextFieldViewModeNever")]
    pub const Never: Self = Self(0);
    /// The overlay view is displayed only while text is being edited in the text field.
    #[doc(alias = "UITextFieldViewModeWhileEditing")]
    pub const WhileEditing: Self = Self(1);
    /// The overlay view is displayed only when text is not being edited.
    #[doc(alias = "UITextFieldViewModeUnlessEditing")]
    pub const UnlessEditing: Self = Self(2);
    /// The overlay view is always displayed if the text field contains text.
    #[doc(alias = "UITextFieldViewModeAlways")]
    pub const Always: Self = Self(3);
}

unsafe impl Encode for UITextFieldViewMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextFieldViewMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicate the reason for ending editing in a text field.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITextFieldDidEndEditingReason(pub NSInteger);
impl UITextFieldDidEndEditingReason {
    /// The text field changes were accepted by the user.
    ///
    /// ## Discussion
    ///
    /// On tvOS, text field changes become committed when the user presses the Done button.
    ///
    ///
    #[doc(alias = "UITextFieldDidEndEditingReasonCommitted")]
    pub const Committed: Self = Self(0);
    /// The text field changes were aborted.
    ///
    /// ## Discussion
    ///
    /// On tvOS, text field changes become cancelled when the user dismisses the text entry interface by pressing the Menu button.
    ///
    ///
    #[doc(alias = "UITextFieldDidEndEditingReasonCancelled")]
    pub const Cancelled: Self = Self(1);
}

unsafe impl Encode for UITextFieldDidEndEditingReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextFieldDidEndEditingReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that displays an editable text area in your interface.
    ///
    /// ## Overview
    ///
    /// You use text fields to gather text-based input from the user using the onscreen keyboard. The keyboard is configurable for many different types of input such as plain text, emails, numbers, and so on. Text fields use the target-action mechanism and a delegate object to report changes made during the course of editing.
    ///
    /// In addition to its basic text-editing behavior, you can add overlay views to a text field to display additional information and provide additional tappable controls. You might add custom overlay views for elements such as a bookmarks button or search icon. Text fields provide a built-in overlay view to clear the current text. The use of custom overlay views is optional.
    ///
    ///
    /// ![](https://docs-assets.developer.apple.com/published/a9c08ac61274deea4eef6f1c14f01dea/media-2557435%402x.png)
    ///
    ///
    /// After adding a text field to your interface, you configure it for use in your app. Configuration involves performing some or all of the following tasks:
    ///
    /// - Configure one or more targets and actions for the text field.
    ///
    /// - Configure the keyboard-related attributes of the text field.
    ///
    /// - Assign a delegate object to handle important tasks, such as:
    ///
    ///   - Determining whether the user should be allowed to edit the text field’s contents.
    ///
    /// - Validating the text entered by the user.
    ///
    /// - Responding to taps in the keyboard’s return button.
    ///
    /// - Forwarding the user-entered text to other parts of your app.
    ///
    /// - Store a reference to the text field in one of your controller objects.
    ///
    /// For information about the methods of the text field’s delegate object, see [`UITextFieldDelegate`](https://developer.apple.com/documentation/uikit/uitextfielddelegate).
    ///
    /// ### Show and hide the keyboard
    ///
    /// When a text field becomes first responder, the system automatically shows the keyboard and binds its input to the text field. A text field becomes the first responder automatically when the user taps it. You can also force a text field to become the first responder by calling its [`becomeFirstResponder`](https://developer.apple.com/documentation/uikit/uiresponder/becomefirstresponder()) method. You might force a text field to become first responder when you require the user to enter some information.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The appearance of the keyboard has the potential to obscure portions of your user interface. You should update your interface as needed to ensure that the text field being edited is visible. Use the keyboard notifications to detect the appearance and disappearance of the keyboard and to make necessary changes to your interface. For more information, see [Respond to keyboard-related notifications](https://developer.apple.com/documentation/uikit/uitextfield#respond-to-keyboard-related-notifications).
    ///
    ///
    ///
    /// </div>
    /// You can ask the system to dismiss the keyboard by calling the [`resignFirstResponder`](https://developer.apple.com/documentation/uikit/uiresponder/resignfirstresponder()) method of your text field. Usually, you dismiss the keyboard in response to specific interactions. For example, you might dismiss the keyboard when the user taps the keyboard’s return key. The system can also dismiss the keyboard in response to user actions. Specifically, the system dismisses the keyboard when the user taps a new control that doesn’t support keyboard input.
    ///
    /// The appearance and dismissal of the keyboard affect the editing state of the text field. When the keyboard appears, the text field enters the editing state and sends the appropriate notifications to its delegate. Similarly, when the text field resigns the first responder status, it leaves the editing state and notifies its delegate. For more information about the sequence of events that occur during editing, see [Validate text and manage the editing process](https://developer.apple.com/documentation/uikit/uitextfield#validate-text-and-manage-the-editing-process).
    ///
    /// #### Configure the keyboard’s appearance
    ///
    /// You customize your text field’s keyboard using the properties of the [`UITextInputTraits`](https://developer.apple.com/documentation/uikit/uitextinputtraits) protocol, which the [`UITextField`](https://developer.apple.com/documentation/uikit/uitextfield) class adopts. UIKit supports standard keyboards for the user’s current language and also supports specialized keyboards for entering numbers, URLs, email addresses, and other specific types of information. You use the properties of this protocol to adjust keyboard traits such as the following:
    ///
    /// - The type of keyboard to display
    ///
    /// - The autocapitalization behavior of the keyboard
    ///
    /// - The autocorrection behavior of the keyboard
    ///
    /// - The type of return key to display
    ///
    /// #### Respond to keyboard-related notifications
    ///
    /// Because the system manages the showing and hiding of the keyboard in response to responder changes, it posts the following notifications for tracking the keyboard-related changes:
    ///
    /// - [`UIKeyboardWillShowNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboardwillshownotification)
    ///
    /// - [`UIKeyboardDidShowNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboarddidshownotification)
    ///
    /// - [`UIKeyboardWillHideNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboardwillhidenotification)
    ///
    /// - [`UIKeyboardDidHideNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboarddidhidenotification)
    ///
    /// - [`UIKeyboardWillChangeFrameNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboardwillchangeframenotification)
    ///
    /// - [`UIKeyboardDidChangeFrameNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboarddidchangeframenotification)
    ///
    /// Each notification contains a [`userInfo`](https://developer.apple.com/documentation/foundation/nsnotification/userinfo) dictionary that includes the size of the keyboard. Because the keyboard can hide portions of your interface, you should use the size information to reposition your content on the screen. For content embedded in a scroll view, you can scroll the text field into view, as illustrated in the following image. In other cases, you can resize your main content view so that it isn’t covered by the keyboard.
    ///
    ///
    /// ![A screenshot that demonstrates adjusting the position of a text field when the keyboard appears.](https://docs-assets.developer.apple.com/published/e17a65caa37c61e4c058c2cb6c175039/media-1965762%402x.png)
    ///
    ///
    /// For more information about managing keyboard interactions, see [Text Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542).
    ///
    /// ### Format the text in a text field
    ///
    /// There are two types of formatting you can do to a text field’s text:
    ///
    /// - You can change the font, color, and style of the text using properties of this class. Alternatively, you can specify an [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) for the text field’s content.
    ///
    /// - You can format the content of a text field using an [`NSFormatter`](https://developer.apple.com/documentation/foundation/formatter) object.
    ///
    /// The [`font`](https://developer.apple.com/documentation/uikit/uitextfield/font), [`textColor`](https://developer.apple.com/documentation/uikit/uitextfield/textcolor), and [`textAlignment`](https://developer.apple.com/documentation/uikit/uitextfield/textalignment) properties, among others, affect the appearance of the text field’s string. Modifying these properties applies the specified characteristic to the entire string. To specify more granular formatting, specify the text field’s text using an [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) object.
    ///
    /// The [`UITextField`](https://developer.apple.com/documentation/uikit/uitextfield) class doesn’t provide built-in support for formatting its string using an [`NSFormatter`](https://developer.apple.com/documentation/foundation/formatter) object, but you can use the text field’s delegate to format the content yourself. To do so, use the text field’s delegate methods to validate text and to format it appropriately. For example, use the [`textField:shouldChangeCharactersInRange:replacementString:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfield(_:shouldchangecharactersin:replacementstring:)) method to validate and format text while the user is typing. For information about how to use formatter objects, see [Data Formatting Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DataFormatting/DataFormatting.html#//apple_ref/doc/uid/10000029i).
    ///
    /// ### Use overlay views to edit content
    ///
    /// Overlay views are small views displayed on the left and right sides of the text view’s editable area. Typically, overlay views are image-based buttons that you set up as additional editing controls. For example, you might use an overlay view to implement a bookmarks button. To configure a button as an overlay view, specify an image for the button’s content and configure the target and action of the button to respond to taps.
    ///
    /// The following code shows how to add a button as the left overlay of a text field. In this case, the code creates a button and configure its size and contents. The [`leftViewMode`](https://developer.apple.com/documentation/uikit/uitextfield/leftviewmode) property specifies when your button is displayed. When the user taps the button, the button calls the configured action method, which in this case is a custom `displayBookmarks:` method.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let overlayButton = UIButton(type: .custom)", "let bookmarkImage = UIImage(systemName: \"bookmark\")", "overlayButton.setImage(bookmarkImage, for: .normal)", "overlayButton.addTarget(self, action: #selector(displayBookmarks), ", "    for: .touchUpInside)", "overlayButton.sizeToFit()", "        ", "// Assign the overlay button to the text field", "textField.leftView = overlayButton", "textField.leftViewMode = .always"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UIButton *overlayButton = [UIButton buttonWithType:UIButtonTypeCustom];", "UIImage *bookmarkImage = [UIImage systemImageNamed:@\"bookmark\"];", "[overlayButton setImage:bookmarkImage forState:UIControlStateNormal];", "[overlayButton addTarget:self action:@selector(displayBookmarks)", "        forControlEvents:UIControlEventTouchUpInside];", "[overlayButton sizeToFit];", "", "// Assign the overlay button to the text field", "self.textField.leftView = overlayButton;", "self.textField.leftViewMode = UITextFieldViewModeAlways;"], metadata: None }] }] })
    /// When configuring overlay views, consider whether you want your text field to display the built-in clear button. The clear button provides the user with a convenient way to delete all of the text field’s text. This button is displayed in the right overlay position, but if you provide a custom right overlay view, use the [`rightViewMode`](https://developer.apple.com/documentation/uikit/uitextfield/rightviewmode) and [`clearButtonMode`](https://developer.apple.com/documentation/uikit/uitextfield/clearbuttonmode) properties to define when your custom overlay should be displayed and when the clear button should be displayed.
    ///
    /// ### Validate text and manage the editing process
    ///
    /// A text field manages the editing of its text with the help of its delegate object. As the user interacts with a text field, the text field notifies its delegate and gives it a chance to control what is happening. You can use the delegate methods to prevent the user from starting or stopping the editing process or to validate text as it’s typed. You can also use the delegate methods to perform related tasks, such as updating other parts of your interface based on the information typed by the user.
    ///
    /// For more information about using the text field’s delegate to manage editing interactions, see [`UITextFieldDelegate`](https://developer.apple.com/documentation/uikit/uitextfielddelegate).
    ///
    /// ### Interface Builder attributes
    ///
    /// The following table lists the attributes that you configure for text fields in Interface Builder.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Attribute" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Text { text: "Text" }] }], [Paragraph { inline_content: [Text { text: "The initial text displayed by the text field. You can specify the text as a plain string or as an attributed string. If you specify an attributed string, Interface Builder provides different options for editing the font, color, and formatting of the string." }] }]], [[Paragraph { inline_content: [Text { text: "Color" }] }], [Paragraph { inline_content: [Text { text: "The color of the text field’s text. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/textColor", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Font" }] }], [Paragraph { inline_content: [Text { text: "The font of the text field’s text. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/font", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Alignment" }] }], [Paragraph { inline_content: [Text { text: "The alignment of the text field’s text inside the editing area. This option is available only when formatting plain strings. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/textAlignment", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Placeholder" }] }], [Paragraph { inline_content: [Text { text: "The placeholder text displayed by the text field. When the text field’s string is empty, the text field displays this string instead, formatting the string so as to indicate that it isn’t the actual text. Typing any text into the text field hides this string. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/placeholder", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Background" }] }], [Paragraph { inline_content: [Text { text: "The background image to display when the text field is enabled. This image is displayed behind the rest of the text field’s content. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/background", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Disabled" }] }], [Paragraph { inline_content: [Text { text: "The background image to display when the text field is disabled. This image is displayed behind the rest of the text field’s content. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/disabledBackground", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Border Style" }] }], [Paragraph { inline_content: [Text { text: "The visual style for the text field’s border. This attribute defines the visual border, if any, drawn around the editable text region. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/borderStyle-swift.property", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Clear Button" }] }], [Paragraph { inline_content: [Text { text: "The behavior of the clear button. The clear button is a built-in overlay view that the user taps to delete all of the text in a text field. Use this attribute to define when the clear button appears. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/clearButtonMode", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Min Font Size" }] }], [Paragraph { inline_content: [Text { text: "The minimum font size for the text field’s text. When the Adjust to Fit option is enabled, the text field automatically varies the font size to ensure maximum legibility of the text. You can use this attribute to specify the smallest font size that your consider appropriate for your text. To set this attribute programmatically, use the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextField/minimumFontSize", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]]], alignments: None, metadata: None })
    /// The following table lists the keyboard-related attributes that you configure for text fields. This attributes correspond to properties of the [`UITextInputTraits`](https://developer.apple.com/documentation/uikit/uitextinputtraits) protocol that the [`UITextField`](https://developer.apple.com/documentation/uikit/uitextfield) class adopts.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Attribute" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Text { text: "Capitalization" }] }], [Paragraph { inline_content: [Text { text: "The automatic capitalization style to apply to typed text. This attribute determines at what time the Shift key is automatically pressed. You can access the value of this attribute programmatically using the text field’s " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextInputTraits/autocapitalizationType", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Correction" }] }], [Paragraph { inline_content: [Text { text: "The autocorrection behavior of the text field. This attribute determines whether autocorrection is enabled or disabled during typing. You can access the value of this attribute programmatically using the text field’s " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextInputTraits/autocorrectionType", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Spell Checking" }] }], [Paragraph { inline_content: [Text { text: "The spell checking behavior of the text field. This attribute determines whether spell checking is enabled or disabled during typing. You can access the value of this attribute programmatically using the text field’s " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextInputTraits/spellCheckingType", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Keyboard Type" }] }], [Paragraph { inline_content: [Text { text: "The style of the text field’s keyboard. This property specifies the type of keyboard displayed when the text field is active. You can access the value of this attribute programmatically using the text field’s " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextInputTraits/keyboardType", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Appearance" }] }], [Paragraph { inline_content: [Text { text: "The visual style applied to the text field’s keyboard. Use this property to specify a dark or light keyboard. You can access the value of this attribute programmatically using the text field’s " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextInputTraits/keyboardAppearance", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property." }] }]], [[Paragraph { inline_content: [Text { text: "Return Key" }] }], [Paragraph { inline_content: [Text { text: "The type of return key to display on the keyboard. Use this property to configure the text and visual style applied to the keyboard’s return key. You can access the value of this attribute programmatically using the text field’s " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextInputTraits/returnKeyType", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property. " }, Image { identifier: "spacer", metadata: None }, Text { text: " The return key is disabled by default and becomes enabled only when the user types some text into the text field. To respond to taps in the Return key, implement the " }, Reference { identifier: "doc://com.apple.uikit/documentation/UIKit/UITextFieldDelegate/textFieldShouldReturn(_:)", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " method in the delegate you assign to the text field." }] }]]], alignments: None, metadata: None })
    /// For information about additional attributes you can configure for a text view, see [`UIControl`](https://developer.apple.com/documentation/uikit/uicontrol).
    ///
    /// ### Internationalization
    ///
    /// The default language of the device affects the keyboard that pops up with the text field (including the return key). You don’t need to do anything to enable this functionality; it’s enabled by default. However, your text field should be able to handle input that comes from any language.
    ///
    /// When using storyboards to build your interface, use Xcode’s base internationalization feature to configure the localizations your project supports. When you add a localization, Xcode creates a strings file for that localization. When configuring your interface programmatically, use the system’s built-in support for loading localized strings and resources. For more information about internationalizing your interface, see [Localization](https://developer.apple.com/documentation/xcode/localization).
    ///
    /// ### Accessibility
    ///
    /// Text fields are accessible by default. The default accessibility trait for a text field is User Interaction Enabled.
    ///
    /// For more information about making iOS controls accessible, see the accessibility information in [`UIControl`](https://developer.apple.com/documentation/uikit/uicontrol). For general information about making your interface accessible, see [Accessibility for UIKit](https://developer.apple.com/documentation/uikit/accessibility-for-uikit).
    ///
    /// ### State preservation
    ///
    /// When you assign a value to a text field’s [`restorationIdentifier`](https://developer.apple.com/documentation/uikit/uiview/restorationidentifier) property, it preserves the selected range of text, if any. During the next launch cycle, the text field attempts to restore that selection. If the selection range can’t be applied to the current text, no selection is made. For more information about how state preservation and restoration works, see [App Programming Guide for iOS](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072).
    ///
    /// For design guidance, see [Human Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/components/selection-and-input/text-fields/).
    ///
    ///
    #[unsafe(super(UIControl, UIView, UIResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
    pub struct UITextField;
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView",
    feature = "objc2-quartz-core"
))]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl CALayerDelegate for UITextField {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl NSCoding for UITextField {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for UITextField {}
);

#[cfg(all(
    feature = "UIAppearance",
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIAppearance for UITextField {}
);

#[cfg(all(
    feature = "UIAppearance",
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIAppearanceContainer for UITextField {}
);

#[cfg(all(
    feature = "UIContentSizeCategoryAdjusting",
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIContentSizeCategoryAdjusting for UITextField {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl UICoordinateSpace for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIDynamicBehavior",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIDynamicItem for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIFocusEnvironment for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIFocusItem for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIFocus",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIFocusItemContainer for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UITextInput",
    feature = "UITextInputTraits",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UIKeyInput for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UILetterformAwareAdjusting",
    feature = "UIResponder",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UILetterformAwareAdjusting for UITextField {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UITextInput",
    feature = "UITextInputTraits",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITextInput for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UITextInputTraits",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITextInputTraits for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UITraitCollection",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITraitEnvironment for UITextField {}
);

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UITextField {
    extern_methods!(
        #[unsafe(method(text))]
        #[unsafe(method_family = none)]
        pub fn text(&self) -> Option<Retained<NSString>>;

        /// Setter for [`text`][Self::text].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setText:))]
        #[unsafe(method_family = none)]
        pub fn setText(&self, text: Option<&NSString>);

        #[unsafe(method(attributedText))]
        #[unsafe(method_family = none)]
        pub fn attributedText(&self) -> Option<Retained<NSAttributedString>>;

        /// Setter for [`attributedText`][Self::attributedText].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAttributedText:))]
        #[unsafe(method_family = none)]
        pub fn setAttributedText(&self, attributed_text: Option<&NSAttributedString>);

        #[cfg(feature = "UIColor")]
        #[unsafe(method(textColor))]
        #[unsafe(method_family = none)]
        pub fn textColor(&self) -> Option<Retained<UIColor>>;

        #[cfg(feature = "UIColor")]
        /// Setter for [`textColor`][Self::textColor].
        #[unsafe(method(setTextColor:))]
        #[unsafe(method_family = none)]
        pub fn setTextColor(&self, text_color: Option<&UIColor>);

        #[cfg(feature = "UIFont")]
        #[unsafe(method(font))]
        #[unsafe(method_family = none)]
        pub fn font(&self) -> Option<Retained<UIFont>>;

        #[cfg(feature = "UIFont")]
        /// Setter for [`font`][Self::font].
        #[unsafe(method(setFont:))]
        #[unsafe(method_family = none)]
        pub fn setFont(&self, font: Option<&UIFont>);

        #[cfg(feature = "NSText")]
        #[unsafe(method(textAlignment))]
        #[unsafe(method_family = none)]
        pub fn textAlignment(&self) -> NSTextAlignment;

        #[cfg(feature = "NSText")]
        /// Setter for [`textAlignment`][Self::textAlignment].
        #[unsafe(method(setTextAlignment:))]
        #[unsafe(method_family = none)]
        pub fn setTextAlignment(&self, text_alignment: NSTextAlignment);

        #[unsafe(method(borderStyle))]
        #[unsafe(method_family = none)]
        pub fn borderStyle(&self) -> UITextBorderStyle;

        /// Setter for [`borderStyle`][Self::borderStyle].
        #[unsafe(method(setBorderStyle:))]
        #[unsafe(method_family = none)]
        pub fn setBorderStyle(&self, border_style: UITextBorderStyle);

        #[unsafe(method(defaultTextAttributes))]
        #[unsafe(method_family = none)]
        pub fn defaultTextAttributes(
            &self,
        ) -> Retained<NSDictionary<NSAttributedStringKey, AnyObject>>;

        /// Setter for [`defaultTextAttributes`][Self::defaultTextAttributes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `default_text_attributes` generic should be of the correct type.
        #[unsafe(method(setDefaultTextAttributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDefaultTextAttributes(
            &self,
            default_text_attributes: &NSDictionary<NSAttributedStringKey, AnyObject>,
        );

        #[unsafe(method(placeholder))]
        #[unsafe(method_family = none)]
        pub fn placeholder(&self) -> Option<Retained<NSString>>;

        /// Setter for [`placeholder`][Self::placeholder].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPlaceholder:))]
        #[unsafe(method_family = none)]
        pub fn setPlaceholder(&self, placeholder: Option<&NSString>);

        #[unsafe(method(attributedPlaceholder))]
        #[unsafe(method_family = none)]
        pub fn attributedPlaceholder(&self) -> Option<Retained<NSAttributedString>>;

        /// Setter for [`attributedPlaceholder`][Self::attributedPlaceholder].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAttributedPlaceholder:))]
        #[unsafe(method_family = none)]
        pub fn setAttributedPlaceholder(&self, attributed_placeholder: Option<&NSAttributedString>);

        #[unsafe(method(clearsOnBeginEditing))]
        #[unsafe(method_family = none)]
        pub fn clearsOnBeginEditing(&self) -> bool;

        /// Setter for [`clearsOnBeginEditing`][Self::clearsOnBeginEditing].
        #[unsafe(method(setClearsOnBeginEditing:))]
        #[unsafe(method_family = none)]
        pub fn setClearsOnBeginEditing(&self, clears_on_begin_editing: bool);

        #[unsafe(method(adjustsFontSizeToFitWidth))]
        #[unsafe(method_family = none)]
        pub fn adjustsFontSizeToFitWidth(&self) -> bool;

        /// Setter for [`adjustsFontSizeToFitWidth`][Self::adjustsFontSizeToFitWidth].
        #[unsafe(method(setAdjustsFontSizeToFitWidth:))]
        #[unsafe(method_family = none)]
        pub fn setAdjustsFontSizeToFitWidth(&self, adjusts_font_size_to_fit_width: bool);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(minimumFontSize))]
        #[unsafe(method_family = none)]
        pub fn minimumFontSize(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`minimumFontSize`][Self::minimumFontSize].
        #[unsafe(method(setMinimumFontSize:))]
        #[unsafe(method_family = none)]
        pub fn setMinimumFontSize(&self, minimum_font_size: CGFloat);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn UITextFieldDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn UITextFieldDelegate>>);

        #[cfg(feature = "UIImage")]
        #[unsafe(method(background))]
        #[unsafe(method_family = none)]
        pub fn background(&self) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImage")]
        /// Setter for [`background`][Self::background].
        #[unsafe(method(setBackground:))]
        #[unsafe(method_family = none)]
        pub fn setBackground(&self, background: Option<&UIImage>);

        #[cfg(feature = "UIImage")]
        #[unsafe(method(disabledBackground))]
        #[unsafe(method_family = none)]
        pub fn disabledBackground(&self) -> Option<Retained<UIImage>>;

        #[cfg(feature = "UIImage")]
        /// Setter for [`disabledBackground`][Self::disabledBackground].
        #[unsafe(method(setDisabledBackground:))]
        #[unsafe(method_family = none)]
        pub fn setDisabledBackground(&self, disabled_background: Option<&UIImage>);

        #[unsafe(method(isEditing))]
        #[unsafe(method_family = none)]
        pub fn isEditing(&self) -> bool;

        #[unsafe(method(allowsEditingTextAttributes))]
        #[unsafe(method_family = none)]
        pub fn allowsEditingTextAttributes(&self) -> bool;

        /// Setter for [`allowsEditingTextAttributes`][Self::allowsEditingTextAttributes].
        #[unsafe(method(setAllowsEditingTextAttributes:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsEditingTextAttributes(&self, allows_editing_text_attributes: bool);

        #[unsafe(method(typingAttributes))]
        #[unsafe(method_family = none)]
        pub fn typingAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<NSAttributedStringKey, AnyObject>>>;

        /// Setter for [`typingAttributes`][Self::typingAttributes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `typing_attributes` generic should be of the correct type.
        #[unsafe(method(setTypingAttributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTypingAttributes(
            &self,
            typing_attributes: Option<&NSDictionary<NSAttributedStringKey, AnyObject>>,
        );

        #[unsafe(method(clearButtonMode))]
        #[unsafe(method_family = none)]
        pub fn clearButtonMode(&self) -> UITextFieldViewMode;

        /// Setter for [`clearButtonMode`][Self::clearButtonMode].
        #[unsafe(method(setClearButtonMode:))]
        #[unsafe(method_family = none)]
        pub fn setClearButtonMode(&self, clear_button_mode: UITextFieldViewMode);

        #[unsafe(method(leftView))]
        #[unsafe(method_family = none)]
        pub fn leftView(&self) -> Option<Retained<UIView>>;

        /// Setter for [`leftView`][Self::leftView].
        #[unsafe(method(setLeftView:))]
        #[unsafe(method_family = none)]
        pub fn setLeftView(&self, left_view: Option<&UIView>);

        #[unsafe(method(leftViewMode))]
        #[unsafe(method_family = none)]
        pub fn leftViewMode(&self) -> UITextFieldViewMode;

        /// Setter for [`leftViewMode`][Self::leftViewMode].
        #[unsafe(method(setLeftViewMode:))]
        #[unsafe(method_family = none)]
        pub fn setLeftViewMode(&self, left_view_mode: UITextFieldViewMode);

        #[unsafe(method(rightView))]
        #[unsafe(method_family = none)]
        pub fn rightView(&self) -> Option<Retained<UIView>>;

        /// Setter for [`rightView`][Self::rightView].
        #[unsafe(method(setRightView:))]
        #[unsafe(method_family = none)]
        pub fn setRightView(&self, right_view: Option<&UIView>);

        #[unsafe(method(rightViewMode))]
        #[unsafe(method_family = none)]
        pub fn rightViewMode(&self) -> UITextFieldViewMode;

        /// Setter for [`rightViewMode`][Self::rightViewMode].
        #[unsafe(method(setRightViewMode:))]
        #[unsafe(method_family = none)]
        pub fn setRightViewMode(&self, right_view_mode: UITextFieldViewMode);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(borderRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn borderRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(textRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn textRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(placeholderRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn placeholderRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(editingRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn editingRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(clearButtonRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn clearButtonRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(leftViewRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn leftViewRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(rightViewRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn rightViewRectForBounds(&self, bounds: CGRect) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[deprecated = "This method is no longer called."]
        #[unsafe(method(drawTextInRect:))]
        #[unsafe(method_family = none)]
        pub fn drawTextInRect(&self, rect: CGRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawPlaceholderInRect:))]
        #[unsafe(method_family = none)]
        pub fn drawPlaceholderInRect(&self, rect: CGRect);

        #[unsafe(method(inputView))]
        #[unsafe(method_family = none)]
        pub fn inputView(&self) -> Option<Retained<UIView>>;

        /// Setter for [`inputView`][Self::inputView].
        #[unsafe(method(setInputView:))]
        #[unsafe(method_family = none)]
        pub fn setInputView(&self, input_view: Option<&UIView>);

        #[unsafe(method(inputAccessoryView))]
        #[unsafe(method_family = none)]
        pub fn inputAccessoryView(&self) -> Option<Retained<UIView>>;

        /// Setter for [`inputAccessoryView`][Self::inputAccessoryView].
        #[unsafe(method(setInputAccessoryView:))]
        #[unsafe(method_family = none)]
        pub fn setInputAccessoryView(&self, input_accessory_view: Option<&UIView>);

        #[unsafe(method(clearsOnInsertion))]
        #[unsafe(method_family = none)]
        pub fn clearsOnInsertion(&self) -> bool;

        /// Setter for [`clearsOnInsertion`][Self::clearsOnInsertion].
        #[unsafe(method(setClearsOnInsertion:))]
        #[unsafe(method_family = none)]
        pub fn setClearsOnInsertion(&self, clears_on_insertion: bool);
    );
}

/// Methods declared on superclass `UIControl`.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UITextField {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame(this: Allocated<Self>, frame: CGRect) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "UIAction",
            feature = "UIMenuElement",
            feature = "objc2-core-foundation"
        ))]
        /// Initializes the control and adds primaryAction for the UIControlEventPrimaryActionTriggered control event. Subclasses of UIControl may alter or add behaviors around the usage of primaryAction, see subclass documentation of this initializer for additional information.
        #[unsafe(method(initWithFrame:primaryAction:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame_primaryAction(
            this: Allocated<Self>,
            frame: CGRect,
            primary_action: Option<&UIAction>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `UIView`.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UITextField {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UITextField {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UITextField {
    extern_methods!();
}

#[cfg(all(
    feature = "UIControl",
    feature = "UIResponder",
    feature = "UITextDragging",
    feature = "UITextInput",
    feature = "UITextInputTraits",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITextDraggable for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIPasteConfigurationSupporting",
    feature = "UIResponder",
    feature = "UITextDropping",
    feature = "UITextInput",
    feature = "UITextInputTraits",
    feature = "UITextPasteConfigurationSupporting",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITextDroppable for UITextField {}
);

#[cfg(all(
    feature = "UIControl",
    feature = "UIPasteConfigurationSupporting",
    feature = "UIResponder",
    feature = "UITextPasteConfigurationSupporting",
    feature = "UIView"
))]
extern_conformance!(
    unsafe impl UITextPasteConfigurationSupporting for UITextField {}
);

/// UIInteractionStateRestorable.
#[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
impl UITextField {
    extern_methods!(
        #[unsafe(method(interactionState))]
        #[unsafe(method_family = none)]
        pub fn interactionState(&self) -> Retained<AnyObject>;

        /// Setter for [`interactionState`][Self::interactionState].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `interaction_state` should be of the correct type.
        #[unsafe(method(setInteractionState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInteractionState(&self, interaction_state: &AnyObject);
    );
}

/// UITextField.
#[cfg(all(feature = "UIResponder", feature = "UIView"))]
impl UIView {
    extern_methods!(
        #[unsafe(method(endEditing:))]
        #[unsafe(method_family = none)]
        pub fn endEditing(&self, force: bool) -> bool;
    );
}

extern_protocol!(
    /// A set of optional methods to manage editing and validating text in a text field object.
    ///
    /// ## Overview
    ///
    /// A text field calls the methods of its delegate in response to important changes. You use these methods to validate text that was typed by the user, to respond to specific interactions with the keyboard, and to control the overall editing process. Editing begins shortly before the text field becomes the first responder and displays the keyboard (or its assigned input view). The flow of the editing process is as follows:
    ///
    /// 1. Before becoming the first responder, the text field calls its delegate’s [`textFieldShouldBeginEditing:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfieldshouldbeginediting(_:)) method. Use that method to allow or prevent the editing of the text field’s contents.
    ///
    /// 2. The text field becomes the first responder.
    ///
    /// In response, the system displays the keyboard (or the text field’s input view) and posts the [`UIKeyboardWillShowNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboardwillshownotification) and [`UIKeyboardDidShowNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboarddidshownotification) notifications as needed. If the keyboard or another input view was already visible, the system posts the [`UIKeyboardWillChangeFrameNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboardwillchangeframenotification) and [`UIKeyboardDidChangeFrameNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboarddidchangeframenotification) notifications instead. 3. The text field calls its delegate’s [`textFieldDidBeginEditing:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfielddidbeginediting(_:)) method and posts a [`UITextFieldTextDidBeginEditingNotification`](https://developer.apple.com/documentation/uikit/uitextfield/textdidbegineditingnotification) notification. 4. The text field calls various delegate methods during editing:
    ///
    /// - Whenever the current text changes, it calls the [`textField:shouldChangeCharactersInRange:replacementString:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfield(_:shouldchangecharactersin:replacementstring:)) method and posts the [`UITextFieldTextDidChangeNotification`](https://developer.apple.com/documentation/uikit/uitextfield/textdidchangenotification) notification.
    ///
    /// - It calls the [`textFieldShouldClear:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfieldshouldclear(_:)) method when the user taps the built-in button to clear the text.
    ///
    /// - It calls the [`textFieldShouldReturn:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfieldshouldreturn(_:)) method when the user taps the keyboard’s return button.
    ///
    /// 5. Before resigning as first responder, the text field calls its delegate’s [`textFieldShouldEndEditing:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfieldshouldendediting(_:)) method. Use that method to validate the current text.
    ///
    /// 6. The text field resigns as first responder.
    ///
    /// In response, the system hides or adjusts the keyboard as needed. When hiding the keyboard, the system posts the [`UIKeyboardWillHideNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboardwillhidenotification) and [`UIKeyboardDidHideNotification`](https://developer.apple.com/documentation/uikit/uiresponder/keyboarddidhidenotification) notifications. 7. The text field calls its delegate’s [`textFieldDidEndEditing:`](https://developer.apple.com/documentation/uikit/uitextfielddelegate/textfielddidendediting(_:)) method and posts a [`UITextFieldTextDidEndEditingNotification`](https://developer.apple.com/documentation/uikit/uitextfield/textdidendeditingnotification) notification.
    ///
    /// For more information about the features of a text field, see [`UITextField`](https://developer.apple.com/documentation/uikit/uitextfield).
    ///
    ///
    pub unsafe trait UITextFieldDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldShouldBeginEditing:))]
        #[unsafe(method_family = none)]
        fn textFieldShouldBeginEditing(&self, text_field: &UITextField) -> bool;

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldDidBeginEditing:))]
        #[unsafe(method_family = none)]
        fn textFieldDidBeginEditing(&self, text_field: &UITextField);

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldShouldEndEditing:))]
        #[unsafe(method_family = none)]
        fn textFieldShouldEndEditing(&self, text_field: &UITextField) -> bool;

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldDidEndEditing:))]
        #[unsafe(method_family = none)]
        fn textFieldDidEndEditing(&self, text_field: &UITextField);

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldDidEndEditing:reason:))]
        #[unsafe(method_family = none)]
        fn textFieldDidEndEditing_reason(
            &self,
            text_field: &UITextField,
            reason: UITextFieldDidEndEditingReason,
        );

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[deprecated]
        #[optional]
        #[unsafe(method(textField:shouldChangeCharactersInRange:replacementString:))]
        #[unsafe(method_family = none)]
        fn textField_shouldChangeCharactersInRange_replacementString(
            &self,
            text_field: &UITextField,
            range: NSRange,
            string: &NSString,
        ) -> bool;

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        /// Asks the delegate if the text at the specified `ranges` should be replaced with `string`.
        ///
        ///
        /// If this method returns YES then the text field will, at its own discretion, choose any one of the specified `ranges` of text and replace it with the specified `replacementString` before deleting the text at the other ranges.
        ///
        ///
        /// Parameter `textField`: The text field asking the delegate
        ///
        /// Parameter `ranges`: The ranges of the text that should be deleted before replacing
        ///
        /// Parameter `replacementString`: The replacement string
        ///
        ///
        /// Returns: Returns YES if the text at the `ranges` should be replaced.
        #[optional]
        #[unsafe(method(textField:shouldChangeCharactersInRanges:replacementString:))]
        #[unsafe(method_family = none)]
        fn textField_shouldChangeCharactersInRanges_replacementString(
            &self,
            text_field: &UITextField,
            ranges: &NSArray<NSValue>,
            string: &NSString,
        ) -> bool;

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldDidChangeSelection:))]
        #[unsafe(method_family = none)]
        fn textFieldDidChangeSelection(&self, text_field: &UITextField);

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldShouldClear:))]
        #[unsafe(method_family = none)]
        fn textFieldShouldClear(&self, text_field: &UITextField) -> bool;

        #[cfg(all(feature = "UIControl", feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textFieldShouldReturn:))]
        #[unsafe(method_family = none)]
        fn textFieldShouldReturn(&self, text_field: &UITextField) -> bool;

        #[cfg(all(
            feature = "UIControl",
            feature = "UIMenu",
            feature = "UIMenuElement",
            feature = "UIResponder",
            feature = "UIView"
        ))]
        /// Asks the delegate for the menu to be shown for the specified text range.
        ///
        ///
        /// Parameter `textField`: The text field requesting the menu.
        ///
        /// Parameter `range`: The characters range for which the menu is presented for.
        ///
        /// Parameter `suggestedActions`: The actions and commands that the system suggests.
        ///
        ///
        /// Returns: Return a UIMenu describing the desired menu hierarchy. Return
        /// `nil`to present the default system menu.
        #[deprecated]
        #[optional]
        #[unsafe(method(textField:editMenuForCharactersInRange:suggestedActions:))]
        #[unsafe(method_family = none)]
        fn textField_editMenuForCharactersInRange_suggestedActions(
            &self,
            text_field: &UITextField,
            range: NSRange,
            suggested_actions: &NSArray<UIMenuElement>,
        ) -> Option<Retained<UIMenu>>;

        #[cfg(all(
            feature = "UIControl",
            feature = "UIMenu",
            feature = "UIMenuElement",
            feature = "UIResponder",
            feature = "UIView"
        ))]
        /// Asks the delegate for the menu to be shown for the specified `ranges`.
        ///
        ///
        /// Parameter `textField`: The text field requesting the menu.
        ///
        /// Parameter `ranges`: The text ranges for which the menu is presented for.
        ///
        /// Parameter `suggestedActions`: The actions and commands that the system suggests.
        ///
        ///
        /// Returns: Return a UIMenu describing the desired menu hierarchy. Return
        /// `nil`to present the default system menu.
        #[optional]
        #[unsafe(method(textField:editMenuForCharactersInRanges:suggestedActions:))]
        #[unsafe(method_family = none)]
        fn textField_editMenuForCharactersInRanges_suggestedActions(
            &self,
            text_field: &UITextField,
            ranges: &NSArray<NSValue>,
            suggested_actions: &NSArray<UIMenuElement>,
        ) -> Option<Retained<UIMenu>>;

        #[cfg(all(
            feature = "UIControl",
            feature = "UIEditMenuInteraction",
            feature = "UIResponder",
            feature = "UIView"
        ))]
        /// Called when the text field is about to present the edit menu.
        ///
        ///
        /// Parameter `textField`: The text field displaying the menu.
        ///
        /// Parameter `animator`: Appearance animator. Add animations to this object to run them alongside the appearance transition.
        #[optional]
        #[unsafe(method(textField:willPresentEditMenuWithAnimator:))]
        #[unsafe(method_family = none)]
        fn textField_willPresentEditMenuWithAnimator(
            &self,
            text_field: &UITextField,
            animator: &ProtocolObject<dyn UIEditMenuInteractionAnimating>,
        );

        #[cfg(all(
            feature = "UIControl",
            feature = "UIEditMenuInteraction",
            feature = "UIResponder",
            feature = "UIView"
        ))]
        /// Called when the text field is about to dismiss the edit menu.
        ///
        ///
        /// Parameter `textField`: The text field displaying the menu.
        ///
        /// Parameter `animator`: Dismissal animator. Add animations to this object to run them alongside the dismissal transition.
        #[optional]
        #[unsafe(method(textField:willDismissEditMenuWithAnimator:))]
        #[unsafe(method_family = none)]
        fn textField_willDismissEditMenuWithAnimator(
            &self,
            text_field: &UITextField,
            animator: &ProtocolObject<dyn UIEditMenuInteractionAnimating>,
        );

        #[cfg(all(
            feature = "UIControl",
            feature = "UIInputSuggestion",
            feature = "UIResponder",
            feature = "UIView"
        ))]
        /// Tells the delegate when the keyboard delivers an input suggestion.
        ///
        /// - Parameters:
        /// - textField: The text field that is currently the first responder.
        /// - inputSuggestion: The input suggestion that the user or system selected.
        #[optional]
        #[unsafe(method(textField:insertInputSuggestion:))]
        #[unsafe(method_family = none)]
        fn textField_insertInputSuggestion(
            &self,
            text_field: &UITextField,
            input_suggestion: &UIInputSuggestion,
        );
    }
);

extern "C" {
    /// A notification that alerts observers when an editing session begins in a text field.
    ///
    /// ## Discussion
    ///
    /// The affected text field is stored in the `object` parameter of the notification. The `userInfo` dictionary is not used.
    ///
    ///
    pub static UITextFieldTextDidBeginEditingNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that alerts observers when the editing session ends for a text field.
    ///
    /// ## Discussion
    ///
    /// The affected text field is stored in the `object` parameter of the notification. The `userInfo` dictionary is not used.
    ///
    ///
    pub static UITextFieldTextDidEndEditingNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that alerts observers when the text in a text field changes.
    ///
    /// ## Discussion
    ///
    /// The affected text field is stored in the `object` parameter of the notification.
    ///
    ///
    pub static UITextFieldTextDidChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// A key that indicates the reason for ending editing in a text field.
    pub static UITextFieldDidEndEditingReasonKey: &'static NSString;
}
