//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// A set of methods a responder uses to implement simple text entry.
    ///
    /// ## Overview
    ///
    /// Adopt this protocol in a subclass of [`UIResponder`](https://developer.apple.com/documentation/uikit/uiresponder) to support text entry. When instances of this subclass are the first responder, the system keyboard displays. Only a small subset of the available keyboards and languages are available to classes that adopt this protocol.
    ///
    ///
    #[cfg(feature = "UITextInputTraits")]
    pub unsafe trait UIKeyInput: UITextInputTraits + MainThreadOnly {
        #[unsafe(method(hasText))]
        #[unsafe(method_family = none)]
        fn hasText(&self) -> bool;

        #[unsafe(method(insertText:))]
        #[unsafe(method_family = none)]
        fn insertText(&self, text: &NSString);

        #[unsafe(method(deleteBackward))]
        #[unsafe(method_family = none)]
        fn deleteBackward(&self);
    }
);

/// The direction of text storage.
///
/// ## Overview
///
/// Constants of this type are used as arguments to the [`baseWritingDirectionForPosition:inDirection:`](https://developer.apple.com/documentation/uikit/uitextinput/basewritingdirection(for:in:)) and [`textStylingAtPosition:inDirection:`](https://developer.apple.com/documentation/uikit/uitextinput/textstyling(at:in:)) methods.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITextStorageDirection(pub NSInteger);
impl UITextStorageDirection {
    /// Storage of the text in a forward direction.
    #[doc(alias = "UITextStorageDirectionForward")]
    pub const Forward: Self = Self(0);
    /// Storage of the text in a backward direction.
    #[doc(alias = "UITextStorageDirectionBackward")]
    pub const Backward: Self = Self(1);
}

unsafe impl Encode for UITextStorageDirection {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextStorageDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The direction of text layout.
///
/// ## Overview
///
/// Constants of this type are used as arguments in the [`positionFromPosition:inDirection:offset:`](https://developer.apple.com/documentation/uikit/uitextinput/position(from:in:offset:)), [`positionWithinRange:farthestInDirection:`](https://developer.apple.com/documentation/uikit/uitextinput/position(within:farthestin:)), and [`characterRangeByExtendingPosition:inDirection:`](https://developer.apple.com/documentation/uikit/uitextinput/characterrange(byextending:in:)) methods.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct UITextLayoutDirection(pub NSInteger);
impl UITextLayoutDirection {
    /// Layout of the text to the right.
    #[doc(alias = "UITextLayoutDirectionRight")]
    pub const Right: Self = Self(2);
    /// Layout of the text to the left.
    #[doc(alias = "UITextLayoutDirectionLeft")]
    pub const Left: Self = Self(3);
    /// Layout of the text in an upward direction.
    #[doc(alias = "UITextLayoutDirectionUp")]
    pub const Up: Self = Self(4);
    /// Layout of the text in a downward direction.
    #[doc(alias = "UITextLayoutDirectionDown")]
    pub const Down: Self = Self(5);
}

unsafe impl Encode for UITextLayoutDirection {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextLayoutDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The direction of the text.
///
/// ## Overview
///
/// This parameter is used in methods declared by the [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) protocol. This general direction type subsumes constants of the [`UITextStorageDirection`](https://developer.apple.com/documentation/uikit/uitextstoragedirection) and [`UITextLayoutDirection`](https://developer.apple.com/documentation/uikit/uitextlayoutdirection) types.
///
///
// NS_TYPED_ENUM
pub type UITextDirection = NSInteger;

/// The granularity of a unit of text.
///
/// ## Overview
///
/// Constants of this type are used as parameters in all methods of the `UITextInputTokenizer` protocol.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITextGranularity(pub NSInteger);
impl UITextGranularity {
    ///
    /// ## Discussion
    ///
    /// The unit of text is a character.
    ///
    ///
    #[doc(alias = "UITextGranularityCharacter")]
    pub const Character: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// The unit of text is a word.
    ///
    ///
    #[doc(alias = "UITextGranularityWord")]
    pub const Word: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// The unit of text is a sentence.
    ///
    ///
    #[doc(alias = "UITextGranularitySentence")]
    pub const Sentence: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// The unit of text is a paragraph.
    ///
    ///
    #[doc(alias = "UITextGranularityParagraph")]
    pub const Paragraph: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// The unit of text is a line.
    ///
    ///
    #[doc(alias = "UITextGranularityLine")]
    pub const Line: Self = Self(4);
    ///
    /// ## Discussion
    ///
    /// The unit of text is a document.
    ///
    ///
    #[doc(alias = "UITextGranularityDocument")]
    pub const Document: Self = Self(5);
}

unsafe impl Encode for UITextGranularity {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextGranularity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that represents the textual interpretation of a spoken phrase that the user dictates.
    ///
    /// ## Overview
    ///
    /// When the user chooses dictation input on a supported device, the system automatically inserts recognized phrases into the current text view. You can use an object of the [`UIDictationPhrase`](https://developer.apple.com/documentation/uikit/uidictationphrase) class to obtain a string representing a phrase a user has dictated. In the case of ambiguous dictation results, a dictation phrase object provides an array containing alternative strings. Methods in the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol allow your app to respond to the completion of dictation.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UIDictationPhrase;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UIDictationPhrase {}
);

impl UIDictationPhrase {
    extern_methods!(
        #[unsafe(method(text))]
        #[unsafe(method_family = none)]
        pub fn text(&self) -> Retained<NSString>;

        #[unsafe(method(alternativeInterpretations))]
        #[unsafe(method_family = none)]
        pub fn alternativeInterpretations(&self) -> Option<Retained<NSArray<NSString>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UIDictationPhrase {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that manages custom bar button items that you add to the shortcuts bar above the keyboard on iPad.
    ///
    /// ## Overview
    ///
    /// Use a [`UITextInputAssistantItem`](https://developer.apple.com/documentation/uikit/uitextinputassistantitem) object to add app-specific actions to the shortcuts bar on iPad. The center of the shortcuts bar displays typing suggestions for the user. You can install custom bar button items that lead or trail the typing suggestions.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  You can add custom items to the shortcuts bar on iPad only. On iPhone, the text input system ignores the contents of the [`UITextInputAssistantItem`](https://developer.apple.com/documentation/uikit/uitextinputassistantitem) object.
    ///
    ///
    ///
    /// </div>
    /// You don’t create instances of this class directly. Instead, you get an input assistant from the [`inputAssistantItem`](https://developer.apple.com/documentation/uikit/uiresponder/inputassistantitem) property of the responder object whose keyboard you want to modify. When the keyboard is onscreen, UIKit automatically searches the responder chain for a text-input assistant object. Typically, you assign the text-input assistant to the object that becomes the first responder. However, you can also assign it to a parent responder object to share a set of shortcuts among multiple children.
    ///
    /// Organize the bar button items you create for the shortcuts bar into groups. A [`UIBarButtonItemGroup`](https://developer.apple.com/documentation/uikit/uibarbuttonitemgroup) object manages each group of items, and each group may contain a single item or several items. UIKit displays as many items as possible based on the available space. When there’s not enough space for all of the items, UIKit collapses each group of items down to a single representative item.
    ///
    /// The following code configures the items of the shortcuts bar. After creating the bar button items, this code creates a group and assigns that group to the [`leadingBarButtonGroups`](https://developer.apple.com/documentation/uikit/uitextinputassistantitem/leadingbarbuttongroups) property. The resulting items appear before the typing suggestions.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Get a UITextView object of the current view controller.", "let item = textView.inputAssistantItem", "", "// Set up the buttons.", "let itemOne = UIBarButtonItem(", "    title: \"One\",", "    style: .plain,", "    target: self,", "    action: Selector(\"handleItemOne:\"))", "let itemTwo = UIBarButtonItem(", "    title: \"Two\",", "    style: .plain,", "    target: self,", "    action: Selector(\"handleItemTwo:\"))", "let itemThree = UIBarButtonItem(", "    title: \"Three\",", "    style: .plain,", "    target: self,", "    action: Selector(\"handleItemThree:\"))", " ", "// Use a nil action to display the individual items.", "let itemChoose = UIBarButtonItem(", "    title: \"Choose\",", "    style: .plain,", "    target: nil,", "    action: nil)", " ", "// Create the item group.", "let group = UIBarButtonItemGroup(", "    barButtonItems: [itemOne, itemTwo, itemThree],", "    representativeItem: itemChoose)", " ", "// Display the items before the typing suggestions.", "item.leadingBarButtonGroups = [group]"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Get a UITextView object of the current view controller.", "UITextInputAssistantItem* item = [self.textView inputAssistantItem];", "", "// Set up the buttons.", "UIBarButtonItem* itemOne = [[UIBarButtonItem alloc] initWithTitle:@\"One\"", "         style:UIBarButtonItemStylePlain target:self action:@selector(handleItemOne:)];", "UIBarButtonItem* itemTwo = [[UIBarButtonItem alloc] initWithTitle:@\"Two\"", "         style:UIBarButtonItemStylePlain target:self action:@selector(handleItemTwo:)];", "UIBarButtonItem* itemThree = [[UIBarButtonItem alloc] initWithTitle:@\"Three\"", "         style:UIBarButtonItemStylePlain target:self action:@selector(handleItemThree:)];", " ", "// Use a nil action to display the individual items.", "UIBarButtonItem* itemChoose = [[UIBarButtonItem alloc] initWithTitle:@\"Choose\"", "         style:UIBarButtonItemStylePlain target:nil action:nil];", " ", "// Create the item group.", "UIBarButtonItemGroup* group = [[UIBarButtonItemGroup alloc]", "       initWithBarButtonItems:@[itemOne, itemTwo, itemThree] representativeItem:itemChoose];", " ", "// Display the items before the typing suggestions.", "item.leadingBarButtonGroups = @[group];"], metadata: None }] }] })
    /// To hide shortcuts altogether, set the [`leadingBarButtonGroups`](https://developer.apple.com/documentation/uikit/uitextinputassistantitem/leadingbarbuttongroups) and [`trailingBarButtonGroups`](https://developer.apple.com/documentation/uikit/uitextinputassistantitem/trailingbarbuttongroups) properties to empty arrays. Doing so hides only the shortcuts and doesn’t hide the typing suggestions. For information on managing the typing suggestions, see [`autocorrectionType`](https://developer.apple.com/documentation/uikit/uitextinputtraits/autocorrectiontype).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextInputAssistantItem;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextInputAssistantItem {}
);

impl UITextInputAssistantItem {
    extern_methods!(
        /// Default is YES, controls if the user is allowed to hide the shortcuts bar. Does not influence the built in auto-hiding logic.
        #[unsafe(method(allowsHidingShortcuts))]
        #[unsafe(method_family = none)]
        pub fn allowsHidingShortcuts(&self) -> bool;

        /// Setter for [`allowsHidingShortcuts`][Self::allowsHidingShortcuts].
        #[unsafe(method(setAllowsHidingShortcuts:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsHidingShortcuts(&self, allows_hiding_shortcuts: bool);

        #[cfg(feature = "UIBarButtonItemGroup")]
        /// Contains UIBarButtonItemGroups that should be displayed in the leading position on the keyboard's assistant bar.
        #[unsafe(method(leadingBarButtonGroups))]
        #[unsafe(method_family = none)]
        pub fn leadingBarButtonGroups(&self) -> Retained<NSArray<UIBarButtonItemGroup>>;

        #[cfg(feature = "UIBarButtonItemGroup")]
        /// Setter for [`leadingBarButtonGroups`][Self::leadingBarButtonGroups].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLeadingBarButtonGroups:))]
        #[unsafe(method_family = none)]
        pub fn setLeadingBarButtonGroups(
            &self,
            leading_bar_button_groups: &NSArray<UIBarButtonItemGroup>,
        );

        #[cfg(feature = "UIBarButtonItemGroup")]
        /// Contains UIBarButtonItemGroups that should be displayed in the trailing position on the keyboard's assistant bar.
        #[unsafe(method(trailingBarButtonGroups))]
        #[unsafe(method_family = none)]
        pub fn trailingBarButtonGroups(&self) -> Retained<NSArray<UIBarButtonItemGroup>>;

        #[cfg(feature = "UIBarButtonItemGroup")]
        /// Setter for [`trailingBarButtonGroups`][Self::trailingBarButtonGroups].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTrailingBarButtonGroups:))]
        #[unsafe(method_family = none)]
        pub fn setTrailingBarButtonGroups(
            &self,
            trailing_bar_button_groups: &NSArray<UIBarButtonItemGroup>,
        );

        #[cfg(all(feature = "UIBarButtonItem", feature = "UIBarItem"))]
        /// A button that appears next to the text preview in the keyboard on visionOS.
        #[unsafe(method(keyboardActionButtonItem))]
        #[unsafe(method_family = none)]
        pub fn keyboardActionButtonItem(&self) -> Option<Retained<UIBarButtonItem>>;

        #[cfg(all(feature = "UIBarButtonItem", feature = "UIBarItem"))]
        /// Setter for [`keyboardActionButtonItem`][Self::keyboardActionButtonItem].
        #[unsafe(method(setKeyboardActionButtonItem:))]
        #[unsafe(method_family = none)]
        pub fn setKeyboardActionButtonItem(
            &self,
            keyboard_action_button_item: Option<&UIBarButtonItem>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl UITextInputAssistantItem {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// A placeholder object that reserves visual space in a text input view.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextPlaceholder;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextPlaceholder {}
);

impl UITextPlaceholder {
    extern_methods!(
        #[unsafe(method(rects))]
        #[unsafe(method_family = none)]
        pub fn rects(&self) -> Retained<NSArray<UITextSelectionRect>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UITextPlaceholder {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// A constant that determines if the system highlights alternative phrases during text input.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UITextAlternativeStyle(pub NSInteger);
impl UITextAlternativeStyle {
    /// A constant that indicates that the text input shouldn’t highlight alternatives because the input text is expected to be correct.
    #[doc(alias = "UITextAlternativeStyleNone")]
    pub const None: Self = Self(0);
    /// A constant that indicates that the text input should highlight alternatives because the input text may be incorrect.
    #[doc(alias = "UITextAlternativeStyleLowConfidence")]
    pub const LowConfidence: Self = Self(1);
}

unsafe impl Encode for UITextAlternativeStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UITextAlternativeStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A set of methods for interacting with the text input system and enabling features in documents.
    ///
    /// ## Overview
    ///
    /// Objects that adopt the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol maintain information about text input and provide that information to the text input system on demand. A [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) object interacts with the text input system by:
    ///
    /// - Reporting text positions and text ranges
    ///
    /// - Responding to queries layout and writing direction
    ///
    /// - Performing hit-testing — returning text positions and ranges for a specific point
    ///
    /// - Providing the system with rectangles for highlighting ranges of text and drawing the _caret_, a glyph that represents the insertion point during text entry
    ///
    /// In addition, a [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) object maintains ranges for selected text and marked text. Marked text, a part of multistage text input, represents provisionally inserted text that the user has yet to confirm. The range of marked text always contains a range of selected text, which might be a range of characters or the caret. Multistage text input is a requirement when the language is ideographic and the keyboard is phonetic.
    ///
    /// ### Integrate with the text input system
    ///
    /// The [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol works with other classes and protocols to integrate text-processing apps with the text input system:
    ///
    /// - [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) and [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) classes: All [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput)-conforming document classes must create custom subclasses of these classes. A [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) object represents a position in a text container. A [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) object, which encapsulates beginning and ending [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) objects, represents a range of characters in the text container.
    ///
    /// - [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) protocol and [`UITextInputStringTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputstringtokenizer) class: The [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) protocol defines an interface for tokenizing input text. The [`UITextInputStringTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputstringtokenizer) class is a default implementation of this protocol.
    ///
    /// - [`UITextInputDelegate`](https://developer.apple.com/documentation/uikit/uitextinputdelegate) protocol: The text input system automatically assigns its own text input delegate (which conforms to this protocol) to the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput)-conforming document object. This text input delegate allows document objects to inform the input system of changes in text and selection.
    ///
    /// - [`UIKeyInput`](https://developer.apple.com/documentation/uikit/uikeyinput) protocol: Implement this protocol to allow text entry and deletion at an insertion point.
    ///
    /// ### Customize keyboard behavior
    ///
    /// The [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol also inherits the [`UITextInputTraits`](https://developer.apple.com/documentation/uikit/uitextinputtraits) protocol, which provides customization of the keyboard and its behaviors.
    ///
    /// When the user chooses dictation input on a supported device, the system automatically inserts recognized phrases into the current text view. Methods in the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol allow your app to respond to the completion of dictation. You can use an object of the [`UIDictationPhrase`](https://developer.apple.com/documentation/uikit/uidictationphrase) class to obtain a string that represents a phrase the user dictates. In the case of ambiguous dictation results, a dictation phrase object provides an array that contains alternative strings.
    ///
    ///
    #[cfg(feature = "UITextInputTraits")]
    pub unsafe trait UITextInput: UIKeyInput + MainThreadOnly {
        #[unsafe(method(textInRange:))]
        #[unsafe(method_family = none)]
        fn textInRange(&self, range: &UITextRange) -> Option<Retained<NSString>>;

        #[unsafe(method(replaceRange:withText:))]
        #[unsafe(method_family = none)]
        fn replaceRange_withText(&self, range: &UITextRange, text: &NSString);

        #[unsafe(method(selectedTextRange))]
        #[unsafe(method_family = none)]
        fn selectedTextRange(&self) -> Option<Retained<UITextRange>>;

        /// Setter for [`selectedTextRange`][Self::selectedTextRange].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSelectedTextRange:))]
        #[unsafe(method_family = none)]
        fn setSelectedTextRange(&self, selected_text_range: Option<&UITextRange>);

        #[unsafe(method(markedTextRange))]
        #[unsafe(method_family = none)]
        fn markedTextRange(&self) -> Option<Retained<UITextRange>>;

        #[unsafe(method(markedTextStyle))]
        #[unsafe(method_family = none)]
        fn markedTextStyle(
            &self,
        ) -> Option<Retained<NSDictionary<NSAttributedStringKey, AnyObject>>>;

        /// Setter for [`markedTextStyle`][Self::markedTextStyle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `marked_text_style` generic should be of the correct type.
        #[unsafe(method(setMarkedTextStyle:))]
        #[unsafe(method_family = none)]
        unsafe fn setMarkedTextStyle(
            &self,
            marked_text_style: Option<&NSDictionary<NSAttributedStringKey, AnyObject>>,
        );

        #[unsafe(method(setMarkedText:selectedRange:))]
        #[unsafe(method_family = none)]
        fn setMarkedText_selectedRange(
            &self,
            marked_text: Option<&NSString>,
            selected_range: NSRange,
        );

        #[unsafe(method(unmarkText))]
        #[unsafe(method_family = none)]
        fn unmarkText(&self);

        #[unsafe(method(beginningOfDocument))]
        #[unsafe(method_family = none)]
        fn beginningOfDocument(&self) -> Retained<UITextPosition>;

        #[unsafe(method(endOfDocument))]
        #[unsafe(method_family = none)]
        fn endOfDocument(&self) -> Retained<UITextPosition>;

        #[unsafe(method(textRangeFromPosition:toPosition:))]
        #[unsafe(method_family = none)]
        fn textRangeFromPosition_toPosition(
            &self,
            from_position: &UITextPosition,
            to_position: &UITextPosition,
        ) -> Option<Retained<UITextRange>>;

        #[unsafe(method(positionFromPosition:offset:))]
        #[unsafe(method_family = none)]
        fn positionFromPosition_offset(
            &self,
            position: &UITextPosition,
            offset: NSInteger,
        ) -> Option<Retained<UITextPosition>>;

        #[unsafe(method(positionFromPosition:inDirection:offset:))]
        #[unsafe(method_family = none)]
        fn positionFromPosition_inDirection_offset(
            &self,
            position: &UITextPosition,
            direction: UITextLayoutDirection,
            offset: NSInteger,
        ) -> Option<Retained<UITextPosition>>;

        #[unsafe(method(comparePosition:toPosition:))]
        #[unsafe(method_family = none)]
        fn comparePosition_toPosition(
            &self,
            position: &UITextPosition,
            other: &UITextPosition,
        ) -> NSComparisonResult;

        #[unsafe(method(offsetFromPosition:toPosition:))]
        #[unsafe(method_family = none)]
        fn offsetFromPosition_toPosition(
            &self,
            from: &UITextPosition,
            to_position: &UITextPosition,
        ) -> NSInteger;

        #[unsafe(method(inputDelegate))]
        #[unsafe(method_family = none)]
        fn inputDelegate(&self) -> Option<Retained<ProtocolObject<dyn UITextInputDelegate>>>;

        /// Setter for [`inputDelegate`][Self::inputDelegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setInputDelegate:))]
        #[unsafe(method_family = none)]
        fn setInputDelegate(
            &self,
            input_delegate: Option<&ProtocolObject<dyn UITextInputDelegate>>,
        );

        #[unsafe(method(tokenizer))]
        #[unsafe(method_family = none)]
        fn tokenizer(&self) -> Retained<ProtocolObject<dyn UITextInputTokenizer>>;

        #[unsafe(method(positionWithinRange:farthestInDirection:))]
        #[unsafe(method_family = none)]
        fn positionWithinRange_farthestInDirection(
            &self,
            range: &UITextRange,
            direction: UITextLayoutDirection,
        ) -> Option<Retained<UITextPosition>>;

        #[unsafe(method(characterRangeByExtendingPosition:inDirection:))]
        #[unsafe(method_family = none)]
        fn characterRangeByExtendingPosition_inDirection(
            &self,
            position: &UITextPosition,
            direction: UITextLayoutDirection,
        ) -> Option<Retained<UITextRange>>;

        #[cfg(feature = "NSText")]
        #[unsafe(method(baseWritingDirectionForPosition:inDirection:))]
        #[unsafe(method_family = none)]
        fn baseWritingDirectionForPosition_inDirection(
            &self,
            position: &UITextPosition,
            direction: UITextStorageDirection,
        ) -> NSWritingDirection;

        #[cfg(feature = "NSText")]
        #[unsafe(method(setBaseWritingDirection:forRange:))]
        #[unsafe(method_family = none)]
        fn setBaseWritingDirection_forRange(
            &self,
            writing_direction: NSWritingDirection,
            range: &UITextRange,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(firstRectForRange:))]
        #[unsafe(method_family = none)]
        fn firstRectForRange(&self, range: &UITextRange) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(caretRectForPosition:))]
        #[unsafe(method_family = none)]
        fn caretRectForPosition(&self, position: &UITextPosition) -> CGRect;

        #[unsafe(method(selectionRectsForRange:))]
        #[unsafe(method_family = none)]
        fn selectionRectsForRange(
            &self,
            range: &UITextRange,
        ) -> Retained<NSArray<UITextSelectionRect>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(closestPositionToPoint:))]
        #[unsafe(method_family = none)]
        fn closestPositionToPoint(&self, point: CGPoint) -> Option<Retained<UITextPosition>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(closestPositionToPoint:withinRange:))]
        #[unsafe(method_family = none)]
        fn closestPositionToPoint_withinRange(
            &self,
            point: CGPoint,
            range: &UITextRange,
        ) -> Option<Retained<UITextPosition>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(characterRangeAtPoint:))]
        #[unsafe(method_family = none)]
        fn characterRangeAtPoint(&self, point: CGPoint) -> Option<Retained<UITextRange>>;

        #[optional]
        #[unsafe(method(shouldChangeTextInRange:replacementText:))]
        #[unsafe(method_family = none)]
        fn shouldChangeTextInRange_replacementText(
            &self,
            range: &UITextRange,
            text: &NSString,
        ) -> bool;

        #[optional]
        #[unsafe(method(textStylingAtPosition:inDirection:))]
        #[unsafe(method_family = none)]
        fn textStylingAtPosition_inDirection(
            &self,
            position: &UITextPosition,
            direction: UITextStorageDirection,
        ) -> Option<Retained<NSDictionary<NSAttributedStringKey, AnyObject>>>;

        #[optional]
        #[unsafe(method(positionWithinRange:atCharacterOffset:))]
        #[unsafe(method_family = none)]
        fn positionWithinRange_atCharacterOffset(
            &self,
            range: &UITextRange,
            offset: NSInteger,
        ) -> Option<Retained<UITextPosition>>;

        #[optional]
        #[unsafe(method(characterOffsetOfPosition:withinRange:))]
        #[unsafe(method_family = none)]
        fn characterOffsetOfPosition_withinRange(
            &self,
            position: &UITextPosition,
            range: &UITextRange,
        ) -> NSInteger;

        #[cfg(all(feature = "UIResponder", feature = "UIView"))]
        #[optional]
        #[unsafe(method(textInputView))]
        #[unsafe(method_family = none)]
        fn textInputView(&self) -> Retained<UIView>;

        #[optional]
        #[unsafe(method(selectionAffinity))]
        #[unsafe(method_family = none)]
        fn selectionAffinity(&self) -> UITextStorageDirection;

        /// Setter for [`selectionAffinity`][Self::selectionAffinity].
        #[optional]
        #[unsafe(method(setSelectionAffinity:))]
        #[unsafe(method_family = none)]
        fn setSelectionAffinity(&self, selection_affinity: UITextStorageDirection);

        #[optional]
        #[unsafe(method(insertDictationResult:))]
        #[unsafe(method_family = none)]
        fn insertDictationResult(&self, dictation_result: &NSArray<UIDictationPhrase>);

        #[optional]
        #[unsafe(method(dictationRecordingDidEnd))]
        #[unsafe(method_family = none)]
        fn dictationRecordingDidEnd(&self);

        #[optional]
        #[unsafe(method(dictationRecognitionFailed))]
        #[unsafe(method_family = none)]
        fn dictationRecognitionFailed(&self);

        #[optional]
        #[unsafe(method(insertDictationResultPlaceholder))]
        #[unsafe(method_family = none)]
        fn insertDictationResultPlaceholder(&self) -> Retained<AnyObject>;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// `placeholder` should be of the correct type.
        #[optional]
        #[unsafe(method(frameForDictationResultPlaceholder:))]
        #[unsafe(method_family = none)]
        unsafe fn frameForDictationResultPlaceholder(&self, placeholder: &AnyObject) -> CGRect;

        /// # Safety
        ///
        /// `placeholder` should be of the correct type.
        #[optional]
        #[unsafe(method(removeDictationResultPlaceholder:willInsertResult:))]
        #[unsafe(method_family = none)]
        unsafe fn removeDictationResultPlaceholder_willInsertResult(
            &self,
            placeholder: &AnyObject,
            will_insert_result: bool,
        );

        #[optional]
        #[unsafe(method(insertText:alternatives:style:))]
        #[unsafe(method_family = none)]
        fn insertText_alternatives_style(
            &self,
            text: &NSString,
            alternatives: &NSArray<NSString>,
            style: UITextAlternativeStyle,
        );

        #[optional]
        #[unsafe(method(setAttributedMarkedText:selectedRange:))]
        #[unsafe(method_family = none)]
        fn setAttributedMarkedText_selectedRange(
            &self,
            marked_text: Option<&NSAttributedString>,
            selected_range: NSRange,
        );

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(insertTextPlaceholderWithSize:))]
        #[unsafe(method_family = none)]
        fn insertTextPlaceholderWithSize(&self, size: CGSize) -> Retained<UITextPlaceholder>;

        #[optional]
        #[unsafe(method(removeTextPlaceholder:))]
        #[unsafe(method_family = none)]
        fn removeTextPlaceholder(&self, text_placeholder: &UITextPlaceholder);

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(beginFloatingCursorAtPoint:))]
        #[unsafe(method_family = none)]
        fn beginFloatingCursorAtPoint(&self, point: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(updateFloatingCursorAtPoint:))]
        #[unsafe(method_family = none)]
        fn updateFloatingCursorAtPoint(&self, point: CGPoint);

        #[optional]
        #[unsafe(method(endFloatingCursor))]
        #[unsafe(method_family = none)]
        fn endFloatingCursor(&self);

        #[cfg(feature = "objc2-core-foundation")]
        /// Similar to `-caretRectForPosition:`, optionally provide a transform for the caret at `position`. As with all geometry information in this protocol,
        /// transforms are assumed to be relative to the `textInputView` coordinate space. If unimplemented, the identity transform is assumed.
        #[optional]
        #[unsafe(method(caretTransformForPosition:))]
        #[unsafe(method_family = none)]
        fn caretTransformForPosition(&self, position: &UITextPosition) -> CGAffineTransform;

        #[cfg(all(feature = "UIMenu", feature = "UIMenuElement"))]
        /// Called when the text input is preparing an edit menu presentation for the specified text range.
        ///
        ///
        /// Parameter `textRange`: The text range for which the menu is presented for.
        ///
        /// Parameter `suggestedActions`: The actions and commands that the system suggests.
        ///
        ///
        /// Returns: Return a UIMenu describing the desired menu hierarchy. Return
        /// `nil`to present the default system menu.
        #[optional]
        #[unsafe(method(editMenuForTextRange:suggestedActions:))]
        #[unsafe(method_family = none)]
        fn editMenuForTextRange_suggestedActions(
            &self,
            text_range: &UITextRange,
            suggested_actions: &NSArray<UIMenuElement>,
        ) -> Option<Retained<UIMenu>>;

        #[cfg(feature = "UIEditMenuInteraction")]
        #[optional]
        #[unsafe(method(willPresentEditMenuWithAnimator:))]
        #[unsafe(method_family = none)]
        fn willPresentEditMenuWithAnimator(
            &self,
            animator: &ProtocolObject<dyn UIEditMenuInteractionAnimating>,
        );

        #[cfg(feature = "UIEditMenuInteraction")]
        #[optional]
        #[unsafe(method(willDismissEditMenuWithAnimator:))]
        #[unsafe(method_family = none)]
        fn willDismissEditMenuWithAnimator(
            &self,
            animator: &ProtocolObject<dyn UIEditMenuInteractionAnimating>,
        );

        #[optional]
        #[unsafe(method(supportsAdaptiveImageGlyph))]
        #[unsafe(method_family = none)]
        fn supportsAdaptiveImageGlyph(&self) -> bool;

        /// Setter for [`supportsAdaptiveImageGlyph`][Self::supportsAdaptiveImageGlyph].
        #[optional]
        #[unsafe(method(setSupportsAdaptiveImageGlyph:))]
        #[unsafe(method_family = none)]
        fn setSupportsAdaptiveImageGlyph(&self, supports_adaptive_image_glyph: bool);

        #[cfg(feature = "NSAdaptiveImageGlyph")]
        #[optional]
        #[unsafe(method(insertAdaptiveImageGlyph:replacementRange:))]
        #[unsafe(method_family = none)]
        fn insertAdaptiveImageGlyph_replacementRange(
            &self,
            adaptive_image_glyph: &NSAdaptiveImageGlyph,
            replacement_range: &UITextRange,
        );

        #[optional]
        #[unsafe(method(isEditable))]
        #[unsafe(method_family = none)]
        fn isEditable(&self) -> bool;

        #[optional]
        #[unsafe(method(insertAttributedText:))]
        #[unsafe(method_family = none)]
        fn insertAttributedText(&self, string: &NSAttributedString);

        #[optional]
        #[unsafe(method(attributedTextInRange:))]
        #[unsafe(method_family = none)]
        fn attributedTextInRange(&self, range: &UITextRange) -> Retained<NSAttributedString>;

        #[optional]
        #[unsafe(method(replaceRange:withAttributedText:))]
        #[unsafe(method_family = none)]
        fn replaceRange_withAttributedText(
            &self,
            range: &UITextRange,
            attributed_text: &NSAttributedString,
        );

        #[optional]
        #[unsafe(method(willPresentWritingTools))]
        #[unsafe(method_family = none)]
        fn willPresentWritingTools(&self);

        #[optional]
        #[unsafe(method(didDismissWritingTools))]
        #[unsafe(method_family = none)]
        fn didDismissWritingTools(&self);

        #[cfg(feature = "UIInputSuggestion")]
        /// Inserts the user or system’s input suggestion into the document.
        #[optional]
        #[unsafe(method(insertInputSuggestion:))]
        #[unsafe(method_family = none)]
        fn insertInputSuggestion(&self, input_suggestion: &UIInputSuggestion);
    }
);

extern "C" {
    /// The background color of the text.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`UIColor`](https://developer.apple.com/documentation/uikit/uicolor) object.
    ///
    ///
    #[deprecated]
    pub static UITextInputTextBackgroundColorKey: &'static NSString;
}

extern "C" {
    /// The color of the text.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`UIColor`](https://developer.apple.com/documentation/uikit/uicolor) object.
    ///
    ///
    #[deprecated]
    pub static UITextInputTextColorKey: &'static NSString;
}

extern "C" {
    /// The font of the text.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`UIFont`](https://developer.apple.com/documentation/uikit/uifont) object.
    ///
    ///
    #[deprecated]
    pub static UITextInputTextFontKey: &'static NSString;
}

extern_class!(
    /// A position in a text container—that is, an index into the backing string in a text-display view.
    ///
    /// ## Overview
    ///
    /// Classes that adopt the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol must create custom [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) objects for representing specific locations within the text managed by the class. The text input system uses both these objects and [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) objects for communicating text-layout information. There are two reasons for using objects for text positions rather than primitive types such as [`NSInteger`](https://developer.apple.com/documentation/objectivec/nsinteger):
    ///
    /// - Some documents contain nested elements (for example, HTML tags and embedded objects) and you need to track both absolute position and position in the visible text.
    ///
    /// - The WebKit framework requires that text indexes and offsets be represented by objects.
    ///
    /// The simplest of [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) objects—for example, one used in plain text—might have a single integer property that represents an offset into a string. If you adopt the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol, you must create a custom [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) subclass as well as a custom [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) subclass.
    ///
    /// This class declares no methods of its own.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextPosition;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextPosition {}
);

impl UITextPosition {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl UITextPosition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// A range of characters in a text container with a starting index and an ending index in string backing a text-entry object.
    ///
    /// ## Overview
    ///
    /// Classes that adopt the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol must create custom [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) objects for representing ranges within the text managed by the class. The starting and ending indexes of the range are represented by [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) objects. The text system uses both [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) and [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) objects for communicating text-layout information. There are two reasons for using objects for text ranges rather than primitive types such as [`NSRange`](https://developer.apple.com/documentation/foundation/nsrange-c.struct):
    ///
    /// - Some documents contain nested elements (for example, HTML tags and embedded objects) and you need to track both absolute position and position in the visible text.
    ///
    /// - The WebKit framework requires that text indexes and offsets be represented by objects.
    ///
    /// If you adopt the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol, you must create a custom [`UITextRange`](https://developer.apple.com/documentation/uikit/uitextrange) subclass as well as a custom [`UITextPosition`](https://developer.apple.com/documentation/uikit/uitextposition) subclass.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextRange;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextRange {}
);

impl UITextRange {
    extern_methods!(
        #[unsafe(method(isEmpty))]
        #[unsafe(method_family = none)]
        pub fn isEmpty(&self) -> bool;

        #[unsafe(method(start))]
        #[unsafe(method_family = none)]
        pub fn start(&self) -> Retained<UITextPosition>;

        #[unsafe(method(end))]
        #[unsafe(method_family = none)]
        pub fn end(&self) -> Retained<UITextPosition>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UITextRange {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// An encapsulation of information about a selected range of text in a document.
    ///
    /// ## Overview
    ///
    /// This class is an abstract class and must be subclassed to be used. The system text input views provide their own concrete implementations of this class.
    ///
    /// ### Subclassing Notes
    ///
    /// If you are implementing a custom text input view, you can subclass and use your custom class to return selection-related information. When subclassing, you should override and reimplement all properties. In your custom implementations, do not call `super`.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextSelectionRect;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextSelectionRect {}
);

impl UITextSelectionRect {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(rect))]
        #[unsafe(method_family = none)]
        pub fn rect(&self) -> CGRect;

        #[cfg(feature = "NSText")]
        #[unsafe(method(writingDirection))]
        #[unsafe(method_family = none)]
        pub fn writingDirection(&self) -> NSWritingDirection;

        #[unsafe(method(containsStart))]
        #[unsafe(method_family = none)]
        pub fn containsStart(&self) -> bool;

        #[unsafe(method(containsEnd))]
        #[unsafe(method_family = none)]
        pub fn containsEnd(&self) -> bool;

        #[unsafe(method(isVertical))]
        #[unsafe(method_family = none)]
        pub fn isVertical(&self) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        /// Custom transform for highlight rects.
        /// This transform is assumed to be in the `textInputView` coordinate space.
        /// Default is CGAffineTransformIdentity (no transform applied).
        #[unsafe(method(transform))]
        #[unsafe(method_family = none)]
        pub fn transform(&self) -> CGAffineTransform;
    );
}

/// Methods declared on superclass `NSObject`.
impl UITextSelectionRect {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_protocol!(
    /// An intermediary between a document and the text input system.
    ///
    /// ## Overview
    ///
    /// A [`UITextInputDelegate`](https://developer.apple.com/documentation/uikit/uitextinputdelegate) conveys notifications of pending or transpired changes in text and selection in the document. UIKit provides a private text input delegate, which it assigns at runtime to the [`inputDelegate`](https://developer.apple.com/documentation/uikit/uitextinput/inputdelegate) property of the object whose class adopts the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol.
    ///
    ///
    pub unsafe trait UITextInputDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "UITextInputTraits")]
        #[unsafe(method(selectionWillChange:))]
        #[unsafe(method_family = none)]
        fn selectionWillChange(&self, text_input: Option<&ProtocolObject<dyn UITextInput>>);

        #[cfg(feature = "UITextInputTraits")]
        #[unsafe(method(selectionDidChange:))]
        #[unsafe(method_family = none)]
        fn selectionDidChange(&self, text_input: Option<&ProtocolObject<dyn UITextInput>>);

        #[cfg(feature = "UITextInputTraits")]
        #[unsafe(method(textWillChange:))]
        #[unsafe(method_family = none)]
        fn textWillChange(&self, text_input: Option<&ProtocolObject<dyn UITextInput>>);

        #[cfg(feature = "UITextInputTraits")]
        #[unsafe(method(textDidChange:))]
        #[unsafe(method_family = none)]
        fn textDidChange(&self, text_input: Option<&ProtocolObject<dyn UITextInput>>);

        #[cfg(all(feature = "UIConversationContext", feature = "UITextInputTraits"))]
        /// Tells the input delegate when text has changed in the input object for a conversation.
        #[unsafe(method(conversationContext:didChange:))]
        #[unsafe(method_family = none)]
        fn conversationContext_didChange(
            &self,
            context: Option<&UIConversationContext>,
            text_input: Option<&ProtocolObject<dyn UITextInput>>,
        );
    }
);

extern_protocol!(
    /// A tokenizer, which is an object that allows the text input system to evaluate text units of different granularities.
    ///
    /// ## Overview
    ///
    /// Granularities of text units are always evaluated with reference to a storage or reference direction.
    ///
    /// Text-processing objects that conform to the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol must hold a reference to a tokenizer (through the [`tokenizer`](https://developer.apple.com/documentation/uikit/uitextinput/tokenizer) property). The [`UITextInputStringTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputstringtokenizer) class provides a default base implementation of the [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) protocol. Tokenizers of this class are suitable for most western-language keyboards. Apps with different requirements may adopt the [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) protocol and create their own tokenizers.
    ///
    ///
    pub unsafe trait UITextInputTokenizer: NSObjectProtocol + MainThreadOnly {
        #[unsafe(method(rangeEnclosingPosition:withGranularity:inDirection:))]
        #[unsafe(method_family = none)]
        fn rangeEnclosingPosition_withGranularity_inDirection(
            &self,
            position: &UITextPosition,
            granularity: UITextGranularity,
            direction: UITextDirection,
        ) -> Option<Retained<UITextRange>>;

        #[unsafe(method(isPosition:atBoundary:inDirection:))]
        #[unsafe(method_family = none)]
        fn isPosition_atBoundary_inDirection(
            &self,
            position: &UITextPosition,
            granularity: UITextGranularity,
            direction: UITextDirection,
        ) -> bool;

        #[unsafe(method(positionFromPosition:toBoundary:inDirection:))]
        #[unsafe(method_family = none)]
        fn positionFromPosition_toBoundary_inDirection(
            &self,
            position: &UITextPosition,
            granularity: UITextGranularity,
            direction: UITextDirection,
        ) -> Option<Retained<UITextPosition>>;

        #[unsafe(method(isPosition:withinTextUnit:inDirection:))]
        #[unsafe(method_family = none)]
        fn isPosition_withinTextUnit_inDirection(
            &self,
            position: &UITextPosition,
            granularity: UITextGranularity,
            direction: UITextDirection,
        ) -> bool;
    }
);

extern_class!(
    /// A base implementation of the text-input tokenizer protocol.
    ///
    /// ## Overview
    ///
    /// If you want to take advantage of this base implementation of the [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) protocol, you should subclass this class and handle application-specific directions and granularities affected by layout. When you instantiate a class you must supply the document class that’s adopting the [`UITextInput`](https://developer.apple.com/documentation/uikit/uitextinput) protocol for your application.
    ///
    /// ### Subclassing notes
    ///
    /// When you subclass [`UITextInputStringTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputstringtokenizer), override all [`UITextInputTokenizer`](https://developer.apple.com/documentation/uikit/uitextinputtokenizer) methods, calling the superclass implementation (`super`) when method parameters aren’t affected by layout. For example, the subclass needs a custom implementation of all methods for line granularity. For the left direction, it needs to decide whether left corresponds at a given position to forward or backward, and then call `super` passing in the storage direction ([`UITextStorageDirection`](https://developer.apple.com/documentation/uikit/uitextstoragedirection)).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextInputStringTokenizer;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextInputStringTokenizer {}
);

extern_conformance!(
    unsafe impl UITextInputTokenizer for UITextInputStringTokenizer {}
);

impl UITextInputStringTokenizer {
    extern_methods!(
        #[cfg(all(feature = "UIResponder", feature = "UITextInputTraits"))]
        /// # Safety
        ///
        /// `text_input` must implement UITextInput.
        #[unsafe(method(initWithTextInput:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTextInput(
            this: Allocated<Self>,
            text_input: &UIResponder,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UITextInputStringTokenizer {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// The current text input mode.
    ///
    /// ## Overview
    ///
    /// You can use this object to determine the primary language currently being used for text input.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UITextInputMode;
);

extern_conformance!(
    unsafe impl NSCoding for UITextInputMode {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for UITextInputMode {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UITextInputMode {}
);

impl UITextInputMode {
    extern_methods!(
        #[unsafe(method(primaryLanguage))]
        #[unsafe(method_family = none)]
        pub fn primaryLanguage(&self) -> Option<Retained<NSString>>;

        #[deprecated]
        #[unsafe(method(currentInputMode))]
        #[unsafe(method_family = none)]
        pub fn currentInputMode(mtm: MainThreadMarker) -> Option<Retained<UITextInputMode>>;

        #[unsafe(method(activeInputModes))]
        #[unsafe(method_family = none)]
        pub fn activeInputModes(mtm: MainThreadMarker) -> Retained<NSArray<UITextInputMode>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UITextInputMode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern "C" {
    /// A notification that posts when the current input mode changes.
    ///
    /// ## Discussion
    ///
    /// The posting object is a [`UITextInputMode`](https://developer.apple.com/documentation/uikit/uitextinputmode) instance.
    ///
    ///
    pub static UITextInputCurrentInputModeDidChangeNotification: &'static NSNotificationName;
}
