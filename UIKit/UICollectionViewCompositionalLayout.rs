//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
use objc2_quartz_core::*;

use crate::*;

/// Constants that describe the reference point of the content insets.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UIContentInsetsReference(pub NSInteger);
impl UIContentInsetsReference {
    /// Content insets use the system default reference point.
    ///
    /// ## Discussion
    ///
    /// When you set this value on a section in a collection view, the section defaults to using the content insets reference value of the collection view.
    ///
    ///
    #[doc(alias = "UIContentInsetsReferenceAutomatic")]
    pub const Automatic: Self = Self(0);
    /// Content insets don’t have a reference point in relation to other insets.
    #[doc(alias = "UIContentInsetsReferenceNone")]
    pub const None: Self = Self(1);
    /// Content insets use a reference point in relation to the safe area.
    #[doc(alias = "UIContentInsetsReferenceSafeArea")]
    pub const SafeArea: Self = Self(2);
    /// Content insets use a reference point in relation to the layout margins.
    #[doc(alias = "UIContentInsetsReferenceLayoutMargins")]
    pub const LayoutMargins: Self = Self(3);
    /// Content insets use a reference point in relation to the readable content guide.
    #[doc(alias = "UIContentInsetsReferenceReadableContent")]
    pub const ReadableContent: Self = Self(4);
}

unsafe impl Encode for UIContentInsetsReference {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UIContentInsetsReference {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that defines scroll direction, section spacing, and headers or footers for the layout.
    ///
    /// ## Overview
    ///
    /// You use a layout configuration to modify a collection view layout’s default scroll direction, add extra spacing between each section of the layout, and add headers or footers to the entire layout.
    ///
    /// You can pass in this configuration when creating a [`UICollectionViewCompositionalLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout), or you can set the [`configuration`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout/configuration) property on an existing layout. If you modify the configuration on an existing layout, the system invalidates the layout so that it will be updated with the new configuration.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let headerFooterSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                             heightDimension: .estimated(44))", "", "let header = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,", "                                                        elementKind: \"header\",", "                                                          alignment: .top)", "let footer = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,", "                                                        elementKind: \"footer\",", "                                                          alignment: .bottom)", "", "let config = UICollectionViewCompositionalLayoutConfiguration()", "config.interSectionSpacing = 20", "config.scrollDirection = .horizontal", "config.boundarySupplementaryItems = [header, footer]"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *headerFooterSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension estimatedDimension:44.0]];", "", "NSCollectionLayoutBoundarySupplementaryItem *header = [NSCollectionLayoutBoundarySupplementaryItem boundarySupplementaryItemWithLayoutSize:headerFooterSize elementKind:@\"header\" alignment:NSRectAlignmentTop];", "", "NSCollectionLayoutBoundarySupplementaryItem *footer = [NSCollectionLayoutBoundarySupplementaryItem boundarySupplementaryItemWithLayoutSize:headerFooterSize elementKind:@\"footer\" alignment:NSRectAlignmentBottom];", "", "UICollectionViewCompositionalLayoutConfiguration *config = [[UICollectionViewCompositionalLayoutConfiguration alloc] init];", "[config setInterSectionSpacing:20.0];", "[config setScrollDirection:UICollectionViewScrollDirectionHorizontal];", "[config setBoundarySupplementaryItems:@[header, footer]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionViewCompositionalLayoutConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for UICollectionViewCompositionalLayoutConfiguration {}
);

unsafe impl CopyingHelper for UICollectionViewCompositionalLayoutConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionViewCompositionalLayoutConfiguration {}
);

impl UICollectionViewCompositionalLayoutConfiguration {
    extern_methods!(
        #[cfg(feature = "UICollectionViewLayout")]
        #[unsafe(method(scrollDirection))]
        #[unsafe(method_family = none)]
        pub fn scrollDirection(&self) -> UICollectionViewScrollDirection;

        #[cfg(feature = "UICollectionViewLayout")]
        /// Setter for [`scrollDirection`][Self::scrollDirection].
        #[unsafe(method(setScrollDirection:))]
        #[unsafe(method_family = none)]
        pub fn setScrollDirection(&self, scroll_direction: UICollectionViewScrollDirection);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(interSectionSpacing))]
        #[unsafe(method_family = none)]
        pub fn interSectionSpacing(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`interSectionSpacing`][Self::interSectionSpacing].
        #[unsafe(method(setInterSectionSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setInterSectionSpacing(&self, inter_section_spacing: CGFloat);

        #[unsafe(method(boundarySupplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItems(
            &self,
        ) -> Retained<NSArray<NSCollectionLayoutBoundarySupplementaryItem>>;

        /// Setter for [`boundarySupplementaryItems`][Self::boundarySupplementaryItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBoundarySupplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn setBoundarySupplementaryItems(
            &self,
            boundary_supplementary_items: &NSArray<NSCollectionLayoutBoundarySupplementaryItem>,
        );

        #[unsafe(method(contentInsetsReference))]
        #[unsafe(method_family = none)]
        pub fn contentInsetsReference(&self) -> UIContentInsetsReference;

        /// Setter for [`contentInsetsReference`][Self::contentInsetsReference].
        #[unsafe(method(setContentInsetsReference:))]
        #[unsafe(method_family = none)]
        pub fn setContentInsetsReference(&self, content_insets_reference: UIContentInsetsReference);
    );
}

/// Methods declared on superclass `NSObject`.
impl UICollectionViewCompositionalLayoutConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// A closure that creates and returns each of the layout’s sections.
///
/// ## Discussion
///
/// You use a section provider to create a compositional layout ([`UICollectionViewCompositionalLayout`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayout)) that has multiple sections with different layouts. The section provider keeps track of the index of the section that it’s currently creating, so you can configure each section differently.
///
/// For example, the following code shows a section provider that creates a two-column layout in the first section, and a four-column layout in each section after the first section.
///
/// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func createPerSectionLayout() -> UICollectionViewLayout {", "    let layout = UICollectionViewCompositionalLayout { (sectionIndex: Int,", "        layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection? in", "        ", "        let columns = sectionIndex == 0 ? 2 : 4", "        ", "        let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                             heightDimension: .fractionalHeight(1.0))", "        let item = NSCollectionLayoutItem(layoutSize: itemSize)", "        ", "        let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                              heightDimension: .absolute(44))", "        let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize,", "                                                          subitem: item,", "                                                            count: columns)", "        ", "        let section = NSCollectionLayoutSection(group: group)", "        return section", "    }", "    return layout", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSectionProvider:^NSCollectionLayoutSection *(NSInteger sectionIndex, id<NSCollectionLayoutEnvironment> layoutEnvironment) {", "    ", "    NSInteger columns = (sectionIndex == 0) ? 2 : 4;", "    ", "    NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension fractionalHeightDimension:1.0]];", "    ", "    NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize];", "", "    NSCollectionLayoutSize *groupSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "    NSCollectionLayoutGroup *group = [NSCollectionLayoutGroup horizontalGroupWithLayoutSize:groupSize subitem:item count:columns];", "            ", "    NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "    return section;", "}];", "", "return layout;"], metadata: None }] }] })
/// A section provider is also invoked in response to system events such as changes in device orientation, system font size, and size classes from iPad multitasking. You can use this opportunity to adapt the layout to different layout environments by inspecting information about the current layout environment ([`NSCollectionLayoutEnvironment`](https://developer.apple.com/documentation/uikit/nscollectionlayoutenvironment)) and using that information to configure each section.
///
/// For example, the following code shows a section provider that creates a two-column layout when the width of the section’s container is less than 800 points, and a four-column layout otherwise.
///
/// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func createAdaptiveLayout() -> UICollectionViewLayout {", "    let layout = UICollectionViewCompositionalLayout { (sectionIndex: Int,", "        layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection in", "", "        let columns = layoutEnvironment.container.effectiveContentSize.width < 800 ? 2 : 4", "        ", "        let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                             heightDimension: .fractionalHeight(1.0))", "        let item = NSCollectionLayoutItem(layoutSize: itemSize)", "        ", "        let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                              heightDimension: .absolute(44))", "        let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize,", "                                                          subitem: item,", "                                                            count: columns)", "        ", "        let section = NSCollectionLayoutSection(group: group)", "        return section", "    }", "    return layout", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSectionProvider:^NSCollectionLayoutSection *(NSInteger sectionIndex, id<NSCollectionLayoutEnvironment> layoutEnvironment) {    ", "    NSInteger columns = (layoutEnvironment.container.effectiveContentSize.width < 800) ? 2 : 4;", "    ", "    NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension fractionalHeightDimension:1.0]];", "    ", "    NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize];", "", "    NSCollectionLayoutSize *groupSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "    NSCollectionLayoutGroup *group = [NSCollectionLayoutGroup horizontalGroupWithLayoutSize:groupSize subitem:item count:columns];", "            ", "    NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "    return section;", "}];", "", "return layout;"], metadata: None }] }] })
/// In iOS 18 and later, UIKit supports automatic trait tracking inside this closure for traits from the `traitCollection` of the `layoutEnvironment` parameter. For more information, see [Automatic trait tracking](https://developer.apple.com/documentation/uikit/automatic-trait-tracking).
///
///
#[cfg(feature = "block2")]
pub type UICollectionViewCompositionalLayoutSectionProvider = *mut block2::DynBlock<
    dyn Fn(
        NSInteger,
        NonNull<ProtocolObject<dyn NSCollectionLayoutEnvironment>>,
    ) -> *mut NSCollectionLayoutSection,
>;

extern_class!(
    /// A layout object that lets you combine items in highly adaptive and flexible visual arrangements.
    ///
    /// ## Overview
    ///
    /// A compositional layout is a type of collection view layout. It’s designed to be composable, flexible, and fast, letting you build any kind of visual arrangement for your content by combining — or compositing — each smaller component into a full layout.
    ///
    /// A compositional layout is composed of one or more sections that break up the layout into distinct visual groupings. Each section is composed of groups of individual items, the smallest unit of data you want to present. A group might lay out its items in a horizontal row, a vertical column, or a custom arrangement.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/981f0b534b7f4153042bfa97691a1f9b/media-3568664~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/1bcae7456df55cf8e3407bb9324c0d33/media-3568664%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of two horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the side of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. Each of the items, groups, and sections are outlined and labeled to show how the pieces fit together." src="https://docs-assets.developer.apple.com/published/981f0b534b7f4153042bfa97691a1f9b/media-3568664~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// You combine the components by building up from items into a group, from groups into a section, and finally into a full layout, like in this example of a basic list layout:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func createBasicListLayout() -> UICollectionViewLayout { ", "    let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),                                  ", "                                         heightDimension: .fractionalHeight(1.0))    ", "    let item = NSCollectionLayoutItem(layoutSize: itemSize)  ", "  ", "    let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),                                          ", "                                          heightDimension: .absolute(44))    ", "    let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize,                                                   ", "                                                     subitems: [item])  ", "  ", "    let section = NSCollectionLayoutSection(group: group)    ", "", "", "    let layout = UICollectionViewCompositionalLayout(section: section)    ", "    return layout", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (UICollectionViewLayout *)createBasicListLayout {", "    NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension fractionalHeightDimension:1.0]];", "    ", "    NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize];", "", "    NSCollectionLayoutSize *groupSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "    NSCollectionLayoutGroup *group = [NSCollectionLayoutGroup horizontalGroupWithLayoutSize:groupSize subitems:@[item]];", "    ", "    NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "", "    UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSection:section];", "    ", "    return layout;", "}"], metadata: None }] }] })
    ///
    #[unsafe(super(UICollectionViewLayout, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "UICollectionViewLayout")]
    pub struct UICollectionViewCompositionalLayout;
);

#[cfg(feature = "UICollectionViewLayout")]
extern_conformance!(
    unsafe impl NSCoding for UICollectionViewCompositionalLayout {}
);

#[cfg(feature = "UICollectionViewLayout")]
extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionViewCompositionalLayout {}
);

#[cfg(feature = "UICollectionViewLayout")]
impl UICollectionViewCompositionalLayout {
    extern_methods!(
        #[unsafe(method(initWithSection:))]
        #[unsafe(method_family = init)]
        pub fn initWithSection(
            this: Allocated<Self>,
            section: &NSCollectionLayoutSection,
        ) -> Retained<Self>;

        #[unsafe(method(initWithSection:configuration:))]
        #[unsafe(method_family = init)]
        pub fn initWithSection_configuration(
            this: Allocated<Self>,
            section: &NSCollectionLayoutSection,
            configuration: &UICollectionViewCompositionalLayoutConfiguration,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `section_provider` must be a valid pointer.
        #[unsafe(method(initWithSectionProvider:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSectionProvider(
            this: Allocated<Self>,
            section_provider: UICollectionViewCompositionalLayoutSectionProvider,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `section_provider` must be a valid pointer.
        #[unsafe(method(initWithSectionProvider:configuration:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSectionProvider_configuration(
            this: Allocated<Self>,
            section_provider: UICollectionViewCompositionalLayoutSectionProvider,
            configuration: &UICollectionViewCompositionalLayoutConfiguration,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub fn configuration(&self) -> Retained<UICollectionViewCompositionalLayoutConfiguration>;

        /// Setter for [`configuration`][Self::configuration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn setConfiguration(
            &self,
            configuration: &UICollectionViewCompositionalLayoutConfiguration,
        );
    );
}

/// Methods declared on superclass `UICollectionViewLayout`.
#[cfg(feature = "UICollectionViewLayout")]
impl UICollectionViewCompositionalLayout {
    extern_methods!(
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// The scrolling behavior of the layout’s sections in relation to the main layout axis.
///
/// ## Overview
///
/// By default, each section lays out its content along the main axis of its layout, defined by the layout configuration’s [`scrollDirection`](https://developer.apple.com/documentation/uikit/uicollectionviewcompositionallayoutconfiguration/scrolldirection) property. You can change this behavior for a particular section by setting its [`orthogonalScrollingBehavior`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsection/orthogonalscrollingbehavior) property to a different value than its default [`UICollectionLayoutSectionOrthogonalScrollingBehaviorNone`](https://developer.apple.com/documentation/uikit/uicollectionlayoutsectionorthogonalscrollingbehavior/none). Setting any other value for this property makes the section lay out its content orthogonally to the main layout axis.
///
///
/// ![Diagram of a collection view layout with multiple sections. The collection view sections are laid out vertically, so the collection view scrolls on the vertical axis to reveal more content. The content in the top section of the collection view scrolls on the horizontal axis, orthogonally to the main layout axis of the collection view’s layout.](https://docs-assets.developer.apple.com/published/4cf72f33e39a4d8db2a13d71d4cc3d70/media-3570451%402x.png)
///
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UICollectionLayoutSectionOrthogonalScrollingBehavior(pub NSInteger);
impl UICollectionLayoutSectionOrthogonalScrollingBehavior {
    /// The section does not allow users to scroll its content orthogonally.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBehaviorNone")]
    pub const None: Self = Self(0);
    /// The section allows users to scroll its content orthogonally with continuous scrolling.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBehaviorContinuous")]
    pub const Continuous: Self = Self(1);
    /// The section allows users to scroll its content orthogonally, coming to a natural stop at the leading boundary of the visible group.
    #[doc(
        alias = "UICollectionLayoutSectionOrthogonalScrollingBehaviorContinuousGroupLeadingBoundary"
    )]
    pub const ContinuousGroupLeadingBoundary: Self = Self(2);
    /// The section allows users to page its content orthogonally.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBehaviorPaging")]
    pub const Paging: Self = Self(3);
    /// The section allows users to page its content orthogonally one group at a time.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBehaviorGroupPaging")]
    pub const GroupPaging: Self = Self(4);
    /// The section allows users to page its content orthogonally one group at a time, centering each group.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBehaviorGroupPagingCentered")]
    pub const GroupPagingCentered: Self = Self(5);
}

unsafe impl Encode for UICollectionLayoutSectionOrthogonalScrollingBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UICollectionLayoutSectionOrthogonalScrollingBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A closure called before each layout cycle to allow modification of items in a section immediately before they’re displayed.
///
/// ## Discussion
///
/// Each section of a collection view layout can have a visible items invalidation handler. You use this handler to perform custom animations on the items currently visible within the bounds of that section. The handler is called before each layout cycle, any time an animation occurs in that section due to changes such as adding or removing items, scrolling the section, or rotating the device.
///
/// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let section = NSCollectionLayoutSection(group: group)", "    ", "section.visibleItemsInvalidationHandler = { visibleItems, scrollOffset, layoutEnvironment in", "    // Perform animations on the visible items.", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "", "[section setVisibleItemsInvalidationHandler:^(NSArray<id<NSCollectionLayoutVisibleItem>> *visibleItems, CGPoint contentOffset, id<NSCollectionLayoutEnvironment> layoutEnvironment) {", "    // Perform animations on the visible items.", "}];"], metadata: None }] }] })
///
#[cfg(all(
    feature = "UIDynamicBehavior",
    feature = "block2",
    feature = "objc2-core-foundation"
))]
pub type NSCollectionLayoutSectionVisibleItemsInvalidationHandler = *mut block2::DynBlock<
    dyn Fn(
        NonNull<NSArray<ProtocolObject<dyn NSCollectionLayoutVisibleItem>>>,
        CGPoint,
        NonNull<ProtocolObject<dyn NSCollectionLayoutEnvironment>>,
    ),
>;

/// Constants that specify the rate of deceleration in the orthogonal scrolling section after the scrolling pan gesture ends.
// NS_TYPED_ENUM
#[cfg(feature = "objc2-core-foundation")]
pub type UICollectionLayoutSectionOrthogonalScrollingDecelerationRate = CGFloat;

extern "C" {
    /// A deceleration rate that matches the parent scroll view’s deceleration rate for the orthogonal scrolling section.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UICollectionLayoutSectionOrthogonalScrollingDecelerationRateAutomatic:
        UICollectionLayoutSectionOrthogonalScrollingDecelerationRate;
}

extern "C" {
    /// The default deceleration rate for the orthogonal scrolling section.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UICollectionLayoutSectionOrthogonalScrollingDecelerationRateNormal:
        UICollectionLayoutSectionOrthogonalScrollingDecelerationRate;
}

extern "C" {
    /// A rapid deceleration rate for the orthogonal scrolling section.
    #[cfg(feature = "objc2-core-foundation")]
    pub static UICollectionLayoutSectionOrthogonalScrollingDecelerationRateFast:
        UICollectionLayoutSectionOrthogonalScrollingDecelerationRate;
}

/// Constants that specify whether the orthogonal scrolling section bounces past the edge of content and back again.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UICollectionLayoutSectionOrthogonalScrollingBounce(pub NSInteger);
impl UICollectionLayoutSectionOrthogonalScrollingBounce {
    /// The orthogonal scroll view bounces when it encounters a content boundary.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBounceAutomatic")]
    pub const Automatic: Self = Self(0);
    /// The orthogonal scroll view bounces even if the content is smaller than its bounds.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBounceAlways")]
    pub const Always: Self = Self(1);
    /// The orthogonal scroll view stops scrolling immediately when it encounters a content boundary without bouncing.
    #[doc(alias = "UICollectionLayoutSectionOrthogonalScrollingBounceNever")]
    pub const Never: Self = Self(2);
}

unsafe impl Encode for UICollectionLayoutSectionOrthogonalScrollingBounce {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for UICollectionLayoutSectionOrthogonalScrollingBounce {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that specifies properties for a layout section that scrolls orthogonally in relation to the main layout axis.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UICollectionLayoutSectionOrthogonalScrollingProperties;
);

extern_conformance!(
    unsafe impl NSCopying for UICollectionLayoutSectionOrthogonalScrollingProperties {}
);

unsafe impl CopyingHelper for UICollectionLayoutSectionOrthogonalScrollingProperties {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UICollectionLayoutSectionOrthogonalScrollingProperties {}
);

impl UICollectionLayoutSectionOrthogonalScrollingProperties {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// The orthogonal scroll view's rate of deceleration after the user lifts their finger.
        #[unsafe(method(decelerationRate))]
        #[unsafe(method_family = none)]
        pub fn decelerationRate(
            &self,
        ) -> UICollectionLayoutSectionOrthogonalScrollingDecelerationRate;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`decelerationRate`][Self::decelerationRate].
        #[unsafe(method(setDecelerationRate:))]
        #[unsafe(method_family = none)]
        pub fn setDecelerationRate(
            &self,
            deceleration_rate: UICollectionLayoutSectionOrthogonalScrollingDecelerationRate,
        );

        /// The orthogonal scroll view's bounce behavior.
        #[unsafe(method(bounce))]
        #[unsafe(method_family = none)]
        pub fn bounce(&self) -> UICollectionLayoutSectionOrthogonalScrollingBounce;

        /// Setter for [`bounce`][Self::bounce].
        #[unsafe(method(setBounce:))]
        #[unsafe(method_family = none)]
        pub fn setBounce(&self, bounce: UICollectionLayoutSectionOrthogonalScrollingBounce);
    );
}

/// Methods declared on superclass `NSObject`.
impl UICollectionLayoutSectionOrthogonalScrollingProperties {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// A container that combines a set of groups into distinct visual groupings.
    ///
    /// ## Overview
    ///
    /// A collection view layout has one or more sections. Sections provide a way to separate the layout into distinct pieces.
    ///
    /// Each section can have the same layout or a different layout than the other sections in the collection view. A section’s layout is determined by the properties of the group ([`NSCollectionLayoutGroup`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup)) that’s used to create the section.
    ///
    /// In the Photos app, each section in the Years page uses the same layout. In the App Store, the Apps page displays several sections with different content arrangements.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/29142d3707bbfb8205cfef012723bedb/media-3568661~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/3a145ace5c9cd5a165dbc9c2759c035f/media-3568661%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of two horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the sides of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. The two different sections are highlighted and labeled as sections." src="https://docs-assets.developer.apple.com/published/3a145ace5c9cd5a165dbc9c2759c035f/media-3568661%402x.png" />
    /// </picture>
    ///
    ///
    /// Each section can have its own background, header, and footer to distinguish it from other sections.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSection;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSection {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSection {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSection {}
);

impl NSCollectionLayoutSection {
    extern_methods!(
        #[unsafe(method(sectionWithGroup:))]
        #[unsafe(method_family = none)]
        pub fn sectionWithGroup(group: &NSCollectionLayoutGroup) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(contentInsets))]
        #[unsafe(method_family = none)]
        pub fn contentInsets(&self) -> NSDirectionalEdgeInsets;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// Setter for [`contentInsets`][Self::contentInsets].
        #[unsafe(method(setContentInsets:))]
        #[unsafe(method_family = none)]
        pub fn setContentInsets(&self, content_insets: NSDirectionalEdgeInsets);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(interGroupSpacing))]
        #[unsafe(method_family = none)]
        pub fn interGroupSpacing(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`interGroupSpacing`][Self::interGroupSpacing].
        #[unsafe(method(setInterGroupSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setInterGroupSpacing(&self, inter_group_spacing: CGFloat);

        #[unsafe(method(contentInsetsReference))]
        #[unsafe(method_family = none)]
        pub fn contentInsetsReference(&self) -> UIContentInsetsReference;

        /// Setter for [`contentInsetsReference`][Self::contentInsetsReference].
        #[unsafe(method(setContentInsetsReference:))]
        #[unsafe(method_family = none)]
        pub fn setContentInsetsReference(&self, content_insets_reference: UIContentInsetsReference);

        /// Specifies the content insets reference for boundary supplementaries in this section.
        /// The default value of this property is UIContentInsetsReference.automatic, which means that any insets specified on a
        /// `NSCollectionLayoutBoundarySupplementaryItem`will follow the layout configuration's
        /// `contentInsetsReference.`
        #[unsafe(method(supplementaryContentInsetsReference))]
        #[unsafe(method_family = none)]
        pub fn supplementaryContentInsetsReference(&self) -> UIContentInsetsReference;

        /// Setter for [`supplementaryContentInsetsReference`][Self::supplementaryContentInsetsReference].
        #[unsafe(method(setSupplementaryContentInsetsReference:))]
        #[unsafe(method_family = none)]
        pub fn setSupplementaryContentInsetsReference(
            &self,
            supplementary_content_insets_reference: UIContentInsetsReference,
        );

        #[unsafe(method(orthogonalScrollingBehavior))]
        #[unsafe(method_family = none)]
        pub fn orthogonalScrollingBehavior(
            &self,
        ) -> UICollectionLayoutSectionOrthogonalScrollingBehavior;

        /// Setter for [`orthogonalScrollingBehavior`][Self::orthogonalScrollingBehavior].
        #[unsafe(method(setOrthogonalScrollingBehavior:))]
        #[unsafe(method_family = none)]
        pub fn setOrthogonalScrollingBehavior(
            &self,
            orthogonal_scrolling_behavior: UICollectionLayoutSectionOrthogonalScrollingBehavior,
        );

        #[unsafe(method(orthogonalScrollingProperties))]
        #[unsafe(method_family = none)]
        pub fn orthogonalScrollingProperties(
            &self,
        ) -> Retained<UICollectionLayoutSectionOrthogonalScrollingProperties>;

        #[unsafe(method(boundarySupplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItems(
            &self,
        ) -> Retained<NSArray<NSCollectionLayoutBoundarySupplementaryItem>>;

        /// Setter for [`boundarySupplementaryItems`][Self::boundarySupplementaryItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBoundarySupplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn setBoundarySupplementaryItems(
            &self,
            boundary_supplementary_items: &NSArray<NSCollectionLayoutBoundarySupplementaryItem>,
        );

        #[cfg(all(
            feature = "UIDynamicBehavior",
            feature = "block2",
            feature = "objc2-core-foundation"
        ))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 3 must be a valid pointer.
        #[unsafe(method(visibleItemsInvalidationHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn visibleItemsInvalidationHandler(
            &self,
        ) -> NSCollectionLayoutSectionVisibleItemsInvalidationHandler;

        #[cfg(all(
            feature = "UIDynamicBehavior",
            feature = "block2",
            feature = "objc2-core-foundation"
        ))]
        /// Setter for [`visibleItemsInvalidationHandler`][Self::visibleItemsInvalidationHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `visible_items_invalidation_handler` must be a valid pointer or null.
        #[unsafe(method(setVisibleItemsInvalidationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVisibleItemsInvalidationHandler(
            &self,
            visible_items_invalidation_handler: NSCollectionLayoutSectionVisibleItemsInvalidationHandler,
        );

        #[unsafe(method(decorationItems))]
        #[unsafe(method_family = none)]
        pub fn decorationItems(&self) -> Retained<NSArray<NSCollectionLayoutDecorationItem>>;

        /// Setter for [`decorationItems`][Self::decorationItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDecorationItems:))]
        #[unsafe(method_family = none)]
        pub fn setDecorationItems(
            &self,
            decoration_items: &NSArray<NSCollectionLayoutDecorationItem>,
        );
    );
}

extern_class!(
    /// The most basic component of a collection view’s layout.
    ///
    /// ## Overview
    ///
    /// An item is a blueprint for how to size, space, and arrange an individual piece of content in your collection view. An item represents a single view that’s rendered onscreen. Generally, an item is a cell, but items can be supplementary views like headers, footers, and other decorations.
    ///
    /// For example, in the Photos app, an item might represent a single photo. In the App Store app, an item might be a cell displaying information about an individual app in a list of featured apps, such as the app icon, app name, tagline, and download button.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/5f87b68259e0fb25503940360e298357/media-3568665~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/4969747519bcd95bb15d128d7a712ae1/media-3568665%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of two horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the sides of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. The two different types of items are highlighted and labeled as items." src="https://docs-assets.developer.apple.com/published/5f87b68259e0fb25503940360e298357/media-3568665~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// Each item specifies its own size in terms of a width dimension and a height dimension. Items can express their dimensions relative to their container, as an absolute value, or as an estimated value that might change at runtime, like in response to a change in system font size. For more information, see [`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/uikit/nscollectionlayoutdimension).
    ///
    /// You combine items into groups that determine how those items are arranged in relation to each other. For more information, see [`NSCollectionLayoutGroup`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutItem {}
);

impl NSCollectionLayoutItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(contentInsets))]
        #[unsafe(method_family = none)]
        pub fn contentInsets(&self) -> NSDirectionalEdgeInsets;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        /// Setter for [`contentInsets`][Self::contentInsets].
        #[unsafe(method(setContentInsets:))]
        #[unsafe(method_family = none)]
        pub fn setContentInsets(&self, content_insets: NSDirectionalEdgeInsets);

        #[unsafe(method(edgeSpacing))]
        #[unsafe(method_family = none)]
        pub fn edgeSpacing(&self) -> Option<Retained<NSCollectionLayoutEdgeSpacing>>;

        /// Setter for [`edgeSpacing`][Self::edgeSpacing].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setEdgeSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setEdgeSpacing(&self, edge_spacing: Option<&NSCollectionLayoutEdgeSpacing>);

        #[unsafe(method(layoutSize))]
        #[unsafe(method_family = none)]
        pub fn layoutSize(&self) -> Retained<NSCollectionLayoutSize>;

        #[unsafe(method(supplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItems(&self) -> Retained<NSArray<NSCollectionLayoutSupplementaryItem>>;
    );
}

extern_class!(
    /// An item used in a group with a custom layout arrangement.
    ///
    /// ## Overview
    ///
    /// You use a custom item if you want to specify a layout with a custom arrangement, like a radial or diagonal layout. You use custom items within a group that’s created with [`customGroupWithLayoutSize:itemProvider:`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/custom(layoutsize:itemprovider:)).
    ///
    /// Instead of providing a layout size for the custom item, like you do when you create an [`NSCollectionLayoutItem`](https://developer.apple.com/documentation/uikit/nscollectionlayoutitem), you provide a frame instead.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutGroupCustomItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutGroupCustomItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutGroupCustomItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutGroupCustomItem {}
);

impl NSCollectionLayoutGroupCustomItem {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(customItemWithFrame:))]
        #[unsafe(method_family = none)]
        pub fn customItemWithFrame(frame: CGRect, mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(customItemWithFrame:zIndex:))]
        #[unsafe(method_family = none)]
        pub fn customItemWithFrame_zIndex(
            frame: CGRect,
            z_index: NSInteger,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        pub fn frame(&self) -> CGRect;

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;
    );
}

/// A closure that creates and returns each of the custom group’s items.
///
/// ## Discussion
///
/// You use a custom item provider to supply the item arrangement when creating a group using the [`customGroupWithLayoutSize:itemProvider:`](https://developer.apple.com/documentation/uikit/nscollectionlayoutgroup/custom(layoutsize:itemprovider:)) initializer.
///
///
#[cfg(feature = "block2")]
pub type NSCollectionLayoutGroupCustomItemProvider = *mut block2::DynBlock<
    dyn Fn(
        NonNull<ProtocolObject<dyn NSCollectionLayoutEnvironment>>,
    ) -> NonNull<NSArray<NSCollectionLayoutGroupCustomItem>>,
>;

extern_class!(
    /// A container for a set of items that lays out the items along a path.
    ///
    /// ## Overview
    ///
    /// Groups determine how the items in a collection view lay out in relation to each other. A group might lay out its items in a horizontal row, a vertical column, or a custom arrangement. A group determines the rules for how items are rendered in relation to each other, but in itself doesn’t render any content.
    ///
    /// For example, in the Photos app, a group of items is a row of photos. In the App Store app, a group might be a single column of cells (items) arranged in a vertical column.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/6d64c3ffd95d486a938762c7f5e92122/media-3568663~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/fc57f40cd933b8fdf6ee5bc26e52d7fa/media-3568663%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the sides of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. The two different types of groups are highlighted and labeled as groups." src="https://docs-assets.developer.apple.com/published/fc57f40cd933b8fdf6ee5bc26e52d7fa/media-3568663%402x.png" />
    /// </picture>
    ///
    ///
    /// Each group specifies its own size in terms of a width dimension and a height dimension. Groups can express their dimensions relative to their container, as an absolute value, or as an estimated value that might change at runtime, like in response to a change in system font size. For more information, see [`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/uikit/nscollectionlayoutdimension).
    ///
    /// Because a group is a subclass of [`NSCollectionLayoutItem`](https://developer.apple.com/documentation/uikit/nscollectionlayoutitem), it behaves like an item. You can combine a group with other items and groups into more complex layouts.
    ///
    ///
    /// ![Illustration of group nesting in a compositional layout. A larger group contains one large item on the leading side and two smaller items stacked vertically in a nested group on the trailing side.](https://docs-assets.developer.apple.com/published/47daaa6eb89261c15d6bcb264846aa1b/media-3568666%402x.png)
    ///
    ///
    /// After you configure a group, you must initialize a section ([`NSCollectionLayoutSection`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsection)) of your collection view layout with that group.
    ///
    ///
    #[unsafe(super(NSCollectionLayoutItem, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutGroup;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutGroup {}
);

unsafe impl CopyingHelper for NSCollectionLayoutGroup {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutGroup {}
);

impl NSCollectionLayoutGroup {
    extern_methods!(
        /// Specifies a group that will horizontally repeat its subitem a fixed number of times.
        ///
        /// Parameter `layoutSize`: The group's size.
        ///
        /// Parameter `subitem`: The subitem to repeat. It is the caller's responsibility to ensure that the group's
        /// `layoutSize`can fit
        /// `count`repetitions of this item.
        ///
        /// Parameter `count`: The number of times to repeat the passed in subitem.
        #[unsafe(method(horizontalGroupWithLayoutSize:repeatingSubitem:count:))]
        #[unsafe(method_family = none)]
        pub fn horizontalGroupWithLayoutSize_repeatingSubitem_count(
            layout_size: &NSCollectionLayoutSize,
            subitem: &NSCollectionLayoutItem,
            count: NSInteger,
        ) -> Retained<Self>;

        #[unsafe(method(horizontalGroupWithLayoutSize:subitems:))]
        #[unsafe(method_family = none)]
        pub fn horizontalGroupWithLayoutSize_subitems(
            layout_size: &NSCollectionLayoutSize,
            subitems: &NSArray<NSCollectionLayoutItem>,
        ) -> Retained<Self>;

        /// Specifies a group that will vertically repeat its subitem a fixed number of times.
        ///
        /// Parameter `layoutSize`: The group's size.
        ///
        /// Parameter `subitem`: The subitem to repeat. It is the caller's responsibility to ensure that the group's
        /// `layoutSize`can fit
        /// `count`repetitions of this item.
        ///
        /// Parameter `count`: The number of times to repeat the passed in subitem.
        #[unsafe(method(verticalGroupWithLayoutSize:repeatingSubitem:count:))]
        #[unsafe(method_family = none)]
        pub fn verticalGroupWithLayoutSize_repeatingSubitem_count(
            layout_size: &NSCollectionLayoutSize,
            subitem: &NSCollectionLayoutItem,
            count: NSInteger,
        ) -> Retained<Self>;

        #[unsafe(method(verticalGroupWithLayoutSize:subitems:))]
        #[unsafe(method_family = none)]
        pub fn verticalGroupWithLayoutSize_subitems(
            layout_size: &NSCollectionLayoutSize,
            subitems: &NSArray<NSCollectionLayoutItem>,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `item_provider` must be a valid pointer.
        #[unsafe(method(customGroupWithLayoutSize:itemProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn customGroupWithLayoutSize_itemProvider(
            layout_size: &NSCollectionLayoutSize,
            item_provider: NSCollectionLayoutGroupCustomItemProvider,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(supplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItems(&self) -> Retained<NSArray<NSCollectionLayoutSupplementaryItem>>;

        /// Setter for [`supplementaryItems`][Self::supplementaryItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSupplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn setSupplementaryItems(
            &self,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        );

        #[unsafe(method(interItemSpacing))]
        #[unsafe(method_family = none)]
        pub fn interItemSpacing(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        /// Setter for [`interItemSpacing`][Self::interItemSpacing].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInterItemSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setInterItemSpacing(&self, inter_item_spacing: Option<&NSCollectionLayoutSpacing>);

        #[unsafe(method(subitems))]
        #[unsafe(method_family = none)]
        pub fn subitems(&self) -> Retained<NSArray<NSCollectionLayoutItem>>;

        #[unsafe(method(visualDescription))]
        #[unsafe(method_family = none)]
        pub fn visualDescription(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutGroup {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An individual dimension representing an item’s width or height in a collection view.
    ///
    /// ## Overview
    ///
    /// Each item in a collection view has an explicit width dimension and height dimension, which combine to define the item’s size ([`NSCollectionLayoutSize`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsize)).
    ///
    /// You can express an item’s dimensions using an absolute, estimated, or fractional value.
    ///
    /// Use an _absolute value_ to specify exact dimensions, like a 44 x 44 point square:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let absoluteSize = NSCollectionLayoutSize(widthDimension: .absolute(44),", "                                         heightDimension: .absolute(44))"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *absoluteSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:44.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];"], metadata: None }] }] })
    /// Use an _estimated value_ if the size of your content might change at runtime, such as when data is loaded or in response to a change in system font size. You provide an initial estimated size and the system computes the actual value later.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let estimatedSize = NSCollectionLayoutSize(widthDimension: .estimated(200),", "                                          heightDimension: .estimated(100))"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *estimatedSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension estimatedDimension:200.0] heightDimension:[NSCollectionLayoutDimension estimatedDimension:100.0]];"], metadata: None }] }] })
    /// Use a _fractional value_ to define a value that’s relative to a dimension of the item’s container. This option simplifies specifying aspect ratios. For example, the following item has a width and a height that are both equal to 20% of its container’s width, creating a square that grows and shrinks as the size of its container changes.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let fractionalSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(0.2),", "                                           heightDimension: .fractionalWidth(0.2))"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *fractionalSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:0.2] heightDimension:[NSCollectionLayoutDimension fractionalWidthDimension:0.2]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutDimension;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutDimension {}
);

unsafe impl CopyingHelper for NSCollectionLayoutDimension {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutDimension {}
);

impl NSCollectionLayoutDimension {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(fractionalWidthDimension:))]
        #[unsafe(method_family = none)]
        pub fn fractionalWidthDimension(
            fractional_width: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(fractionalHeightDimension:))]
        #[unsafe(method_family = none)]
        pub fn fractionalHeightDimension(
            fractional_height: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(absoluteDimension:))]
        #[unsafe(method_family = none)]
        pub fn absoluteDimension(
            absolute_dimension: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(estimatedDimension:))]
        #[unsafe(method_family = none)]
        pub fn estimatedDimension(
            estimated_dimension: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Items with this dimension type will receive at least as much room as the view requires, and will
        /// grow to match the dimension of the largest estimated sibling in their parent.
        /// When specified on the outermost group for a section, the largest size will be shared across the entire section.
        ///
        /// Eg: All `NSCollectionLayoutItem`s specified with a `uniformAcrossSiblingsWithEstimate:` `heightDimension` in a horizontal `NSCollectionLayoutGroup`
        /// will have a height equal to the height of the tallest item in that group.
        ///
        /// When computing the size for a dimension of this type, the layout will need to retrieve preferred attributes for all siblings
        /// in its parent, which in `UICollectionView` means creating views for all dependent items. This can be very expensive, so `uniformAcrossSiblingsWithEstimate` should
        /// only be used in layouts where the number of dependent items is known to be relatively small.
        #[unsafe(method(uniformAcrossSiblingsWithEstimate:))]
        #[unsafe(method_family = none)]
        pub fn uniformAcrossSiblingsWithEstimate(
            estimated_dimension: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(isFractionalWidth))]
        #[unsafe(method_family = none)]
        pub fn isFractionalWidth(&self) -> bool;

        #[unsafe(method(isFractionalHeight))]
        #[unsafe(method_family = none)]
        pub fn isFractionalHeight(&self) -> bool;

        #[unsafe(method(isAbsolute))]
        #[unsafe(method_family = none)]
        pub fn isAbsolute(&self) -> bool;

        /// Returns `YES` if the receiver is `estimated` OR `uniformAcrossSiblings`.
        #[unsafe(method(isEstimated))]
        #[unsafe(method_family = none)]
        pub fn isEstimated(&self) -> bool;

        #[unsafe(method(isUniformAcrossSiblings))]
        #[unsafe(method_family = none)]
        pub fn isUniformAcrossSiblings(&self) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(dimension))]
        #[unsafe(method_family = none)]
        pub fn dimension(&self) -> CGFloat;
    );
}

extern_class!(
    /// The width and the height of an item in a collection view.
    ///
    /// ## Overview
    ///
    /// A size is a pair of dimensions ([`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/uikit/nscollectionlayoutdimension)): a width dimension and a height dimension. Every component of a collection view layout has an explicit size.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSize;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSize {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSize {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSize {}
);

impl NSCollectionLayoutSize {
    extern_methods!(
        #[unsafe(method(sizeWithWidthDimension:heightDimension:))]
        #[unsafe(method_family = none)]
        pub fn sizeWithWidthDimension_heightDimension(
            width: &NSCollectionLayoutDimension,
            height: &NSCollectionLayoutDimension,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(widthDimension))]
        #[unsafe(method_family = none)]
        pub fn widthDimension(&self) -> Retained<NSCollectionLayoutDimension>;

        #[unsafe(method(heightDimension))]
        #[unsafe(method_family = none)]
        pub fn heightDimension(&self) -> Retained<NSCollectionLayoutDimension>;
    );
}

extern_class!(
    /// An object that defines the space between or around items in a collection view.
    ///
    /// ## Overview
    ///
    /// In a collection view layout, you use a spacing object to specify both the amount of space and the way in which it’s calculated.
    ///
    /// You can express spacing using fixed or flexible spacing.
    ///
    /// Use _fixed spacing_ to provide an exact amount of space. For example, the following code creates exactly 200 points of space between the items in the group.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["group.interItemSpacing = .fixed(200.0)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[group setInterItemSpacing: [NSCollectionLayoutSpacing fixedSpacing:200.0]];"], metadata: None }] }] })
    /// Use _flexible spacing_ to provide a minimum amount of space that can grow as more space becomes available. For example, the following code creates at least 200 points of space between the items in the group. As more space becomes available, items are respaced evenly in the additional space.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["group.interItemSpacing = .flexible(200.0)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[group setInterItemSpacing: [NSCollectionLayoutSpacing flexibleSpacing:200.0]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSpacing;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSpacing {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSpacing {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSpacing {}
);

impl NSCollectionLayoutSpacing {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(flexibleSpacing:))]
        #[unsafe(method_family = none)]
        pub fn flexibleSpacing(flexible_spacing: CGFloat, mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(fixedSpacing:))]
        #[unsafe(method_family = none)]
        pub fn fixedSpacing(fixed_spacing: CGFloat, mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(spacing))]
        #[unsafe(method_family = none)]
        pub fn spacing(&self) -> CGFloat;

        #[unsafe(method(isFlexibleSpacing))]
        #[unsafe(method_family = none)]
        pub fn isFlexibleSpacing(&self) -> bool;

        #[unsafe(method(isFixedSpacing))]
        #[unsafe(method_family = none)]
        pub fn isFixedSpacing(&self) -> bool;
    );
}

extern_class!(
    /// An object that defines the space around the edges of items in a collection view.
    ///
    /// ## Overview
    ///
    /// You use edge spacing to create additional spacing around the edges of an item to adjust the position of the item in relation to its container and other items.
    ///
    /// The leading and trailing spaces within edge spacing differ in left-to-right versus right-to-left environments. In a left-to-right environment, the leading space is on the left, and the trailing space is on the right. In a right-to-left environment, the leading space is on the right, and the trailing space is on the left. This difference ensures that your collection view layout is built with support for right-to-left languages.
    ///
    /// The following diagram shows the difference between adding 2 points of trailing edge spacing in a left-to-right versus a right-to-left environment.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/0eb1dca0c8e3363af7104445aa047c88/media-3570381~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/a315a0a064f715f044a87ad23b139457/media-3570381%402x.png 2x" />
    ///     <img alt="Two diagrams that compare edge spacing in a left-to-right and a right-to-left environment. Both diagrams show a group of three square items in a row. The first diagram, labeled trailing in left-to-right environment, shows trailing space on the right of each item, implying that leading space is on the left. The second diagram, labeled trailing in right-to-left environment, shows trailing space on the left of each item, implying that leading space is on the right." src="https://docs-assets.developer.apple.com/published/a315a0a064f715f044a87ad23b139457/media-3570381%402x.png" />
    /// </picture>
    ///
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutEdgeSpacing;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutEdgeSpacing {}
);

unsafe impl CopyingHelper for NSCollectionLayoutEdgeSpacing {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutEdgeSpacing {}
);

impl NSCollectionLayoutEdgeSpacing {
    extern_methods!(
        #[unsafe(method(spacingForLeading:top:trailing:bottom:))]
        #[unsafe(method_family = none)]
        pub fn spacingForLeading_top_trailing_bottom(
            leading: Option<&NSCollectionLayoutSpacing>,
            top: Option<&NSCollectionLayoutSpacing>,
            trailing: Option<&NSCollectionLayoutSpacing>,
            bottom: Option<&NSCollectionLayoutSpacing>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(leading))]
        #[unsafe(method_family = none)]
        pub fn leading(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        #[unsafe(method(top))]
        #[unsafe(method_family = none)]
        pub fn top(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        #[unsafe(method(trailing))]
        #[unsafe(method_family = none)]
        pub fn trailing(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        #[unsafe(method(bottom))]
        #[unsafe(method_family = none)]
        pub fn bottom(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;
    );
}

extern_class!(
    /// An object used to add an extra visual decoration to an item in a collection view.
    ///
    /// ## Overview
    ///
    /// You use supplementary items to attach additional views to your content. For example, you might attach a badge to an item or a frame around a group. A supplementary item follows the index path of the item it’s attached to.
    ///
    /// If you want to create a header or footer for your layout or its sections, use a boundary supplementary item ([`NSCollectionLayoutBoundarySupplementaryItem`](https://developer.apple.com/documentation/uikit/nscollectionlayoutboundarysupplementaryitem)) instead.
    ///
    /// Each type of supplementary item must have a unique element kind. Consider tracking these strings together in a way that makes it straightforward to identify each element, for example:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["struct ElementKind {", "    static let badge = \"badge-element-kind\"", "    static let background = \"background-element-kind\"", "    static let sectionHeader = \"section-header-element-kind\"", "    static let sectionFooter = \"section-footer-element-kind\"", "    static let layoutHeader = \"layout-header-element-kind\"", "    static let layoutFooter = \"layout-footer-element-kind\"", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSString* const ELEMENT_KIND_BADGE = @\"badge-element-kind\";", "NSString* const ELEMENT_KIND_BACKGROUND = @\"background-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_HEADER = @\"section-header-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_FOOTER = @\"section-footer-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_HEADER = @\"layout-header-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_FOOTER = @\"layout-footer-element-kind\";"], metadata: None }] }] })
    /// Add supplementary items to an item by passing in an array of supplementary items when you construct the item:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let itemSize = NSCollectionLayoutSize(widthDimension: .absolute(44),", "                                     heightDimension: .absolute(44))", "    ", "let badgeAnchor = NSCollectionLayoutAnchor(edges: [.top, .trailing],", "                                fractionalOffset: CGPoint(x: 0.3, y: -0.3))", "   ", "let badgeSize = NSCollectionLayoutSize(widthDimension: .absolute(20),", "                                      heightDimension: .absolute(20))", "    ", "let badge = NSCollectionLayoutSupplementaryItem(layoutSize: badgeSize,", "                                               elementKind: ElementKind.badge,", "                                           containerAnchor: badgeAnchor)", "    ", "let item = NSCollectionLayoutItem(layoutSize: itemSize,", "                          supplementaryItems: [badge])"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:44.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "NSCollectionLayoutAnchor *badgeAnchor = [NSCollectionLayoutAnchor layoutAnchorWithEdges: NSDirectionalRectEdgeTop|NSDirectionalRectEdgeTrailing fractionalOffset:CGPointMake(0.3, -0.3)];", "", "NSCollectionLayoutSize *badgeSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:20.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:20.0]];", "", "NSCollectionLayoutSupplementaryItem *badge = [NSCollectionLayoutSupplementaryItem supplementaryItemWithLayoutSize:badgeSize elementKind:ELEMENT_KIND_BADGE containerAnchor:badgeAnchor];", "", "NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize supplementaryItems:@[badge]];", ""], metadata: None }] }] })
    ///
    #[unsafe(super(NSCollectionLayoutItem, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSupplementaryItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSupplementaryItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSupplementaryItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSupplementaryItem {}
);

impl NSCollectionLayoutSupplementaryItem {
    extern_methods!(
        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;

        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:itemAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor_itemAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
            item_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        pub fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(elementKind))]
        #[unsafe(method_family = none)]
        pub fn elementKind(&self) -> Retained<NSString>;

        #[unsafe(method(containerAnchor))]
        #[unsafe(method_family = none)]
        pub fn containerAnchor(&self) -> Retained<NSCollectionLayoutAnchor>;

        #[unsafe(method(itemAnchor))]
        #[unsafe(method_family = none)]
        pub fn itemAnchor(&self) -> Option<Retained<NSCollectionLayoutAnchor>>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutSupplementaryItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An object used to add headers or footers to a collection view.
    ///
    /// ## Overview
    ///
    /// A boundary supplementary item is a specialized type of supplementary item ([`NSCollectionLayoutSupplementaryItem`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsupplementaryitem)). You use boundary supplementary items to add headers or footers to a section of a collection view or the entire collection view.
    ///
    /// Each type of supplementary item must have a unique element kind. Consider tracking these strings together in a way that makes it straightforward to identify each element, for example:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["struct ElementKind {", "    static let badge = \"badge-element-kind\"", "    static let background = \"background-element-kind\"", "    static let sectionHeader = \"section-header-element-kind\"", "    static let sectionFooter = \"section-footer-element-kind\"", "    static let layoutHeader = \"layout-header-element-kind\"", "    static let layoutFooter = \"layout-footer-element-kind\"", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSString* const ELEMENT_KIND_BADGE = @\"badge-element-kind\";", "NSString* const ELEMENT_KIND_BACKGROUND = @\"background-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_HEADER = @\"section-header-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_FOOTER = @\"section-footer-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_HEADER = @\"layout-header-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_FOOTER = @\"layout-footer-element-kind\";"], metadata: None }] }] })
    /// Add boundary supplementary items to a section by setting that section’s [`boundarySupplementaryItems`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsection/boundarysupplementaryitems) property:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let section = NSCollectionLayoutSection(group: group)", "", "let headerFooterSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                             heightDimension: .estimated(44))", "    ", "let sectionHeader = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,", "                                                               elementKind: ElementKind.sectionHeader,", "                                                                 alignment: .top)", "let sectionFooter = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,", "                                                               elementKind: ElementKind.sectionFooter,", "                                                                 alignment: .bottom)", "    ", "section.boundarySupplementaryItems = [sectionHeader, sectionFooter]"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "", "NSCollectionLayoutSize *headerFooterSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "NSCollectionLayoutBoundarySupplementaryItem *sectionHeader = [NSCollectionLayoutBoundarySupplementaryItem boundarySupplementaryItemWithLayoutSize: headerFooterSize elementKind: ELEMENT_KIND_SECTION_HEADER alignment: NSRectAlignmentTop];", "", "NSCollectionLayoutBoundarySupplementaryItem *sectionFooter = [NSCollectionLayoutBoundarySupplementaryItem boundarySupplementaryItemWithLayoutSize: headerFooterSize elementKind: ELEMENT_KIND_SECTION_FOOTER alignment: NSRectAlignmentBottom];", "", "[section setBoundarySupplementaryItems: @[sectionHeader, sectionFooter]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSCollectionLayoutSupplementaryItem, NSCollectionLayoutItem, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutBoundarySupplementaryItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutBoundarySupplementaryItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutBoundarySupplementaryItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutBoundarySupplementaryItem {}
);

impl NSCollectionLayoutBoundarySupplementaryItem {
    extern_methods!(
        #[cfg(feature = "UIGeometry")]
        #[unsafe(method(boundarySupplementaryItemWithLayoutSize:elementKind:alignment:))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItemWithLayoutSize_elementKind_alignment(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            alignment: NSRectAlignment,
        ) -> Retained<Self>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(boundarySupplementaryItemWithLayoutSize:elementKind:alignment:absoluteOffset:))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItemWithLayoutSize_elementKind_alignment_absoluteOffset(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            alignment: NSRectAlignment,
            absolute_offset: CGPoint,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(extendsBoundary))]
        #[unsafe(method_family = none)]
        pub fn extendsBoundary(&self) -> bool;

        /// Setter for [`extendsBoundary`][Self::extendsBoundary].
        #[unsafe(method(setExtendsBoundary:))]
        #[unsafe(method_family = none)]
        pub fn setExtendsBoundary(&self, extends_boundary: bool);

        #[unsafe(method(pinToVisibleBounds))]
        #[unsafe(method_family = none)]
        pub fn pinToVisibleBounds(&self) -> bool;

        /// Setter for [`pinToVisibleBounds`][Self::pinToVisibleBounds].
        #[unsafe(method(setPinToVisibleBounds:))]
        #[unsafe(method_family = none)]
        pub fn setPinToVisibleBounds(&self, pin_to_visible_bounds: bool);

        #[cfg(feature = "UIGeometry")]
        #[unsafe(method(alignment))]
        #[unsafe(method_family = none)]
        pub fn alignment(&self) -> NSRectAlignment;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub fn offset(&self) -> CGPoint;
    );
}

/// Methods declared on superclass `NSCollectionLayoutSupplementaryItem`.
impl NSCollectionLayoutBoundarySupplementaryItem {
    extern_methods!(
        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;

        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:itemAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor_itemAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
            item_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutBoundarySupplementaryItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An object used to add a background to a section of a collection view.
    ///
    /// ## Overview
    ///
    /// Each type of decoration item must have a unique element kind. Consider tracking these strings together in a way that makes it straightforward to identify each element, for example:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["struct ElementKind {", "    static let badge = \"badge-element-kind\"", "    static let background = \"background-element-kind\"", "    static let sectionHeader = \"section-header-element-kind\"", "    static let sectionFooter = \"section-footer-element-kind\"", "    static let layoutHeader = \"layout-header-element-kind\"", "    static let layoutFooter = \"layout-footer-element-kind\"", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSString* const ELEMENT_KIND_BADGE = @\"badge-elemn’s-kind\";", "NSString* const ELEMENT_KIND_BACKGROUND = @\"background-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_HEADER = @\"section-header-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_FOOTER = @\"section-footer-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_HEADER = @\"layout-header-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_FOOTER = @\"layout-footer-element-kind\";"], metadata: None }] }] })
    /// Add a background to a section by setting that section’s [`decorationItems`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsection/decorationitems) property:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let sectionBackground = NSCollectionLayoutDecorationItem.background(", "        elementKind: ElementKind.background)", "", "section.decorationItems = [sectionBackground]", "", "let layout = UICollectionViewCompositionalLayout(section: section)", "layout.register(", "    SectionBackgroundDecorationView.self,", "    forDecorationViewOfKind: ElementKind.background)", "return layout"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutDecorationItem *sectionBackground = [NSCollectionLayoutDecorationItem backgroundDecorationItemWithElementKind: ELEMENT_KIND_BACKGROUND];", "", "[section setDecorationItems: @[sectionBackground]];", "", "UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSection: section];", "[layout registerClass: [SectionBackgroundDecorationView class] forDecorationViewOfKind: ELEMENT_KIND_BACKGROUND];", "return layout;"], metadata: None }] }] })
    ///
    #[unsafe(super(NSCollectionLayoutItem, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutDecorationItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutDecorationItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutDecorationItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutDecorationItem {}
);

impl NSCollectionLayoutDecorationItem {
    extern_methods!(
        #[unsafe(method(backgroundDecorationItemWithElementKind:))]
        #[unsafe(method_family = none)]
        pub fn backgroundDecorationItemWithElementKind(
            element_kind: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        pub fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(elementKind))]
        #[unsafe(method_family = none)]
        pub fn elementKind(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutDecorationItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that defines how to attach a supplementary item to an item in a collection view.
    ///
    /// ## Overview
    ///
    /// You use an anchor to attach a supplementary item to a specific item. An anchor contains information about where on the item your supplementary item is attached, including:
    ///
    /// - An edge or set of edges. You can attach a supplementary item to a single edge, or to a corner by specifying two adjacent edges.
    ///
    /// - An offset from the item. By default, the supplementary item is anchored within the specified edges of the item it’s attached to. You can change this location by providing a custom offset when you create an anchor.
    ///
    /// ### Edges
    ///
    /// The leading and trailing edges for anchors differ in left-to-right versus right-to-left environments. In a left-to-right environment, the leading edge is on the left, and the trailing edge is on the right. In a right-to-left environment, the leading edge is on the right, and the trailing edge is on the left. This difference ensures that your collection view layout is built with support for right-to-left languages.
    ///
    /// The following diagram shows anchor placement for the specified edges in a left-to-right environment.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/90a0677fdd2f803d9388e6a44dca75c3/media-3570665~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/b7e68b458cab77379003c0ce5e2ef3e9/media-3570665%402x.png 2x" />
    ///     <img alt="Diagram showing anchor positions. Top, bottom, leading, and trailing anchors are on the halfway point on their respective edges. The anchors defined by the edge combinations top and leading, top and trailing, bottom and leading, and bottom and trailing are in the corners between each of those sets of edges." src="https://docs-assets.developer.apple.com/published/b7e68b458cab77379003c0ce5e2ef3e9/media-3570665%402x.png" />
    /// </picture>
    ///
    ///
    /// ### Offset
    ///
    /// You can express anchor offset in these ways:
    ///
    /// - Absolute value. The offset is calculated as a point value. For example, an absolute x offset of `30.0` means that the origin of the supplementary item is offset by 30 points in the positive x direction.
    ///
    /// - Fractional value. The offset is calculated as a fraction of the supplementary item’s dimensions. For example, a fractional x offset of `0.3` means that the origin of the supplementary item is offset by 30% of the supplementary item’s width in the positive x direction.
    ///
    /// The following code creates a basic badge and attaches it to an item’s top trailing corner.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let itemSize = NSCollectionLayoutSize(widthDimension: .absolute(44),", "                                     heightDimension: .absolute(44))", "    ", "let badgeAnchor = NSCollectionLayoutAnchor(edges: [.top, .trailing],", "                                fractionalOffset: CGPoint(x: 0.3, y: -0.3))", "    ", "let badgeSize = NSCollectionLayoutSize(widthDimension: .absolute(20),", "                                      heightDimension: .absolute(20))", "    ", "let badge = NSCollectionLayoutSupplementaryItem(layoutSize: badgeSize,", "                                               elementKind: \"badge\",", "                                           containerAnchor: badgeAnchor)", "    ", "let item = NSCollectionLayoutItem(layoutSize: itemSize,", "                          supplementaryItems: [badge])", ""], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:44.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "NSCollectionLayoutAnchor *badgeAnchor = [NSCollectionLayoutAnchor layoutAnchorWithEdges: NSDirectionalRectEdgeTop|NSDirectionalRectEdgeTrailing fractionalOffset:CGPointMake(0.3, -0.3)];", "", "NSCollectionLayoutSize *badgeSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:20.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:20.0]];", "", "NSCollectionLayoutSupplementaryItem *badge = [NSCollectionLayoutSupplementaryItem supplementaryItemWithLayoutSize:badgeSize elementKind:ELEMENT_KIND_BADGE containerAnchor:badgeAnchor];", "", "NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize supplementaryItems:@[badge]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutAnchor;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutAnchor {}
);

unsafe impl CopyingHelper for NSCollectionLayoutAnchor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutAnchor {}
);

impl NSCollectionLayoutAnchor {
    extern_methods!(
        #[cfg(feature = "UIGeometry")]
        #[unsafe(method(layoutAnchorWithEdges:))]
        #[unsafe(method_family = none)]
        pub fn layoutAnchorWithEdges(
            edges: NSDirectionalRectEdge,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(layoutAnchorWithEdges:absoluteOffset:))]
        #[unsafe(method_family = none)]
        pub fn layoutAnchorWithEdges_absoluteOffset(
            edges: NSDirectionalRectEdge,
            absolute_offset: CGPoint,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(layoutAnchorWithEdges:fractionalOffset:))]
        #[unsafe(method_family = none)]
        pub fn layoutAnchorWithEdges_fractionalOffset(
            edges: NSDirectionalRectEdge,
            fractional_offset: CGPoint,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "UIGeometry")]
        #[unsafe(method(edges))]
        #[unsafe(method_family = none)]
        pub fn edges(&self) -> NSDirectionalRectEdge;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub fn offset(&self) -> CGPoint;

        #[unsafe(method(isAbsoluteOffset))]
        #[unsafe(method_family = none)]
        pub fn isAbsoluteOffset(&self) -> bool;

        #[unsafe(method(isFractionalOffset))]
        #[unsafe(method_family = none)]
        pub fn isFractionalOffset(&self) -> bool;
    );
}

extern_protocol!(
    /// A protocol used to provide information about the size and content insets of a layout’s container.
    ///
    /// ## Overview
    ///
    /// In a section provider, you use the [`container`](https://developer.apple.com/documentation/uikit/nscollectionlayoutenvironment/container) property of the layout environment ([`NSCollectionLayoutEnvironment`](https://developer.apple.com/documentation/uikit/nscollectionlayoutenvironment)) to get information about the container of the layout, such as its size and content insets. Knowing about the container’s size while rendering the layout’s sections helps you make decisions about how to display the layout.
    ///
    ///
    pub unsafe trait NSCollectionLayoutContainer: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentSize))]
        #[unsafe(method_family = none)]
        fn contentSize(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(effectiveContentSize))]
        #[unsafe(method_family = none)]
        fn effectiveContentSize(&self) -> CGSize;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(contentInsets))]
        #[unsafe(method_family = none)]
        fn contentInsets(&self) -> NSDirectionalEdgeInsets;

        #[cfg(all(feature = "UIGeometry", feature = "objc2-core-foundation"))]
        #[unsafe(method(effectiveContentInsets))]
        #[unsafe(method_family = none)]
        fn effectiveContentInsets(&self) -> NSDirectionalEdgeInsets;
    }
);

extern_protocol!(
    /// A protocol used to provide information about the layout’s container and environment traits, such as size classes and display scale factor.
    ///
    /// ## Overview
    ///
    /// In a section provider, you use the layout environment to get information about the context that the layout appears in. You can get information about the layout’s container, such as its size and content insets, and the traits of its environment, such as size classes, display scale factor, and user interface idiom. You use this information while rendering the layout’s sections to help you make decisions about how to display the layout.
    ///
    /// For example, the following code uses the layout environment’s trait collection to check whether the UI is in Dark Mode while creating the layout’s sections.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let layout = UICollectionViewCompositionalLayout { (sectionIndex: Int,", "    layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection in", "        ", "    if layoutEnvironment.traitCollection.userInterfaceStyle == .dark {", "        return sectionForUserInterfaceStyle(.dark)", "    } else {", "        return sectionForUserInterfaceStyle(.light)", "    }", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSectionProvider:^NSCollectionLayoutSection *(NSInteger section, id<NSCollectionLayoutEnvironment> layoutEnvironment) {", "    if (layoutEnvironment.traitCollection.userInterfaceStyle == UIUserInterfaceStyleDark) {", "        return [self sectionForUserInterfaceStyle: UIUserInterfaceStyleDark];", "    } else {", "        return [self sectionForUserInterfaceStyle: UIUserInterfaceStyleLight];", "    }", "}];"], metadata: None }] }] })
    ///
    pub unsafe trait NSCollectionLayoutEnvironment:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(container))]
        #[unsafe(method_family = none)]
        fn container(&self) -> Retained<ProtocolObject<dyn NSCollectionLayoutContainer>>;

        #[cfg(feature = "UITraitCollection")]
        #[unsafe(method(traitCollection))]
        #[unsafe(method_family = none)]
        fn traitCollection(&self) -> Retained<UITraitCollection>;
    }
);

extern_protocol!(
    /// An item that’s currently visible within the bounds of a section.
    ///
    /// ## Overview
    ///
    /// A visible item represents an item in a collection view that’s currently visible onscreen, such as a cell, supplementary view, or decoration. You access a specific section’s visible items in its visible item invalidation handler ([`NSCollectionLayoutSectionVisibleItemsInvalidationHandler`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsectionvisibleitemsinvalidationhandler)), stored in the [`visibleItemsInvalidationHandler`](https://developer.apple.com/documentation/uikit/nscollectionlayoutsection/visibleitemsinvalidationhandler) property. The handler is called before each layout cycle, any time an animation occurs in that section due to changes such as adding or removing items, scrolling the section, or rotating the device.
    ///
    ///
    #[cfg(feature = "UIDynamicBehavior")]
    pub unsafe trait NSCollectionLayoutVisibleItem:
        NSObjectProtocol + UIDynamicItem + MainThreadOnly
    {
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(alpha))]
        #[unsafe(method_family = none)]
        fn alpha(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`alpha`][Self::alpha].
        #[unsafe(method(setAlpha:))]
        #[unsafe(method_family = none)]
        fn setAlpha(&self, alpha: CGFloat);

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        fn setHidden(&self, hidden: bool);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(center))]
        #[unsafe(method_family = none)]
        fn center(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`center`][Self::center].
        #[unsafe(method(setCenter:))]
        #[unsafe(method_family = none)]
        fn setCenter(&self, center: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(transform))]
        #[unsafe(method_family = none)]
        fn transform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`transform`][Self::transform].
        #[unsafe(method(setTransform:))]
        #[unsafe(method_family = none)]
        fn setTransform(&self, transform: CGAffineTransform);

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(transform3D))]
        #[unsafe(method_family = none)]
        fn transform3D(&self) -> CATransform3D;

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`transform3D`][Self::transform3D].
        #[unsafe(method(setTransform3D:))]
        #[unsafe(method_family = none)]
        fn setTransform3D(&self, transform3_d: CATransform3D);

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        fn name(&self) -> Retained<NSString>;

        #[unsafe(method(indexPath))]
        #[unsafe(method_family = none)]
        fn indexPath(&self) -> Retained<NSIndexPath>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        fn frame(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(bounds))]
        #[unsafe(method_family = none)]
        fn bounds(&self) -> CGRect;

        #[cfg(feature = "UICollectionViewLayout")]
        #[unsafe(method(representedElementCategory))]
        #[unsafe(method_family = none)]
        fn representedElementCategory(&self) -> UICollectionElementCategory;

        #[unsafe(method(representedElementKind))]
        #[unsafe(method_family = none)]
        fn representedElementKind(&self) -> Option<Retained<NSString>>;
    }
);

/// Deprecated.
impl NSCollectionLayoutSection {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(supplementariesFollowContentInsets))]
        #[unsafe(method_family = none)]
        pub fn supplementariesFollowContentInsets(&self) -> bool;

        /// Setter for [`supplementariesFollowContentInsets`][Self::supplementariesFollowContentInsets].
        #[deprecated]
        #[unsafe(method(setSupplementariesFollowContentInsets:))]
        #[unsafe(method_family = none)]
        pub fn setSupplementariesFollowContentInsets(
            &self,
            supplementaries_follow_content_insets: bool,
        );
    );
}

/// Deprecated.
impl NSCollectionLayoutGroup {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(horizontalGroupWithLayoutSize:subitem:count:))]
        #[unsafe(method_family = none)]
        pub fn horizontalGroupWithLayoutSize_subitem_count(
            layout_size: &NSCollectionLayoutSize,
            subitem: &NSCollectionLayoutItem,
            count: NSInteger,
        ) -> Retained<Self>;

        #[deprecated]
        #[unsafe(method(verticalGroupWithLayoutSize:subitem:count:))]
        #[unsafe(method_family = none)]
        pub fn verticalGroupWithLayoutSize_subitem_count(
            layout_size: &NSCollectionLayoutSize,
            subitem: &NSCollectionLayoutItem,
            count: NSInteger,
        ) -> Retained<Self>;
    );
}
