//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants that indicate the types of changes.
///
/// ## Overview
///
/// These values are also OR’ed together in notifications to inform instances of `NSLayoutManager` was changed—see [`textStorage:edited:range:changeInLength:invalidatedRange:`](https://developer.apple.com/documentation/appkit/nslayoutmanager/textstorage(_:edited:range:changeinlength:invalidatedrange:)).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSTextStorageEditActions(pub NSUInteger);
bitflags::bitflags! {
    impl NSTextStorageEditActions: NSUInteger {
/// Attributes were added, removed, or changed.
        #[doc(alias = "NSTextStorageEditedAttributes")]
        const EditedAttributes = 1<<0;
/// Characters were added, removed, or replaced.
        #[doc(alias = "NSTextStorageEditedCharacters")]
        const EditedCharacters = 1<<1;
    }
}

unsafe impl Encode for NSTextStorageEditActions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSTextStorageEditActions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The fundamental storage mechanism of TextKit that contains the text managed by the system.
    ///
    /// ## Overview
    ///
    /// [`NSTextStorage`](https://developer.apple.com/documentation/uikit/nstextstorage) is a semi-concrete subclass of [`NSMutableAttributedString`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring) that adds behavior for managing a set of client [`NSLayoutManager`](https://developer.apple.com/documentation/uikit/nslayoutmanager) objects. A text storage object notifies its layout managers of changes to its characters or attributes, which lets the layout managers redisplay the text as needed.
    ///
    /// You can access a text storage object from any thread of your app, but your app must guarantee access from only one thread at a time.
    ///
    /// In macOS, this class also defines properties for getting and setting scriptable attributes of [`NSTextStorage`](https://developer.apple.com/documentation/uikit/nstextstorage) objects. Unless you’re dealing with scriptability, you shouldn’t access these properties directly. In particular, using the [`characters`](https://developer.apple.com/documentation/appkit/nstextstorage/characters), [`words`](https://developer.apple.com/documentation/appkit/nstextstorage/words), or [`paragraphs`](https://developer.apple.com/documentation/appkit/nstextstorage/paragraphs) properties is an inefficient way to manipulate the text storage, since accessing these properties involves the creation of many objects. Instead, use the text access methods defined by [`NSMutableAttributedString`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring), [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring), [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring), and [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) to perform character-level manipulation.
    ///
    /// ### Subclassing Notes
    ///
    /// The [`NSTextStorage`](https://developer.apple.com/documentation/uikit/nstextstorage) class implements change management through the [`beginEditing`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring/beginediting()) and [`endEditing`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring/endediting()) methods, as well as verification of attributes, delegate handling, and layout management notification. The one aspect it doesn’t implement is managing the actual attributed string storage, which subclasses manage by overriding the two [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) primitives:
    ///
    /// - [`string`](https://developer.apple.com/documentation/foundation/nsattributedstring/string)
    ///
    /// - [`attributesAtIndex:effectiveRange:`](https://developer.apple.com/documentation/foundation/nsattributedstring/attributes(at:effectiverange:))
    ///
    /// Subclasses must also override two [`NSMutableAttributedString`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring) primitives:
    ///
    /// - [`replaceCharactersInRange:withString:`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring/replacecharacters(in:with:)-6oq9r)
    ///
    /// - [`setAttributes:range:`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring/setattributes(_:range:))
    ///
    /// These primitives should perform the change, then call [`edited:range:changeInLength:`](https://developer.apple.com/documentation/uikit/nstextstorage/edited(_:range:changeinlength:)) to let the parent class know there are changes.
    ///
    ///
    #[unsafe(super(NSMutableAttributedString, NSAttributedString, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSTextStorage;
);

extern_conformance!(
    unsafe impl NSCoding for NSTextStorage {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSTextStorage {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NSTextStorage {}
);

impl NSTextStorage {
    extern_methods!(
        #[cfg(feature = "NSLayoutManager")]
        /// ************************** Layout manager ***************************
        #[unsafe(method(layoutManagers))]
        #[unsafe(method_family = none)]
        pub fn layoutManagers(&self) -> Retained<NSArray<NSLayoutManager>>;

        #[cfg(feature = "NSLayoutManager")]
        #[unsafe(method(addLayoutManager:))]
        #[unsafe(method_family = none)]
        pub fn addLayoutManager(&self, a_layout_manager: &NSLayoutManager);

        #[cfg(feature = "NSLayoutManager")]
        #[unsafe(method(removeLayoutManager:))]
        #[unsafe(method_family = none)]
        pub fn removeLayoutManager(&self, a_layout_manager: &NSLayoutManager);

        /// ************************** Pending edit info ***************************
        #[unsafe(method(editedMask))]
        #[unsafe(method_family = none)]
        pub fn editedMask(&self) -> NSTextStorageEditActions;

        #[unsafe(method(editedRange))]
        #[unsafe(method_family = none)]
        pub fn editedRange(&self) -> NSRange;

        #[unsafe(method(changeInLength))]
        #[unsafe(method_family = none)]
        pub fn changeInLength(&self) -> NSInteger;

        /// ************************** Delegate ***************************
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSTextStorageDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSTextStorageDelegate>>);

        /// ************************** Edit management ***************************
        #[unsafe(method(edited:range:changeInLength:))]
        #[unsafe(method_family = none)]
        pub fn edited_range_changeInLength(
            &self,
            edited_mask: NSTextStorageEditActions,
            edited_range: NSRange,
            delta: NSInteger,
        );

        #[unsafe(method(processEditing))]
        #[unsafe(method_family = none)]
        pub fn processEditing(&self);

        /// ************************** Attribute fixing ***************************
        #[unsafe(method(fixesAttributesLazily))]
        #[unsafe(method_family = none)]
        pub fn fixesAttributesLazily(&self) -> bool;

        #[unsafe(method(invalidateAttributesInRange:))]
        #[unsafe(method_family = none)]
        pub fn invalidateAttributesInRange(&self, range: NSRange);

        #[unsafe(method(ensureAttributesAreFixedInRange:))]
        #[unsafe(method_family = none)]
        pub fn ensureAttributesAreFixedInRange(&self, range: NSRange);

        /// ************************** NSTextStorageObserving ***************************
        #[unsafe(method(textStorageObserver))]
        #[unsafe(method_family = none)]
        pub fn textStorageObserver(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSTextStorageObserving>>>;

        /// Setter for [`textStorageObserver`][Self::textStorageObserver].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setTextStorageObserver:))]
        #[unsafe(method_family = none)]
        pub fn setTextStorageObserver(
            &self,
            text_storage_observer: Option<&ProtocolObject<dyn NSTextStorageObserving>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSTextStorage {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSTextStorage {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// The optional methods that delegates of text storage objects implement to handle text-edit processing.
    /// **  NSTextStorage delegate methods ***
    pub unsafe trait NSTextStorageDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(textStorage:willProcessEditing:range:changeInLength:))]
        #[unsafe(method_family = none)]
        fn textStorage_willProcessEditing_range_changeInLength(
            &self,
            text_storage: &NSTextStorage,
            edited_mask: NSTextStorageEditActions,
            edited_range: NSRange,
            delta: NSInteger,
        );

        #[optional]
        #[unsafe(method(textStorage:didProcessEditing:range:changeInLength:))]
        #[unsafe(method_family = none)]
        fn textStorage_didProcessEditing_range_changeInLength(
            &self,
            text_storage: &NSTextStorage,
            edited_mask: NSTextStorageEditActions,
            edited_range: NSRange,
            delta: NSInteger,
        );
    }
);

extern "C" {
    /// A notification that posts before a text storage begins processing edits.
    ///
    /// ## Discussion
    ///
    /// The framework posts this notification before a text storage begins processing edits in [`processEditing`](https://developer.apple.com/documentation/uikit/nstextstorage/processediting()). Observers other than the delegate shouldn’t make further changes to the text storage. The notification object is the text storage object that’s about to process the edits. This notification doesn’t contain a `userInfo` dictionary.
    ///
    ///
    /// ** Notifications ***
    pub static NSTextStorageWillProcessEditingNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts after a text storage finishes processing edits.
    ///
    /// ## Discussion
    ///
    /// The framework posts this notification after a text storage finishes processing edits in [`processEditing`](https://developer.apple.com/documentation/uikit/nstextstorage/processediting()). Observers other than the delegate shouldn’t make further changes to the text storage. The notification object is the text storage object that processed the edits. This notification doesn’t contain a `userInfo` dictionary.
    ///
    ///
    pub static NSTextStorageDidProcessEditingNotification: &'static NSNotificationName;
}

extern_protocol!(
    /// Optional methods that delegates implement to handle editing and transaction processing.
    pub unsafe trait NSTextStorageObserving: NSObjectProtocol {
        #[unsafe(method(textStorage))]
        #[unsafe(method_family = none)]
        fn textStorage(&self) -> Option<Retained<NSTextStorage>>;

        /// Setter for [`textStorage`][Self::textStorage].
        #[unsafe(method(setTextStorage:))]
        #[unsafe(method_family = none)]
        fn setTextStorage(&self, text_storage: Option<&NSTextStorage>);

        #[unsafe(method(processEditingForTextStorage:edited:range:changeInLength:invalidatedRange:))]
        #[unsafe(method_family = none)]
        fn processEditingForTextStorage_edited_range_changeInLength_invalidatedRange(
            &self,
            text_storage: &NSTextStorage,
            edit_mask: NSTextStorageEditActions,
            new_char_range: NSRange,
            delta: NSInteger,
            invalidated_char_range: NSRange,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(performEditingTransactionForTextStorage:usingBlock:))]
        #[unsafe(method_family = none)]
        fn performEditingTransactionForTextStorage_usingBlock(
            &self,
            text_storage: &NSTextStorage,
            transaction: &block2::DynBlock<dyn Fn() + '_>,
        );
    }
);
