//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

/// Values that describe options for enumerating text layout fragments.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSTextLayoutFragmentEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSTextLayoutFragmentEnumerationOptions: NSUInteger {
/// The value that represents no selected enumeration options.
        #[doc(alias = "NSTextLayoutFragmentEnumerationOptionsNone")]
        const None = 0;
/// Causes the enumeration to start from the last element.
        #[doc(alias = "NSTextLayoutFragmentEnumerationOptionsReverse")]
        const Reverse = 1<<0;
/// When enumerating, tell the layout fragments to estimate their size.
        #[doc(alias = "NSTextLayoutFragmentEnumerationOptionsEstimatesSize")]
        const EstimatesSize = 1<<1;
/// When enumerating, tell the layout fragments to layout their contents.
        #[doc(alias = "NSTextLayoutFragmentEnumerationOptionsEnsuresLayout")]
        const EnsuresLayout = 1<<2;
/// Synthesize the extra line fragment when necessary.
        #[doc(alias = "NSTextLayoutFragmentEnumerationOptionsEnsuresExtraLineFragment")]
        const EnsuresExtraLineFragment = 1<<3;
    }
}

unsafe impl Encode for NSTextLayoutFragmentEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSTextLayoutFragmentEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Values that describe the possible layout states.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSTextLayoutFragmentState(pub NSUInteger);
impl NSTextLayoutFragmentState {
    /// No layout information is available.
    #[doc(alias = "NSTextLayoutFragmentStateNone")]
    pub const None: Self = Self(0);
    /// The text layout manager hasnâ€™t performed a full layout yet for the region covered by this layout fragment and is returning an estimated bounds.
    #[doc(alias = "NSTextLayoutFragmentStateEstimatedUsageBounds")]
    pub const EstimatedUsageBounds: Self = Self(1);
    /// The layout fragment measurements are available without text line fragments.
    #[doc(alias = "NSTextLayoutFragmentStateCalculatedUsageBounds")]
    pub const CalculatedUsageBounds: Self = Self(2);
    /// Measurements for the text line fragments and layout fragment are available.
    #[doc(alias = "NSTextLayoutFragmentStateLayoutAvailable")]
    pub const LayoutAvailable: Self = Self(3);
}

unsafe impl Encode for NSTextLayoutFragmentState {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSTextLayoutFragmentState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A class that represents the layout fragment typically corresponding to a rendering surface, such as a layer or view subclass.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSTextLayoutFragment;
);

extern_conformance!(
    unsafe impl NSCoding for NSTextLayoutFragment {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSTextLayoutFragment {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NSTextLayoutFragment {}
);

impl NSTextLayoutFragment {
    extern_methods!(
        #[cfg(all(feature = "NSTextElement", feature = "NSTextRange"))]
        #[unsafe(method(initWithTextElement:range:))]
        #[unsafe(method_family = init)]
        pub fn initWithTextElement_range(
            this: Allocated<Self>,
            text_element: &NSTextElement,
            range_in_element: Option<&NSTextRange>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSTextLayoutManager")]
        #[unsafe(method(textLayoutManager))]
        #[unsafe(method_family = none)]
        pub fn textLayoutManager(&self) -> Option<Retained<NSTextLayoutManager>>;

        #[cfg(feature = "NSTextElement")]
        #[unsafe(method(textElement))]
        #[unsafe(method_family = none)]
        pub fn textElement(&self) -> Option<Retained<NSTextElement>>;

        #[cfg(feature = "NSTextRange")]
        #[unsafe(method(rangeInElement))]
        #[unsafe(method_family = none)]
        pub fn rangeInElement(&self) -> Retained<NSTextRange>;

        #[cfg(feature = "NSTextLineFragment")]
        #[unsafe(method(textLineFragments))]
        #[unsafe(method_family = none)]
        pub fn textLineFragments(&self) -> Retained<NSArray<NSTextLineFragment>>;

        #[cfg(all(feature = "NSTextLineFragment", feature = "objc2-core-foundation"))]
        #[unsafe(method(textLineFragmentForVerticalOffset:requiresExactMatch:))]
        #[unsafe(method_family = none)]
        pub fn textLineFragmentForVerticalOffset_requiresExactMatch(
            &self,
            vertical_offset: CGFloat,
            requires_exact_match: bool,
        ) -> Option<Retained<NSTextLineFragment>>;

        #[cfg(all(feature = "NSTextLineFragment", feature = "NSTextRange"))]
        #[unsafe(method(textLineFragmentForTextLocation:isUpstreamAffinity:))]
        #[unsafe(method_family = none)]
        pub fn textLineFragmentForTextLocation_isUpstreamAffinity(
            &self,
            text_location: &ProtocolObject<dyn NSTextLocation>,
            is_upstream_affinity: bool,
        ) -> Option<Retained<NSTextLineFragment>>;

        #[unsafe(method(layoutQueue))]
        #[unsafe(method_family = none)]
        pub fn layoutQueue(&self) -> Option<Retained<NSOperationQueue>>;

        /// Setter for [`layoutQueue`][Self::layoutQueue].
        ///
        /// # Safety
        ///
        /// `layout_queue` possibly has additional threading requirements.
        #[unsafe(method(setLayoutQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLayoutQueue(&self, layout_queue: Option<&NSOperationQueue>);

        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub fn state(&self) -> NSTextLayoutFragmentState;

        #[unsafe(method(invalidateLayout))]
        #[unsafe(method_family = none)]
        pub fn invalidateLayout(&self);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(layoutFragmentFrame))]
        #[unsafe(method_family = none)]
        pub fn layoutFragmentFrame(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(renderingSurfaceBounds))]
        #[unsafe(method_family = none)]
        pub fn renderingSurfaceBounds(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(leadingPadding))]
        #[unsafe(method_family = none)]
        pub fn leadingPadding(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(trailingPadding))]
        #[unsafe(method_family = none)]
        pub fn trailingPadding(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(topMargin))]
        #[unsafe(method_family = none)]
        pub fn topMargin(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(bottomMargin))]
        #[unsafe(method_family = none)]
        pub fn bottomMargin(&self) -> CGFloat;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(drawAtPoint:inContext:))]
        #[unsafe(method_family = none)]
        pub fn drawAtPoint_inContext(&self, point: CGPoint, context: &CGContext);

        #[cfg(feature = "NSTextAttachment")]
        #[unsafe(method(textAttachmentViewProviders))]
        #[unsafe(method_family = none)]
        pub fn textAttachmentViewProviders(
            &self,
        ) -> Retained<NSArray<NSTextAttachmentViewProvider>>;

        #[cfg(all(feature = "NSTextRange", feature = "objc2-core-foundation"))]
        #[unsafe(method(frameForTextAttachmentAtLocation:))]
        #[unsafe(method_family = none)]
        pub fn frameForTextAttachmentAtLocation(
            &self,
            location: &ProtocolObject<dyn NSTextLocation>,
        ) -> CGRect;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSTextLayoutFragment {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
