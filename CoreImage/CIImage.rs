//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
#[cfg(feature = "objc2-core-video")]
use objc2_core_video::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-image-io")]
use objc2_image_io::*;
#[cfg(feature = "objc2-io-surface")]
use objc2_io_surface::*;
#[cfg(feature = "objc2-metal")]
use objc2_metal::*;

use crate::*;

/// Pixel data formats for image input, output, and processing.
// NS_TYPED_ENUM
pub type CIFormat = c_int;

extern "C" {
    /// A 32-bit-per-pixel, fixed-point pixel format in which the alpha value precedes the red, green, and blue color components.
    pub static kCIFormatARGB8: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, fixed-point pixel format in which the blue, green, and red color components precede the alpha value.
    pub static kCIFormatBGRA8: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, fixed-point pixel format in which the red, green, and blue color components precede the alpha value.
    pub static kCIFormatRGBA8: CIFormat;
}

extern "C" {
    pub static kCIFormatRGBX8: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, fixed-point pixel format in which the alpha value precedes the blue, green, and red color components.
    pub static kCIFormatABGR8: CIFormat;
}

extern "C" {
    /// A 64-bit-per-pixel, floating-point pixel format.
    pub static kCIFormatRGBAh: CIFormat;
}

extern "C" {
    /// A 64-bit-per-pixel, fixed-point pixel format.
    pub static kCIFormatRGBA16: CIFormat;
}

extern "C" {
    /// A 128-bit-per-pixel, floating-point pixel format.
    pub static kCIFormatRGBAf: CIFormat;
}

extern "C" {
    pub static kCIFormatRGBX16: CIFormat;
}

extern "C" {
    pub static kCIFormatRGBXh: CIFormat;
}

extern "C" {
    pub static kCIFormatRGBXf: CIFormat;
}

extern "C" {
    pub static kCIFormatRGB10: CIFormat;
}

extern "C" {
    /// An 8-bit-per-pixel, fixed-point pixel format in which the sole component is alpha.
    pub static kCIFormatA8: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, fixed-point pixel format in which the sole component is alpha.
    pub static kCIFormatA16: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, half-width floating-point pixel format in which the sole component is alpha.
    pub static kCIFormatAh: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, full-width floating-point pixel format in which the sole component is alpha.
    pub static kCIFormatAf: CIFormat;
}

extern "C" {
    /// An 8-bit-per-pixel, fixed-point pixel format in which the sole component is a red color value.
    pub static kCIFormatR8: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, fixed-point pixel format in which the sole component is a red color value.
    pub static kCIFormatR16: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, floating-point pixel format in which the sole component is a red color value.
    pub static kCIFormatRh: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, floating-point pixel format in which the sole component is a red color value.
    pub static kCIFormatRf: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, fixed-point pixel format with only red and green color components.
    pub static kCIFormatRG8: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, fixed-point pixel format with only red and green color components.
    pub static kCIFormatRG16: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, floating-point pixel format with only red and green color components.
    pub static kCIFormatRGh: CIFormat;
}

extern "C" {
    /// A 64-bit-per-pixel, floating-point pixel format with only red and green color components.
    pub static kCIFormatRGf: CIFormat;
}

extern "C" {
    /// An 8-bit-per-pixel, fixed-point pixel format in which the sole component is luminance.
    pub static kCIFormatL8: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, fixed-point pixel format in which the sole component is luminance.
    pub static kCIFormatL16: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, half-width floating-point pixel format in which the sole component is luminance.
    pub static kCIFormatLh: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, full-width floating-point pixel format in which the sole component is luminance.
    pub static kCIFormatLf: CIFormat;
}

extern "C" {
    /// A 16-bit-per-pixel, fixed-point pixel format with only 8-bit luminance and alpha components.
    pub static kCIFormatLA8: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, fixed-point pixel format with only 16-bit luminance and alpha components.
    pub static kCIFormatLA16: CIFormat;
}

extern "C" {
    /// A 32-bit-per-pixel, half-width floating-point pixel format with 16-bit luminance and alpha components.
    pub static kCIFormatLAh: CIFormat;
}

extern "C" {
    /// A 64-bit-per-pixel, full-width floating-point pixel format with 32-bit luminance and alpha components.
    pub static kCIFormatLAf: CIFormat;
}

// NS_TYPED_ENUM
pub type CIImageOption = NSString;

extern "C" {
    /// The key for a color space.
    ///
    /// ## Discussion
    ///
    /// For more information on this data type see [`CGColorSpaceRef`](https://developer.apple.com/documentation/coregraphics/cgcolorspace). Typically you use this option when you need to load an elevation, mask, normal vector, or RAW sensor data directly from a file without color correcting it. This constant specifies to override Core Image, which, by default, assumes that data is in GenericRGB.
    ///
    /// The value you supply for this dictionary key must be a [`CGColorSpaceRef`](https://developer.apple.com/documentation/coregraphics/cgcolorspace) data type. If a value for this key isn’t supplied, the image’s [`colorSpace`](https://developer.apple.com/documentation/coreimage/ciimage/colorspace) dictionary are populated automatically by calling [`CGImageSourceCopyPropertiesAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecopypropertiesatindex(_:_:_:)). To request that Core Image perform no color management, specify the [`NSNull`](https://developer.apple.com/documentation/foundation/nsnull) object as the value for this key. Use this option for images that don’t contain color data (such as elevation maps, normal vector maps, and sampled function tables).
    ///
    ///
    pub static kCIImageColorSpace: &'static CIImageOption;
}

extern "C" {
    /// A Boolean value to control whether an image created with a CVPixelBuffer or an IOSurface should be cropped and offset according clean aperture attachments.
    ///
    /// ## Discussion
    ///
    /// For a `CVPixelBuffer` this will use `kCVImageBufferPreferredCleanApertureKey` or `kCVImageBufferCleanApertureKey`.
    ///
    /// If the value for this option is:
    ///
    /// - True: then image will be cropped and offset to the clean aperture.
    ///
    /// - False: then the full image is returned.
    ///
    /// - [`CIVector`](https://developer.apple.com/documentation/coreimage/civector) : then use it as a `CGRect` to crop and offset.
    ///
    /// - Not specified : then it will behave as if False was specified.
    ///
    ///
    /// A Boolean value to control whether an image created with a CVPixelBuffer or an IOSurface
    /// should be cropped and offset according clean aperture attachments.
    ///
    /// For a `CVPixelBuffer` this will use `kCVImageBufferPreferredCleanApertureKey`
    /// or `kCVImageBufferCleanApertureKey`.
    ///
    /// If the value for this option is:
    /// * True: then image will be cropped and offset to the clean aperture.
    /// * False: then the full image is returned.
    /// * ``CIVector`` : then use it as a `CGRect` to crop and offset.
    /// * Not specified : then it will behave as if False was specified.
    pub static kCIImageApplyCleanAperture: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageToneMapHDRtoSDR: &'static CIImageOption;
}

extern "C" {
    /// A Boolean value that indicates whether to read Gain Map HDR images as HDR.
    pub static kCIImageExpandToHDR: &'static CIImageOption;
}

extern "C" {
    /// A value for overriding the automatic behavior of the Content Headroom property
    /// when creating an image.
    ///
    /// The value for this key should be an `NSNumber` instance.
    pub static kCIImageContentHeadroom: &'static CIImageOption;
}

extern "C" {
    /// A value for overriding the automatic behavior of the Content Average Light Level property when creating an image.
    ///
    /// ## Discussion
    ///
    /// The value for this key should be an `NSNumber` instance.
    ///
    ///
    /// A value for overriding the automatic behavior of the Content Average Light Level property
    /// when creating an image.
    ///
    /// The value for this key should be an `NSNumber` instance.
    pub static kCIImageContentAverageLightLevel: &'static CIImageOption;
}

extern "C" {
    /// The key into the properties dictionary to indicate whether to use nearest-neighbor sampling.
    ///
    /// ## Discussion
    ///
    /// The value for this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean value specifying whether the image should be sampled using nearest neighbor behavior.  An unspecified value defaults to linear sampling.
    ///
    ///
    pub static kCIImageNearestSampling: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageCacheImmediately: &'static CIImageOption;
}

extern "C" {
    /// The key for image metadata properties.
    ///
    /// ## Discussion
    ///
    /// To ensure that an image has no metadata properties, set the value of this key to `[NSNull null]`.
    ///
    ///
    pub static kCIImageProperties: &'static CIImageOption;
}

extern "C" {
    /// The key for transforming an image according to orientation metadata.
    ///
    /// ## Discussion
    ///
    /// Images can contain metadata that reveals the orientation at capture time.  You can load this metadata into [`CIImage`](https://developer.apple.com/documentation/coreimage/ciimage) with [`imageWithContentsOfURL:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithcontentsofurl:) or [`initWithData:`](https://developer.apple.com/documentation/coreimage/ciimage/init(data:)) when the captured image contains orientation metadata.  Use any of the `initWith:options:` methods if the [`kCIImageProperties`](https://developer.apple.com/documentation/coreimage/ciimageoption/properties) ([`NSDictionary`](https://developer.apple.com/documentation/foundation/nsdictionary) of metadata properties) option is also provided.
    ///
    /// If the value of this key is true, then calls to [`imageWithContentsOfURL:options:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithcontentsofurl:options:) and [`imageWithData:options:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithdata:options:) will return the image transformed according to its orientation metadata.
    ///
    ///
    pub static kCIImageApplyOrientationProperty: &'static CIImageOption;
}

extern "C" {
    /// The key for an OpenGL texture target.
    ///
    /// ## Discussion
    ///
    /// The value for this key must be an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a supported OpenGL texture target constant, either `GL_TEXTURE_2D` or `GL_TEXTURE_RECTANGLE_ARB`. You may only use this key when initializing an image using the [`initWithTexture:size:flipped:options:`](https://developer.apple.com/documentation/coreimage/ciimage/init(texture:size:flipped:options:)) method.
    ///
    ///
    #[deprecated = "Core Image OpenGL API deprecated. (Define CI_SILENCE_GL_DEPRECATION to silence these warnings)"]
    pub static kCIImageTextureTarget: &'static CIImageOption;
}

extern "C" {
    /// The key for an OpenGL texture format.
    ///
    /// ## Discussion
    ///
    /// The value for this key must be an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Core Image pixel format constant. (See `Pixel Formats`.) You may only use this key when initializing an image using the [`initWithTexture:size:flipped:options:`](https://developer.apple.com/documentation/coreimage/ciimage/init(texture:size:flipped:options:)) method.
    ///
    ///
    #[deprecated = "Core Image OpenGL API deprecated. (Define CI_SILENCE_GL_DEPRECATION to silence these warnings)"]
    pub static kCIImageTextureFormat: &'static CIImageOption;
}

extern "C" {
    /// The key into the properties dictionary indicating whether to return an auxiliary depth image.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean [`true`](https://developer.apple.com/documentation/swift/true) or [`false`](https://developer.apple.com/documentation/swift/false).  If the value is [`true`](https://developer.apple.com/documentation/swift/true), then calls to [`imageWithContentsOfURL:options:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithcontentsofurl:options:) and [`imageWithData:options:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithdata:options:) will return the auxiliary image as a half-float monochrome image instead of the primary image, or [`nil`](https://developer.apple.com/documentation/objectivec/nil-227m0) if no auxiliary image exists.
    ///
    ///
    pub static kCIImageAuxiliaryDepth: &'static CIImageOption;
}

extern "C" {
    /// The key into the properties dictionary indicating whether to return an auxiliary disparity image.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean [`true`](https://developer.apple.com/documentation/swift/true) or [`false`](https://developer.apple.com/documentation/swift/false).  If the value is [`true`](https://developer.apple.com/documentation/swift/true), then calls to [`imageWithContentsOfURL:options:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithcontentsofurl:options:) and [`imageWithData:options:`](https://developer.apple.com/documentation/coreimage/ciimage/imagewithdata:options:) will return the auxiliary image as a half-float monochrome image instead of the primary image, or [`nil`](https://developer.apple.com/documentation/objectivec/nil-227m0) if no auxiliary image exists.
    ///
    ///
    pub static kCIImageAuxiliaryDisparity: &'static CIImageOption;
}

extern "C" {
    /// The key into the properties dictionary indicating whether to return auxiliary portrait effects matte.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean [`true`](https://developer.apple.com/documentation/swift/true) or [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    pub static kCIImageAuxiliaryPortraitEffectsMatte: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageAuxiliarySemanticSegmentationSkinMatte: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageAuxiliarySemanticSegmentationHairMatte: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageAuxiliarySemanticSegmentationTeethMatte: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageAuxiliarySemanticSegmentationGlassesMatte: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageAuxiliarySemanticSegmentationSkyMatte: &'static CIImageOption;
}

extern "C" {
    pub static kCIImageAuxiliaryHDRGainMap: &'static CIImageOption;
}

extern_class!(
    /// A representation of an image to be processed or produced by Core Image filters.
    ///
    /// ## Overview
    ///
    /// You use `CIImage` objects in conjunction with other Core Image classes—such as [`CIFilter`](https://developer.apple.com/documentation/coreimage/cifilter-swift.class), [`CIContext`](https://developer.apple.com/documentation/coreimage/cicontext), [`CIVector`](https://developer.apple.com/documentation/coreimage/civector), and [`CIColor`](https://developer.apple.com/documentation/coreimage/cicolor)—to take advantage of the built-in Core Image filters when processing images. You can create `CIImage` objects with data supplied from a variety of sources, including Quartz 2D images, Core Video image buffers ([`CVImageBufferRef`](https://developer.apple.com/documentation/corevideo/cvimagebuffer)), URL-based objects, and `NSData` objects.
    ///
    /// Although a `CIImage` object has image data associated with it, it is not an image. You can think of a `CIImage` object as an image “recipe.” A `CIImage` object has all the information necessary to produce an image, but Core Image doesn’t actually render an image until it is told to do so. This lazy evaluation allows Core Image to operate as efficiently as possible. To show a `CIImage` object as an on-screen image, you can display it as a [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) in [`UIImageView`](https://developer.apple.com/documentation/uikit/uiimageview):
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["guard let imageURL = Bundle.main.url(forResource: \"YourJPEGName\", withExtension: \"JPG\") else {", "    print(\"Could not find image\")", "    return", "}", "guard let let ciImage = CIImage(contentsOf: imageURL) else {", "    print(\"Could not create CIImage\")", "    return", "}", "let uiImage = UIImage(ciImage: ciImage)", "let imageView = UIImageView(image: uiImage)    ", "self.view.addSubview(imageView)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSURL* imageURL = [[NSBundle mainBundle] URLForResource:@\"YourJPEGName\" withExtension:@\"JPG\"];", "CIImage* ciImage = [CIImage imageWithContentsOfURL:imageURL];", "UIImage* uiImage = [UIImage imageWithCIImage:ciImage];", "UIImageView* imageView = [[UIImageView alloc] initWithImage:uiImage];", "[self.view addSubview:imageView];"], metadata: None }] }] })
    /// `CIContext`  and `CIImage` objects are immutable, which means each can be shared safely among threads. Multiple threads can use the same GPU or CPU `CIContext` object to render `CIImage` objects.  However, this is not the case for `CIFilter` objects, which are mutable. A `CIFilter` object cannot be shared safely among threads.  If you app is multithreaded, each thread must create its own `CIFilter` objects. Otherwise, your app could behave unexpectedly.
    ///
    /// Core Image also provides auto-adjustment methods. These methods analyze an image for common deficiencies and return a set of filters to correct those deficiencies. The filters are preset with values for improving image quality by altering values for skin tones, saturation, contrast, and shadows and for removing red-eye or other artifacts caused by flash. (See Getting Autoadjustment Filters.)
    ///
    /// For a discussion of all the methods you can use to create `CIImage` objects on iOS and macOS, see [Core Image Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CIImage;
);

unsafe impl Send for CIImage {}

unsafe impl Sync for CIImage {}

extern_conformance!(
    unsafe impl NSCoding for CIImage {}
);

extern_conformance!(
    unsafe impl NSCopying for CIImage {}
);

unsafe impl CopyingHelper for CIImage {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CIImage {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CIImage {}
);

impl CIImage {
    extern_methods!(
        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(imageWithCGImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCGImage(image: &CGImage) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-graphics")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(imageWithCGImage:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCGImage_options(
            image: &CGImage,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-image-io")]
        /// # Safety
        ///
        /// `dict` generic should be of the correct type.
        #[unsafe(method(imageWithCGImageSource:index:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCGImageSource_index_options(
            source: &CGImageSource,
            index: usize,
            dict: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-graphics")]
        #[deprecated]
        #[unsafe(method(imageWithCGLayer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCGLayer(layer: &CGLayer) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-graphics")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[deprecated]
        #[unsafe(method(imageWithCGLayer:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCGLayer_options(
            layer: &CGLayer,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(imageWithBitmapData:bytesPerRow:size:format:colorSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithBitmapData_bytesPerRow_size_format_colorSpace(
            data: &NSData,
            bytes_per_row: usize,
            size: CGSize,
            format: CIFormat,
            color_space: Option<&CGColorSpace>,
        ) -> Retained<CIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[deprecated = "Core Image OpenGL API deprecated. (Define CI_SILENCE_GL_DEPRECATION to silence these warnings)"]
        #[unsafe(method(imageWithTexture:size:flipped:colorSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithTexture_size_flipped_colorSpace(
            name: c_uint,
            size: CGSize,
            flipped: bool,
            color_space: Option<&CGColorSpace>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[deprecated = "Core Image OpenGL API deprecated. (Define CI_SILENCE_GL_DEPRECATION to silence these warnings)"]
        #[unsafe(method(imageWithTexture:size:flipped:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithTexture_size_flipped_options(
            name: c_uint,
            size: CGSize,
            flipped: bool,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-metal")]
        /// # Safety
        ///
        /// - `texture` may need to be synchronized.
        /// - `texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `options` generic should be of the correct type.
        #[unsafe(method(imageWithMTLTexture:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithMTLTexture_options(
            texture: &ProtocolObject<dyn MTLTexture>,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<CIImage>>;

        #[unsafe(method(imageWithContentsOfURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithContentsOfURL(url: &NSURL) -> Option<Retained<CIImage>>;

        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(imageWithContentsOfURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithContentsOfURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<CIImage>>;

        #[unsafe(method(imageWithData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithData(data: &NSData) -> Option<Retained<CIImage>>;

        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(imageWithData:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithData_options(
            data: &NSData,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<CIImage>>;

        #[cfg(feature = "objc2-core-video")]
        #[unsafe(method(imageWithCVImageBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCVImageBuffer(image_buffer: &CVImageBuffer) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-video")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(imageWithCVImageBuffer:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCVImageBuffer_options(
            image_buffer: &CVImageBuffer,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-video")]
        #[unsafe(method(imageWithCVPixelBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCVPixelBuffer(pixel_buffer: &CVPixelBuffer) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-video")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(imageWithCVPixelBuffer:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithCVPixelBuffer_options(
            pixel_buffer: &CVPixelBuffer,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-io-surface")]
        #[unsafe(method(imageWithIOSurface:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithIOSurface(surface: &IOSurfaceRef) -> Retained<CIImage>;

        #[cfg(feature = "objc2-io-surface")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(imageWithIOSurface:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithIOSurface_options(
            surface: &IOSurfaceRef,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<CIImage>;

        #[cfg(feature = "CIColor")]
        #[unsafe(method(imageWithColor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageWithColor(color: &CIColor) -> Retained<CIImage>;

        #[unsafe(method(emptyImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn emptyImage() -> Retained<CIImage>;

        #[unsafe(method(blackImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn blackImage() -> Retained<CIImage>;

        #[unsafe(method(whiteImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn whiteImage() -> Retained<CIImage>;

        #[unsafe(method(grayImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn grayImage() -> Retained<CIImage>;

        #[unsafe(method(redImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn redImage() -> Retained<CIImage>;

        #[unsafe(method(greenImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn greenImage() -> Retained<CIImage>;

        #[unsafe(method(blueImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn blueImage() -> Retained<CIImage>;

        #[unsafe(method(cyanImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn cyanImage() -> Retained<CIImage>;

        #[unsafe(method(magentaImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn magentaImage() -> Retained<CIImage>;

        #[unsafe(method(yellowImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn yellowImage() -> Retained<CIImage>;

        #[unsafe(method(clearImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearImage() -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(initWithCGImage:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCGImage(this: Allocated<Self>, image: &CGImage) -> Retained<Self>;

        #[cfg(feature = "objc2-core-graphics")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithCGImage:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCGImage_options(
            this: Allocated<Self>,
            image: &CGImage,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-image-io")]
        /// # Safety
        ///
        /// `dict` generic should be of the correct type.
        #[unsafe(method(initWithCGImageSource:index:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCGImageSource_index_options(
            this: Allocated<Self>,
            source: &CGImageSource,
            index: usize,
            dict: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-graphics")]
        #[deprecated = "Use initWithCGImage: instead."]
        #[unsafe(method(initWithCGLayer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCGLayer(this: Allocated<Self>, layer: &CGLayer) -> Retained<Self>;

        #[cfg(feature = "objc2-core-graphics")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[deprecated = "Use initWithCGImage:options instead."]
        #[unsafe(method(initWithCGLayer:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCGLayer_options(
            this: Allocated<Self>,
            layer: &CGLayer,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData(this: Allocated<Self>, data: &NSData) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithData:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_options(
            this: Allocated<Self>,
            data: &NSData,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[unsafe(method(initWithBitmapData:bytesPerRow:size:format:colorSpace:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBitmapData_bytesPerRow_size_format_colorSpace(
            this: Allocated<Self>,
            data: &NSData,
            bytes_per_row: usize,
            size: CGSize,
            format: CIFormat,
            color_space: Option<&CGColorSpace>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-core-graphics"))]
        #[deprecated = "Core Image OpenGL API deprecated. (Define CI_SILENCE_GL_DEPRECATION to silence these warnings)"]
        #[unsafe(method(initWithTexture:size:flipped:colorSpace:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTexture_size_flipped_colorSpace(
            this: Allocated<Self>,
            name: c_uint,
            size: CGSize,
            flipped: bool,
            color_space: Option<&CGColorSpace>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[deprecated = "Core Image OpenGL API deprecated. (Define CI_SILENCE_GL_DEPRECATION to silence these warnings)"]
        #[unsafe(method(initWithTexture:size:flipped:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTexture_size_flipped_options(
            this: Allocated<Self>,
            name: c_uint,
            size: CGSize,
            flipped: bool,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-metal")]
        /// # Safety
        ///
        /// - `texture` may need to be synchronized.
        /// - `texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `options` generic should be of the correct type.
        #[unsafe(method(initWithMTLTexture:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMTLTexture_options(
            this: Allocated<Self>,
            texture: &ProtocolObject<dyn MTLTexture>,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfURL(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithContentsOfURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-io-surface")]
        #[unsafe(method(initWithIOSurface:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOSurface(
            this: Allocated<Self>,
            surface: &IOSurfaceRef,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-io-surface")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithIOSurface:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOSurface_options(
            this: Allocated<Self>,
            surface: &IOSurfaceRef,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-io-surface")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[deprecated]
        #[unsafe(method(initWithIOSurface:plane:format:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOSurface_plane_format_options(
            this: Allocated<Self>,
            surface: &IOSurfaceRef,
            plane: usize,
            format: CIFormat,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-video")]
        #[unsafe(method(initWithCVImageBuffer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCVImageBuffer(
            this: Allocated<Self>,
            image_buffer: &CVImageBuffer,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-video")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithCVImageBuffer:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCVImageBuffer_options(
            this: Allocated<Self>,
            image_buffer: &CVImageBuffer,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-video")]
        #[unsafe(method(initWithCVPixelBuffer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCVPixelBuffer(
            this: Allocated<Self>,
            pixel_buffer: &CVPixelBuffer,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-video")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithCVPixelBuffer:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCVPixelBuffer_options(
            this: Allocated<Self>,
            pixel_buffer: &CVPixelBuffer,
            options: Option<&NSDictionary<CIImageOption, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "CIColor")]
        #[unsafe(method(initWithColor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithColor(this: Allocated<Self>, color: &CIColor) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageByApplyingTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingTransform(
            &self,
            matrix: CGAffineTransform,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageByApplyingTransform:highQualityDownsample:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingTransform_highQualityDownsample(
            &self,
            matrix: CGAffineTransform,
            high_quality_downsample: bool,
        ) -> Retained<CIImage>;

        #[unsafe(method(imageByApplyingOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingOrientation(&self, orientation: c_int) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageTransformForOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageTransformForOrientation(&self, orientation: c_int) -> CGAffineTransform;

        #[cfg(feature = "objc2-image-io")]
        #[unsafe(method(imageByApplyingCGOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingCGOrientation(
            &self,
            orientation: CGImagePropertyOrientation,
        ) -> Retained<CIImage>;

        #[cfg(all(feature = "objc2-core-foundation", feature = "objc2-image-io"))]
        #[unsafe(method(imageTransformForCGOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageTransformForCGOrientation(
            &self,
            orientation: CGImagePropertyOrientation,
        ) -> CGAffineTransform;

        #[unsafe(method(imageByCompositingOverImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByCompositingOverImage(&self, dest: &CIImage) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageByCroppingToRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByCroppingToRect(&self, rect: CGRect) -> Retained<CIImage>;

        #[unsafe(method(imageByClampingToExtent))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByClampingToExtent(&self) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageByClampingToRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByClampingToRect(&self, rect: CGRect) -> Retained<CIImage>;

        /// # Safety
        ///
        /// `params` generic should be of the correct type.
        #[unsafe(method(imageByApplyingFilter:withInputParameters:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingFilter_withInputParameters(
            &self,
            filter_name: &NSString,
            params: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<CIImage>;

        #[unsafe(method(imageByApplyingFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingFilter(&self, filter_name: &NSString) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(imageByColorMatchingColorSpaceToWorkingSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByColorMatchingColorSpaceToWorkingSpace(
            &self,
            color_space: &CGColorSpace,
        ) -> Option<Retained<CIImage>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(imageByColorMatchingWorkingSpaceToColorSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByColorMatchingWorkingSpaceToColorSpace(
            &self,
            color_space: &CGColorSpace,
        ) -> Option<Retained<CIImage>>;

        #[unsafe(method(imageByPremultiplyingAlpha))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByPremultiplyingAlpha(&self) -> Retained<CIImage>;

        #[unsafe(method(imageByUnpremultiplyingAlpha))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByUnpremultiplyingAlpha(&self) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(imageBySettingAlphaOneInExtent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageBySettingAlphaOneInExtent(&self, extent: CGRect) -> Retained<CIImage>;

        /// Create an image by applying a gaussian blur to the receiver.
        /// - Parameters:
        /// - sigma: The sigma of the gaussian blur to apply to the receiver.
        /// If the sigma is very small (less than `0.16`) then the receiver is returned.
        /// - Returns:
        /// An autoreleased ``CIImage`` instance or the received image.
        #[unsafe(method(imageByApplyingGaussianBlurWithSigma:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingGaussianBlurWithSigma(
            &self,
            sigma: c_double,
        ) -> Retained<CIImage>;

        /// Return a new image by changing the receiver's metadata properties.
        ///
        /// When you create an image, Core Image sets an image’s properties to a metadata
        /// dictionary as described here: ``properties``.
        /// Use this method to override an image’s metadata properties with new values.
        ///
        /// - Parameters:
        /// - properties: A dictionary of metadata properties akin to the `CGImageSourceCopyPropertiesAtIndex()` function.
        /// - Returns:
        /// An autoreleased ``CIImage`` instance with a copy of the new properties.
        ///
        /// # Safety
        ///
        /// `properties` generic should be of the correct type.
        #[unsafe(method(imageBySettingProperties:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageBySettingProperties(
            &self,
            properties: &NSDictionary,
        ) -> Retained<CIImage>;

        /// Create an image by changing the receiver's sample mode to bilinear interpolation.
        /// - Returns:
        /// An autoreleased ``CIImage`` instance with a bilinear sampling.
        #[unsafe(method(imageBySamplingLinear))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageBySamplingLinear(&self) -> Retained<CIImage>;

        /// Create an image by changing the receiver's sample mode to nearest neighbor.
        /// - Returns:
        /// An autoreleased ``CIImage`` instance with a nearest sampling.
        #[unsafe(method(imageBySamplingNearest))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageBySamplingNearest(&self) -> Retained<CIImage>;

        /// Create an image that inserts a intermediate that is cacheable
        ///
        /// This intermediate will be not be cached if ``kCIContextCacheIntermediates`` is false.
        /// - Returns:
        /// An autoreleased ``CIImage``.
        #[unsafe(method(imageByInsertingIntermediate))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByInsertingIntermediate(&self) -> Retained<CIImage>;

        /// Create an image that inserts a intermediate that is cacheable.
        ///
        /// - Parameters:
        /// - cache: Controls if Core Image caches the returned image.
        /// * `YES` : This intermediate will be cacheable even if
        /// ``kCIContextCacheIntermediates`` is false.
        /// * `NO`  : the intermediate will be not be cached if
        /// ``kCIContextCacheIntermediates`` is false.
        /// - Returns:
        /// An autoreleased ``CIImage``.
        #[unsafe(method(imageByInsertingIntermediate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByInsertingIntermediate_(&self, cache: bool) -> Retained<CIImage>;

        /// Create an image that inserts a intermediate that is cached in tiles
        ///
        /// This intermediate will be cacheable even if ``kCIContextCacheIntermediates`` is false.
        /// - Returns:
        /// An autoreleased ``CIImage``.
        #[unsafe(method(imageByInsertingTiledIntermediate))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByInsertingTiledIntermediate(&self) -> Retained<CIImage>;

        /// Create an image that applies a gain map Core Image image to the received Core Image image.
        ///
        /// The gain map image can be obtained by creating a ``CIImage`` instance from `NSURL`/`NSData`
        /// and setting the ``kCIImageAuxiliaryHDRGainMap`` option set to `
        /// `true``.
        ///
        /// If the gain map ``CIImage`` instance doesn't have the needed ``properties`` metadata,
        /// the received image will be returned as-is.
        ///
        /// - Returns:
        /// An autoreleased ``CIImage`` instance or the received image.
        #[unsafe(method(imageByApplyingGainMap:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingGainMap(&self, gainmap: &CIImage) -> Retained<CIImage>;

        /// Create an image that applies a gain map Core Image image with a specified headroom to the received Core Image image.
        ///
        /// - Parameters:
        /// - gainmap: The gain map ``CIImage`` instance to apply to the receiver.
        /// - headroom: a float value that specify how much headroom the resulting image should have.
        /// The headroom value will be limited to between 1.0 (i.e. SDR) and
        /// the full headroom allowed by the gain map.
        /// - Returns:
        /// An autoreleased ``CIImage`` instance or the received image.
        #[unsafe(method(imageByApplyingGainMap:headroom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByApplyingGainMap_headroom(
            &self,
            gainmap: &CIImage,
            headroom: c_float,
        ) -> Retained<CIImage>;

        /// Create an image by changing the receiver's contentHeadroom property.
        ///
        /// Changing this value will alter the behavior of the `CIToneMapHeadroom` and `CISystemToneMap` filters.
        /// * If the value is set to 0.0 then the returned image's headroom is unknown.
        /// * If the value is set to 1.0 then the returned image is SDR.
        /// * If the value is set to greater 1.0 then the returned image is HDR.
        /// * Otherwise the returned image's headroom is unknown.
        ///
        /// - Returns:
        /// An autoreleased ``CIImage``.
        #[unsafe(method(imageBySettingContentHeadroom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageBySettingContentHeadroom(&self, headroom: c_float) -> Retained<CIImage>;

        /// Create an image by changing the receiver's contentAverageLightLevel property.
        ///
        /// Changing this value will alter the behavior of the `CIToneMapHeadroom` and `CISystemToneMap` filters.
        /// * If the value is set to 0.0 or less then the returned image's ``contentAverageLightLevel`` is unknown.
        ///
        /// - Returns:
        /// An autoreleased ``CIImage``.
        #[unsafe(method(imageBySettingContentAverageLightLevel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageBySettingContentAverageLightLevel(
            &self,
            average: c_float,
        ) -> Retained<CIImage>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Returns a rectangle the defines the bounds of non-(0,0,0,0) pixels in the image.
        /// > Note: the ``extent`` of `CIImage`` may be infinite or have a non-zero origin.
        #[unsafe(method(extent))]
        #[unsafe(method_family = none)]
        pub unsafe fn extent(&self) -> CGRect;

        /// Returns YES if the image is known to have and alpha value of `1.0` over the entire image extent.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isOpaque))]
        #[unsafe(method_family = none)]
        pub unsafe fn isOpaque(&self) -> bool;

        /// Returns the metadata properties dictionary of the image.
        ///
        /// If the ``CIImage`` was created from `NSURL` or `NSData` then this dictionary is determined by calling `CGImageSourceCopyPropertiesAtIndex()`.
        ///
        /// If the ``CIImage`` was created with the ``kCIImageProperties`` option, then that dictionary is returned.
        ///
        /// If the ``CIImage`` was created by applying ``CIFilter-class`` or ``CIKernel`` then the
        /// properties of the root inputImage will be returned.
        #[unsafe(method(properties))]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[cfg(feature = "CIFilterShape")]
        #[unsafe(method(definition))]
        #[unsafe(method_family = none)]
        pub unsafe fn definition(&self) -> Retained<CIFilterShape>;

        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(colorSpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorSpace(&self) -> Option<Retained<CGColorSpace>>;

        /// Returns the content headroom of the image.
        ///
        /// If the image headroom is unknown, then the value 0.0 will be returned.
        ///
        /// If the image headroom is known, then a value greater than or equal to 1.0 will be returned.
        /// A value of 1.0 will be returned if the image is SDR.
        /// A value greater than 1.0 will be returned if the image is HDR.
        ///
        /// The image headroom may known when a CIImage is first initialized.
        /// If the a CIImage is initialized using:
        /// * `NSURL` or `NSData` : the headroom may be determined by associated metadata
        /// or deduced from pixel format or colorSpace information.
        /// * `CGImage` : headroom may be determined by `CGImageGetHeadroomInfo()`
        /// or deduced from pixel format or colorSpace information.
        /// * `IOSurface` : then the headroom will be determined by `kIOSurfaceContentHeadroom`.
        /// or deduced from pixel format or colorSpace information.
        /// * `CVPixelBuffer` : then the headroom will be determined by `kCVImageBufferContentLightLevelInfoKey`.
        /// or deduced from pixel format or colorSpace information.
        /// * `BitmapData` : headroom may be deduced from pixel format or colorSpace information.
        ///
        /// If the image is the result of applying a ``CIFilter-class`` or ``CIKernel``, this method will return `0.0`.
        ///
        /// There are exceptions to this.  Applying a `CIWarpKernel`` or certain ``CIFilter-class``
        /// (e.g. `CIGaussianBlur`, `CILanczosScaleTransform`, `CIAreaAverage` and some others)
        /// to an image will result in a ``CIImage`` instance with the same `contentHeadroom` property value.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(contentHeadroom))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentHeadroom(&self) -> c_float;

        /// Returns the content average light level of the image.
        ///
        /// If the image average light level is unknown, then the value 0.0 will be returned.
        ///
        /// If the image headroom is known, then a value greater than or equal to 0.0 will be returned.
        ///
        /// The image average light level may known when a CIImage is first initialized.
        /// If the a CIImage is initialized with a:
        /// * `CGImage` : then the headroom will be determined by `CGImageGetContentAverageLightLevel()`.
        /// * `CVPixelBuffer` : then the headroom will be determined by `kCVImageBufferContentLightLevelInfoKey`.
        ///
        /// If the image is the result of applying a ``CIFilter-class`` or ``CIKernel``, this property will return `0.0`.
        ///
        /// There are exceptions to this.  Applying a ``CIWarpKernel`` or certain ``CIFilter-class``
        /// (e.g. `CIGaussianBlur`, `CILanczosScaleTransform`, `CIAreaAverage` and some others)
        /// to an image will result in a ``CIImage`` instance with the same `contentAverageLightLevel` property value.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(contentAverageLightLevel))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentAverageLightLevel(&self) -> c_float;

        #[cfg(feature = "objc2-core-video")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(pixelBuffer))]
        #[unsafe(method_family = none)]
        pub unsafe fn pixelBuffer(&self) -> Option<Retained<CVPixelBuffer>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(CGImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn CGImage(&self) -> Option<Retained<CGImage>>;

        #[cfg(feature = "objc2-metal")]
        /// Returns a Metal Texture if the Core Image image was created with a texture.
        ///
        /// This will return non-nil if the image was created with ``/CIImage/imageWithMTLTexture:options:`` and no options.
        /// Otherwise this property will be `nil` you should instead call
        /// ``/CIContext/render:toMTLTexture:commandBuffer:bounds:colorSpace:``.
        /// > Warning: Modifying the contents of this texture will cause the ``CIImage`` instance to render with incorrect results.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(metalTexture))]
        #[unsafe(method_family = none)]
        pub unsafe fn metalTexture(&self) -> Option<Retained<ProtocolObject<dyn MTLTexture>>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(regionOfInterestForImage:inRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn regionOfInterestForImage_inRect(
            &self,
            image: &CIImage,
            rect: CGRect,
        ) -> CGRect;
    );
}

/// Methods declared on superclass `NSObject`.
impl CIImage {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

// NS_TYPED_ENUM
pub type CIImageAutoAdjustmentOption = NSString;

extern "C" {
    /// A key used to specify whether to return enhancement filters.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is a `CFBoolean` value. Supply `false` to indicate not to return enhancement filters. If you don’t specify this option, Core Image assumes its value is `true`.
    ///
    ///
    pub static kCIImageAutoAdjustEnhance: &'static CIImageAutoAdjustmentOption;
}

extern "C" {
    /// A key used to specify whether to return a red eye filter.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is a `CFBoolean` value. Supply `false` to indicate not to return a red eye filter. If you don’t specify this option, Core Image assumes its value is `true`.
    ///
    ///
    pub static kCIImageAutoAdjustRedEye: &'static CIImageAutoAdjustmentOption;
}

extern "C" {
    /// A key used to specify an array of features that you want to apply enhancement and red eye filters to.
    ///
    /// ## Discussion
    ///
    /// The associated value is an array of `CIFeature` objects. If you don’t supply an array, the Core Image searches for features using the `CIDetector` class.
    ///
    ///
    pub static kCIImageAutoAdjustFeatures: &'static CIImageAutoAdjustmentOption;
}

extern "C" {
    /// A key used to specify whether to return a filter that crops the image to focus on detected features.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is a `CFBoolean` value. If `true`, the returned filters include an operation that crops the image around the features specified with the [`kCIImageAutoAdjustFeatures`](https://developer.apple.com/documentation/coreimage/ciimageautoadjustmentoption/features) option (or any features detected in the image, if that option is not present). Supply `false` to indicate not to return a crop filter. If you don’t specify this option, Core Image assumes its value is `false`.
    ///
    ///
    pub static kCIImageAutoAdjustCrop: &'static CIImageAutoAdjustmentOption;
}

extern "C" {
    /// A key used to specify whether to return a filter that rotates the image to keep a level perspective.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is a `CFBoolean` value. If `true`, Core Image analyzes the image to determine whether it would benefit from rotation—for example, a landscape photo in which the horizon is not horizontal—and returns a filter to perform that rotation. Supply `false` to indicate not to return a rotation filter. If you don’t specify this option, Core Image assumes its value is `false`.
    ///
    ///
    pub static kCIImageAutoAdjustLevel: &'static CIImageAutoAdjustmentOption;
}

/// AutoAdjustment.
impl CIImage {
    extern_methods!(
        #[cfg(feature = "CIFilter")]
        #[unsafe(method(autoAdjustmentFilters))]
        #[unsafe(method_family = none)]
        pub unsafe fn autoAdjustmentFilters(&self) -> Retained<NSArray<CIFilter>>;

        #[cfg(feature = "CIFilter")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(autoAdjustmentFiltersWithOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn autoAdjustmentFiltersWithOptions(
            &self,
            options: Option<&NSDictionary<CIImageAutoAdjustmentOption, AnyObject>>,
        ) -> Retained<NSArray<CIFilter>>;
    );
}

/// LabConversion.
impl CIImage {
    extern_methods!(
        #[unsafe(method(imageByConvertingWorkingSpaceToLab))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByConvertingWorkingSpaceToLab(&self) -> Retained<CIImage>;

        #[unsafe(method(imageByConvertingLabToWorkingSpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageByConvertingLabToWorkingSpace(&self) -> Retained<CIImage>;
    );
}
