//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Context of a SmartCard PIN authentication operation.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tktokensmartcardpinauthoperation?language=objc)
    #[unsafe(super(TKTokenAuthOperation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "TKToken")]
    pub struct TKTokenSmartCardPINAuthOperation;
);

#[cfg(feature = "TKToken")]
extern_conformance!(
    unsafe impl NSCoding for TKTokenSmartCardPINAuthOperation {}
);

#[cfg(feature = "TKToken")]
extern_conformance!(
    unsafe impl NSObjectProtocol for TKTokenSmartCardPINAuthOperation {}
);

#[cfg(feature = "TKToken")]
extern_conformance!(
    unsafe impl NSSecureCoding for TKTokenSmartCardPINAuthOperation {}
);

#[cfg(feature = "TKToken")]
impl TKTokenSmartCardPINAuthOperation {
    extern_methods!(
        #[cfg(feature = "TKSmartCard")]
        /// PIN formatting properties.
        ///
        /// Note: The property is initialized with a default instance of TKSmartCardPINFormat.
        #[unsafe(method(PINFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINFormat(&self) -> Retained<TKSmartCardPINFormat>;

        #[cfg(feature = "TKSmartCard")]
        /// Setter for [`PINFormat`][Self::PINFormat].
        #[unsafe(method(setPINFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINFormat(&self, pin_format: &TKSmartCardPINFormat);

        /// APDU template into which PIN gets filled in. If set to nil, the system will not attempt to authenticate by sending the formatted APDU to the SmartCard, but rather the token itself is expected to perform the authentication.  It is preferred to provide APDUTemplate if possible, because it allows using hardware PINPad for secure PIN entry (provided that the reader has one).
        #[unsafe(method(APDUTemplate))]
        #[unsafe(method_family = none)]
        pub unsafe fn APDUTemplate(&self) -> Option<Retained<NSData>>;

        /// Setter for [`APDUTemplate`][Self::APDUTemplate].
        #[unsafe(method(setAPDUTemplate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAPDUTemplate(&self, apdu_template: Option<&NSData>);

        /// Offset in bytes within APDU template to mark the location for filling in the PIN.
        #[unsafe(method(PINByteOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINByteOffset(&self) -> NSInteger;

        /// Setter for [`PINByteOffset`][Self::PINByteOffset].
        #[unsafe(method(setPINByteOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINByteOffset(&self, pin_byte_offset: NSInteger);

        #[cfg(feature = "TKSmartCard")]
        /// TKSmartCard to which the formatted APDU gets sent in order to authenticate (used only if 'APDUTemplate' is set).
        #[unsafe(method(smartCard))]
        #[unsafe(method_family = none)]
        pub unsafe fn smartCard(&self) -> Option<Retained<TKSmartCard>>;

        #[cfg(feature = "TKSmartCard")]
        /// Setter for [`smartCard`][Self::smartCard].
        #[unsafe(method(setSmartCard:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSmartCard(&self, smart_card: Option<&TKSmartCard>);

        /// PIN value which will be set when 'finishWithError:' gets triggered.  Note that the PIN is not set in case that APDUTemplate was set.  In this case, PIN was already sent to the card using specified template.
        #[unsafe(method(PIN))]
        #[unsafe(method_family = none)]
        pub unsafe fn PIN(&self) -> Option<Retained<NSString>>;

        /// Setter for [`PIN`][Self::PIN].
        #[unsafe(method(setPIN:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPIN(&self, pin: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "TKToken")]
impl TKTokenSmartCardPINAuthOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// TKSmartCardTokenSession represents token session based on SmartCard token.
    ///
    /// When implementing SmartCard token extension, subclass TKSmartCardTokenSession and implement TKTokenSessionDelegate on it.  Use #token property to get access and send APDUs to the underlying SmartCard.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardtokensession?language=objc)
    #[unsafe(super(TKTokenSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "TKToken")]
    pub struct TKSmartCardTokenSession;
);

#[cfg(feature = "TKToken")]
extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardTokenSession {}
);

#[cfg(feature = "TKToken")]
impl TKSmartCardTokenSession {
    extern_methods!(
        #[cfg(feature = "TKSmartCard")]
        /// contains TKSmartCard instance with active exclusive session and SmartCard application selected.
        ///
        /// This property can be accessed only when handling one of the methods of TKTokenSessionDelegate protocol.  If associated token has set AID property, then the returned card has opened exclusive session to the card and the application is already selected.  Therefore there is no need to call -[TKSmartCard beginSessionWithReply:]) on returned SmartCard instance in such case and system will take care of terminating session when current token request servicing is finished,  -[TKSmartCard endSession] must not be called either.
        ///
        /// You can store any kind of context state information representing state of the card into smartCard.context property.  This property will be automatically set to nil if the card is reset or accessed by different TKSmartCard instance (possibly in another process).  Checking TKSmartCard.context property for previously stored value can be used to avoid potentially costly restoring of SmartCard state before performing the operation.
        #[deprecated]
        #[unsafe(method(smartCard))]
        #[unsafe(method_family = none)]
        pub unsafe fn smartCard(&self) -> Retained<TKSmartCard>;

        #[cfg(feature = "TKSmartCard")]
        /// Returns a TKSmartCard instance with an active exclusive session and the SmartCard application selected. Replaces the deprecated
        /// `smartCard`property.
        ///
        /// The TKSmartCard object is only accessible within the methods of the TKTokenSessionDelegate protocol. If the associated token has an AID set, the returned card will have an exclusive session already opened and the specified application selected. In this scenario: Do not call -[TKSmartCard beginSessionWithReply:]) on the returned SmartCard instance. The system manages the session lifecycle and will terminate it automatically when the current token request servicing is finished. Do not call -[TKSmartCard endSession]. You can use the `smartCard.context` property to store any context-specific state information related to the card. This property is automatically set to `nil` if the card is reset or accessed by a different TKSmartCard instance (potentially in another process). Before performing an operation, check the `TKSmartCard.context` property for a previously stored value. This can help you avoid potentially costly restoration of the SmartCard state if it's already available.
        ///
        /// Parameter `error`: An NSError object containing details if the operation fails.
        #[unsafe(method(getSmartCardWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn getSmartCardWithError(
            &self,
        ) -> Result<Retained<TKSmartCard>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `TKTokenSession`.
#[cfg(feature = "TKToken")]
impl TKSmartCardTokenSession {
    extern_methods!(
        /// Parameter `token`: Token instance to which is this session instance bound.
        #[unsafe(method(initWithToken:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithToken(this: Allocated<Self>, token: &TKToken) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "TKToken")]
impl TKSmartCardTokenSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// TKSmartCardToken base class for implementing SmartCard based token.
    ///
    /// When implementing SmartCard token extension, subclass TKSmartCardToken and implement TKTokenDelegate on it.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardtoken?language=objc)
    #[unsafe(super(TKToken, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "TKToken")]
    pub struct TKSmartCardToken;
);

#[cfg(feature = "TKToken")]
extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardToken {}
);

#[cfg(feature = "TKToken")]
impl TKSmartCardToken {
    extern_methods!(
        #[cfg(feature = "TKSmartCard")]
        /// Initializes token instance with specified attributes.
        ///
        /// Parameter `smartCard`: TKSmartCard instance representing connection to SmartCard on which the intance should operate.
        ///
        /// Parameter `AID`: ISO7816-4 application ID which is preselected on the card.
        ///
        /// Parameter `instanceID`: Unique, persistent identifier of this token.  This is typically implemented by some kind of SmartCard serial number.
        ///
        /// Parameter `tokenDriver`: associated driver which initiated creation of this token.
        #[unsafe(method(initWithSmartCard:AID:instanceID:tokenDriver:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSmartCard_AID_instanceID_tokenDriver(
            this: Allocated<Self>,
            smart_card: &TKSmartCard,
            aid: Option<&NSData>,
            instance_id: &NSString,
            token_driver: &TKSmartCardTokenDriver,
        ) -> Retained<Self>;

        /// This is AID which is specified in extension's plist NSExtensionAttributes as
        /// `com.apple.ctk.aid`attribute. If the attribute specifies array of multiple AIDs, this parameter represents AID which was found on the card and is already preselected.  If
        /// `com.apple.ctk.aid`is not present, no application is automatically preselected and value of this property is nil.
        #[unsafe(method(AID))]
        #[unsafe(method_family = none)]
        pub unsafe fn AID(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(initWithTokenDriver:instanceID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTokenDriver_instanceID(
            this: Allocated<Self>,
            token_driver: &TKTokenDriver,
            instance_id: &NSString,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `TKToken`.
#[cfg(feature = "TKToken")]
impl TKSmartCardToken {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "TKToken")]
impl TKSmartCardToken {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// TKSmartCardTokenDriver represents driver for specific SmartCard type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardtokendriver?language=objc)
    #[unsafe(super(TKTokenDriver, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "TKToken")]
    pub struct TKSmartCardTokenDriver;
);

#[cfg(feature = "TKToken")]
extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardTokenDriver {}
);

#[cfg(feature = "TKToken")]
impl TKSmartCardTokenDriver {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "TKToken")]
impl TKSmartCardTokenDriver {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// TKSmartCardTokenDriverDelegate is used to implement creation of new token instance according to the SmartCard.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardtokendriverdelegate?language=objc)
    #[cfg(feature = "TKToken")]
    pub unsafe trait TKSmartCardTokenDriverDelegate: TKTokenDriverDelegate {
        #[cfg(feature = "TKSmartCard")]
        /// Called by system when new SmartCard is detected.  You must override this method to create a new valid token TKSmartCardToken instance for
        /// `smartCard.`
        /// Parameter `smartCard`: Target SmartCard.
        ///
        /// Parameter `AID`: ISO7816-4 AID (application ID) which is already selected on the card.  If
        /// `com.apple.ctk.aid`is not present, no application is selected and this parameter is nil.
        ///
        /// Parameter `error`: Error details if operation fails.
        ///
        /// Returns: Newly created token instance representing
        /// `smartCard.`If an error occurs or driver decides that it does not want to handle specified smartCard as token, return nil.
        #[unsafe(method(tokenDriver:createTokenForSmartCard:AID:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn tokenDriver_createTokenForSmartCard_AID_error(
            &self,
            driver: &TKSmartCardTokenDriver,
            smart_card: &TKSmartCard,
            aid: Option<&NSData>,
        ) -> Result<Retained<TKSmartCardToken>, Retained<NSError>>;
    }
);
