//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An interface to all available smart card reader slots.
    ///
    /// ## Overview
    ///
    /// Get a list of all known smart card reader slots in the system using the [`slotNames`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotmanager/slotnames) property, and access individual slots by name using the [`getSlotWithName:reply:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotmanager/getslot(withname:reply:)) method.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The [`com.apple.security.smartcard`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.security.smartcard) entitlement is required in order to use `TKSmartCardSlotManager`.
    ///
    ///
    ///
    /// </div>
    ///
    /// Represents pool of SmartCard reader slots.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardSlotManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardSlotManager {}
);

impl TKSmartCardSlotManager {
    extern_methods!(
        /// Global pool of SmartCard reader slots.
        /// macOS: Note that defaultManager instance is accessible only if the calling application has 'com.apple.security.smartcard' entitlement set to Boolean:YES.  If the calling application does not have this entitlement, defaultManager is always set to nil.
        /// iOS: The defaultManager instance is always accessible.
        #[unsafe(method(defaultManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultManager() -> Option<Retained<TKSmartCardSlotManager>>;

        /// Array of currently known slots in the system.  Slots are identified by NSString name instances.  Use KVO to be notified about slots arrivals and removals.
        #[unsafe(method(slotNames))]
        #[unsafe(method_family = none)]
        pub unsafe fn slotNames(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "block2")]
        /// Instantiates smartcard reader slot of specified name.  If specified name is not registered, reports nil.
        #[unsafe(method(getSlotWithName:reply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getSlotWithName_reply(
            &self,
            name: &NSString,
            reply: &block2::DynBlock<dyn Fn(*mut TKSmartCardSlot)>,
        );

        /// Gets SmartCard reader slot with specified name.  If reader slot with this name does not exist, returns nil.
        #[unsafe(method(slotNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn slotNamed(&self, name: &NSString) -> Option<Retained<TKSmartCardSlot>>;

        #[cfg(all(feature = "TKSmartCardSlotNFCSession", feature = "block2"))]
        /// Creates an NFC smart card slot using the device's hardware and presents a system UI.
        ///
        /// Parameter `message`: Message shown in the system-presented UI
        ///
        /// Parameter `completion`: Completion handler which returns the NFC session of the created slot or an error on failure.
        /// If an NFC slot already exists and current caller is not the initial creator `TKErrorCodeObjectNotFound` error is returned.
        ///
        ///
        /// To finish the NFC session and dismiss the system-presented UI use `TKSmartCardSlotNFCSession.endSession`.
        ///
        ///
        /// Warning: Caller requires `com.apple.developer.nfc.readersession.iso7816.select-identifiers` Info.plist record which specifies application identifiers of the NFC cards
        ///
        /// ```text
        ///  https://developer.apple.com/documentation/bundleresources/information-property-list/com.apple.developer.nfc.readersession.iso7816.select-identifiers
        /// ```
        ///
        /// # Safety
        ///
        /// `completion` block must be sendable.
        #[unsafe(method(createNFCSlotWithMessage:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createNFCSlotWithMessage_completion(
            &self,
            message: Option<&NSString>,
            completion: &block2::DynBlock<dyn Fn(*mut TKSmartCardSlotNFCSession, *mut NSError)>,
        );

        /// Determines whether NFC (Near Field Communication) is supported on this device.
        ///
        ///
        /// Returns: `YES` if NFC is supported and available for use, NO otherwise.
        #[unsafe(method(isNFCSupported))]
        #[unsafe(method_family = none)]
        pub unsafe fn isNFCSupported(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardSlotManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// All smart card slot states.
/// Enumerates all possible slot states.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct TKSmartCardSlotState(pub NSInteger);
impl TKSmartCardSlotState {
    ///
    /// ## Discussion
    ///
    /// The Smart Card reader slot is no longer known to the system.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This is the terminal state of a `TKSmartCardSlotThis` instance; once it has reached this state, the Smart Card reader slot cannot be reinitialized.
    ///
    ///
    ///
    /// </div>
    ///
    /// Slot is no longer known to the system.  This is terminal state for TKSmartCardSlot instance, once reached, the slot instance can never be revived.
    #[doc(alias = "TKSmartCardSlotStateMissing")]
    pub const Missing: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// The Smart Card reader slot is empty; no card is inserted.
    ///
    ///
    /// The slot is empty, no card is inserted.
    #[doc(alias = "TKSmartCardSlotStateEmpty")]
    pub const Empty: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// A Smart Card was inserted into the slot and an initial probe is in underway.
    ///
    ///
    /// The card was inserted into the slot and an initial probe is in progress.
    #[doc(alias = "TKSmartCardSlotStateProbing")]
    pub const Probing: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// A Smart Card is inserted, but is mute, or does not provide responses to commands.
    ///
    ///
    /// The card inserted in the slot does not answer.
    #[doc(alias = "TKSmartCardSlotStateMuteCard")]
    pub const MuteCard: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// A Smart Card is inserted and properly answered to a reset command.
    ///
    ///
    /// Card properly answered to reset.
    #[doc(alias = "TKSmartCardSlotStateValidCard")]
    pub const ValidCard: Self = Self(4);
}

unsafe impl Encode for TKSmartCardSlotState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardSlotState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Possible PIN character sets.
/// Enumerates all possible PIN character sets.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct TKSmartCardPINCharset(pub NSInteger);
impl TKSmartCardPINCharset {
    ///
    /// ## Discussion
    ///
    /// PIN is only composed of digits.
    ///
    ///
    /// PIN is only composed of digits.
    #[doc(alias = "TKSmartCardPINCharsetNumeric")]
    pub const Numeric: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// PIN can be composed of digits and letters.
    ///
    ///
    /// PIN can be composed of digits and letters.
    #[doc(alias = "TKSmartCardPINCharsetAlphanumeric")]
    pub const Alphanumeric: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// PIN can be composed of digits and uppercase letters.
    ///
    ///
    /// PIN can be composed of digits and uppercase letters.
    #[doc(alias = "TKSmartCardPINCharsetUpperAlphanumeric")]
    pub const UpperAlphanumeric: Self = Self(2);
}

unsafe impl Encode for TKSmartCardPINCharset {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINCharset {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Possible PIN encoding types.
/// Enumerates all possible PIN encoding types.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct TKSmartCardPINEncoding(pub NSInteger);
impl TKSmartCardPINEncoding {
    ///
    /// ## Discussion
    ///
    /// Characters are encoded in Binary format (for example, `1234` is encoded as `01h 02h 03h 04h`).
    ///
    ///
    /// Characters are encoded in Binary format (1234 => 01h 02h 03h 04h).
    #[doc(alias = "TKSmartCardPINEncodingBinary")]
    pub const Binary: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// Characters are encoded in ASCII format (for example, `1234` is encoded as `31h 32h 33h 34h`).
    ///
    ///
    /// Characters are encoded in ASCII format (1234 => 31h 32h 33h 34h).
    #[doc(alias = "TKSmartCardPINEncodingASCII")]
    pub const ASCII: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// Characters (only digits) are encoded in BCD format (for example, `1234` is encoded as `12h 34h`).
    ///
    ///
    /// Characters (only digits) are encoded in BCD format (1234 => 12h 34h).
    #[doc(alias = "TKSmartCardPINEncodingBCD")]
    pub const BCD: Self = Self(2);
}

unsafe impl Encode for TKSmartCardPINEncoding {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Possible PIN justification types
/// Enumerates all posible PIN justification types.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct TKSmartCardPINJustification(pub NSInteger);
impl TKSmartCardPINJustification {
    ///
    /// ## Discussion
    ///
    /// Justify to the left.
    ///
    ///
    /// Justify to the left.
    #[doc(alias = "TKSmartCardPINJustificationLeft")]
    pub const Left: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// Justify to the right.
    ///
    ///
    /// Justify to the right.
    #[doc(alias = "TKSmartCardPINJustificationRight")]
    pub const Right: Self = Self(1);
}

unsafe impl Encode for TKSmartCardPINJustification {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINJustification {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Bitmask specifying condition(s) under which PIN entry should be considered complete.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct TKSmartCardPINCompletion(pub NSUInteger);
bitflags::bitflags! {
    impl TKSmartCardPINCompletion: NSUInteger {
/// Completion by reaching the maximum PIN length.
        #[doc(alias = "TKSmartCardPINCompletionMaxLength")]
        const MaxLength = 1<<0;
/// Completion by pressing the validation key.
        #[doc(alias = "TKSmartCardPINCompletionKey")]
        const Key = 1<<1;
/// Completion by timeout expiration.
        #[doc(alias = "TKSmartCardPINCompletionTimeout")]
        const Timeout = 1<<2;
    }
}

unsafe impl Encode for TKSmartCardPINCompletion {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINCompletion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Bitmask specifying whether PIN confirmation should be requested.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct TKSmartCardPINConfirmation(pub NSUInteger);
bitflags::bitflags! {
    impl TKSmartCardPINConfirmation: NSUInteger {
/// No confirmation requested.
        #[doc(alias = "TKSmartCardPINConfirmationNone")]
        const None = 0;
/// Confirmation (entry) of the new PIN requested.
        #[doc(alias = "TKSmartCardPINConfirmationNew")]
        const New = 1<<0;
/// Confirmation (entry) of the current PIN requested.
        #[doc(alias = "TKSmartCardPINConfirmationCurrent")]
        const Current = 1<<1;
    }
}

unsafe impl Encode for TKSmartCardPINConfirmation {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINConfirmation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The formatting properties for a PIN, such as character encoding and length constraints.
    ///
    /// ## Overview
    ///
    /// You typically interact with `TKSmartCardPINFormat` objects when calling the [`userInteractionForSecurePINChangeWithPINFormat:APDU:currentPINByteOffset:newPINByteOffset:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/userinteractionforsecurepinchange(_:apdu:currentpinbyteoffset:newpinbyteoffset:)) and [`userInteractionForSecurePINVerificationWithPINFormat:APDU:PINByteOffset:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/userinteractionforsecurepinverification(_:apdu:pinbyteoffset:)) methods on an instance of [`TKSmartCard`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard).
    ///
    ///
    /// Specifies PIN formatting properties.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardPINFormat;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardPINFormat {}
);

impl TKSmartCardPINFormat {
    extern_methods!(
        /// Format of PIN characters.
        ///
        /// Note: Default value: TKSmartCardPINCharsetNumeric
        #[unsafe(method(charset))]
        #[unsafe(method_family = none)]
        pub unsafe fn charset(&self) -> TKSmartCardPINCharset;

        /// Setter for [`charset`][Self::charset].
        #[unsafe(method(setCharset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCharset(&self, charset: TKSmartCardPINCharset);

        /// Encoding of PIN characters.
        ///
        /// Note: Default value: TKSmartCardPINEncodingASCII
        #[unsafe(method(encoding))]
        #[unsafe(method_family = none)]
        pub unsafe fn encoding(&self) -> TKSmartCardPINEncoding;

        /// Setter for [`encoding`][Self::encoding].
        #[unsafe(method(setEncoding:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEncoding(&self, encoding: TKSmartCardPINEncoding);

        /// Minimum number of characters to form a valid PIN.
        ///
        /// Note: Default value: 4
        #[unsafe(method(minPINLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn minPINLength(&self) -> NSInteger;

        /// Setter for [`minPINLength`][Self::minPINLength].
        #[unsafe(method(setMinPINLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinPINLength(&self, min_pin_length: NSInteger);

        /// Maximum number of characters to form a valid PIN.
        ///
        /// Note: Default value: 8
        #[unsafe(method(maxPINLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxPINLength(&self) -> NSInteger;

        /// Setter for [`maxPINLength`][Self::maxPINLength].
        #[unsafe(method(setMaxPINLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaxPINLength(&self, max_pin_length: NSInteger);

        /// Total length of the PIN block in bytes.
        ///
        /// Note: Default value: 8
        #[unsafe(method(PINBlockByteLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINBlockByteLength(&self) -> NSInteger;

        /// Setter for [`PINBlockByteLength`][Self::PINBlockByteLength].
        #[unsafe(method(setPINBlockByteLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINBlockByteLength(&self, pin_block_byte_length: NSInteger);

        /// PIN justification within the PIN block.
        ///
        /// Note: Default value: TKSmartCardPINJustificationLeft
        #[unsafe(method(PINJustification))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINJustification(&self) -> TKSmartCardPINJustification;

        /// Setter for [`PINJustification`][Self::PINJustification].
        #[unsafe(method(setPINJustification:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINJustification(&self, pin_justification: TKSmartCardPINJustification);

        /// Offset in bits within the PIN block to mark a location for filling in the formatted PIN (justified with respect to PINJustification).
        ///
        /// Note: Default value: 0
        ///
        /// The offset, in bits, within the PIN block to mark a location for filling in the formatted PIN, which is justified with respect to the PINJustification property value.
        #[unsafe(method(PINBitOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINBitOffset(&self) -> NSInteger;

        /// Setter for [`PINBitOffset`][Self::PINBitOffset].
        #[unsafe(method(setPINBitOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINBitOffset(&self, pin_bit_offset: NSInteger);

        /// Offset in bits within the PIN block to mark a location for filling in the PIN length (always left justified).
        ///
        /// Note: Default value: 0
        ///
        /// The offset, in bits, within the PIN block to mark a location for filling in the PIN length, which is always left justified.
        #[unsafe(method(PINLengthBitOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINLengthBitOffset(&self) -> NSInteger;

        /// Setter for [`PINLengthBitOffset`][Self::PINLengthBitOffset].
        #[unsafe(method(setPINLengthBitOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINLengthBitOffset(&self, pin_length_bit_offset: NSInteger);

        /// Size in bits of the PIN length field. If set to 0, PIN length is not written.
        ///
        /// Note: Default value: 0
        #[unsafe(method(PINLengthBitSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINLengthBitSize(&self) -> NSInteger;

        /// Setter for [`PINLengthBitSize`][Self::PINLengthBitSize].
        #[unsafe(method(setPINLengthBitSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINLengthBitSize(&self, pin_length_bit_size: NSInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardPINFormat {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The interface implemented by a Smart Card user interaction delegate to handle user interaction events.
    /// Delegate for user interactions involving the SmartCard reader.
    pub unsafe trait TKSmartCardUserInteractionDelegate {
        /// A valid character has been entered.
        #[optional]
        #[unsafe(method(characterEnteredInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn characterEnteredInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// A correction key has been pressed.
        #[optional]
        #[unsafe(method(correctionKeyPressedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn correctionKeyPressedInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// The validation key has been pressed (end of PIN entry).
        #[optional]
        #[unsafe(method(validationKeyPressedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn validationKeyPressedInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// An invalid character has been entered.
        #[optional]
        #[unsafe(method(invalidCharacterEnteredInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn invalidCharacterEnteredInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// Indicates that the old PIN needs to be entered.
        #[optional]
        #[unsafe(method(oldPINRequestedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn oldPINRequestedInUserInteraction(&self, interaction: &TKSmartCardUserInteraction);

        /// Indicates that the new PIN needs to be entered.
        #[optional]
        #[unsafe(method(newPINRequestedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn newPINRequestedInUserInteraction(&self, interaction: &TKSmartCardUserInteraction);

        /// Indicates that the new PIN needs to be confirmed (re-entered).
        #[optional]
        #[unsafe(method(newPINConfirmationRequestedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn newPINConfirmationRequestedInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );
    }
);

extern_class!(
    /// The base class for encapsulating user interaction with a Smart Card reader.
    ///
    /// ## Overview
    ///
    /// There are two types of user interactions: those for secure PIN change and those for secure PIN validation. These interactions are instances of the [`TKSmartCardUserInteractionForSecurePINChange`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforsecurepinchange), or [`TKSmartCardUserInteractionForSecurePINVerification`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforsecurepinverification) subclasses of [`TKSmartCardUserInteractionForPINOperation`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforpinoperation), respectively. [`TKSmartCardUserInteractionForPINOperation`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforpinoperation) is a subclass of `TKSmartCardUserInteraction`.
    ///
    /// You interact with instances of one of the subclasses of [`TKSmartCardUserInteractionForPINOperation`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforpinoperation)when calling the [`userInteractionForSecurePINChangeWithPINFormat:APDU:currentPINByteOffset:newPINByteOffset:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/userinteractionforsecurepinchange(_:apdu:currentpinbyteoffset:newpinbyteoffset:)) and [`userInteractionForSecurePINVerificationWithPINFormat:APDU:PINByteOffset:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/userinteractionforsecurepinverification(_:apdu:pinbyteoffset:)) methods on an [`TKSmartCard`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard) object.
    ///
    ///
    /// Represents handle to a user interaction involving the SmartCard reader.
    ///
    /// It is a proxy object obtained as a result of invoking the userInteractionFor*** family of methods in TKSmartCardSlot and TKSmartCard.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteraction;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteraction {}
);

impl TKSmartCardUserInteraction {
    extern_methods!(
        /// Delegate for state observing of the interaction.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn TKSmartCardUserInteractionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn TKSmartCardUserInteractionDelegate>>,
        );

        /// Initial interaction timeout. If set to 0, the reader-defined default timeout is used.
        ///
        /// Note: Default value: 0
        #[unsafe(method(initialTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn initialTimeout(&self) -> NSTimeInterval;

        /// Setter for [`initialTimeout`][Self::initialTimeout].
        #[unsafe(method(setInitialTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInitialTimeout(&self, initial_timeout: NSTimeInterval);

        /// Timeout after the first key stroke. If set to 0, the reader-defined default timeout is used.
        ///
        /// Note: Default value: 0
        #[unsafe(method(interactionTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn interactionTimeout(&self) -> NSTimeInterval;

        /// Setter for [`interactionTimeout`][Self::interactionTimeout].
        #[unsafe(method(setInteractionTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInteractionTimeout(&self, interaction_timeout: NSTimeInterval);

        #[cfg(feature = "block2")]
        /// Runs the interaction.
        #[unsafe(method(runWithReply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runWithReply(&self, reply: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>);

        /// Attempts to cancel a running interaction. Note that for some interactions, this functionality might not be available.
        ///
        /// Returns: Returns NO if the operation is not running, or cancelling is not supported.
        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancel(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteraction {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A representation of user interaction for secure PIN operations on a Smart Card reader.
    ///
    /// ## Overview
    ///
    /// There are two types of user interactions: those for secure PIN change and those for secure PIN validation. These interactions are instances of the [`TKSmartCardUserInteractionForSecurePINChange`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforsecurepinchange), or [`TKSmartCardUserInteractionForSecurePINVerification`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforsecurepinverification) subclasses of [`TKSmartCardUserInteractionForPINOperation`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforpinoperation), respectively.
    ///
    /// You interact with instances of one of the subclasses of [`TKSmartCardUserInteractionForPINOperation`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforpinoperation) when calling the [`userInteractionForSecurePINChangeWithPINFormat:APDU:currentPINByteOffset:newPINByteOffset:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/userinteractionforsecurepinchange(_:apdu:currentpinbyteoffset:newpinbyteoffset:)) and [`userInteractionForSecurePINVerificationWithPINFormat:APDU:PINByteOffset:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/userinteractionforsecurepinverification(_:apdu:pinbyteoffset:)) methods on an [`TKSmartCard`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard) object.
    ///
    /// The result of a user interaction is available once the interaction has completed.
    ///
    ///
    /// User interaction for the secure PIN operations on the SmartCard reader.
    ///
    /// Note: Result is available after the interaction has been successfully completed.
    #[unsafe(super(TKSmartCardUserInteraction, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteractionForPINOperation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteractionForPINOperation {}
);

impl TKSmartCardUserInteractionForPINOperation {
    extern_methods!(
        /// Bitmask specifying condition(s) under which PIN entry should be considered complete.
        ///
        /// Note: Default value: TKSmartCardPINCompletionKey
        #[unsafe(method(PINCompletion))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINCompletion(&self) -> TKSmartCardPINCompletion;

        /// Setter for [`PINCompletion`][Self::PINCompletion].
        #[unsafe(method(setPINCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINCompletion(&self, pin_completion: TKSmartCardPINCompletion);

        /// List of message indices referring to a predefined message table. It is used to specify the type and number of messages displayed during the PIN operation.
        ///
        /// If nil, the reader does not display any message (reader specific). Typically, PIN verification takes 1 message, PIN modification 1-3 messages.
        ///
        /// Note: Default value: nil
        #[unsafe(method(PINMessageIndices))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINMessageIndices(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`PINMessageIndices`][Self::PINMessageIndices].
        #[unsafe(method(setPINMessageIndices:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINMessageIndices(&self, pin_message_indices: Option<&NSArray<NSNumber>>);

        /// Locale defining the language of displayed messages. If set to nil, the user's current locale is used.
        ///
        /// Note: Default value: the user's current locale
        #[unsafe(method(locale))]
        #[unsafe(method_family = none)]
        pub unsafe fn locale(&self) -> Option<Retained<NSLocale>>;

        /// Setter for [`locale`][Self::locale].
        ///
        /// # Safety
        ///
        /// `locale` might not allow `None`.
        #[unsafe(method(setLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocale(&self, locale: Option<&NSLocale>);

        /// SW1SW2 result code.
        #[unsafe(method(resultSW))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultSW(&self) -> u16;

        /// Setter for [`resultSW`][Self::resultSW].
        #[unsafe(method(setResultSW:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResultSW(&self, result_sw: u16);

        /// Optional block of returned data (without SW1SW2 bytes).
        #[unsafe(method(resultData))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`resultData`][Self::resultData].
        #[unsafe(method(setResultData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResultData(&self, result_data: Option<&NSData>);
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteractionForPINOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A representation of the user interaction for secure PIN change verification on a Smart Card reader.
    ///
    /// ## Overview
    ///
    /// The result of a user interaction is available once the interaction has completed.
    ///
    ///
    /// User interaction for the secure PIN verification on the SmartCard reader.
    ///
    /// Note: Result is available after the interaction has been successfully completed.
    #[unsafe(super(
        TKSmartCardUserInteractionForPINOperation,
        TKSmartCardUserInteraction,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteractionForSecurePINVerification;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteractionForSecurePINVerification {}
);

impl TKSmartCardUserInteractionForSecurePINVerification {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteractionForSecurePINVerification {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A representation of the user interaction for secure PIN change operations on a Smart Card reader.
    ///
    /// ## Overview
    ///
    /// The result of a user interaction is available once the interaction has completed.
    ///
    ///
    /// User interaction for the secure PIN change on the SmartCard reader.
    ///
    /// Note: Result is available after the interaction has been successfully completed.
    #[unsafe(super(
        TKSmartCardUserInteractionForPINOperation,
        TKSmartCardUserInteraction,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteractionForSecurePINChange;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteractionForSecurePINChange {}
);

impl TKSmartCardUserInteractionForSecurePINChange {
    extern_methods!(
        /// Bitmask specifying whether PIN confirmation should be requested.
        ///
        /// Note: Default value: TKSmartCardPINConfirmationNone
        #[unsafe(method(PINConfirmation))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINConfirmation(&self) -> TKSmartCardPINConfirmation;

        /// Setter for [`PINConfirmation`][Self::PINConfirmation].
        #[unsafe(method(setPINConfirmation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINConfirmation(&self, pin_confirmation: TKSmartCardPINConfirmation);
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteractionForSecurePINChange {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A single smart card reader slot in the system.
    ///
    /// ## Overview
    ///
    /// Use the [`TKSmartCardSlotManager`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotmanager) class to manage all the smart card reader slots available to the system. You can retrieve the names of available smart card reader slots for a system using the [`slotNames`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotmanager/slotnames) property of a manager object, and access instances of [`TKSmartCardSlot`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslot) using the  [`getSlotWithName:reply:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotmanager/getslot(withname:reply:)) method.
    ///
    ///
    /// Represents single slot which can contain SmartCard.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardSlot;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardSlot {}
);

impl TKSmartCardSlot {
    extern_methods!(
        /// Current state of the slot.  Use KVO to be notified about state changes.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> TKSmartCardSlotState;

        #[cfg(feature = "TKSmartCardATR")]
        /// ATR of the inserted SmartCard, or nil if no or mute SmartCard is inserted.
        #[unsafe(method(ATR))]
        #[unsafe(method_family = none)]
        pub unsafe fn ATR(&self) -> Option<Retained<TKSmartCardATR>>;

        /// Name of the SmartCard reader slot.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        /// Maximal length of input APDU that the slot is able to transfer to the card.
        #[unsafe(method(maxInputLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxInputLength(&self) -> NSInteger;

        /// Maximal length of output APDU that the slot is able to transfer from the card.
        #[unsafe(method(maxOutputLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxOutputLength(&self) -> NSInteger;

        /// Creates new object representing currently inserted and valid card.
        ///
        /// It is possible to instantiate multiple objects for single card, exclusivity is handled by sessions on the level of created SmartCard objects.
        ///
        /// Returns: Newly created SmartCard object, or nil if slot does not contain valid card.
        #[unsafe(method(makeSmartCard))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeSmartCard(&self) -> Option<Retained<TKSmartCard>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardSlot {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A representation of a smart card.
    ///
    /// ## Overview
    ///
    /// This class provides an interface for managing sessions with a smart card, transmitting requests, and facilitating user interaction.
    ///
    /// You can create a [`TKSmartCard`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard) object when a smart card is inserted into a slot, by calling the [`makeSmartCard`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslot/makesmartcard()) method on the corresponding [`TKSmartCardSlot`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslot) object. To start communicating with the smart card, call the [`beginSessionWithReply:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/beginsession(reply:)) method on the [`TKSmartCard`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard) object. Once an exclusive session has been established, you transmit data using the [`transmitRequest:reply:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/transmit(_:reply:)) method. After youâ€™ve finished communicating with a smart card, you call the [`endSession`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/endsession()) method.
    ///
    /// If the smart card is physically removed from its slot, the session object becomes invalid, and any further calls to [`transmitRequest:reply:`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/transmit(_:reply:)) will return an error. You can use Key-Value Observing on the [`valid`](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard/isvalid) property to be notified when a smart card is invalidated, due to being removed from the slot or another reason.
    ///
    ///
    /// Represents SmartCard inserted in the slot. Once the card is physically removed from the slot, the session object is invalid and will always fail the operation invoked on it.  In order to communicate with the card, an exclusive session must be established.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCard;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCard {}
);

impl TKSmartCard {
    extern_methods!(
        /// Slot in which is this card inserted.
        #[unsafe(method(slot))]
        #[unsafe(method_family = none)]
        pub unsafe fn slot(&self) -> Retained<TKSmartCardSlot>;

        /// Flag indicating whether card is valid, i.e. it was not removed from the reader.  Use Key-Value-Observing to be notified about card removal.
        #[unsafe(method(valid))]
        #[unsafe(method_family = none)]
        pub unsafe fn valid(&self) -> bool;

        #[cfg(feature = "TKSmartCardATR")]
        /// Bitmask containing allowed protocols to be used when communicating with the card.  This property is consulted only during connection to the card, changes are not propagated to already connected session.  By default, any protocol can be used.
        #[unsafe(method(allowedProtocols))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowedProtocols(&self) -> TKSmartCardProtocol;

        #[cfg(feature = "TKSmartCardATR")]
        /// Setter for [`allowedProtocols`][Self::allowedProtocols].
        #[unsafe(method(setAllowedProtocols:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowedProtocols(&self, allowed_protocols: TKSmartCardProtocol);

        #[cfg(feature = "TKSmartCardATR")]
        /// Protocol used for communication with the SmartCard.  If no card session is established, TKSmartCardProtocolNone is set.
        #[unsafe(method(currentProtocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentProtocol(&self) -> TKSmartCardProtocol;

        /// Flag indicating whether card session should be considered as sensitive.  Sensitive session always gets card after reset before communicating with it and never leaves card without reset to be used by another SmartCard object.  This might be important in case that card session contain some important state which should not leak to another SmartCard object (possibly running in another, foreign application).  Default is NO.
        #[unsafe(method(sensitive))]
        #[unsafe(method_family = none)]
        pub unsafe fn sensitive(&self) -> bool;

        /// Setter for [`sensitive`][Self::sensitive].
        #[unsafe(method(setSensitive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSensitive(&self, sensitive: bool);

        /// User-specified context kept as long as the card is powered.  Once the card is removed or another TKSmartCard object opens session, this property is automatically set to nil.
        #[unsafe(method(context))]
        #[unsafe(method_family = none)]
        pub unsafe fn context(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`context`][Self::context].
        ///
        /// # Safety
        ///
        /// `context` should be of the correct type.
        #[unsafe(method(setContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContext(&self, context: Option<&AnyObject>);

        #[cfg(feature = "block2")]
        /// Begins session with the card.
        ///
        /// When session exists, other requests for sessions from other card objects to the same card are blocked. Session is reference-counted, the same amount of 'end' calls must be done to really terminate the session. Note that finishing session does not automatically mean that the card is disconnected; it only happens when another session from different card object is requested.
        ///
        /// Parameter `success`: Signals whether session was successfully started.
        ///
        /// Parameter `error`: More information about error preventing the transaction to start
        #[unsafe(method(beginSessionWithReply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginSessionWithReply(
            &self,
            reply: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Transmits raw command to the card.  This call is allowed only inside session.
        ///
        /// Parameter `request`: Request part of APDU
        ///
        /// Parameter `reponse`: Response part of APDU, or nil if communication with the card failed
        ///
        /// Parameter `error`: Error details when communication with the card failed
        #[unsafe(method(transmitRequest:reply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn transmitRequest_reply(
            &self,
            request: &NSData,
            reply: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        /// Terminates the transaction. If no transaction is pending any more, the connection will be closed if there is another session in the system waiting for the transaction.
        #[unsafe(method(endSession))]
        #[unsafe(method_family = none)]
        pub unsafe fn endSession(&self);

        /// Creates a new user interaction object for secure PIN verification using the SmartCard reader facilities (typically a HW keypad).
        ///
        /// Note: This interaction is only allowed within a session.
        ///
        /// Parameter `PINFormat`: PIN format descriptor.
        ///
        /// Parameter `APDU`: Predefined APDU in which the SmartCard reader fills in the PIN.
        ///
        /// Parameter `PINByteOffset`: Offset in bytes within APDU data field to mark a location of a PIN block for filling in the entered PIN (currently unused, must be 0).
        ///
        /// Returns: A new user interaction object, or nil if this feature is not supported by the SmartCard reader. After the interaction has been successfully completed the operation result is available in the result properites.
        #[unsafe(method(userInteractionForSecurePINVerificationWithPINFormat:APDU:PINByteOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInteractionForSecurePINVerificationWithPINFormat_APDU_PINByteOffset(
            &self,
            pin_format: &TKSmartCardPINFormat,
            apdu: &NSData,
            pin_byte_offset: NSInteger,
        ) -> Option<Retained<TKSmartCardUserInteractionForSecurePINVerification>>;

        /// Creates a new user interaction object for secure PIN change using the SmartCard reader facilities (typically a HW keypad).
        ///
        /// Note: This interaction is only allowed within a session.
        ///
        /// Parameter `PINFormat`: PIN format descriptor.
        ///
        /// Parameter `APDU`: Predefined APDU in which the SmartCard reader fills in the PIN(s).
        ///
        /// Parameter `currentPINByteOffset`: Offset in bytes within APDU data field to mark a location of a PIN block for filling in the current PIN.
        ///
        /// Parameter `newPINByteOffset`: Offset in bytes within APDU data field to mark a location of a PIN block for filling in the new PIN.
        ///
        /// Returns: A new user interaction object, or nil if this feature is not supported by the SmartCard reader. After the interaction has been successfully completed the operation result is available in the result properites.
        #[unsafe(method(userInteractionForSecurePINChangeWithPINFormat:APDU:currentPINByteOffset:newPINByteOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInteractionForSecurePINChangeWithPINFormat_APDU_currentPINByteOffset_newPINByteOffset(
            &self,
            pin_format: &TKSmartCardPINFormat,
            apdu: &NSData,
            current_pin_byte_offset: NSInteger,
            new_pin_byte_offset: NSInteger,
        ) -> Option<Retained<TKSmartCardUserInteractionForSecurePINChange>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCard {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// APDULevelTransmit.
///
/// Extension of base TKSmartCard interface implementing ISO7816-3 and ISO7816-4 structured APDU transmission.
impl TKSmartCard {
    extern_methods!(
        /// CLA byte which will be used for sendIns: APDU transmits.  Default value is 0x00.
        #[unsafe(method(cla))]
        #[unsafe(method_family = none)]
        pub unsafe fn cla(&self) -> u8;

        /// Setter for [`cla`][Self::cla].
        #[unsafe(method(setCla:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCla(&self, cla: u8);

        /// Flag indicating whether extended length APDUs should be used. It is automatically enabled only when used slot supports transmitting extended length commands and card announces that extended length APDU are supported in its ATR. However, caller can explicitly override this decision.
        #[unsafe(method(useExtendedLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn useExtendedLength(&self) -> bool;

        /// Setter for [`useExtendedLength`][Self::useExtendedLength].
        #[unsafe(method(setUseExtendedLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseExtendedLength(&self, use_extended_length: bool);

        /// Flag indicating whether command chaining of APDU with data field longer than 255 bytes can be used.  It is automatically enabled when card announces that command chaining is supported in its ATR.  However, caller can explicitly override this decision.
        #[unsafe(method(useCommandChaining))]
        #[unsafe(method_family = none)]
        pub unsafe fn useCommandChaining(&self) -> bool;

        /// Setter for [`useCommandChaining`][Self::useCommandChaining].
        #[unsafe(method(setUseCommandChaining:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseCommandChaining(&self, use_command_chaining: bool);

        #[cfg(feature = "block2")]
        /// Transmits APDU to the card and returns response.
        ///
        /// Asynchronous high level variant of command for transmitting APDU to the card.  Handles all ISO7816-4 APDU cases translation to proper sequences according to used protocol.  Consults useExtendedAPDU and useCommandChaining properties and uses these modes whenever appropriate and beneficial for sending requested APDU request.
        ///
        /// Parameter `ins`: INS code of the APDU
        ///
        /// Parameter `p1`: P1 code of the APDU
        ///
        /// Parameter `p2`: P2 code of the APDU
        ///
        /// Parameter `requestData`: Data field of the APDU, or nil if no input data field should be present (i.e case1 or case2 APDUs).  Length of the data serves as Lc field of the APDU.
        ///
        /// Parameter `le`: Expected number of bytes to be returned, or nil if no output data are expected (i.e. case1 or case3 APDUs). To get as much bytes as card provides, pass
        /// @
        /// 0.
        ///
        /// Parameter `replyData`: Block of returned data without SW1SW2 bytes, or nil if an error occured.
        ///
        /// Parameter `sw`: SW1SW2 result code, first two bytes of returned card's reply.
        ///
        /// Parameter `error`: Contains error details when nil is returned.  Specific error is also filled in if there was no communication error, but card returned other SW code than 0x9000.
        #[unsafe(method(sendIns:p1:p2:data:le:reply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIns_p1_p2_data_le_reply(
            &self,
            ins: u8,
            p1: u8,
            p2: u8,
            request_data: Option<&NSData>,
            le: Option<&NSNumber>,
            reply: &block2::DynBlock<dyn Fn(*mut NSData, u16, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Synchronous variant of session creation.  Begins the session, executes given block and ends session.
        ///
        /// Parameter `error`: Error receiving more information when transaction failed to start or block failed for some reason.
        ///
        /// Parameter `block`: Block to be executed when the session was successfully begun.
        ///
        /// Returns: Returns YES if the session was successfully begun and block returned YES, otherwise NO.
        #[unsafe(method(inSessionWithError:executeBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn inSessionWithError_executeBlock(
            &self,
            error: Option<&mut Option<Retained<NSError>>>,
            block: &block2::DynBlock<dyn Fn(*mut *mut NSError) -> Bool>,
        ) -> bool;

        /// Transmits APDU to the card and returns response.
        ///
        /// Synchronous high level variant of command for transmitting APDU to the card.  Handles all ISO7816-4 APDU cases translation to proper sequences according to used protocol.  Should be used in block passed to -[TKSmartCard inSessionWithError:executeBlock:] method.
        ///
        /// Parameter `ins`: INS code of the APDU
        ///
        /// Parameter `p1`: P1 code of the APDU
        ///
        /// Parameter `p2`: P2 code of the APDU
        ///
        /// Parameter `data`: Data field of the APDU.  Length of the data serves as Lc field of the APDU
        ///
        /// Parameter `le`: Expected number of bytes to be returned, or nil if no output data are expected (i.e. case1 or case3 APDUs). To get as much bytes as card provides, pass
        /// @
        /// 0.
        ///
        /// Parameter `sw`: On output, filled with SW1SW2 result code
        ///
        /// Parameter `error`: Contains error details when nil is returned.  Specific error is also filled in if there was no communication error, but card returned other SW code than 0x9000.
        ///
        /// Returns: Returned data field, excluding SW status bytes.  If an error occured, returns nil.
        ///
        /// # Safety
        ///
        /// `sw` must be a valid pointer.
        #[unsafe(method(sendIns:p1:p2:data:le:sw:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIns_p1_p2_data_le_sw_error(
            &self,
            ins: u8,
            p1: u8,
            p2: u8,
            request_data: Option<&NSData>,
            le: Option<&NSNumber>,
            sw: NonNull<u16>,
        ) -> Result<Retained<NSData>, Retained<NSError>>;
    );
}
