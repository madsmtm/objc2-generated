//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Represents pool of SmartCard reader slots.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotmanager?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardSlotManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardSlotManager {}
);

impl TKSmartCardSlotManager {
    extern_methods!(
        /// Global pool of SmartCard reader slots.
        /// macOS: Note that defaultManager instance is accessible only if the calling application has 'com.apple.security.smartcard' entitlement set to Boolean:YES.  If the calling application does not have this entitlement, defaultManager is always set to nil.
        /// iOS: The defaultManager instance is always accessible.
        #[unsafe(method(defaultManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultManager() -> Option<Retained<TKSmartCardSlotManager>>;

        /// Array of currently known slots in the system.  Slots are identified by NSString name instances.  Use KVO to be notified about slots arrivals and removals.
        #[unsafe(method(slotNames))]
        #[unsafe(method_family = none)]
        pub unsafe fn slotNames(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "block2")]
        /// Instantiates smartcard reader slot of specified name.  If specified name is not registered, reports nil.
        #[unsafe(method(getSlotWithName:reply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getSlotWithName_reply(
            &self,
            name: &NSString,
            reply: &block2::DynBlock<dyn Fn(*mut TKSmartCardSlot)>,
        );

        /// Gets SmartCard reader slot with specified name.  If reader slot with this name does not exist, returns nil.
        #[unsafe(method(slotNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn slotNamed(&self, name: &NSString) -> Option<Retained<TKSmartCardSlot>>;

        #[cfg(all(feature = "TKSmartCardSlotNFCSession", feature = "block2"))]
        /// Creates an NFC smart card slot using the device's hardware and presents a system UI.
        ///
        /// Parameter `message`: Message shown in the system-presented UI
        ///
        /// Parameter `completion`: Completion handler which returns the NFC session of the created slot or an error on failure.
        /// If an NFC slot already exists and current caller is not the initial creator `TKErrorCodeObjectNotFound` error is returned.
        ///
        ///
        /// To finish the NFC session and dismiss the system-presented UI use `TKSmartCardSlotNFCSession.endSession`.
        ///
        ///
        /// Warning: Caller requires `com.apple.developer.nfc.readersession.iso7816.select-identifiers` Info.plist record which specifies application identifiers of the NFC cards
        ///
        /// ```text
        ///  https://developer.apple.com/documentation/bundleresources/information-property-list/com.apple.developer.nfc.readersession.iso7816.select-identifiers
        /// ```
        #[unsafe(method(createNFCSlotWithMessage:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createNFCSlotWithMessage_completion(
            &self,
            message: Option<&NSString>,
            completion: &block2::DynBlock<dyn Fn(*mut TKSmartCardSlotNFCSession, *mut NSError)>,
        );

        /// Determines whether NFC (Near Field Communication) is supported on this device.
        ///
        ///
        /// Returns: `YES` if NFC is supported and available for use, NO otherwise.
        #[unsafe(method(isNFCSupported))]
        #[unsafe(method_family = none)]
        pub unsafe fn isNFCSupported(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardSlotManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Enumerates all possible slot states.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslotstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardSlotState(pub NSInteger);
impl TKSmartCardSlotState {
    /// Slot is no longer known to the system.  This is terminal state for TKSmartCardSlot instance, once reached, the slot instance can never be revived.
    #[doc(alias = "TKSmartCardSlotStateMissing")]
    pub const Missing: Self = Self(0);
    /// The slot is empty, no card is inserted.
    #[doc(alias = "TKSmartCardSlotStateEmpty")]
    pub const Empty: Self = Self(1);
    /// The card was inserted into the slot and an initial probe is in progress.
    #[doc(alias = "TKSmartCardSlotStateProbing")]
    pub const Probing: Self = Self(2);
    /// The card inserted in the slot does not answer.
    #[doc(alias = "TKSmartCardSlotStateMuteCard")]
    pub const MuteCard: Self = Self(3);
    /// Card properly answered to reset.
    #[doc(alias = "TKSmartCardSlotStateValidCard")]
    pub const ValidCard: Self = Self(4);
}

unsafe impl Encode for TKSmartCardSlotState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardSlotState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerates all possible PIN character sets.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardpincharset?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardPINCharset(pub NSInteger);
impl TKSmartCardPINCharset {
    /// PIN is only composed of digits.
    #[doc(alias = "TKSmartCardPINCharsetNumeric")]
    pub const Numeric: Self = Self(0);
    /// PIN can be composed of digits and letters.
    #[doc(alias = "TKSmartCardPINCharsetAlphanumeric")]
    pub const Alphanumeric: Self = Self(1);
    /// PIN can be composed of digits and uppercase letters.
    #[doc(alias = "TKSmartCardPINCharsetUpperAlphanumeric")]
    pub const UpperAlphanumeric: Self = Self(2);
}

unsafe impl Encode for TKSmartCardPINCharset {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINCharset {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerates all possible PIN encoding types.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardpinencoding?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardPINEncoding(pub NSInteger);
impl TKSmartCardPINEncoding {
    /// Characters are encoded in Binary format (1234 => 01h 02h 03h 04h).
    #[doc(alias = "TKSmartCardPINEncodingBinary")]
    pub const Binary: Self = Self(0);
    /// Characters are encoded in ASCII format (1234 => 31h 32h 33h 34h).
    #[doc(alias = "TKSmartCardPINEncodingASCII")]
    pub const ASCII: Self = Self(1);
    /// Characters (only digits) are encoded in BCD format (1234 => 12h 34h).
    #[doc(alias = "TKSmartCardPINEncodingBCD")]
    pub const BCD: Self = Self(2);
}

unsafe impl Encode for TKSmartCardPINEncoding {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerates all posible PIN justification types.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardpinjustification?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardPINJustification(pub NSInteger);
impl TKSmartCardPINJustification {
    /// Justify to the left.
    #[doc(alias = "TKSmartCardPINJustificationLeft")]
    pub const Left: Self = Self(0);
    /// Justify to the right.
    #[doc(alias = "TKSmartCardPINJustificationRight")]
    pub const Right: Self = Self(1);
}

unsafe impl Encode for TKSmartCardPINJustification {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINJustification {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Bitmask specifying condition(s) under which PIN entry should be considered complete.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardpincompletion?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardPINCompletion(pub NSUInteger);
bitflags::bitflags! {
    impl TKSmartCardPINCompletion: NSUInteger {
/// Completion by reaching the maximum PIN length.
        #[doc(alias = "TKSmartCardPINCompletionMaxLength")]
        const MaxLength = 1<<0;
/// Completion by pressing the validation key.
        #[doc(alias = "TKSmartCardPINCompletionKey")]
        const Key = 1<<1;
/// Completion by timeout expiration.
        #[doc(alias = "TKSmartCardPINCompletionTimeout")]
        const Timeout = 1<<2;
    }
}

unsafe impl Encode for TKSmartCardPINCompletion {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINCompletion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Bitmask specifying whether PIN confirmation should be requested.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardpinconfirmation?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct TKSmartCardPINConfirmation(pub NSUInteger);
bitflags::bitflags! {
    impl TKSmartCardPINConfirmation: NSUInteger {
/// No confirmation requested.
        #[doc(alias = "TKSmartCardPINConfirmationNone")]
        const None = 0;
/// Confirmation (entry) of the new PIN requested.
        #[doc(alias = "TKSmartCardPINConfirmationNew")]
        const New = 1<<0;
/// Confirmation (entry) of the current PIN requested.
        #[doc(alias = "TKSmartCardPINConfirmationCurrent")]
        const Current = 1<<1;
    }
}

unsafe impl Encode for TKSmartCardPINConfirmation {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for TKSmartCardPINConfirmation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Specifies PIN formatting properties.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardpinformat?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardPINFormat;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardPINFormat {}
);

impl TKSmartCardPINFormat {
    extern_methods!(
        /// Format of PIN characters.
        ///
        /// Note: Default value: TKSmartCardPINCharsetNumeric
        #[unsafe(method(charset))]
        #[unsafe(method_family = none)]
        pub unsafe fn charset(&self) -> TKSmartCardPINCharset;

        /// Setter for [`charset`][Self::charset].
        #[unsafe(method(setCharset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCharset(&self, charset: TKSmartCardPINCharset);

        /// Encoding of PIN characters.
        ///
        /// Note: Default value: TKSmartCardPINEncodingASCII
        #[unsafe(method(encoding))]
        #[unsafe(method_family = none)]
        pub unsafe fn encoding(&self) -> TKSmartCardPINEncoding;

        /// Setter for [`encoding`][Self::encoding].
        #[unsafe(method(setEncoding:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEncoding(&self, encoding: TKSmartCardPINEncoding);

        /// Minimum number of characters to form a valid PIN.
        ///
        /// Note: Default value: 4
        #[unsafe(method(minPINLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn minPINLength(&self) -> NSInteger;

        /// Setter for [`minPINLength`][Self::minPINLength].
        #[unsafe(method(setMinPINLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinPINLength(&self, min_pin_length: NSInteger);

        /// Maximum number of characters to form a valid PIN.
        ///
        /// Note: Default value: 8
        #[unsafe(method(maxPINLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxPINLength(&self) -> NSInteger;

        /// Setter for [`maxPINLength`][Self::maxPINLength].
        #[unsafe(method(setMaxPINLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaxPINLength(&self, max_pin_length: NSInteger);

        /// Total length of the PIN block in bytes.
        ///
        /// Note: Default value: 8
        #[unsafe(method(PINBlockByteLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINBlockByteLength(&self) -> NSInteger;

        /// Setter for [`PINBlockByteLength`][Self::PINBlockByteLength].
        #[unsafe(method(setPINBlockByteLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINBlockByteLength(&self, pin_block_byte_length: NSInteger);

        /// PIN justification within the PIN block.
        ///
        /// Note: Default value: TKSmartCardPINJustificationLeft
        #[unsafe(method(PINJustification))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINJustification(&self) -> TKSmartCardPINJustification;

        /// Setter for [`PINJustification`][Self::PINJustification].
        #[unsafe(method(setPINJustification:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINJustification(&self, pin_justification: TKSmartCardPINJustification);

        /// Offset in bits within the PIN block to mark a location for filling in the formatted PIN (justified with respect to PINJustification).
        ///
        /// Note: Default value: 0
        ///
        /// The offset, in bits, within the PIN block to mark a location for filling in the formatted PIN, which is justified with respect to the PINJustification property value.
        #[unsafe(method(PINBitOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINBitOffset(&self) -> NSInteger;

        /// Setter for [`PINBitOffset`][Self::PINBitOffset].
        #[unsafe(method(setPINBitOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINBitOffset(&self, pin_bit_offset: NSInteger);

        /// Offset in bits within the PIN block to mark a location for filling in the PIN length (always left justified).
        ///
        /// Note: Default value: 0
        ///
        /// The offset, in bits, within the PIN block to mark a location for filling in the PIN length, which is always left justified.
        #[unsafe(method(PINLengthBitOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINLengthBitOffset(&self) -> NSInteger;

        /// Setter for [`PINLengthBitOffset`][Self::PINLengthBitOffset].
        #[unsafe(method(setPINLengthBitOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINLengthBitOffset(&self, pin_length_bit_offset: NSInteger);

        /// Size in bits of the PIN length field. If set to 0, PIN length is not written.
        ///
        /// Note: Default value: 0
        #[unsafe(method(PINLengthBitSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINLengthBitSize(&self) -> NSInteger;

        /// Setter for [`PINLengthBitSize`][Self::PINLengthBitSize].
        #[unsafe(method(setPINLengthBitSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINLengthBitSize(&self, pin_length_bit_size: NSInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardPINFormat {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Delegate for user interactions involving the SmartCard reader.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractiondelegate?language=objc)
    pub unsafe trait TKSmartCardUserInteractionDelegate {
        /// A valid character has been entered.
        #[optional]
        #[unsafe(method(characterEnteredInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn characterEnteredInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// A correction key has been pressed.
        #[optional]
        #[unsafe(method(correctionKeyPressedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn correctionKeyPressedInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// The validation key has been pressed (end of PIN entry).
        #[optional]
        #[unsafe(method(validationKeyPressedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn validationKeyPressedInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// An invalid character has been entered.
        #[optional]
        #[unsafe(method(invalidCharacterEnteredInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn invalidCharacterEnteredInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );

        /// Indicates that the old PIN needs to be entered.
        #[optional]
        #[unsafe(method(oldPINRequestedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn oldPINRequestedInUserInteraction(&self, interaction: &TKSmartCardUserInteraction);

        /// Indicates that the new PIN needs to be entered.
        #[optional]
        #[unsafe(method(newPINRequestedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn newPINRequestedInUserInteraction(&self, interaction: &TKSmartCardUserInteraction);

        /// Indicates that the new PIN needs to be confirmed (re-entered).
        #[optional]
        #[unsafe(method(newPINConfirmationRequestedInUserInteraction:))]
        #[unsafe(method_family = none)]
        unsafe fn newPINConfirmationRequestedInUserInteraction(
            &self,
            interaction: &TKSmartCardUserInteraction,
        );
    }
);

extern_class!(
    /// Represents handle to a user interaction involving the SmartCard reader.
    ///
    /// It is a proxy object obtained as a result of invoking the userInteractionFor*** family of methods in TKSmartCardSlot and TKSmartCard.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteraction?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteraction;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteraction {}
);

impl TKSmartCardUserInteraction {
    extern_methods!(
        /// Delegate for state observing of the interaction.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn TKSmartCardUserInteractionDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn TKSmartCardUserInteractionDelegate>>,
        );

        /// Initial interaction timeout. If set to 0, the reader-defined default timeout is used.
        ///
        /// Note: Default value: 0
        #[unsafe(method(initialTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn initialTimeout(&self) -> NSTimeInterval;

        /// Setter for [`initialTimeout`][Self::initialTimeout].
        #[unsafe(method(setInitialTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInitialTimeout(&self, initial_timeout: NSTimeInterval);

        /// Timeout after the first key stroke. If set to 0, the reader-defined default timeout is used.
        ///
        /// Note: Default value: 0
        #[unsafe(method(interactionTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn interactionTimeout(&self) -> NSTimeInterval;

        /// Setter for [`interactionTimeout`][Self::interactionTimeout].
        #[unsafe(method(setInteractionTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInteractionTimeout(&self, interaction_timeout: NSTimeInterval);

        #[cfg(feature = "block2")]
        /// Runs the interaction.
        #[unsafe(method(runWithReply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runWithReply(&self, reply: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>);

        /// Attempts to cancel a running interaction. Note that for some interactions, this functionality might not be available.
        ///
        /// Returns: Returns NO if the operation is not running, or cancelling is not supported.
        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancel(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteraction {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// User interaction for the secure PIN operations on the SmartCard reader.
    ///
    /// Note: Result is available after the interaction has been successfully completed.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforpinoperation?language=objc)
    #[unsafe(super(TKSmartCardUserInteraction, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteractionForPINOperation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteractionForPINOperation {}
);

impl TKSmartCardUserInteractionForPINOperation {
    extern_methods!(
        /// Bitmask specifying condition(s) under which PIN entry should be considered complete.
        ///
        /// Note: Default value: TKSmartCardPINCompletionKey
        #[unsafe(method(PINCompletion))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINCompletion(&self) -> TKSmartCardPINCompletion;

        /// Setter for [`PINCompletion`][Self::PINCompletion].
        #[unsafe(method(setPINCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINCompletion(&self, pin_completion: TKSmartCardPINCompletion);

        /// List of message indices referring to a predefined message table. It is used to specify the type and number of messages displayed during the PIN operation.
        ///
        /// If nil, the reader does not display any message (reader specific). Typically, PIN verification takes 1 message, PIN modification 1-3 messages.
        ///
        /// Note: Default value: nil
        #[unsafe(method(PINMessageIndices))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINMessageIndices(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`PINMessageIndices`][Self::PINMessageIndices].
        #[unsafe(method(setPINMessageIndices:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINMessageIndices(&self, pin_message_indices: Option<&NSArray<NSNumber>>);

        /// Locale defining the language of displayed messages. If set to nil, the user's current locale is used.
        ///
        /// Note: Default value: the user's current locale
        #[unsafe(method(locale))]
        #[unsafe(method_family = none)]
        pub unsafe fn locale(&self) -> Option<Retained<NSLocale>>;

        /// Setter for [`locale`][Self::locale].
        #[unsafe(method(setLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocale(&self, locale: Option<&NSLocale>);

        /// SW1SW2 result code.
        #[unsafe(method(resultSW))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultSW(&self) -> u16;

        /// Setter for [`resultSW`][Self::resultSW].
        #[unsafe(method(setResultSW:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResultSW(&self, result_sw: u16);

        /// Optional block of returned data (without SW1SW2 bytes).
        #[unsafe(method(resultData))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`resultData`][Self::resultData].
        #[unsafe(method(setResultData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResultData(&self, result_data: Option<&NSData>);
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteractionForPINOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// User interaction for the secure PIN verification on the SmartCard reader.
    ///
    /// Note: Result is available after the interaction has been successfully completed.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforsecurepinverification?language=objc)
    #[unsafe(super(
        TKSmartCardUserInteractionForPINOperation,
        TKSmartCardUserInteraction,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteractionForSecurePINVerification;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteractionForSecurePINVerification {}
);

impl TKSmartCardUserInteractionForSecurePINVerification {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteractionForSecurePINVerification {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// User interaction for the secure PIN change on the SmartCard reader.
    ///
    /// Note: Result is available after the interaction has been successfully completed.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcarduserinteractionforsecurepinchange?language=objc)
    #[unsafe(super(
        TKSmartCardUserInteractionForPINOperation,
        TKSmartCardUserInteraction,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardUserInteractionForSecurePINChange;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardUserInteractionForSecurePINChange {}
);

impl TKSmartCardUserInteractionForSecurePINChange {
    extern_methods!(
        /// Bitmask specifying whether PIN confirmation should be requested.
        ///
        /// Note: Default value: TKSmartCardPINConfirmationNone
        #[unsafe(method(PINConfirmation))]
        #[unsafe(method_family = none)]
        pub unsafe fn PINConfirmation(&self) -> TKSmartCardPINConfirmation;

        /// Setter for [`PINConfirmation`][Self::PINConfirmation].
        #[unsafe(method(setPINConfirmation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPINConfirmation(&self, pin_confirmation: TKSmartCardPINConfirmation);
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardUserInteractionForSecurePINChange {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Represents single slot which can contain SmartCard.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcardslot?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCardSlot;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCardSlot {}
);

impl TKSmartCardSlot {
    extern_methods!(
        /// Current state of the slot.  Use KVO to be notified about state changes.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> TKSmartCardSlotState;

        #[cfg(feature = "TKSmartCardATR")]
        /// ATR of the inserted SmartCard, or nil if no or mute SmartCard is inserted.
        #[unsafe(method(ATR))]
        #[unsafe(method_family = none)]
        pub unsafe fn ATR(&self) -> Option<Retained<TKSmartCardATR>>;

        /// Name of the SmartCard reader slot.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        /// Maximal length of input APDU that the slot is able to transfer to the card.
        #[unsafe(method(maxInputLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxInputLength(&self) -> NSInteger;

        /// Maximal length of output APDU that the slot is able to transfer from the card.
        #[unsafe(method(maxOutputLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxOutputLength(&self) -> NSInteger;

        /// Creates new object representing currently inserted and valid card.
        ///
        /// It is possible to instantiate multiple objects for single card, exclusivity is handled by sessions on the level of created SmartCard objects.
        ///
        /// Returns: Newly created SmartCard object, or nil if slot does not contain valid card.
        #[unsafe(method(makeSmartCard))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeSmartCard(&self) -> Option<Retained<TKSmartCard>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCardSlot {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Represents SmartCard inserted in the slot. Once the card is physically removed from the slot, the session object is invalid and will always fail the operation invoked on it.  In order to communicate with the card, an exclusive session must be established.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tksmartcard?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKSmartCard;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKSmartCard {}
);

impl TKSmartCard {
    extern_methods!(
        /// Slot in which is this card inserted.
        #[unsafe(method(slot))]
        #[unsafe(method_family = none)]
        pub unsafe fn slot(&self) -> Retained<TKSmartCardSlot>;

        /// Flag indicating whether card is valid, i.e. it was not removed from the reader.  Use Key-Value-Observing to be notified about card removal.
        #[unsafe(method(valid))]
        #[unsafe(method_family = none)]
        pub unsafe fn valid(&self) -> bool;

        #[cfg(feature = "TKSmartCardATR")]
        /// Bitmask containing allowed protocols to be used when communicating with the card.  This property is consulted only during connection to the card, changes are not propagated to already connected session.  By default, any protocol can be used.
        #[unsafe(method(allowedProtocols))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowedProtocols(&self) -> TKSmartCardProtocol;

        #[cfg(feature = "TKSmartCardATR")]
        /// Setter for [`allowedProtocols`][Self::allowedProtocols].
        #[unsafe(method(setAllowedProtocols:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowedProtocols(&self, allowed_protocols: TKSmartCardProtocol);

        #[cfg(feature = "TKSmartCardATR")]
        /// Protocol used for communication with the SmartCard.  If no card session is established, TKSmartCardProtocolNone is set.
        #[unsafe(method(currentProtocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentProtocol(&self) -> TKSmartCardProtocol;

        /// Flag indicating whether card session should be considered as sensitive.  Sensitive session always gets card after reset before communicating with it and never leaves card without reset to be used by another SmartCard object.  This might be important in case that card session contain some important state which should not leak to another SmartCard object (possibly running in another, foreign application).  Default is NO.
        #[unsafe(method(sensitive))]
        #[unsafe(method_family = none)]
        pub unsafe fn sensitive(&self) -> bool;

        /// Setter for [`sensitive`][Self::sensitive].
        #[unsafe(method(setSensitive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSensitive(&self, sensitive: bool);

        /// User-specified context kept as long as the card is powered.  Once the card is removed or another TKSmartCard object opens session, this property is automatically set to nil.
        #[unsafe(method(context))]
        #[unsafe(method_family = none)]
        pub unsafe fn context(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`context`][Self::context].
        #[unsafe(method(setContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContext(&self, context: Option<&AnyObject>);

        #[cfg(feature = "block2")]
        /// Begins session with the card.
        ///
        /// When session exists, other requests for sessions from other card objects to the same card are blocked. Session is reference-counted, the same amount of 'end' calls must be done to really terminate the session. Note that finishing session does not automatically mean that the card is disconnected; it only happens when another session from different card object is requested.
        ///
        /// Parameter `success`: Signals whether session was successfully started.
        ///
        /// Parameter `error`: More information about error preventing the transaction to start
        #[unsafe(method(beginSessionWithReply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginSessionWithReply(
            &self,
            reply: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Transmits raw command to the card.  This call is allowed only inside session.
        ///
        /// Parameter `request`: Request part of APDU
        ///
        /// Parameter `reponse`: Response part of APDU, or nil if communication with the card failed
        ///
        /// Parameter `error`: Error details when communication with the card failed
        #[unsafe(method(transmitRequest:reply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn transmitRequest_reply(
            &self,
            request: &NSData,
            reply: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        /// Terminates the transaction. If no transaction is pending any more, the connection will be closed if there is another session in the system waiting for the transaction.
        #[unsafe(method(endSession))]
        #[unsafe(method_family = none)]
        pub unsafe fn endSession(&self);

        /// Creates a new user interaction object for secure PIN verification using the SmartCard reader facilities (typically a HW keypad).
        ///
        /// Note: This interaction is only allowed within a session.
        ///
        /// Parameter `PINFormat`: PIN format descriptor.
        ///
        /// Parameter `APDU`: Predefined APDU in which the SmartCard reader fills in the PIN.
        ///
        /// Parameter `PINByteOffset`: Offset in bytes within APDU data field to mark a location of a PIN block for filling in the entered PIN (currently unused, must be 0).
        ///
        /// Returns: A new user interaction object, or nil if this feature is not supported by the SmartCard reader. After the interaction has been successfully completed the operation result is available in the result properites.
        #[unsafe(method(userInteractionForSecurePINVerificationWithPINFormat:APDU:PINByteOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInteractionForSecurePINVerificationWithPINFormat_APDU_PINByteOffset(
            &self,
            pin_format: &TKSmartCardPINFormat,
            apdu: &NSData,
            pin_byte_offset: NSInteger,
        ) -> Option<Retained<TKSmartCardUserInteractionForSecurePINVerification>>;

        /// Creates a new user interaction object for secure PIN change using the SmartCard reader facilities (typically a HW keypad).
        ///
        /// Note: This interaction is only allowed within a session.
        ///
        /// Parameter `PINFormat`: PIN format descriptor.
        ///
        /// Parameter `APDU`: Predefined APDU in which the SmartCard reader fills in the PIN(s).
        ///
        /// Parameter `currentPINByteOffset`: Offset in bytes within APDU data field to mark a location of a PIN block for filling in the current PIN.
        ///
        /// Parameter `newPINByteOffset`: Offset in bytes within APDU data field to mark a location of a PIN block for filling in the new PIN.
        ///
        /// Returns: A new user interaction object, or nil if this feature is not supported by the SmartCard reader. After the interaction has been successfully completed the operation result is available in the result properites.
        #[unsafe(method(userInteractionForSecurePINChangeWithPINFormat:APDU:currentPINByteOffset:newPINByteOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInteractionForSecurePINChangeWithPINFormat_APDU_currentPINByteOffset_newPINByteOffset(
            &self,
            pin_format: &TKSmartCardPINFormat,
            apdu: &NSData,
            current_pin_byte_offset: NSInteger,
            new_pin_byte_offset: NSInteger,
        ) -> Option<Retained<TKSmartCardUserInteractionForSecurePINChange>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl TKSmartCard {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// APDULevelTransmit.
/// Extension of base TKSmartCard interface implementing ISO7816-3 and ISO7816-4 structured APDU transmission.
impl TKSmartCard {
    extern_methods!(
        /// CLA byte which will be used for sendIns: APDU transmits.  Default value is 0x00.
        #[unsafe(method(cla))]
        #[unsafe(method_family = none)]
        pub unsafe fn cla(&self) -> u8;

        /// Setter for [`cla`][Self::cla].
        #[unsafe(method(setCla:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCla(&self, cla: u8);

        /// Flag indicating whether extended length APDUs should be used. It is automatically enabled only when used slot supports transmitting extended length commands and card announces that extended length APDU are supported in its ATR. However, caller can explicitly override this decision.
        #[unsafe(method(useExtendedLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn useExtendedLength(&self) -> bool;

        /// Setter for [`useExtendedLength`][Self::useExtendedLength].
        #[unsafe(method(setUseExtendedLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseExtendedLength(&self, use_extended_length: bool);

        /// Flag indicating whether command chaining of APDU with data field longer than 255 bytes can be used.  It is automatically enabled when card announces that command chaining is supported in its ATR.  However, caller can explicitly override this decision.
        #[unsafe(method(useCommandChaining))]
        #[unsafe(method_family = none)]
        pub unsafe fn useCommandChaining(&self) -> bool;

        /// Setter for [`useCommandChaining`][Self::useCommandChaining].
        #[unsafe(method(setUseCommandChaining:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseCommandChaining(&self, use_command_chaining: bool);

        #[cfg(feature = "block2")]
        /// Transmits APDU to the card and returns response.
        ///
        /// Asynchronous high level variant of command for transmitting APDU to the card.  Handles all ISO7816-4 APDU cases translation to proper sequences according to used protocol.  Consults useExtendedAPDU and useCommandChaining properties and uses these modes whenever appropriate and beneficial for sending requested APDU request.
        ///
        /// Parameter `ins`: INS code of the APDU
        ///
        /// Parameter `p1`: P1 code of the APDU
        ///
        /// Parameter `p2`: P2 code of the APDU
        ///
        /// Parameter `requestData`: Data field of the APDU, or nil if no input data field should be present (i.e case1 or case2 APDUs).  Length of the data serves as Lc field of the APDU.
        ///
        /// Parameter `le`: Expected number of bytes to be returned, or nil if no output data are expected (i.e. case1 or case3 APDUs). To get as much bytes as card provides, pass
        /// @
        /// 0.
        ///
        /// Parameter `replyData`: Block of returned data without SW1SW2 bytes, or nil if an error occured.
        ///
        /// Parameter `sw`: SW1SW2 result code, first two bytes of returned card's reply.
        ///
        /// Parameter `error`: Contains error details when nil is returned.  Specific error is also filled in if there was no communication error, but card returned other SW code than 0x9000.
        #[unsafe(method(sendIns:p1:p2:data:le:reply:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIns_p1_p2_data_le_reply(
            &self,
            ins: u8,
            p1: u8,
            p2: u8,
            request_data: Option<&NSData>,
            le: Option<&NSNumber>,
            reply: &block2::DynBlock<dyn Fn(*mut NSData, u16, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Synchronous variant of session creation.  Begins the session, executes given block and ends session.
        ///
        /// Parameter `error`: Error receiving more information when transaction failed to start or block failed for some reason.
        ///
        /// Parameter `block`: Block to be executed when the session was successfully begun.
        ///
        /// Returns: Returns YES if the session was successfully begun and block returned YES, otherwise NO.
        #[unsafe(method(inSessionWithError:executeBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn inSessionWithError_executeBlock(
            &self,
            error: Option<&mut Option<Retained<NSError>>>,
            block: &block2::DynBlock<dyn Fn(*mut *mut NSError) -> Bool>,
        ) -> bool;

        /// Transmits APDU to the card and returns response.
        ///
        /// Synchronous high level variant of command for transmitting APDU to the card.  Handles all ISO7816-4 APDU cases translation to proper sequences according to used protocol.  Should be used in block passed to -[TKSmartCard inSessionWithError:executeBlock:] method.
        ///
        /// Parameter `ins`: INS code of the APDU
        ///
        /// Parameter `p1`: P1 code of the APDU
        ///
        /// Parameter `p2`: P2 code of the APDU
        ///
        /// Parameter `data`: Data field of the APDU.  Length of the data serves as Lc field of the APDU
        ///
        /// Parameter `le`: Expected number of bytes to be returned, or nil if no output data are expected (i.e. case1 or case3 APDUs). To get as much bytes as card provides, pass
        /// @
        /// 0.
        ///
        /// Parameter `sw`: On output, filled with SW1SW2 result code
        ///
        /// Parameter `error`: Contains error details when nil is returned.  Specific error is also filled in if there was no communication error, but card returned other SW code than 0x9000.
        ///
        /// Returns: Returned data field, excluding SW status bytes.  If an error occured, returns nil.
        #[unsafe(method(sendIns:p1:p2:data:le:sw:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIns_p1_p2_data_le_sw_error(
            &self,
            ins: u8,
            p1: u8,
            p2: u8,
            request_data: Option<&NSData>,
            le: Option<&NSNumber>,
            sw: NonNull<u16>,
        ) -> Result<Retained<NSData>, Retained<NSError>>;
    );
}
