//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Holds configuration of one class of tokens
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tktokendriverconfiguration?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKTokenDriverConfiguration;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKTokenDriverConfiguration {}
);

impl TKTokenDriverConfiguration {
    extern_methods!(
        #[cfg(feature = "TKToken")]
        /// Contains dictionary of token class configurations keyed by TKTokenDriverClassID of token driver.
        ///
        /// Hosting application of token extension will contain the list of configurations for hosted token extensions. All other callers will get an empty array. This means that only token's hosting application can actually modify token's configuration. Typically, hosting application will contain only one token extension, therefore this dictionary will have one element.
        #[unsafe(method(driverConfigurations))]
        #[unsafe(method_family = none)]
        pub unsafe fn driverConfigurations(
        ) -> Retained<NSDictionary<TKTokenDriverClassID, TKTokenDriverConfiguration>>;

        #[cfg(feature = "TKToken")]
        /// ClassID of the token configuration. ClassID is taken from
        /// `com.apple.ctk.class-id`token extension attribute.
        #[unsafe(method(classID))]
        #[unsafe(method_family = none)]
        pub unsafe fn classID(&self) -> Retained<TKTokenDriverClassID>;

        #[cfg(feature = "TKToken")]
        /// Dictionary of all currently configured tokens for this token class, keyed by instanceID.
        #[unsafe(method(tokenConfigurations))]
        #[unsafe(method_family = none)]
        pub unsafe fn tokenConfigurations(
            &self,
        ) -> Retained<NSDictionary<TKTokenInstanceID, TKTokenConfiguration>>;

        #[cfg(feature = "TKToken")]
        /// Creates new configuration object for token with specified instanceID and adds it into tokenConfigurations dictionary. If configuration with specified instanceID already exists, it is replaced with new empty configuration.
        #[unsafe(method(addTokenConfigurationForTokenInstanceID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTokenConfigurationForTokenInstanceID(
            &self,
            instance_id: &TKTokenInstanceID,
        ) -> Retained<TKTokenConfiguration>;

        #[cfg(feature = "TKToken")]
        /// Removes configuration with specified tokenID. Does nothing if no such token configuration exists.
        #[unsafe(method(removeTokenConfigurationForTokenInstanceID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTokenConfigurationForTokenInstanceID(
            &self,
            instance_id: &TKTokenInstanceID,
        );

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Holds configuration of one token identified by unique token's instanceID
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/cryptotokenkit/tktokenconfiguration?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct TKTokenConfiguration;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for TKTokenConfiguration {}
);

impl TKTokenConfiguration {
    extern_methods!(
        #[cfg(feature = "TKToken")]
        /// Unique, persistent identifier of this token, always created by specific token implementation. Typically implemented by some kind of serial number of the target hardware, for example SmartCard serial number.
        #[unsafe(method(instanceID))]
        #[unsafe(method_family = none)]
        pub unsafe fn instanceID(&self) -> Retained<TKTokenInstanceID>;

        /// Additional configuration available for token instance.
        ///
        /// Token implementation and its hosting application can use this data for specifying any additional configuration for the token. System does not interpret this data in any way. For example, network-based HSM can store here (using Codable or other serialization mechanisms) target network address, access credentials and the list of identities accessible in the HSM.
        #[unsafe(method(configurationData))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`configurationData`][Self::configurationData].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setConfigurationData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConfigurationData(&self, configuration_data: Option<&NSData>);

        #[cfg(feature = "TKTokenKeychainItem")]
        /// All keychain items of this token.
        #[unsafe(method(keychainItems))]
        #[unsafe(method_family = none)]
        pub unsafe fn keychainItems(&self) -> Retained<NSArray<TKTokenKeychainItem>>;

        #[cfg(feature = "TKTokenKeychainItem")]
        /// Setter for [`keychainItems`][Self::keychainItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setKeychainItems:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setKeychainItems(&self, keychain_items: &NSArray<TKTokenKeychainItem>);

        #[cfg(all(feature = "TKToken", feature = "TKTokenKeychainItem"))]
        /// Returns keychain item key with specified objectID.  Fills error with TKTokenErrorCodeObjectNotFound if no such key exists.
        ///
        /// # Safety
        ///
        /// `object_id` should be of the correct type.
        #[unsafe(method(keyForObjectID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyForObjectID_error(
            &self,
            object_id: &TKTokenObjectID,
        ) -> Result<Retained<TKTokenKeychainKey>, Retained<NSError>>;

        #[cfg(all(feature = "TKToken", feature = "TKTokenKeychainItem"))]
        /// Returns certificate with specified objectID.  Fills error with TKTokenErrorCodeObjectNotFound if no such certificate exists.
        ///
        /// # Safety
        ///
        /// `object_id` should be of the correct type.
        #[unsafe(method(certificateForObjectID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn certificateForObjectID_error(
            &self,
            object_id: &TKTokenObjectID,
        ) -> Result<Retained<TKTokenKeychainCertificate>, Retained<NSError>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
