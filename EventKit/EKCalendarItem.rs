//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/eventkit/ekcalendaritem?language=objc)
    #[unsafe(super(EKObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "EKObject")]
    pub struct EKCalendarItem;
);

#[cfg(feature = "EKObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for EKCalendarItem {}
);

#[cfg(feature = "EKObject")]
impl EKCalendarItem {
    extern_methods!(
        /// This is now deprecated; use calendarItemIdentifier instead.
        #[unsafe(method(UUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn UUID(&self) -> Retained<NSString>;

        #[cfg(feature = "EKCalendar")]
        /// The calendar that this calendar item belongs to.
        ///
        /// This will be nil for new calendar items until you set it.
        #[unsafe(method(calendar))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendar(&self) -> Option<Retained<EKCalendar>>;

        #[cfg(feature = "EKCalendar")]
        /// Setter for [`calendar`][Self::calendar].
        #[unsafe(method(setCalendar:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCalendar(&self, calendar: Option<&EKCalendar>);

        /// A unique identifier for a calendar item.
        ///
        /// Item identifiers are not sync-proof in that a full sync will lose
        /// this identifier, so you should always have a back up plan for dealing
        /// with a reminder that is no longer fetchable by this property, e.g. by title, etc.
        /// Use [EKEventStore calendarItemWithIdentifier:] to look up the item by this value.
        #[unsafe(method(calendarItemIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendarItemIdentifier(&self) -> Retained<NSString>;

        /// A server-provided identifier for this calendar item
        ///
        /// This identifier, provided by the server, allows you to reference the same event or reminder across
        /// multiple devices. For calendars stored locally on the device, including the birthday calendar,
        /// it simply passes through to calendarItemIdentifier.
        ///
        /// This identifier is unique as of creation for every calendar item.  However, there are some
        /// cases where duplicate copies of a calendar item can exist in the same database, including:
        /// - A calendar item was imported from an ICS file into multiple calendars
        /// - An event was created in a calendar shared with the user and the user was also invited to the event
        /// - The user is a delegate of a calendar that also has this event
        /// - A subscribed calendar was added to multiple accounts
        /// In such cases, you should choose between calendar items based on other factors, such as
        /// the calendar or source.
        ///
        /// This identifier is the same for all occurrences of a recurring event. If you wish to differentiate
        /// between occurrences, you may want to use the start date.
        ///
        /// This may be nil for new calendar items that do not yet belong to a calendar.
        ///
        /// In addition, there are two caveats for Exchange-based calendars:
        /// - This identifier will be different between EventKit on iOS versus OS X
        /// - This identifier will be different between devices for EKReminders
        #[unsafe(method(calendarItemExternalIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendarItemExternalIdentifier(&self) -> Option<Retained<NSString>>;

        /// The title of this calendar item.
        ///
        /// This will be an empty string for new calendar items until you set it.
        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub unsafe fn title(&self) -> Retained<NSString>;

        /// Setter for [`title`][Self::title].
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTitle(&self, title: Option<&NSString>);

        #[unsafe(method(location))]
        #[unsafe(method_family = none)]
        pub unsafe fn location(&self) -> Option<Retained<NSString>>;

        /// Setter for [`location`][Self::location].
        #[unsafe(method(setLocation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocation(&self, location: Option<&NSString>);

        #[unsafe(method(notes))]
        #[unsafe(method_family = none)]
        pub unsafe fn notes(&self) -> Option<Retained<NSString>>;

        /// Setter for [`notes`][Self::notes].
        #[unsafe(method(setNotes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNotes(&self, notes: Option<&NSString>);

        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`URL`][Self::URL].
        #[unsafe(method(setURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setURL(&self, url: Option<&NSURL>);

        #[unsafe(method(lastModifiedDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn lastModifiedDate(&self) -> Option<Retained<NSDate>>;

        #[unsafe(method(creationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn creationDate(&self) -> Option<Retained<NSDate>>;

        #[unsafe(method(timeZone))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeZone(&self) -> Option<Retained<NSTimeZone>>;

        /// Setter for [`timeZone`][Self::timeZone].
        #[unsafe(method(setTimeZone:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeZone(&self, time_zone: Option<&NSTimeZone>);

        #[unsafe(method(hasAlarms))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasAlarms(&self) -> bool;

        #[unsafe(method(hasRecurrenceRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasRecurrenceRules(&self) -> bool;

        #[unsafe(method(hasAttendees))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasAttendees(&self) -> bool;

        #[unsafe(method(hasNotes))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasNotes(&self) -> bool;

        #[cfg(feature = "EKParticipant")]
        #[unsafe(method(attendees))]
        #[unsafe(method_family = none)]
        pub unsafe fn attendees(&self) -> Option<Retained<NSArray<EKParticipant>>>;

        #[cfg(feature = "EKAlarm")]
        #[unsafe(method(alarms))]
        #[unsafe(method_family = none)]
        pub unsafe fn alarms(&self) -> Option<Retained<NSArray<EKAlarm>>>;

        #[cfg(feature = "EKAlarm")]
        /// Setter for [`alarms`][Self::alarms].
        #[unsafe(method(setAlarms:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAlarms(&self, alarms: Option<&NSArray<EKAlarm>>);

        #[cfg(feature = "EKAlarm")]
        /// Adds an alarm to this item.
        ///
        /// This method add an alarm to an item. Be warned that some calendars can only
        /// allow a certain maximum number of alarms. When this item is saved, it will
        /// truncate any extra alarms from the array.
        #[unsafe(method(addAlarm:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAlarm(&self, alarm: &EKAlarm);

        #[cfg(feature = "EKAlarm")]
        /// Removes an alarm from this item.
        #[unsafe(method(removeAlarm:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAlarm(&self, alarm: &EKAlarm);

        #[cfg(feature = "EKRecurrenceRule")]
        /// An array of EKRecurrenceRules, or nil if none.
        #[unsafe(method(recurrenceRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn recurrenceRules(&self) -> Option<Retained<NSArray<EKRecurrenceRule>>>;

        #[cfg(feature = "EKRecurrenceRule")]
        /// Setter for [`recurrenceRules`][Self::recurrenceRules].
        #[unsafe(method(setRecurrenceRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRecurrenceRules(
            &self,
            recurrence_rules: Option<&NSArray<EKRecurrenceRule>>,
        );

        #[cfg(feature = "EKRecurrenceRule")]
        #[unsafe(method(addRecurrenceRule:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRecurrenceRule(&self, rule: &EKRecurrenceRule);

        #[cfg(feature = "EKRecurrenceRule")]
        #[unsafe(method(removeRecurrenceRule:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeRecurrenceRule(&self, rule: &EKRecurrenceRule);

        #[unsafe(method(hasMaximumAlarms))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasMaximumAlarms(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "EKObject")]
impl EKCalendarItem {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
