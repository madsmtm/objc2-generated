//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
use objc2_app_kit::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The EKCalendar class represents a calendar for events.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/eventkit/ekcalendar?language=objc)
    #[unsafe(super(EKObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "EKObject")]
    pub struct EKCalendar;
);

#[cfg(feature = "EKObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for EKCalendar {}
);

#[cfg(feature = "EKObject")]
impl EKCalendar {
    extern_methods!(
        #[cfg(feature = "EKEventStore")]
        #[unsafe(method(calendarWithEventStore:))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendarWithEventStore(event_store: &EKEventStore) -> Retained<EKCalendar>;

        #[cfg(all(feature = "EKEventStore", feature = "EKTypes"))]
        /// Creates a new autoreleased calendar that may contain the given entity type.
        ///
        /// You can only create calendars that accept either reminders or events via our API.
        /// However, other servers might allow mixing the two (though it is not common).
        ///
        ///
        /// Parameter `entityType`: The entity type that this calendar may support.
        ///
        /// Parameter `eventStore`: The event store in which to create this calendar.
        #[unsafe(method(calendarForEntityType:eventStore:))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendarForEntityType_eventStore(
            entity_type: EKEntityType,
            event_store: &EKEventStore,
        ) -> Retained<EKCalendar>;

        #[cfg(feature = "EKSource")]
        /// The source representing the 'account' this calendar belongs to.
        /// This is only settable when initially creating a calendar and then
        /// effectively read-only after that. That is, you can create a calendar,
        /// but you cannot move it to another source.
        ///
        /// This will be nil for new calendars until you set it.
        #[unsafe(method(source))]
        #[unsafe(method_family = none)]
        pub unsafe fn source(&self) -> Option<Retained<EKSource>>;

        #[cfg(feature = "EKSource")]
        /// Setter for [`source`][Self::source].
        #[unsafe(method(setSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSource(&self, source: Option<&EKSource>);

        /// A unique identifier for the calendar. It is not sync-proof in that a full
        /// sync will lose this identifier, so you should always have a back up plan for dealing
        /// with a calendar that is no longer fetchable by this property, e.g. by title, type, color, etc.
        /// Use [EKEventStore calendarWithIdentifier:] to look up the calendar by this value.
        #[unsafe(method(calendarIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendarIdentifier(&self) -> Retained<NSString>;

        /// The title of the calendar.
        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub unsafe fn title(&self) -> Retained<NSString>;

        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTitle(&self, title: &NSString);

        #[cfg(feature = "EKTypes")]
        /// The type of the calendar as a EKCalendarType. This is actually based on
        /// what source the calendar is in, as well as whether it is a subscribed calendar.
        ///
        /// CalDAV subscribed calendars have type EKCalendarTypeCalDAV with isSubscribed = YES.
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub unsafe fn r#type(&self) -> EKCalendarType;

        /// Represents whether you can this add, remove, or modify items in this calendar.
        #[unsafe(method(allowsContentModifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsContentModifications(&self) -> bool;

        /// YES if this calendar is a subscribed calendar.
        #[unsafe(method(isSubscribed))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSubscribed(&self) -> bool;

        /// If this is set to YES, it means you cannot modify any attributes of
        /// the calendar or delete it. It does NOT imply that you cannot add events
        /// or reminders to the calendar.
        #[unsafe(method(isImmutable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isImmutable(&self) -> bool;

        #[cfg(feature = "objc2-core-graphics")]
        /// Returns the calendar color as a CGColorRef.
        ///
        /// This will be nil for new calendars until you set it.
        #[unsafe(method(CGColor))]
        #[unsafe(method_family = none)]
        pub unsafe fn CGColor(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`CGColor`][Self::CGColor].
        #[unsafe(method(setCGColor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCGColor(&self, cg_color: Option<&CGColor>);

        #[cfg(feature = "objc2-app-kit")]
        #[cfg(target_os = "macos")]
        /// Returns the calendar color as a NSColor.
        ///
        /// This will be nil for new calendars until you set it.
        #[unsafe(method(color))]
        #[unsafe(method_family = none)]
        pub unsafe fn color(&self) -> Retained<NSColor>;

        #[cfg(feature = "objc2-app-kit")]
        #[cfg(target_os = "macos")]
        /// Setter for [`color`][Self::color].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setColor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColor(&self, color: Option<&NSColor>);

        #[cfg(feature = "EKTypes")]
        /// Returns a bitfield of supported event availabilities, or EKCalendarEventAvailabilityNone
        /// if this calendar does not support setting availability on an event.
        #[unsafe(method(supportedEventAvailabilities))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedEventAvailabilities(&self) -> EKCalendarEventAvailabilityMask;

        #[cfg(feature = "EKTypes")]
        #[unsafe(method(allowedEntityTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowedEntityTypes(&self) -> EKEntityMask;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "EKObject")]
impl EKCalendar {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
