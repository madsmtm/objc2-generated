//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A node for use in manually creating decision trees, representing a specific question and possible answers, or an action that follows from answering other questions.
    ///
    /// ## Overview
    ///
    /// A [`GKDecisionNode`](https://developer.apple.com/documentation/gameplaykit/gkdecisionnode) instance represents an element in a decision tree (a [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree) object). Decision trees contain two kinds of nodes. Some nodes, including the tree’s root node, represent individual decisions to be made (also called a question or _attribute_) and reference child nodes for each possible outcome of (or _branch_ from) that decision. Each branch can lead to another question node, or to a leaf node—nodes that have no branches represent a final outcome (or _action_) to result from the tree’s decision-making process. After creating a decision tree from a set of nodes, you can present the tree with a set of inputs (values for attributes, or answers to questions) and the tree provides a final action that follows from the branches corresponding to each attribute.
    ///
    /// There are two ways to create a decision tree. You use the [`GKDecisionNode`](https://developer.apple.com/documentation/gameplaykit/gkdecisionnode) class directly only when you want to define an entire decision tree manually—that is, to specify each question, the possible branches from each question, and the possible final actions. To create such a decision tree, start with the [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree)  [`initWithAttribute:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/init(attribute:)) initializer, then use the methods listed in Creating Child Nodes for Decision Branches to add branches to the tree.
    ///
    /// To instead automatically learn a decision tree given a set of questions and example answers, use the [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree)  [`initWithExamples:actions:attributes:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/init(examples:actions:attributes:)) method.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKDecisionNode;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKDecisionNode {}
);

impl GKDecisionNode {
    extern_methods!(
        /// Creates a numeric branch to a node containing the specified attribute
        ///
        ///
        /// Parameter `value`: The value to create a branch with
        ///
        /// Parameter `attribute`: The attribute of the created node
        ///
        /// Returns: The node lead to by the branch
        ///
        /// # Safety
        ///
        /// `attribute` should be of the correct type.
        #[unsafe(method(createBranchWithValue:attribute:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createBranchWithValue_attribute(
            &self,
            value: &NSNumber,
            attribute: &ProtocolObject<dyn NSObjectProtocol>,
        ) -> Retained<Self>;

        /// Creates a predicated branch to a node containing the specified attribute
        ///
        ///
        /// Parameter `predicate`: The predicate to create a branch with
        ///
        /// Parameter `attribute`: The attribute of the created node
        ///
        /// Returns: The node lead to by the branch
        ///
        /// # Safety
        ///
        /// `attribute` should be of the correct type.
        #[unsafe(method(createBranchWithPredicate:attribute:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createBranchWithPredicate_attribute(
            &self,
            predicate: &NSPredicate,
            attribute: &ProtocolObject<dyn NSObjectProtocol>,
        ) -> Retained<Self>;

        /// Creates a random branch to a node containing the specified attribute
        ///
        ///
        /// Parameter `weight`: The weight to create a branch with (weighted for random selection)
        ///
        /// Parameter `attribute`: The attribute of the created node
        ///
        /// Returns: The node lead to by the branch
        ///
        ///
        /// See: GKDecisionTree
        ///
        /// # Safety
        ///
        /// `attribute` should be of the correct type.
        #[unsafe(method(createBranchWithWeight:attribute:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createBranchWithWeight_attribute(
            &self,
            weight: NSInteger,
            attribute: &ProtocolObject<dyn NSObjectProtocol>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKDecisionNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A data structure that models a set of specific questions, their possible answers, and the actions that follow from a series of answers.
    ///
    /// ## Overview
    ///
    /// You can define a decision tree manually, by specifying questions, answers, and actions, or you can allow the [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree) class to automatically learn a predictive model based on example data. A decision tree has several elements:
    ///
    /// - _Attributes_ represent individual questions to be answered or choices to be made.
    ///
    /// - _Branches_ are the possible answers to the questions or choices posed by each attribute.
    ///
    /// - _Actions_ are the final outcomes of the tree’s decision-making process. Each branch from an attribute leads either to another attribute or to an action.
    ///
    /// When you use the [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree) class, attributes and actions can be any object type relevant to your app or game. You can define branches for specific answer values, using predicates, or with weights that influence a random decision. For example, a strategy combat game might use a decision tree to choose what a character should do on its turn, based on several criteria about the match in progress. In this case:
    ///
    /// - For attributes, you might use (non-user-visible) strings that represent those criteria, such as `"Type?"` (what type of enemy is the character’s opponent?), `"HP?"` (how much health does the opponent have remaining?), and `"Special?"` (is the character’s special move available for use?).
    ///
    /// - For branches, you’d use an appropriate style for each attribute. The `"Type?"` attribute might have a branch for each possible enemy type, but the `"HP?"` attribute could use predicates to determine whether the enemy’s health is above or below a certain threshold value.
    ///
    /// - For actions, you might define your own enumerated type representing the kinds of attacks the character can choose (such as `Pound`, `Tackle`, and `Barrier`). Alternately, you might use instances of your own custom classes representing items or spells available to the character.
    ///
    /// [Figure 1](/documentation/gameplaykit/gkdecisiontree#1965709) illustrates a possible tree structure based on the above example attributes, branches, and actions.
    ///
    ///
    /// ![](https://docs-assets.developer.apple.com/published/830b9b95793f8ae2657e979f69f65b17/media-1965709%402x.png)
    ///
    ///
    /// ### Creating a Decision Tree
    ///
    /// The [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree) class offers two ways to create decision trees.
    ///
    /// In a _manually defined decision tree_, you define each attribute to be tested (or question to be asked), the possible branches (or answers) from each attribute, and the actions (or final outcomes) resulting from each complete series of attribute tests and branches. To manually create a tree, start by using the [`initWithAttribute:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/init(attribute:)) initializer to define the first question to be asked. Then, use [`GKDecisionNode`](https://developer.apple.com/documentation/gameplaykit/gkdecisionnode) methods on the new tree’s [`rootNode`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/rootnode) object to define branches and the child nodes they lead to, with accompanying attribute or action values.
    ///
    /// In a _learned decision tree_, you provide a set of attributes (or questions); a body of example items, each of which represents a set of attribute values (or answers to questions); and the final action to be taken for each example. The [`GKDecisionTree`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree) class then automatically infers a decision tree structure that, when presented with a set of attribute values matching or similar to one of your examples, predicts the corresponding action. To create a learned decision tree, use the [`initWithExamples:actions:attributes:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/init(examples:actions:attributes:)) initializer. The following table shows sample input for a learned decision tree (based on the same hypothetical game shown in [Figure 1](/documentation/gameplaykit/gkdecisiontree#1965709)).
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Opponent Type " }, Image { identifier: "spacer", metadata: None }, Text { text: " (“Type?” attribute)" }] }], [Paragraph { inline_content: [Text { text: "Opponent Health " }, Image { identifier: "spacer", metadata: None }, Text { text: " (“HP?” attribute)" }] }], [Paragraph { inline_content: [Text { text: "Can Use Special Move " }, Image { identifier: "spacer", metadata: None }, Text { text: " (“Special?” attribute)" }] }], [Paragraph { inline_content: [Text { text: "Move to Use " }, Image { identifier: "spacer", metadata: None }, Text { text: " (Action)" }] }]], [[Paragraph { inline_content: [Text { text: "Electric" }] }], [Paragraph { inline_content: [Text { text: "10" }] }], [Paragraph { inline_content: [Text { text: "Yes" }] }], [Paragraph { inline_content: [Text { text: "Psychic Strike" }] }]], [[Paragraph { inline_content: [Text { text: "Electric" }] }], [Paragraph { inline_content: [Text { text: "30" }] }], [Paragraph { inline_content: [Text { text: "No" }] }], [Paragraph { inline_content: [Text { text: "Pound" }] }]], [[Paragraph { inline_content: [Text { text: "Electric" }] }], [Paragraph { inline_content: [Text { text: "40" }] }], [Paragraph { inline_content: [Text { text: "Yes" }] }], [Paragraph { inline_content: [Text { text: "Barrier" }] }]], [[Paragraph { inline_content: [Text { text: "Fire" }] }], [Paragraph { inline_content: [Text { text: "10" }] }], [Paragraph { inline_content: [Text { text: "Yes" }] }], [Paragraph { inline_content: [Text { text: "Pound" }] }]], [[Paragraph { inline_content: [Text { text: "Fire" }] }], [Paragraph { inline_content: [Text { text: "30" }] }], [Paragraph { inline_content: [Text { text: "No" }] }], [Paragraph { inline_content: [Text { text: "Tackle" }] }]], [[Paragraph { inline_content: [Text { text: "Water" }] }], [Paragraph { inline_content: [Text { text: "10" }] }], [Paragraph { inline_content: [Text { text: "No" }] }], [Paragraph { inline_content: [Text { text: "Pound" }] }]], [[Paragraph { inline_content: [Text { text: "Water" }] }], [Paragraph { inline_content: [Text { text: "40" }] }], [Paragraph { inline_content: [Text { text: "No" }] }], [Paragraph { inline_content: [Text { text: "Tackle" }] }]]], alignments: None, metadata: None })
    /// After creating either kind of decision tree, you can use the inherited [`description`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/description) property to examine its structure.
    ///
    /// ### Making Decisions
    ///
    /// After you’ve created a tree, use the [`findActionForAnswers:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/findaction(foranswers:)) method to evaluate it and choose an action. When you call that method, you provide a set of inputs (values for attributes, or answers to questions), and the tree follows the branches corresponding to each input value to produce an action.
    ///
    /// <div class="warning">
    ///
    /// ### Tip
    ///  When defining an attribute with a small set of possible values, define your own enum type to name the possible values. Then use the underlying numeric value of that enum when building trees with the [`GKDecisionNode`](https://developer.apple.com/documentation/gameplaykit/gkdecisionnode) [`createBranchWithValue:attribute:`](https://developer.apple.com/documentation/gameplaykit/gkdecisionnode/createbranch(value:attribute:)) method or the [`initWithExamples:actions:attributes:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/init(examples:actions:attributes:)) initializer, and when passing a set of attribute values to the [`findActionForAnswers:`](https://developer.apple.com/documentation/gameplaykit/gkdecisiontree/findaction(foranswers:)) method.
    ///
    ///
    ///
    /// </div>
    /// For example, the following code evaluates a tree similar to the examples in [Figure 1](/documentation/gameplaykit/gkdecisiontree#1965709) and the table above:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let answers = [", "    \"Type?\": MyEnemyType.Electric.rawValue, // an enum value", "    \"HP?\": 20,", "    \"Special?\": true,", "]", "let action = myDecisionTree.findAction(forAnswers: answers)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSDictionary *answers = @{", "    @\"Type?\" : @(MyEnemyTypeElectric), // an enum value", "    @\"HP?\" : @20,", "    @\"Special?\" : @YES,", "};", "NSString *action = [myDecisionTree findActionForAnswers:answers];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKDecisionTree;
);

extern_conformance!(
    unsafe impl NSCoding for GKDecisionTree {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKDecisionTree {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for GKDecisionTree {}
);

impl GKDecisionTree {
    extern_methods!(
        /// The node for the decision tree that all other nodes descend from
        #[unsafe(method(rootNode))]
        #[unsafe(method_family = none)]
        pub unsafe fn rootNode(&self) -> Option<Retained<GKDecisionNode>>;

        #[cfg(feature = "GKRandomSource")]
        /// The random source used by the decision tree when descending on a random branch
        /// This must be set before creating any weighted branches
        ///
        /// See: GKDecisionNode
        #[unsafe(method(randomSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn randomSource(&self) -> Retained<GKRandomSource>;

        #[cfg(feature = "GKRandomSource")]
        /// Setter for [`randomSource`][Self::randomSource].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRandomSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRandomSource(&self, random_source: &GKRandomSource);

        /// Initializes the decision tree with a root node containing the provided attribute
        ///
        ///
        /// Parameter `attribute`: The attribute to be contained at the root of the tree
        ///
        /// Returns: GKDecisionTree with the set root
        ///
        /// # Safety
        ///
        /// `attribute` should be of the correct type.
        #[unsafe(method(initWithAttribute:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAttribute(
            this: Allocated<Self>,
            attribute: &ProtocolObject<dyn NSObjectProtocol>,
        ) -> Retained<Self>;

        /// Initializes and constructs a decision tree by learning from the provided examples
        /// &
        /// attributes
        ///
        ///
        /// Parameter `examples`: Must be an array of examples (with each example being a collection of the various attributes at a given state)
        ///
        /// Parameter `actions`: An array of the corresponding actions for each example. Ordered such that the first action matches with the first example in examples.
        ///
        /// Parameter `attributes`: The list of attributes. Ordered such that the first attribute matches with the first result in each example.
        /// So if we have two attributes: [distance, jump height], and two examples: [[20, 8], [15, 14]], and the resulting actions here: [Roll, Jump], we can think of this as a matrix:
        ///
        /// distance| height
        /// <
        /// -  Attributes
        /// _______|_______
        /// |       |       |
        /// |  20   |   8   |  jump
        /// |-------|-------|-------
        /// <
        /// -  Results
        /// |  15   |   14  |  roll
        /// |_______|_______|
        /// ^
        /// |
        /// Examples
        ///
        ///
        /// Returns: GKDecisionTree created by learning from the provided examples for the provided attributes
        ///
        /// # Safety
        ///
        /// - `examples` generic generic should be of the correct type.
        /// - `actions` generic should be of the correct type.
        /// - `attributes` generic should be of the correct type.
        #[unsafe(method(initWithExamples:actions:attributes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithExamples_actions_attributes(
            this: Allocated<Self>,
            examples: &NSArray<NSArray<ProtocolObject<dyn NSObjectProtocol>>>,
            actions: &NSArray<ProtocolObject<dyn NSObjectProtocol>>,
            attributes: &NSArray<ProtocolObject<dyn NSObjectProtocol>>,
        ) -> Retained<Self>;

        /// Initializes a decision tree from the contents of a file
        ///
        ///
        /// Parameter `url`: The URL from which the contents will be loaded
        ///
        /// Returns: The instance of the decision tree constructed
        #[unsafe(method(initWithURL:error:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_error(
            this: Allocated<Self>,
            url: &NSURL,
            error: Option<&NSError>,
        ) -> Retained<Self>;

        /// Exports a decision tree to the given URL
        ///
        ///
        /// Parameter `url`: The URL to which the contents will be exported
        ///
        /// Returns: The response indicating the status of the decision tree being successfully exported
        #[unsafe(method(exportToURL:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportToURL_error(&self, url: &NSURL, error: Option<&NSError>) -> bool;

        /// Will branch down from the root node to find the correct action attribute for the given collection of results and their respective attributes
        ///
        ///
        /// Parameter `answers`: The dictionary of attributes (keys) and their answers (values)
        ///
        /// Returns: The attribute found by traversing the tree given the provided answers
        ///
        /// # Safety
        ///
        /// - `answers` generic should be of the correct type.
        /// - `answers` generic should be of the correct type.
        #[unsafe(method(findActionForAnswers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findActionForAnswers(
            &self,
            answers: &NSDictionary<
                ProtocolObject<dyn NSObjectProtocol>,
                ProtocolObject<dyn NSObjectProtocol>,
            >,
        ) -> Option<Retained<ProtocolObject<dyn NSObjectProtocol>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKDecisionTree {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
