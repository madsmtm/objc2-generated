//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// The common interface for all randomization classes in (or usable with) GameplayKit.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The randomization services provided in GameplayKit are suitable for reliably creating deterministic, pseudorandom gameplay mechanics, but are not cryptographically robust. For cryptography, obfuscation, or cipher uses, use the Security framework, described in [Cryptographic Services Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172).
    ///
    ///
    ///
    /// </div>
    /// GameplayKit randomization classes include the [`GKRandomSource`](https://developer.apple.com/documentation/gameplaykit/gkrandomsource) and [`GKRandomDistribution`](https://developer.apple.com/documentation/gameplaykit/gkrandomdistribution) classes and their subclasses. You use those classes to generate random behavior for gameplay mechanics, and use this protocol type directly when composing random sources to create more complex randomizers.
    ///
    /// For more information on choosing and using randomizers in GameplayKit, read [Randomization](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// A protocol for random sources that can generate random numbers. This is the minimal interface needed
    /// to consume random values from a source; concrete subclasses should be used for configuring the
    /// production of random values.
    /// The availability of deterministic random sources is critical to creating reliable gameplay mechanics.
    /// Ensure that systems that should not influence each other have unique random sources and avoid sharing
    /// sources unless absolutely needed.
    ///
    /// This protocol allows you to provide custom random sources from classes that are not able to
    /// derive from GKRandomSource directly.
    pub unsafe trait GKRandom {
        /// Returns the next integer in the random sequence and moves ahead to the next one.
        /// The value is in the range of [INT32_MIN, INT32_MAX].
        /// The lower bits are not guaranteed to be random so please use another
        /// property for simple choices.
        ///
        ///
        /// See: nextBool
        ///
        /// See: nextUniform
        #[unsafe(method(nextInt))]
        #[unsafe(method_family = none)]
        unsafe fn nextInt(&self) -> NSInteger;

        /// Returns the next unsigned value in the random sequence that is less than upperBound.
        /// The value is in the range of [0, upperBound). Thus the value never equals or exceeeds upperBound.
        /// The unsigned nature and upper bound allows implementations to use logical shifts to return a
        /// value whose lower bits are more random than a similar call to nextInt.
        ///
        /// This is used to implement nextBool and nextUniform by default.
        #[unsafe(method(nextIntWithUpperBound:))]
        #[unsafe(method_family = none)]
        unsafe fn nextIntWithUpperBound(&self, upper_bound: NSUInteger) -> NSUInteger;

        /// Returns the next uniform float in the random sequence and moves ahead to the next one.
        /// The value is in the range of [0.0, 1.0].
        /// There is no weighting across the range so remapping this with a curve may give the best
        /// sampling distribution for your algorithm.
        ///
        /// By default this should be based on nextIntWithUpperBound:. Implementions may base it on
        /// another representation if needed.
        ///
        ///
        /// See: nextIntWithUpperBound:
        ///
        /// See: nextInt
        #[unsafe(method(nextUniform))]
        #[unsafe(method_family = none)]
        unsafe fn nextUniform(&self) -> c_float;

        /// Returns the next true or false value in the random sequence and moves ahead to the next one.
        /// The value is either nonzero (true) or zero (false).
        /// Use this for simple boolean switches in logic that don't require fuzzy evaluation.
        /// For fuzzy evaluation use nextUniform.
        ///
        /// By default this should be based on nextIntWithUpperBound:. Implementations may base it on
        /// another representation if needed.
        ///
        ///
        /// See: nextIntWithUpperBound:
        ///
        /// See: nextUniform
        #[unsafe(method(nextBool))]
        #[unsafe(method_family = none)]
        unsafe fn nextBool(&self) -> bool;
    }
);

extern_class!(
    /// The superclass for all basic randomization classes in GameplayKit.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The randomization services provided in GameplayKit are suitable for reliably creating deterministic, pseudorandom gameplay mechanics, but are not cryptographically robust. For cryptography, obfuscation, or cipher uses, use the Security framework, described in [Cryptographic Services Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172).
    ///
    ///
    ///
    /// </div>
    /// In most cases you do not use this class directly; instead, use one of the subclasses listed below. On its own, a random source provides little control over the range or distribution of generated random numbers; to specify such options, use a random source in conjunction with one of the [`GKRandomDistribution`](https://developer.apple.com/documentation/gameplaykit/gkrandomdistribution) classes.
    ///
    /// When you create an instance of [`GKRandomSource`](https://developer.apple.com/documentation/gameplaykit/gkrandomsource) or one of its subclasses, the resulting random source is both _independent_ and _deterministic_—that is, the sequence of numbers generated by one instance has no effect on the sequence generated by another instance, and that sequence can be replicated when necessary. For details on replicating sequences, see each of the random source classes.
    ///
    /// Your choice of random source class determines the algorithm used for random number generation:
    ///
    /// - The [`GKARC4RandomSource`](https://developer.apple.com/documentation/gameplaykit/gkarc4randomsource) class uses an algorithm similar to that employed in arc4random family of C functions. (However, instances of this class are independent from calls to the arc4random functions.)
    ///
    /// - The [`GKLinearCongruentialRandomSource`](https://developer.apple.com/documentation/gameplaykit/gklinearcongruentialrandomsource) class uses an algorithm that is faster, but less random, than the [`GKARC4RandomSource`](https://developer.apple.com/documentation/gameplaykit/gkarc4randomsource) class. (Specifically, the low bits of generated numbers repeat more often than the high bits.) Use this source when performance is more important than robust unpredictability.
    ///
    /// - The [`GKMersenneTwisterRandomSource`](https://developer.apple.com/documentation/gameplaykit/gkmersennetwisterrandomsource) class uses an algorithm that is slower, but more random, than the [`GKARC4RandomSource`](https://developer.apple.com/documentation/gameplaykit/gkarc4randomsource) class. Use this source when it’s important that your use of random numbers not show repeating patterns and performance is of less concern.
    ///
    ///
    /// A concrete random source that can generate random numbers. The implementation details are up to the system and
    /// if a particular algorithm is needed then use one of the provided subclasses.
    ///
    /// For certain specialized applications a shared system source may be needed and for those instances there is
    /// a wrapped interface over arc4random_*, accessible via +[GKRandomSource sharedRandom].
    ///
    ///
    /// See: GKARC4RandomSource
    ///
    /// See: GKLinearCongruentialRandomSource
    ///
    /// See: GKMersenneTwisterRandomSource
    ///
    /// See: GKRandomSource.systemRandom
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKRandomSource;
);

extern_conformance!(
    unsafe impl GKRandom for GKRandomSource {}
);

extern_conformance!(
    unsafe impl NSCoding for GKRandomSource {}
);

extern_conformance!(
    unsafe impl NSCopying for GKRandomSource {}
);

unsafe impl CopyingHelper for GKRandomSource {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for GKRandomSource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for GKRandomSource {}
);

impl GKRandomSource {
    extern_methods!(
        /// Creates a new random source initialized using bits from an entropy source like SecRandomCopyBytes.
        /// When used directly from the base class; this source is deterministic and performant but the underlying implementation
        /// details are not specified. Use a subclass with a specific algorithm implementation guaranteed if your application requires
        /// very stringent random source charateristics.
        ///
        ///
        /// See: GKARC4RandomSource
        ///
        /// See: GKLinearCongruentialRandomSource
        ///
        /// See: GKMersenneTwisterRandomSource
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Deserializes a random source from an NSCoder. All random sources support coding for serializing and deserializing the state
        /// of the random source. Each subclass has its own contract for what parts of the state is preserved when serialized but the
        /// general contract is that a serialized source must generate the same sequence of values as the original source would from the
        /// instant it was serialized.
        ///
        /// Note that the sharedRandom instance is an exception as it is explicitly seedless and a shared singleton instance.
        /// When serialized and deserialized it will return the current sharedRandom instance instead.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, a_decoder: &NSCoder) -> Retained<Self>;

        /// Returns a shared instance of a random source that uses the system's underlying random source.
        /// Using this instance modifies the outcome of future calls to the arc4random family of C calls. It is
        /// also affected by calls to the C apis and should not be used for sources that are intended to
        /// be deterministic.
        ///
        ///
        /// Note that while it may seem semantically similar to a GKARC4RandomSource, this is not a drop in replacement.
        #[unsafe(method(sharedRandom))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedRandom() -> Retained<GKRandomSource>;

        /// Returns a shuffled instance of the given array. The objects in the array are shuffled based on a Fisher-Yates shuffle.
        ///
        /// Any random, be it custom, source or a distribution, that can provide a number with an upper bound of at least the
        /// array.count is suitable for this shuffle.
        ///
        /// # Safety
        ///
        /// `array` generic should be of the correct type.
        #[unsafe(method(arrayByShufflingObjectsInArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn arrayByShufflingObjectsInArray(&self, array: &NSArray) -> Retained<NSArray>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKRandomSource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

mod private_NSArrayGameplayKit {
    pub trait Sealed {}
}

/// Category "GameplayKit" on [`NSArray`].
#[doc(alias = "GameplayKit")]
pub unsafe trait NSArrayGameplayKit<ObjectType: Message>:
    ClassType + Sized + private_NSArrayGameplayKit::Sealed
{
    extern_methods!(
        #[unsafe(method(shuffledArrayWithRandomSource:))]
        #[unsafe(method_family = none)]
        unsafe fn shuffledArrayWithRandomSource(
            &self,
            random_source: &GKRandomSource,
        ) -> Retained<NSArray<ObjectType>>;

        #[unsafe(method(shuffledArray))]
        #[unsafe(method_family = none)]
        unsafe fn shuffledArray(&self) -> Retained<NSArray<ObjectType>>;
    );
}

impl<ObjectType: Message> private_NSArrayGameplayKit::Sealed for NSArray<ObjectType> {}
unsafe impl<ObjectType: Message> NSArrayGameplayKit<ObjectType> for NSArray<ObjectType> {}

extern_class!(
    /// A basic random number generator implementing the ARC4 algorithm, which is suitable for most gameplay mechanics.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The randomization services provided in GameplayKit are suitable for reliably creating deterministic, pseudorandom gameplay mechanics, but are not cryptographically robust. For cryptography, obfuscation, or cipher uses, use the Security framework, described in [Cryptographic Services Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172).
    ///
    ///
    ///
    /// </div>
    /// To generate basic random values with this random source, use the methods defined in the [`GKRandom`](https://developer.apple.com/documentation/gameplaykit/gkrandom) protocol. To generate random values with a specific range and distribution, use this random source with the [`GKRandomDistribution`](https://developer.apple.com/documentation/gameplaykit/gkrandomdistribution) class or one of its subclasses.
    ///
    /// When you create an instance of this class, the resulting random source is both _independent_ and _deterministic_—that is, the sequence of numbers generated by one instance has no effect on the sequence generated by any other instance, and that sequence can be replicated when necessary. For details on replicating sequences, see the [`seed`](https://developer.apple.com/documentation/gameplaykit/gkarc4randomsource/seed) property and [`initWithSeed:`](https://developer.apple.com/documentation/gameplaykit/gkarc4randomsource/init(seed:)) initializer.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The [`GKARC4RandomSource`](https://developer.apple.com/documentation/gameplaykit/gkarc4randomsource) class uses a similar agorithm to, but is independent from, the arc4random family of C functions.
    ///
    ///
    ///
    /// </div>
    /// For more information on choosing and using randomizers in GameplayKit, read [Randomization](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// A deterministic pseudo-random source that generates random numbers based on an arc4 algorithm.
    /// This is a deterministic random source suitable for creating reliable gameplay mechanics.
    ///
    /// While deterministic, this is not a cryptographic random source, however it may be useful
    /// for obfuscation of gameplay data in manner similar to a stream cipher.
    #[unsafe(super(GKRandomSource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKARC4RandomSource;
);

extern_conformance!(
    unsafe impl GKRandom for GKARC4RandomSource {}
);

extern_conformance!(
    unsafe impl NSCoding for GKARC4RandomSource {}
);

extern_conformance!(
    unsafe impl NSCopying for GKARC4RandomSource {}
);

unsafe impl CopyingHelper for GKARC4RandomSource {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for GKARC4RandomSource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for GKARC4RandomSource {}
);

impl GKARC4RandomSource {
    extern_methods!(
        /// The seed used to stir the arc4 random source.
        /// The seed is not encoded through archiving, but the equivalent state buffers are encoded.
        #[unsafe(method(seed))]
        #[unsafe(method_family = none)]
        pub unsafe fn seed(&self) -> Retained<NSData>;

        /// Setter for [`seed`][Self::seed].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSeed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSeed(&self, seed: &NSData);

        /// Initializes an arc4 random source with bits from high entropy system resource like SecRandomCopyBytes.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Initializes an arc4 random source with bits from the seed.
        #[unsafe(method(initWithSeed:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSeed(this: Allocated<Self>, seed: &NSData) -> Retained<Self>;

        /// Arc4 based random sources have repeatable initial sequences. If used for obfuscation you should
        /// drop N values from the start, where N should be any number larger than 768 to ensure the initial
        /// sequence is flushed.
        #[unsafe(method(dropValuesWithCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dropValuesWithCount(&self, count: NSUInteger);
    );
}

/// Methods declared on superclass `GKRandomSource`.
impl GKARC4RandomSource {
    extern_methods!(
        /// Deserializes a random source from an NSCoder. All random sources support coding for serializing and deserializing the state
        /// of the random source. Each subclass has its own contract for what parts of the state is preserved when serialized but the
        /// general contract is that a serialized source must generate the same sequence of values as the original source would from the
        /// instant it was serialized.
        ///
        /// Note that the sharedRandom instance is an exception as it is explicitly seedless and a shared singleton instance.
        /// When serialized and deserialized it will return the current sharedRandom instance instead.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, a_decoder: &NSCoder) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKARC4RandomSource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A basic random number generator implementing the linear congruential generator algorithm, which is faster but less random than the default random source.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The randomization services provided in GameplayKit are suitable for reliably creating deterministic, pseudorandom gameplay mechanics, but are not cryptographically robust. For cryptography, obfuscation, or cipher uses, use the Security framework, described in [Cryptographic Services Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172).
    ///
    ///
    ///
    /// </div>
    /// To generate basic random values with this random source, use the methods defined in the [`GKRandom`](https://developer.apple.com/documentation/gameplaykit/gkrandom) protocol. To generate random values with a specific range and distribution, use this random source with the [`GKRandomDistribution`](https://developer.apple.com/documentation/gameplaykit/gkrandomdistribution) class or one of its subclasses.
    ///
    /// When you create an instance of this class, the resulting random source is both _independent_ and _deterministic_—that is, the sequence of numbers generated by one instance has no effect on the sequence generated by any other instance, and that sequence can be replicated when necessary. For details on replicating sequences, see the [`seed`](https://developer.apple.com/documentation/gameplaykit/gklinearcongruentialrandomsource/seed) property and [`initWithSeed:`](https://developer.apple.com/documentation/gameplaykit/gklinearcongruentialrandomsource/init(seed:)) initializer.
    ///
    /// The linear congruential random source uses the algorithm described by Donald E. Knuth in _The Art of Computer Programming_, Volume 2: _Seminumerical Algorithms_, section 3.2.1, with the common seed mask value of `0x5DEECE66D`. This random source is therefore compatible with other implementations of that algorithm, including the `java.util.Random` class in Java. That is, if you initialize a [`GKLinearCongruentialRandomSource`](https://developer.apple.com/documentation/gameplaykit/gklinearcongruentialrandomsource) instance and a compatible implementation using the same seed value, both generate the same sequence of numbers.
    ///
    /// For more information on choosing and using randomizers in GameplayKit, read [Randomization](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// A deterministic pseudo-random source that generates random numbers based on a linear congruential algorithm.
    /// This is a deterministic random source suitable for creating reliable gameplay mechanics.
    /// It is slightly faster than an Arc4 source, but less random. In particular the lower bits
    /// of the generated values are less random than the higher bits.
    ///
    /// While deterministic, this is not a cryptographic random source. It is also not suitable
    /// for obfuscation of gameplay data.
    #[unsafe(super(GKRandomSource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKLinearCongruentialRandomSource;
);

extern_conformance!(
    unsafe impl GKRandom for GKLinearCongruentialRandomSource {}
);

extern_conformance!(
    unsafe impl NSCoding for GKLinearCongruentialRandomSource {}
);

extern_conformance!(
    unsafe impl NSCopying for GKLinearCongruentialRandomSource {}
);

unsafe impl CopyingHelper for GKLinearCongruentialRandomSource {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for GKLinearCongruentialRandomSource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for GKLinearCongruentialRandomSource {}
);

impl GKLinearCongruentialRandomSource {
    extern_methods!(
        /// The seed used to stir the linear congruential random source.
        /// The seed changes each time a random value is generated from this source, as the seed is the state buffer.
        /// The seed is encoded through archiving.
        #[unsafe(method(seed))]
        #[unsafe(method_family = none)]
        pub unsafe fn seed(&self) -> u64;

        /// Setter for [`seed`][Self::seed].
        #[unsafe(method(setSeed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSeed(&self, seed: u64);

        /// Initializes a linear congruential random source with bits from high entropy system resource like SecRandomCopyBytes.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Initializes a linear congruential random source with bits the given 64 bit seed.
        #[unsafe(method(initWithSeed:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSeed(this: Allocated<Self>, seed: u64) -> Retained<Self>;
    );
}

/// Methods declared on superclass `GKRandomSource`.
impl GKLinearCongruentialRandomSource {
    extern_methods!(
        /// Deserializes a random source from an NSCoder. All random sources support coding for serializing and deserializing the state
        /// of the random source. Each subclass has its own contract for what parts of the state is preserved when serialized but the
        /// general contract is that a serialized source must generate the same sequence of values as the original source would from the
        /// instant it was serialized.
        ///
        /// Note that the sharedRandom instance is an exception as it is explicitly seedless and a shared singleton instance.
        /// When serialized and deserialized it will return the current sharedRandom instance instead.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, a_decoder: &NSCoder) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKLinearCongruentialRandomSource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A basic random number generator implementing the Mersenne Twister algorithm, which is more random, but slower than the default random source.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The randomization services provided in GameplayKit are suitable for reliably creating deterministic, pseudorandom gameplay mechanics, but are not cryptographically robust. For cryptography, obfuscation, or cipher uses, use the Security framework, described in [Cryptographic Services Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/cryptoservices/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011172).
    ///
    ///
    ///
    /// </div>
    /// To generate basic random values with this random source, use the methods defined in the [`GKRandom`](https://developer.apple.com/documentation/gameplaykit/gkrandom) protocol. To generate random values with a specific range and distribution, use this random source with the [`GKRandomDistribution`](https://developer.apple.com/documentation/gameplaykit/gkrandomdistribution) class or one of its subclasses.
    ///
    /// When you create an instance of this class, the resulting random source is both _independent_ and _deterministic_—that is, the sequence of numbers generated by one instance has no effect on the sequence generated by any other instance, and that sequence can be replicated when necessary. For details on replicating sequences, see the [`seed`](https://developer.apple.com/documentation/gameplaykit/gkmersennetwisterrandomsource/seed) property and [`initWithSeed:`](https://developer.apple.com/documentation/gameplaykit/gkmersennetwisterrandomsource/init(seed:)) initializer.
    ///
    /// The Mersenne Twister random source uses a common 64-bit variant of the algorithm originally described by Matsumoto and Nishimura in 2000, based on the Mersenne prime power 19937. This random source is therefore compatible with other implementations of that algorithm, including the `mt19937_64` type from the `std::mersenne_twister_engine` template in C++11. That is, if you initialize a [`GKMersenneTwisterRandomSource`](https://developer.apple.com/documentation/gameplaykit/gkmersennetwisterrandomsource) instance and a compatible implementation using the same seed value, both generate the same sequence of numbers.
    ///
    /// For more information on choosing and using randomizers in GameplayKit, read [Randomization](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html#//apple_ref/doc/uid/TP40015172-CH9) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// A deterministic pseudo-random source that generates random numbers based on a mersenne twister algorithm.
    /// This is a deterministic random source suitable for creating reliable gameplay mechanics.
    /// It is slightly slower than an Arc4 source, but more random, in that it has a longer period until repeating sequences.
    ///
    /// While deterministic, this is not a cryptographic random source. It is however suitable
    /// for obfuscation of gameplay data.
    #[unsafe(super(GKRandomSource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMersenneTwisterRandomSource;
);

extern_conformance!(
    unsafe impl GKRandom for GKMersenneTwisterRandomSource {}
);

extern_conformance!(
    unsafe impl NSCoding for GKMersenneTwisterRandomSource {}
);

extern_conformance!(
    unsafe impl NSCopying for GKMersenneTwisterRandomSource {}
);

unsafe impl CopyingHelper for GKMersenneTwisterRandomSource {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for GKMersenneTwisterRandomSource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for GKMersenneTwisterRandomSource {}
);

impl GKMersenneTwisterRandomSource {
    extern_methods!(
        /// The seed used to stir the mersenne twister random source.
        /// The seed is not encoded through archiving, but the equivalent state buffers are encoded.
        #[unsafe(method(seed))]
        #[unsafe(method_family = none)]
        pub unsafe fn seed(&self) -> u64;

        /// Setter for [`seed`][Self::seed].
        #[unsafe(method(setSeed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSeed(&self, seed: u64);

        /// Initializes a linear congruential random source with bits from a high entropy system resource like SecRandomCopyBytes.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Initializes a linear congruential random source with bits the given 64 bit seed.
        #[unsafe(method(initWithSeed:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSeed(this: Allocated<Self>, seed: u64) -> Retained<Self>;
    );
}

/// Methods declared on superclass `GKRandomSource`.
impl GKMersenneTwisterRandomSource {
    extern_methods!(
        /// Deserializes a random source from an NSCoder. All random sources support coding for serializing and deserializing the state
        /// of the random source. Each subclass has its own contract for what parts of the state is preserved when serialized but the
        /// general contract is that a serialized source must generate the same sequence of values as the original source would from the
        /// instant it was serialized.
        ///
        /// Note that the sharedRandom instance is an exception as it is explicitly seedless and a shared singleton instance.
        /// When serialized and deserialized it will return the current sharedRandom instance instead.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, a_decoder: &NSCoder) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKMersenneTwisterRandomSource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
