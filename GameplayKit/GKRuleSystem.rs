//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A rule system consists of 3 things:
    /// - The current state, which upon creation is considered the inital state.
    /// - The current set of rules.
    /// - The current set of facts.
    ///
    /// Each time a fact is added to the system, the set of rules are evaluated in order and their actions executed in the system if their predicates are true.
    /// Rules can be fuzzy, allowing predicates and facts to be asserted to a degree of confidence instead of just boolean on/off.
    ///
    /// The facts can be any kind of objects as long as they correctly determine equality using isEqual:
    /// The simplest approach is to use strings or dictionaries as they provide the most flexibility in defining
    /// facts, but user defined classes work just as well and may describe the problem space better.
    ///
    /// The fact set is at all times a fuzzy set, as defined by fact membership in the set being modulated by their
    /// grade of membership. The rules may use the grade of membership to predicate their actions and in such a
    /// manner create fuzzy logic. The fuzzy logic Zadeh operators are available on the system itself in order
    /// to query multiple facts for combined membership grade.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkrulesystem?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKRuleSystem;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKRuleSystem {}
);

impl GKRuleSystem {
    extern_methods!(
        /// Initializes a clean rule system with no state, rules or facts.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Explicitly evaluate the agenda of the rule system based on the current state and the current set of facts.
        ///
        /// This may in turn assert or retract more facts or change the state of the system, including activating more
        /// rules in the agenda.
        #[unsafe(method(evaluate))]
        #[unsafe(method_family = none)]
        pub unsafe fn evaluate(&self);

        /// The implementation-defined state. If any changes are made on this outside the system you must
        /// call evaluate to have the system take account of the changes.
        ///
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// The returned generic should be of the correct type.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> Retained<NSMutableDictionary>;

        /// The current set of rules that will be used to set the agenda when rules are first added to the system.
        /// They will also be used to refill the agenda whenever it is set.
        ///
        /// This is at all times the union of the agenda and executed sets.
        ///
        ///
        /// See: agenda
        ///
        /// See: executed
        #[unsafe(method(rules))]
        #[unsafe(method_family = none)]
        pub unsafe fn rules(&self) -> Retained<NSArray<GKRule>>;

        /// Adds a rule to the system. Also adds it to the agenda in salience order.
        #[unsafe(method(addRule:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRule(&self, rule: &GKRule);

        /// Adds rules to the system. Also adds them to the agenda in salience order.
        #[unsafe(method(addRulesFromArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRulesFromArray(&self, rules: &NSArray<GKRule>);

        /// Removes all rules from the system.  This also removes them from the agenda and executed sets.
        #[unsafe(method(removeAllRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAllRules(&self);

        /// The current set of rules to be evaluated, in salience order, where if the salience is equivalent
        /// the order of insertion into the agenda is used to decide which is first.
        /// Adjust salience of your rules to adjust the order the next time the agenda is reset. Changing salience
        /// on a rule currently in the agenda does not change its order in the agenda.
        ///
        /// This is at all times the difference between the rules and executed sets.
        ///
        ///
        /// See: rules
        ///
        /// See: executed
        ///
        /// See: reset
        #[unsafe(method(agenda))]
        #[unsafe(method_family = none)]
        pub unsafe fn agenda(&self) -> Retained<NSArray<GKRule>>;

        /// The current set of rules that have already executed. Rules in this set will not be executed again until
        /// the system is reset.
        ///
        /// This is at all times the difference between the rules and agenda sets.
        ///
        ///
        /// See: rules
        ///
        /// See: agenda
        ///
        /// See: reset
        #[unsafe(method(executed))]
        #[unsafe(method_family = none)]
        pub unsafe fn executed(&self) -> Retained<NSArray<GKRule>>;

        /// The current set of facts. Facts have a grade of membership that is >= 0.0. Query the system for the
        /// individual grades of membership with gradeForFact:
        ///
        ///
        /// See: gradeForFact:
        #[unsafe(method(facts))]
        #[unsafe(method_family = none)]
        pub unsafe fn facts(&self) -> Retained<NSArray>;

        /// Returns the current membership grade for the given fact, which is 0.0 if the fact
        /// is not a member of the current set of facts.
        ///
        ///
        /// Returns: The membership grade of the given fact, in the range [0.0, 1.0].
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(gradeForFact:))]
        #[unsafe(method_family = none)]
        pub unsafe fn gradeForFact(&self, fact: &ProtocolObject<dyn NSObjectProtocol>) -> c_float;

        /// Returns the combined membership grade for the all the given facts.
        ///
        /// This performs the logical AND operation between the given facts.
        ///
        ///
        /// Returns: The membership grade by applying the AND operator on the given facts, in the range [0.0, 1.0].
        ///
        /// # Safety
        ///
        /// `facts` generic should be of the correct type.
        #[unsafe(method(minimumGradeForFacts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumGradeForFacts(&self, facts: &NSArray) -> c_float;

        /// Returns the maximum membership grade for the any one of the given facts.
        ///
        /// This performs the logical OR operation between the given facts.
        ///
        ///
        /// Returns: The membership grade by applying the OR operator on the given facts, in the range [0.0, 1.0].
        ///
        /// # Safety
        ///
        /// `facts` generic should be of the correct type.
        #[unsafe(method(maximumGradeForFacts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumGradeForFacts(&self, facts: &NSArray) -> c_float;

        /// Asserts a fact with membership grade of 1.0.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        /// This is shorthand for calling assertFact:grade: with a grade of 1.0
        ///
        ///
        /// See: assertFact:grade:
        ///
        /// See: evaluate
        ///
        /// See: NSObject.isEqual:
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(assertFact:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assertFact(&self, fact: &ProtocolObject<dyn NSObjectProtocol>);

        /// Asserts a fact with the supplied membership grade.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(assertFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assertFact_grade(
            &self,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        );

        /// Retracts a fact, setting its membership grade to 0, which also removes it from the fact set.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        /// This is short hand for calling retractFact:grade: with a grade of 1.0
        ///
        ///
        /// See: retractFact:grade:
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(retractFact:))]
        #[unsafe(method_family = none)]
        pub unsafe fn retractFact(&self, fact: &ProtocolObject<dyn NSObjectProtocol>);

        /// Retracts a fact, reducing its membership grade by the supplied grade. If this brings the grade to 0
        /// it is also removed from the fact set.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(retractFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn retractFact_grade(
            &self,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        );

        /// Clears the agenda and executed sets and removes all facts currently in the system.
        /// It then fills the agenda with rules from the rule set, in salience order.
        ///
        /// See: rules
        ///
        /// See: facts
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl GKRuleSystem {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The concrete class that the GKRuleSystem uses to evaluate the current state and facts with predicated rules.
    /// These are sharable between systems, so don't retain any state in the rules themselves. Use the system-provided
    /// state storage.
    ///
    ///
    /// See: GKRuleSystem.state
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkrule?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKRule;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKRule {}
);

impl GKRule {
    extern_methods!(
        /// Salience defines the order in the rule agenda that the system will evaluate. A rule with higher salience will
        /// be evaluated before another rule in the agenda that has a lower salience.
        ///
        /// Defaults to 0.
        ///
        /// See: GKRuleSystem.agenda
        #[unsafe(method(salience))]
        #[unsafe(method_family = none)]
        pub unsafe fn salience(&self) -> NSInteger;

        /// Setter for [`salience`][Self::salience].
        #[unsafe(method(setSalience:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSalience(&self, salience: NSInteger);

        /// Called by the rule system when it is this rule's turn to be evaluated. If the predicate returns YES then
        /// the action for the rule will be performed. Once the action is performed the rule will move to the system's
        /// executed list until the agenda is reset.
        ///
        ///
        /// See: performAction
        ///
        /// See: GKRuleSystem.agenda
        ///
        /// See: GKRuleSystem.executed
        ///
        /// See: GKRuleSystem.reset
        ///
        /// Returns: YES is the predicate passes and the action needs to be performed, NO otherwise.
        #[unsafe(method(evaluatePredicateWithSystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn evaluatePredicateWithSystem(&self, system: &GKRuleSystem) -> bool;

        /// Performs the action consequence for the rule. This will only be called if the predicate evaluates to YES.
        /// Any facts asserted or retracted by the action on the system will cause the system to evaluate the agenda
        /// rule set again once the action completes.
        #[unsafe(method(performActionWithSystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performActionWithSystem(&self, system: &GKRuleSystem);

        /// Create a data-driven rule that uses NSPredicate and a single assert as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:assertingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_assertingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        /// Short hand for data-driven rule that uses NSPredicate and a single retract as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:retractingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_retractingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Short hand for making a rule that uses blocks for the predicate and action. This rule is not able to be archived
        /// using NSKeyedArchiver so use a subclass or NSPredicate based rule if serialization of the rule is needed.
        #[unsafe(method(ruleWithBlockPredicate:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithBlockPredicate_action(
            predicate: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>) -> Bool>,
            action: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>)>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A convenient subclass of GKRule that leverages existing NSPRedicate functionality for evaluating the predicate
    /// of the rule.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule?language=objc)
    #[unsafe(super(GKRule, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKNSPredicateRule;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKNSPredicateRule {}
);

impl GKNSPredicateRule {
    extern_methods!(
        /// The NSPredicate that is used inside this subclass's implementation of evaluatePredicateWithSystem:
        /// In order to effectively use this class you must still override performActionWithSystem:
        ///
        ///
        /// See: GKRule.evaluatePredicateWithSystem:
        #[unsafe(method(predicate))]
        #[unsafe(method_family = none)]
        pub unsafe fn predicate(&self) -> Retained<NSPredicate>;

        /// Initializes a new rule with the given NSPredicate
        #[unsafe(method(initWithPredicate:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPredicate(
            this: Allocated<Self>,
            predicate: &NSPredicate,
        ) -> Retained<Self>;

        /// Overridden here to call the predicate's evaluateWithObject:substitutionVariables:, using sys
        /// as the object and the system's state dictionary as the source of the substitution variables.
        ///
        ///
        /// Returns: YES if the NSPredicate evaluation passes and the action needs to be performed, NO otherwise.
        #[unsafe(method(evaluatePredicateWithSystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn evaluatePredicateWithSystem(&self, system: &GKRuleSystem) -> bool;
    );
}

/// Methods declared on superclass `GKRule`.
impl GKNSPredicateRule {
    extern_methods!(
        /// Create a data-driven rule that uses NSPredicate and a single assert as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:assertingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_assertingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        /// Short hand for data-driven rule that uses NSPredicate and a single retract as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:retractingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_retractingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Short hand for making a rule that uses blocks for the predicate and action. This rule is not able to be archived
        /// using NSKeyedArchiver so use a subclass or NSPredicate based rule if serialization of the rule is needed.
        #[unsafe(method(ruleWithBlockPredicate:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithBlockPredicate_action(
            predicate: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>) -> Bool>,
            action: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>)>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKNSPredicateRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
