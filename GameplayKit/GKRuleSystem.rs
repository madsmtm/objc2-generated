//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A list of rules, together with a context for evaluating them and interpreting results, for use in constructing data-driven logic or fuzzy logic systems.
    ///
    /// ## Overview
    ///
    /// A [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) object manages a list of rules ([`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) objects). A rule system also offers methods for evaluating its list of rules in a context defined by two features: a [`state`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/state) dictionary containing information to be tested by rules, and a set of [`facts`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/facts) representing the conclusions drawn as a result of rule evaluation. You can evaluate facts based on a binary truth state—that is, a fact either is or is not in the set—or on a continuously variable membership grade, representing different levels of veracity, confidence, or strength for use in fuzzy logic.
    ///
    /// You construct a rule system by creating [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) objects and adding them to the system’s list of rules. There are multiple ways to construct rules: for greater reusability, use the methods listed in Creating Data-Driven Rules; or for greater flexibility, use the [`ruleWithBlockPredicate:action:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(blockpredicate:action:)) method or create a custom subclass of [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) or [`GKNSPredicateRule`](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule). Then, add rules to the system with the methods listed in Managing a System’s List of Rules below.
    ///
    /// To evaluate a system, call the [`evaluate`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/evaluate()) method. This method processes each rule in the system in the order it appears in the system’s [`agenda`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/agenda) list. You set this order with the [`salience`](https://developer.apple.com/documentation/gameplaykit/gkrule/salience) property of each rule, or with the order in which you add rules to the system. As the system processes each rule, it tests the rule’s [`evaluatePredicateWithSystem:`](https://developer.apple.com/documentation/gameplaykit/gkrule/evaluatepredicate(in:)) method to determine whether the rule is satisfied in the context of the system. If the rule’s predicate is satisfied, the system executes the rule’s [`performActionWithSystem:`](https://developer.apple.com/documentation/gameplaykit/gkrule/performaction(in:)) method and moves the rule to the [`executed`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/executed) list (so the further evaluation of the agenda doesn’t repeatedly trigger the rule’s action).
    ///
    /// Rules typically use the system’s [`state`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/state) dictionary as input and its set of [`facts`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/facts) as output. (However, more complex systems can include sets of rules whose predicates test facts or whose actions mutate the system’s state.) After evaluating a rule system, you can examine the set of facts it has produced using the methods listed in Drawing Conclusions from Facts below. You can then use the presence of a fact in the set, the value of its membership grade, or the combined membership grades of a group of facts to influence the behaviors in your game.
    ///
    /// For more information about rules and rule systems, read [Rule Systems](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html#//apple_ref/doc/uid/TP40015172-CH10) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// A rule system consists of 3 things:
    /// - The current state, which upon creation is considered the inital state.
    /// - The current set of rules.
    /// - The current set of facts.
    ///
    /// Each time a fact is added to the system, the set of rules are evaluated in order and their actions executed in the system if their predicates are true.
    /// Rules can be fuzzy, allowing predicates and facts to be asserted to a degree of confidence instead of just boolean on/off.
    ///
    /// The facts can be any kind of objects as long as they correctly determine equality using isEqual:
    /// The simplest approach is to use strings or dictionaries as they provide the most flexibility in defining
    /// facts, but user defined classes work just as well and may describe the problem space better.
    ///
    /// The fact set is at all times a fuzzy set, as defined by fact membership in the set being modulated by their
    /// grade of membership. The rules may use the grade of membership to predicate their actions and in such a
    /// manner create fuzzy logic. The fuzzy logic Zadeh operators are available on the system itself in order
    /// to query multiple facts for combined membership grade.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKRuleSystem;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKRuleSystem {}
);

impl GKRuleSystem {
    extern_methods!(
        /// Initializes a clean rule system with no state, rules or facts.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Explicitly evaluate the agenda of the rule system based on the current state and the current set of facts.
        ///
        /// This may in turn assert or retract more facts or change the state of the system, including activating more
        /// rules in the agenda.
        #[unsafe(method(evaluate))]
        #[unsafe(method_family = none)]
        pub unsafe fn evaluate(&self);

        /// The implementation-defined state. If any changes are made on this outside the system you must
        /// call evaluate to have the system take account of the changes.
        ///
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// The returned generic should be of the correct type.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> Retained<NSMutableDictionary>;

        /// The current set of rules that will be used to set the agenda when rules are first added to the system.
        /// They will also be used to refill the agenda whenever it is set.
        ///
        /// This is at all times the union of the agenda and executed sets.
        ///
        ///
        /// See: agenda
        ///
        /// See: executed
        #[unsafe(method(rules))]
        #[unsafe(method_family = none)]
        pub unsafe fn rules(&self) -> Retained<NSArray<GKRule>>;

        /// Adds a rule to the system. Also adds it to the agenda in salience order.
        #[unsafe(method(addRule:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRule(&self, rule: &GKRule);

        /// Adds rules to the system. Also adds them to the agenda in salience order.
        #[unsafe(method(addRulesFromArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRulesFromArray(&self, rules: &NSArray<GKRule>);

        /// Removes all rules from the system.  This also removes them from the agenda and executed sets.
        #[unsafe(method(removeAllRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAllRules(&self);

        /// The current set of rules to be evaluated, in salience order, where if the salience is equivalent
        /// the order of insertion into the agenda is used to decide which is first.
        /// Adjust salience of your rules to adjust the order the next time the agenda is reset. Changing salience
        /// on a rule currently in the agenda does not change its order in the agenda.
        ///
        /// This is at all times the difference between the rules and executed sets.
        ///
        ///
        /// See: rules
        ///
        /// See: executed
        ///
        /// See: reset
        #[unsafe(method(agenda))]
        #[unsafe(method_family = none)]
        pub unsafe fn agenda(&self) -> Retained<NSArray<GKRule>>;

        /// The current set of rules that have already executed. Rules in this set will not be executed again until
        /// the system is reset.
        ///
        /// This is at all times the difference between the rules and agenda sets.
        ///
        ///
        /// See: rules
        ///
        /// See: agenda
        ///
        /// See: reset
        #[unsafe(method(executed))]
        #[unsafe(method_family = none)]
        pub unsafe fn executed(&self) -> Retained<NSArray<GKRule>>;

        /// The current set of facts. Facts have a grade of membership that is >= 0.0. Query the system for the
        /// individual grades of membership with gradeForFact:
        ///
        ///
        /// See: gradeForFact:
        #[unsafe(method(facts))]
        #[unsafe(method_family = none)]
        pub unsafe fn facts(&self) -> Retained<NSArray>;

        /// Returns the current membership grade for the given fact, which is 0.0 if the fact
        /// is not a member of the current set of facts.
        ///
        ///
        /// Returns: The membership grade of the given fact, in the range [0.0, 1.0].
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(gradeForFact:))]
        #[unsafe(method_family = none)]
        pub unsafe fn gradeForFact(&self, fact: &ProtocolObject<dyn NSObjectProtocol>) -> c_float;

        /// Returns the combined membership grade for the all the given facts.
        ///
        /// This performs the logical AND operation between the given facts.
        ///
        ///
        /// Returns: The membership grade by applying the AND operator on the given facts, in the range [0.0, 1.0].
        ///
        /// # Safety
        ///
        /// `facts` generic should be of the correct type.
        #[unsafe(method(minimumGradeForFacts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumGradeForFacts(&self, facts: &NSArray) -> c_float;

        /// Returns the maximum membership grade for the any one of the given facts.
        ///
        /// This performs the logical OR operation between the given facts.
        ///
        ///
        /// Returns: The membership grade by applying the OR operator on the given facts, in the range [0.0, 1.0].
        ///
        /// # Safety
        ///
        /// `facts` generic should be of the correct type.
        #[unsafe(method(maximumGradeForFacts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumGradeForFacts(&self, facts: &NSArray) -> c_float;

        /// Asserts a fact with membership grade of 1.0.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        /// This is shorthand for calling assertFact:grade: with a grade of 1.0
        ///
        ///
        /// See: assertFact:grade:
        ///
        /// See: evaluate
        ///
        /// See: NSObject.isEqual:
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(assertFact:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assertFact(&self, fact: &ProtocolObject<dyn NSObjectProtocol>);

        /// Asserts a fact with the supplied membership grade.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(assertFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assertFact_grade(
            &self,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        );

        /// Retracts a fact, setting its membership grade to 0, which also removes it from the fact set.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        /// This is short hand for calling retractFact:grade: with a grade of 1.0
        ///
        ///
        /// See: retractFact:grade:
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(retractFact:))]
        #[unsafe(method_family = none)]
        pub unsafe fn retractFact(&self, fact: &ProtocolObject<dyn NSObjectProtocol>);

        /// Retracts a fact, reducing its membership grade by the supplied grade. If this brings the grade to 0
        /// it is also removed from the fact set.
        ///
        /// This will cause the current rules to be evaluated, which may in turn assert or retract more facts
        /// or change the state of the system.
        ///
        ///
        /// See: evaluate
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(retractFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn retractFact_grade(
            &self,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        );

        /// Clears the agenda and executed sets and removes all facts currently in the system.
        /// It then fills the agenda with rules from the rule set, in salience order.
        ///
        /// See: rules
        ///
        /// See: facts
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl GKRuleSystem {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A rule to be used in the context of a rule system, with a predicate to be tested and an action to be executed when the test succeeds.
    ///
    /// ## Overview
    ///
    /// Evaluating a [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) object tests each of its rules, which typically examine the state or facts associated with the rule system, and executes the actions specified by each rule whose test passes, such as asserting or retracting facts in the rule system or modifying its state.
    ///
    /// A rule has two parts: a predicate and an action.
    ///
    /// - The rule’s _predicate_ determines whether the rule has been satisfied, within the context of a given rule system. Evaluating a rule’s predicate typically involves examining information in the rule sytem’s [`state`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/state) dictionary or testing the membership grade of facts claimed by the system (see the [`facts`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/facts) property in [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) for details).
    ///
    /// - The rule’s _action_ is executed if and only if the rule’s predicate is satisfied. Rule actions typically involve asserting or retracting facts in the system (see the [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) methods listed in Asserting and Retracting Facts) or modifying information in the system’s [`state`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem/state) dictionary.
    ///
    /// There are multiple ways to create rules for use in a rule system, each with its own advantages.
    ///
    /// - Typical rule predicates involve conditional logic tests on the properties of the containing rule system, and typical rule actions assert or retract facts. If your rules fit this pattern, you can use the [`ruleWithPredicate:assertingFact:grade:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(predicate:assertingfact:grade:)) and [`ruleWithPredicate:retractingFact:grade:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(predicate:retractingfact:grade:)) methods to create rules that are entirely data-driven—that is, they can be easily archived for later reuse, edited without compiling source code, and created at runtime.
    ///
    /// - To create rules with entirely custom logic for both predicate and action, use the [`ruleWithBlockPredicate:action:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(blockpredicate:action:)) method. This method creates rules that are very flexible, but that cannot be archived for reuse.
    ///
    /// - To create rules with more complex custom logic, implement your own rule classes: subclass [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) to build custom logic for both the rule’s predicate and its action, or subclass [`GKNSPredicateRule`](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule) to use an [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) object for the rule’s predicate and build custom logic only for the rule’s action. The reusability of custom rule classes depends on your implementation of such classes.
    ///
    /// For more information about rules and rule systems, read [Rule Systems](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html#//apple_ref/doc/uid/TP40015172-CH10) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    /// ### Subclassing Notes
    ///
    /// GameplayKit evaluates rules in the context of a [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) object, so custom rule classes should be _functional_—that is, they generally should not carry independent state that affects their predicate or action.
    ///
    /// #### Methods to Override
    ///
    /// Subclasses of [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) must implement both of the following methods:
    ///
    /// - Override the [`evaluatePredicateWithSystem:`](https://developer.apple.com/documentation/gameplaykit/gkrule/evaluatepredicate(in:)) method to evaluate your rule in the context of the provided rule system.
    ///
    /// - Override the [`performActionWithSystem:`](https://developer.apple.com/documentation/gameplaykit/gkrule/performaction(in:)) method to perform whatever actions should result when your rule is satisfied (that is, when your [`evaluatePredicateWithSystem:`](https://developer.apple.com/documentation/gameplaykit/gkrule/evaluatepredicate(in:)) implementation returns [`true`](https://developer.apple.com/documentation/swift/true)) in the context of the provided rule system.
    ///
    /// #### Alternatives to Subclassing
    ///
    /// - Use the [`ruleWithPredicate:assertingFact:grade:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(predicate:assertingfact:grade:)) or [`ruleWithPredicate:retractingFact:grade:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(predicate:retractingfact:grade:)) to create a rule that uses an [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) object for evaluation and whose action asserts or retracts a fact in the containing rule system.
    ///
    /// - Subclass [`GKNSPredicateRule`](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule) instead to use an [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) object for evaluating the rule and write custom logic only for the rule’s action.
    ///
    /// - Use the [`ruleWithBlockPredicate:action:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(blockpredicate:action:)) method to quickly create a rule whose custom logic is contained in block objects.
    ///
    ///
    /// The concrete class that the GKRuleSystem uses to evaluate the current state and facts with predicated rules.
    /// These are sharable between systems, so don't retain any state in the rules themselves. Use the system-provided
    /// state storage.
    ///
    ///
    /// See: GKRuleSystem.state
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKRule;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKRule {}
);

impl GKRule {
    extern_methods!(
        /// Salience defines the order in the rule agenda that the system will evaluate. A rule with higher salience will
        /// be evaluated before another rule in the agenda that has a lower salience.
        ///
        /// Defaults to 0.
        ///
        /// See: GKRuleSystem.agenda
        #[unsafe(method(salience))]
        #[unsafe(method_family = none)]
        pub unsafe fn salience(&self) -> NSInteger;

        /// Setter for [`salience`][Self::salience].
        #[unsafe(method(setSalience:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSalience(&self, salience: NSInteger);

        /// Called by the rule system when it is this rule's turn to be evaluated. If the predicate returns YES then
        /// the action for the rule will be performed. Once the action is performed the rule will move to the system's
        /// executed list until the agenda is reset.
        ///
        ///
        /// See: performAction
        ///
        /// See: GKRuleSystem.agenda
        ///
        /// See: GKRuleSystem.executed
        ///
        /// See: GKRuleSystem.reset
        ///
        /// Returns: YES is the predicate passes and the action needs to be performed, NO otherwise.
        #[unsafe(method(evaluatePredicateWithSystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn evaluatePredicateWithSystem(&self, system: &GKRuleSystem) -> bool;

        /// Performs the action consequence for the rule. This will only be called if the predicate evaluates to YES.
        /// Any facts asserted or retracted by the action on the system will cause the system to evaluate the agenda
        /// rule set again once the action completes.
        #[unsafe(method(performActionWithSystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performActionWithSystem(&self, system: &GKRuleSystem);

        /// Create a data-driven rule that uses NSPredicate and a single assert as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:assertingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_assertingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        /// Short hand for data-driven rule that uses NSPredicate and a single retract as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:retractingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_retractingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Short hand for making a rule that uses blocks for the predicate and action. This rule is not able to be archived
        /// using NSKeyedArchiver so use a subclass or NSPredicate based rule if serialization of the rule is needed.
        #[unsafe(method(ruleWithBlockPredicate:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithBlockPredicate_action(
            predicate: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>) -> Bool>,
            action: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>)>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A rule for use in a rule system that uses a Foundation [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) object to evaluate itself.
    ///
    /// ## Overview
    ///
    /// The [`GKNSPredicateRule`](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule) class is a specialized subclass of the [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) class (which represents rules to be used by [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) objects). Custom subclasses of [`GKNSPredicateRule`](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule) use an [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) object to evaluate a rule, rather than requiring custom logic for evaluation as is the case with custom [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) subclasses.
    ///
    /// For more information about rules and rule systems, read [Rule Systems](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html#//apple_ref/doc/uid/TP40015172-CH10) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    /// ### Subclassing Notes
    ///
    /// GameplayKit evaluates rules in the context of a [`GKRuleSystem`](https://developer.apple.com/documentation/gameplaykit/gkrulesystem) object, so custom rule classes should be _functional_—that is, they generally should not carry independent state that affects their predicate or action.
    ///
    /// #### Methods to Override
    ///
    /// Override the [`performActionWithSystem:`](https://developer.apple.com/documentation/gameplaykit/gkrule/performaction(in:)) method to perform whatever actions should result when your rule is satisfied (that is, when its [`predicate`](https://developer.apple.com/documentation/gameplaykit/gknspredicaterule/predicate) property evaluates to true in the context of the provided rule system).
    ///
    /// #### Alternatives to Subclassing
    ///
    /// - Use the [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) method [`ruleWithPredicate:assertingFact:grade:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(predicate:assertingfact:grade:)) or [`ruleWithPredicate:retractingFact:grade:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(predicate:retractingfact:grade:)) to create a rule that uses an [`NSPredicate`](https://developer.apple.com/documentation/foundation/nspredicate) object for evaluation and whose action asserts or retracts a fact in the containing rule system.
    ///
    /// - Use the [`GKRule`](https://developer.apple.com/documentation/gameplaykit/gkrule) method [`ruleWithBlockPredicate:action:`](https://developer.apple.com/documentation/gameplaykit/gkrule/init(blockpredicate:action:)) method to quickly create a rule whose custom logic is contained in block objects.
    ///
    ///
    /// A convenient subclass of GKRule that leverages existing NSPRedicate functionality for evaluating the predicate
    /// of the rule.
    #[unsafe(super(GKRule, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKNSPredicateRule;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKNSPredicateRule {}
);

impl GKNSPredicateRule {
    extern_methods!(
        /// The NSPredicate that is used inside this subclass's implementation of evaluatePredicateWithSystem:
        /// In order to effectively use this class you must still override performActionWithSystem:
        ///
        ///
        /// See: GKRule.evaluatePredicateWithSystem:
        #[unsafe(method(predicate))]
        #[unsafe(method_family = none)]
        pub unsafe fn predicate(&self) -> Retained<NSPredicate>;

        /// Initializes a new rule with the given NSPredicate
        #[unsafe(method(initWithPredicate:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPredicate(
            this: Allocated<Self>,
            predicate: &NSPredicate,
        ) -> Retained<Self>;

        /// Overridden here to call the predicate's evaluateWithObject:substitutionVariables:, using sys
        /// as the object and the system's state dictionary as the source of the substitution variables.
        ///
        ///
        /// Returns: YES if the NSPredicate evaluation passes and the action needs to be performed, NO otherwise.
        #[unsafe(method(evaluatePredicateWithSystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn evaluatePredicateWithSystem(&self, system: &GKRuleSystem) -> bool;
    );
}

/// Methods declared on superclass `GKRule`.
impl GKNSPredicateRule {
    extern_methods!(
        /// Create a data-driven rule that uses NSPredicate and a single assert as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:assertingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_assertingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        /// Short hand for data-driven rule that uses NSPredicate and a single retract as the action.
        ///
        /// # Safety
        ///
        /// `fact` should be of the correct type.
        #[unsafe(method(ruleWithPredicate:retractingFact:grade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithPredicate_retractingFact_grade(
            predicate: &NSPredicate,
            fact: &ProtocolObject<dyn NSObjectProtocol>,
            grade: c_float,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Short hand for making a rule that uses blocks for the predicate and action. This rule is not able to be archived
        /// using NSKeyedArchiver so use a subclass or NSPredicate based rule if serialization of the rule is needed.
        #[unsafe(method(ruleWithBlockPredicate:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ruleWithBlockPredicate_action(
            predicate: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>) -> Bool>,
            action: &block2::DynBlock<dyn Fn(NonNull<GKRuleSystem>)>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKNSPredicateRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
