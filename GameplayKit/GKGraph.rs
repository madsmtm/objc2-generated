//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A collection of nodes that describes the navigability of a game world and provides _pathfinding_ methods to search for routes through that space.
    ///
    /// ## Overview
    ///
    /// Individual nodes in a graph represent discrete locations that a character or other object in your game can occupy, and the connections between adjacent nodes represent the ability of a game entity to travel from one location to another. Use the [`GKGraph`](https://developer.apple.com/documentation/gameplaykit/gkgraph) class to create a general graph, or the [`GKGridGraph`](https://developer.apple.com/documentation/gameplaykit/gkgridgraph), [`GKObstacleGraph`](https://developer.apple.com/documentation/gameplaykit/gkobstaclegraph), or [`GKMeshGraph`](https://developer.apple.com/documentation/gameplaykit/gkmeshgraph) subclass to generate specialized graphs that contain more information about the geometry of your game world.
    ///
    /// Each set of graph and node classes can generate graphs for different kinds of spaces:
    ///
    /// - The base classes [`GKGraph`](https://developer.apple.com/documentation/gameplaykit/gkgraph) and [`GKGraphNode`](https://developer.apple.com/documentation/gameplaykit/gkgraphnode) contain functionality general to all graphs and nodes. You can also use these classes on their own to construct graphs that contain no geometry information. This option is useful for games where the connections between spaces are more important than their physical locations, such as board games.
    ///
    /// - Use the [`GKGridGraph`](https://developer.apple.com/documentation/gameplaykit/gkgridgraph) and [`GKGridGraphNode`](https://developer.apple.com/documentation/gameplaykit/gkgridgraphnode) classes to describe game worlds that constrain movement to an integer grid, such as tactical role-playing games.
    ///
    /// - Use the [`GKObstacleGraph`](https://developer.apple.com/documentation/gameplaykit/gkobstaclegraph) or [`GKMeshGraph`](https://developer.apple.com/documentation/gameplaykit/gkmeshgraph) class to describe 2D game worlds that allow continuous movement in open spaces that are interrupted by impassable obstacles ([`GKPolygonObstacle`](https://developer.apple.com/documentation/gameplaykit/gkpolygonobstacle) objects). Obstacle graphs automatically generate nodes containing 2D point information ([`GKGraphNode2D`](https://developer.apple.com/documentation/gameplaykit/gkgraphnode2d) objects), and you can also add your own such nodes representing locations of interest.
    ///
    /// The graphs modeled by this class are always _directed_—that is, a connection between two nodes describes one direction of travel between them. To enable travel between two nodes in either direction, you must create a connection in each direction. You can choose to connect both directions at once with the [`connectNodeToLowestCostNode:bidirectional:`](https://developer.apple.com/documentation/gameplaykit/gkgraph/connecttolowestcostnode(node:bidirectional:)) method (for graphs) or the addConnection:bidirectional: method (for nodes).
    ///
    /// Using a graph for pathfinding typically involves three major steps:
    ///
    /// 1. Create a graph once (for example, when initializing a game level class) with static information about your game world.
    ///
    /// 2. When you need to find a route between points, connect temporary nodes to the graph at those points. Use the [`connectNodeToLowestCostNode:bidirectional:`](https://developer.apple.com/documentation/gameplaykit/gkgraph/connecttolowestcostnode(node:bidirectional:)) method to connect nodes using their own geometry information, or the [`connectNodeUsingObstacles:`](https://developer.apple.com/documentation/gameplaykit/gkobstaclegraph/connectusingobstacles(node:)) or [`connectNodeToAdjacentNodes:`](https://developer.apple.com/documentation/gameplaykit/gkgridgraph/connecttoadjacentnodes(node:)) method to use the additional constraints of obstacle and grid graphs.
    ///
    /// 3. Call the [`findPathFromNode:toNode:`](https://developer.apple.com/documentation/gameplaykit/gkgraph/findpath(from:to:)) method to find a route between locations in the graph. This method returns an array of graph nodes, starting with the requested start point of the path, and proceeding to adjacent nodes in order until it reaches the requested end point. Use the geometry information contained in each node to make use of the route—for example, in a SpriteKit game you might create a sequence of move actions to move a character from point to point along the path.
    ///
    /// 4. The temporary nodes you created for finding a path typically have little usefulness after a path has been found. Remove those nodes before reusing the graph for future searches.
    ///
    /// To learn more about graphs and pathfinding, see [Pathfinding](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html#//apple_ref/doc/uid/TP40015172-CH3) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// Representation of a directed graph of GKGraphNodes
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKGraph;
);

extern_conformance!(
    unsafe impl NSCoding for GKGraph {}
);

extern_conformance!(
    unsafe impl NSCopying for GKGraph {}
);

unsafe impl CopyingHelper for GKGraph {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for GKGraph {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for GKGraph {}
);

impl GKGraph {
    extern_methods!(
        #[cfg(feature = "GKGraphNode")]
        /// The list of nodes in this graph
        #[unsafe(method(nodes))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodes(&self) -> Option<Retained<NSArray<GKGraphNode>>>;

        #[cfg(feature = "GKGraphNode")]
        /// Creates a graph with the provided array of nodes.
        ///
        /// Parameter `nodes`: the nodes to create the graph with
        #[unsafe(method(graphWithNodes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn graphWithNodes(nodes: &NSArray<GKGraphNode>) -> Retained<Self>;

        #[cfg(feature = "GKGraphNode")]
        #[unsafe(method(initWithNodes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNodes(
            this: Allocated<Self>,
            nodes: &NSArray<GKGraphNode>,
        ) -> Retained<Self>;

        #[cfg(feature = "GKGraphNode")]
        /// Connects the node to this graph via the lowest cost node to reach in this graph
        ///
        /// Parameter `node`: the node to connect
        ///
        /// Parameter `bidirectional`: should the connection be bidirectional? Otherwise it is one way connected into the graph
        #[unsafe(method(connectNodeToLowestCostNode:bidirectional:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectNodeToLowestCostNode_bidirectional(
            &self,
            node: &GKGraphNode,
            bidirectional: bool,
        );

        #[cfg(feature = "GKGraphNode")]
        /// Removes nodes from this graph.
        /// All connections starting and/or ending with this node are removed.
        ///
        /// Parameter `nodes`: an array of nodes to be removed
        #[unsafe(method(removeNodes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeNodes(&self, nodes: &NSArray<GKGraphNode>);

        #[cfg(feature = "GKGraphNode")]
        /// Adds nodes to this graph.  No new connections are added.
        /// If the node already exists in this graph this does nothing.
        ///
        /// Parameter `nodes`: and array of nodes to be added
        #[unsafe(method(addNodes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addNodes(&self, nodes: &NSArray<GKGraphNode>);

        #[cfg(feature = "GKGraphNode")]
        /// Attempts to find the optimal path between the two nodes indicated.
        /// If such a path exists, it is returned in start to end order.
        /// If it doesn't exist, the array returned will be empty.
        /// Asserts if neither of these nodes are in this graph.  Use [GKGraphNode findPathFromNode:] instead.
        ///
        /// Parameter `startNode`: node to start pathing from
        ///
        /// Parameter `endNode`: goal node of the pathfinding attempt
        #[unsafe(method(findPathFromNode:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findPathFromNode_toNode(
            &self,
            start_node: &GKGraphNode,
            end_node: &GKGraphNode,
        ) -> Retained<NSArray<GKGraphNode>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKGraph {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
