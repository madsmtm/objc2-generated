//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Models a finite state machine that has a single current state.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkstatemachine?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKStateMachine;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKStateMachine {}
);

impl GKStateMachine {
    extern_methods!(
        #[cfg(feature = "GKState")]
        /// The current state that the state machine is in.
        /// Prior to the first called to enterState this is equal to nil.
        #[unsafe(method(currentState))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentState(&self) -> Option<Retained<GKState>>;

        #[cfg(feature = "GKState")]
        /// Creates a state machine with an array of possible states and an initial state.
        ///
        ///
        /// Parameter `states`: a list of possible states for this state machine.
        #[unsafe(method(stateMachineWithStates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stateMachineWithStates(states: &NSArray<GKState>) -> Retained<Self>;

        #[cfg(feature = "GKState")]
        #[unsafe(method(initWithStates:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithStates(
            this: Allocated<Self>,
            states: &NSArray<GKState>,
        ) -> Retained<Self>;

        /// Updates the current state machine.
        ///
        ///
        /// Parameter `sec`: the time, in seconds, since the last frame
        #[unsafe(method(updateWithDeltaTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateWithDeltaTime(&self, sec: NSTimeInterval);

        #[cfg(feature = "GKState")]
        /// Gets the instance of the indicated state class from this state machine.
        /// Returns nil if the state does not exist
        ///
        ///
        /// Parameter `stateClass`: the class of the state to be retrieved
        ///
        /// # Safety
        ///
        /// `state_class` probably has further requirements.
        #[unsafe(method(stateForClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stateForClass(&self, state_class: &AnyClass) -> Option<Retained<GKState>>;

        /// Returns YES if the indicated class is a a valid next state or if currentState is nil
        ///
        ///
        /// Parameter `stateClass`: the class of the state to be tested
        ///
        /// # Safety
        ///
        /// `state_class` probably has further requirements.
        #[unsafe(method(canEnterState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canEnterState(&self, state_class: &AnyClass) -> bool;

        /// Calls canEnterState to check if we can enter the given state and then enters that state if so.
        /// [GKState willExitWithNextState:] is called on the old current state.
        /// [GKState didEnterWithPreviousState:] is called on the new state.
        ///
        ///
        /// Parameter `stateClass`: the class of the state to switch to
        ///
        /// Returns: YES if state was entered.  NO otherwise.
        ///
        /// # Safety
        ///
        /// `state_class` probably has further requirements.
        #[unsafe(method(enterState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enterState(&self, state_class: &AnyClass) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKStateMachine {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
