//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A collection of GKGraphNodes that are governed by a set of extruded GKPolygonObstacles
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkobstaclegraph?language=objc)
    #[unsafe(super(GKGraph, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
    pub struct GKObstacleGraph<NodeType: ?Sized = AnyObject>;
);

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
impl<NodeType: ?Sized + Message + AsRef<GKGraphNode2D>> GKObstacleGraph<NodeType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewNodeType: ?Sized + Message + AsRef<GKGraphNode2D>>(
        &self,
    ) -> &GKObstacleGraph<NewNodeType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
extern_conformance!(
    unsafe impl<NodeType: ?Sized + NSCoding + AsRef<GKGraphNode2D>> NSCoding
        for GKObstacleGraph<NodeType>
    {
    }
);

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
extern_conformance!(
    unsafe impl<NodeType: ?Sized + AsRef<GKGraphNode2D>> NSCopying for GKObstacleGraph<NodeType> {}
);

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
unsafe impl<NodeType: ?Sized + Message + AsRef<GKGraphNode2D>> CopyingHelper
    for GKObstacleGraph<NodeType>
{
    type Result = Self;
}

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
extern_conformance!(
    unsafe impl<NodeType: ?Sized + AsRef<GKGraphNode2D>> NSObjectProtocol
        for GKObstacleGraph<NodeType>
    {
    }
);

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
extern_conformance!(
    unsafe impl<NodeType: ?Sized + NSSecureCoding + AsRef<GKGraphNode2D>> NSSecureCoding
        for GKObstacleGraph<NodeType>
    {
    }
);

#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
impl<NodeType: Message + AsRef<GKGraphNode2D>> GKObstacleGraph<NodeType> {
    extern_methods!(
        #[cfg(feature = "GKObstacle")]
        #[unsafe(method(obstacles))]
        #[unsafe(method_family = none)]
        pub unsafe fn obstacles(&self) -> Retained<NSArray<GKPolygonObstacle>>;

        #[unsafe(method(bufferRadius))]
        #[unsafe(method_family = none)]
        pub unsafe fn bufferRadius(&self) -> c_float;

        #[cfg(feature = "GKObstacle")]
        /// Creates an optimal bidirectional graph based on a list of obstacles.
        /// Each vertex of each obstacle is extruded and a connection is made between each vertex that does not intersect an obstacle
        /// Guaranteed not to have any edges which intersect obstacles.
        /// Same effect as [[GKObstacleGraph alloc] init], setting bufferRadius, and then calling addObstacles.
        ///
        /// Parameter `obstacles`: a list of obstacles to create the graph from
        ///
        /// Parameter `bufferRadius`: the circular radius of a potential agent that will navigate this graph.  Obstacles are extruded by this amount to create the graph.  Must be positive.  Negative values are clipped to 0.0f
        #[unsafe(method(graphWithObstacles:bufferRadius:))]
        #[unsafe(method_family = none)]
        pub unsafe fn graphWithObstacles_bufferRadius(
            obstacles: &NSArray<GKPolygonObstacle>,
            buffer_radius: c_float,
        ) -> Retained<Self>;

        #[cfg(feature = "GKObstacle")]
        #[unsafe(method(initWithObstacles:bufferRadius:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithObstacles_bufferRadius(
            this: Allocated<Self>,
            obstacles: &NSArray<GKPolygonObstacle>,
            buffer_radius: c_float,
        ) -> Retained<Self>;

        #[cfg(feature = "GKObstacle")]
        /// Creates an optimal bidirectional graph based on a list of obstacles.
        /// Each vertex of each obstacle is extruded and a connection is made between each vertex that does not intersect an obstacle
        /// Guaranteed not to have any edges which intersect obstacles.
        /// Same effect as [[GKObstacleGraph alloc] init], setting bufferRadius, and then calling addObstacles.
        ///
        /// Parameter `obstacles`: a list of obstacles to create the graph from
        ///
        /// Parameter `bufferRadius`: the circular radius of a potential agent that will navigate this graph.  Obstacles are extruded by this amount to create the graph.  Must be positive.  Negative values are clipped to 0.0f
        ///
        /// Parameter `nodeClass`: the class of the nodes that this graph should create.  Must descend from GKGraphNode2D
        ///
        /// # Safety
        ///
        /// `node_class` probably has further requirements.
        #[unsafe(method(graphWithObstacles:bufferRadius:nodeClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn graphWithObstacles_bufferRadius_nodeClass(
            obstacles: &NSArray<GKPolygonObstacle>,
            buffer_radius: c_float,
            node_class: &AnyClass,
        ) -> Retained<Self>;

        #[cfg(feature = "GKObstacle")]
        /// # Safety
        ///
        /// `node_class` probably has further requirements.
        #[unsafe(method(initWithObstacles:bufferRadius:nodeClass:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithObstacles_bufferRadius_nodeClass(
            this: Allocated<Self>,
            obstacles: &NSArray<GKPolygonObstacle>,
            buffer_radius: c_float,
            node_class: &AnyClass,
        ) -> Retained<Self>;

        /// Connects the node to this graph by testing edge intersection with existing obstacles.
        /// Same behavior as if this node had been present during initWithObstacles.
        ///
        /// Parameter `node`: the node to connect
        #[unsafe(method(connectNodeUsingObstacles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectNodeUsingObstacles(&self, node: &NodeType);

        #[cfg(feature = "GKObstacle")]
        /// Same behavior as connectNodeUsingObstacles: except you can optionally ignore certain obstacles from being tested for intersection.
        #[unsafe(method(connectNodeUsingObstacles:ignoringObstacles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectNodeUsingObstacles_ignoringObstacles(
            &self,
            node: &NodeType,
            obstacles_to_ignore: &NSArray<GKPolygonObstacle>,
        );

        #[cfg(feature = "GKObstacle")]
        /// Same behavior as connectNodeUsingObstacles: except you can optionally ignore the bounding radius of certain obstacles from being tested for intersection
        #[unsafe(method(connectNodeUsingObstacles:ignoringBufferRadiusOfObstacles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectNodeUsingObstacles_ignoringBufferRadiusOfObstacles(
            &self,
            node: &NodeType,
            obstacles_buffer_radius_to_ignore: &NSArray<GKPolygonObstacle>,
        );

        #[cfg(feature = "GKObstacle")]
        /// Adds obstacles to this graph.
        /// Obstacle is extruded and graph nodes are generated from its vertices and then connected to this graph
        /// Nothing is done if an obstacle is already present in this graph
        /// Any existing connections that intersect the new obstacles are destroyed unless they are protected with [GKObstacleGraph lockConnection:]
        ///
        /// Parameter `obstacles`: an array of obstacles to be added
        ///
        /// See: lockConnection
        #[unsafe(method(addObstacles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObstacles(&self, obstacles: &NSArray<GKPolygonObstacle>);

        #[cfg(feature = "GKObstacle")]
        /// Removes obstacles from this graph.
        /// All associated graph nodes are removed and their connections are bidirectionally removed.
        /// Connections between obstacle nodes that were previously invalidated by any of these obstacles are restored.
        /// Nothing is done if an obstacle is already present in this graph
        ///
        /// Parameter `obstacles`: an array of obstacles to be removed
        #[unsafe(method(removeObstacles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObstacles(&self, obstacles: &NSArray<GKPolygonObstacle>);

        /// Removes all obstacles from this graph.
        #[unsafe(method(removeAllObstacles))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAllObstacles(&self);

        #[cfg(feature = "GKObstacle")]
        /// Returns an array of the graph nodes associated with a given obstacle
        ///
        /// Parameter `obstacle`: the obstacle who's nodes are to be retrieved
        #[unsafe(method(nodesForObstacle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodesForObstacle(
            &self,
            obstacle: &GKPolygonObstacle,
        ) -> Retained<NSArray<NodeType>>;

        /// Marks a connection as "locked", preventing this connection from being destroyed when you add obstacles that would intersect it
        ///
        /// Parameter `startNode`: startNode of the connection to lock
        ///
        /// Parameter `endNode`: endNode of the connection to lock
        #[unsafe(method(lockConnectionFromNode:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lockConnectionFromNode_toNode(
            &self,
            start_node: &NodeType,
            end_node: &NodeType,
        );

        /// "Unlocks" a connection, removing its protection from being destroyed when you add obstacles that would intersect it
        ///
        /// Parameter `startNode`: startNode of the connection to unlock
        ///
        /// Parameter `endNode`: endNode of the connection to unlock
        ///
        /// See: lockConnection
        #[unsafe(method(unlockConnectionFromNode:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unlockConnectionFromNode_toNode(
            &self,
            start_node: &NodeType,
            end_node: &NodeType,
        );

        /// Query if a given connection is locked
        ///
        /// Parameter `startNode`: startNode of the connection to query
        ///
        /// Parameter `endNode`: endNode of the connection to query
        ///
        /// See: lockConnection
        ///
        /// See: unlockConnection
        ///
        /// Returns: YES if the connection was locked with lockConnection, NO if it was never locked or was unlocked via unlockConnection
        #[unsafe(method(isConnectionLockedFromNode:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isConnectionLockedFromNode_toNode(
            &self,
            start_node: &NodeType,
            end_node: &NodeType,
        ) -> bool;

        /// Returns the class of the specified generic index
        #[unsafe(method(classForGenericArgumentAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn classForGenericArgumentAtIndex(&self, index: NSUInteger)
            -> &'static AnyClass;
    );
}

/// Methods declared on superclass `GKGraph`.
#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
impl<NodeType: Message + AsRef<GKGraphNode2D>> GKObstacleGraph<NodeType> {
    extern_methods!(
        /// Creates a graph with the provided array of nodes.
        ///
        /// Parameter `nodes`: the nodes to create the graph with
        #[unsafe(method(graphWithNodes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn graphWithNodes(nodes: &NSArray<GKGraphNode>) -> Retained<Self>;

        #[unsafe(method(initWithNodes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNodes(
            this: Allocated<Self>,
            nodes: &NSArray<GKGraphNode>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "GKGraph", feature = "GKGraphNode"))]
impl<NodeType: Message + AsRef<GKGraphNode2D>> GKObstacleGraph<NodeType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
