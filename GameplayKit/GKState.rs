//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// Represents a single state in a state machine.
    /// By default, states allow transitions freely to and from the states in the machine.
    ///
    /// If a more restricted set of valid transitions are needed in the state machine, you may override isValidNextState: where applicable.
    ///
    ///
    /// See: GKStateMachine
    ///
    /// See: isValidNextState:
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gameplaykit/gkstate?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKState;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKState {}
);

impl GKState {
    extern_methods!(
        #[cfg(feature = "GKStateMachine")]
        /// The state machine that this state is associated with.
        /// This is nil if this state hasn't been added to a state machine yet.
        #[unsafe(method(stateMachine))]
        #[unsafe(method_family = none)]
        pub unsafe fn stateMachine(&self) -> Option<Retained<GKStateMachine>>;

        /// Creates a new state to be used in a state machine.
        ///
        ///
        /// See: GKStateMachine
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Returns YES if the given class is a valid next state to enter.
        ///
        /// By default GKState will return YES for any class that is subclass of GKState.
        /// Override this in a subclass to enforce limited edge traversals in the state machine.
        ///
        ///
        /// See: GKStateMachine.canEnterState:
        ///
        /// See: GKStateMachine.enterState:
        ///
        ///
        /// Parameter `stateClass`: the class to be checked
        ///
        /// Returns: YES if the class is kind of GKState and the state transition is valid, else NO.
        ///
        /// # Safety
        ///
        /// `state_class` probably has further requirements.
        #[unsafe(method(isValidNextState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isValidNextState(&self, state_class: &AnyClass) -> bool;

        /// Called by GKStateMachine when this state is entered.
        ///
        ///
        /// Parameter `previousState`: the state that was exited to enter this state.  This is nil if this is the state machine's first entered state.
        ///
        /// See: stateMachineWithStates:initialStateClass:
        #[unsafe(method(didEnterWithPreviousState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didEnterWithPreviousState(&self, previous_state: Option<&GKState>);

        /// Called by GKStateMachine when it is updated
        ///
        ///
        /// Parameter `seconds`: the time in seconds since the last update
        #[unsafe(method(updateWithDeltaTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateWithDeltaTime(&self, seconds: NSTimeInterval);

        /// Called by GKStateMachine when this state is exited
        ///
        ///
        /// Parameter `nextState`: the state that is being entered next
        #[unsafe(method(willExitWithNextState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn willExitWithNextState(&self, next_state: &GKState);
    );
}

/// Methods declared on superclass `NSObject`.
impl GKState {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
