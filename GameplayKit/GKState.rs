//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The abstract superclass for defining state-specific logic as part of a state machine.
    ///
    /// ## Overview
    ///
    /// The [`GKState`](https://developer.apple.com/documentation/gameplaykit/gkstate) abstract class defines the features of state classes to be used with a state machine (a [`GKStateMachine`](https://developer.apple.com/documentation/gameplaykit/gkstatemachine) object). You build a state machine by defining a separate [`GKState`](https://developer.apple.com/documentation/gameplaykit/gkstate) subclass for each state of the machine. In each state class, you use the [`isValidNextState:`](https://developer.apple.com/documentation/gameplaykit/gkstate/isvalidnextstate(_:)) method to define which other states are valid for a machine to transition into. State classes provide a place to put state-dependent game logic, such as actions that should happen when entering or exiting a specific state, or per-frame update code that is valid only when in a specific state.
    ///
    /// For more information about state machines, read [State Machines](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/StateMachine.html#//apple_ref/doc/uid/TP40015172-CH7) in [GameplayKit Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/GameplayKit_Guide/index.html#//apple_ref/doc/uid/TP40015172).
    ///
    ///
    /// Represents a single state in a state machine.
    /// By default, states allow transitions freely to and from the states in the machine.
    ///
    /// If a more restricted set of valid transitions are needed in the state machine, you may override isValidNextState: where applicable.
    ///
    ///
    /// See: GKStateMachine
    ///
    /// See: isValidNextState:
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKState;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKState {}
);

impl GKState {
    extern_methods!(
        #[cfg(feature = "GKStateMachine")]
        /// The state machine that this state is associated with.
        /// This is nil if this state hasn't been added to a state machine yet.
        #[unsafe(method(stateMachine))]
        #[unsafe(method_family = none)]
        pub unsafe fn stateMachine(&self) -> Option<Retained<GKStateMachine>>;

        /// Creates a new state to be used in a state machine.
        ///
        ///
        /// See: GKStateMachine
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Returns YES if the given class is a valid next state to enter.
        ///
        /// By default GKState will return YES for any class that is subclass of GKState.
        /// Override this in a subclass to enforce limited edge traversals in the state machine.
        ///
        ///
        /// See: GKStateMachine.canEnterState:
        ///
        /// See: GKStateMachine.enterState:
        ///
        ///
        /// Parameter `stateClass`: the class to be checked
        ///
        /// Returns: YES if the class is kind of GKState and the state transition is valid, else NO.
        ///
        /// # Safety
        ///
        /// `state_class` probably has further requirements.
        #[unsafe(method(isValidNextState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isValidNextState(&self, state_class: &AnyClass) -> bool;

        /// Called by GKStateMachine when this state is entered.
        ///
        ///
        /// Parameter `previousState`: the state that was exited to enter this state.  This is nil if this is the state machine's first entered state.
        ///
        /// See: stateMachineWithStates:initialStateClass:
        #[unsafe(method(didEnterWithPreviousState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didEnterWithPreviousState(&self, previous_state: Option<&GKState>);

        /// Called by GKStateMachine when it is updated
        ///
        ///
        /// Parameter `seconds`: the time in seconds since the last update
        #[unsafe(method(updateWithDeltaTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateWithDeltaTime(&self, seconds: NSTimeInterval);

        /// Called by GKStateMachine when this state is exited
        ///
        ///
        /// Parameter `nextState`: the state that is being entered next
        #[unsafe(method(willExitWithNextState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn willExitWithNextState(&self, next_state: &GKState);
    );
}

/// Methods declared on superclass `NSObject`.
impl GKState {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
