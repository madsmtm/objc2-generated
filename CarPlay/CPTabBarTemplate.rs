//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A container template that displays and manages other templates, presenting them as tabs.
    ///
    /// ## Overview
    ///
    /// `CPTabBarTemplate` is a container template that displays a collection of other templates, where each template occupies a single tab in the tab bar. At runtime, use [`maximumTabCount`](https://developer.apple.com/documentation/carplay/cptabbartemplate/maximumtabcount) to determine the maximum number of tabs that your tab bar can display.
    ///
    /// When creating an instance of `CPTabBarTemplate`, provide an array of templates for the tab bar to display. CarPlay treats the array’s templates as root templates, each with its own navigation hierarchy. When a tab bar template is the [`rootTemplate`](https://developer.apple.com/documentation/carplay/cpinterfacecontroller/roottemplate) of your app’s interface controller and you use the controller to add and remove templates, CarPlay applies those changes to the selected tab’s navigation hierarchy.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  You can’t add a tab bar template to an existing navigation hierarchy, or present one modally. Instead, use [`setRootTemplate:animated:completion:`](https://developer.apple.com/documentation/carplay/cpinterfacecontroller/setroottemplate(_:animated:completion:)) to set the tab bar as your app’s root template.
    ///
    ///
    ///
    /// </div>
    /// Use a transactional approach when making changes to the tab bar. Retrieve the current set of templates using the [`templates`](https://developer.apple.com/documentation/carplay/cptabbartemplate/templates) property. Add, remove, reorder, or make appearance changes to one or more of the array’s templates. For example, use the [`tabTitle`](https://developer.apple.com/documentation/carplay/cptemplate/tabtitle) property to update a template’s tab title, or set [`showsTabBadge`](https://developer.apple.com/documentation/carplay/cptemplate/showstabbadge) to `true` to add an indicator to a template’s tab. Then call the [`updateTemplates:`](https://developer.apple.com/documentation/carplay/cptabbartemplate/updatetemplates(_:)) method and pass it the updated array. CarPlay commits those changes and updates the tab bar.
    ///
    /// When the user selects a tab, the template calls the [`tabBarTemplate:didSelectTemplate:`](https://developer.apple.com/documentation/carplay/cptabbartemplatedelegate/tabbartemplate(_:didselect:)) method on its delegate, which is an object you provide that conforms to the [`CPTabBarTemplateDelegate`](https://developer.apple.com/documentation/carplay/cptabbartemplatedelegate) protocol.
    ///
    ///
    #[unsafe(super(CPTemplate, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CPTemplate")]
    pub struct CPTabBarTemplate;
);

#[cfg(feature = "CPTemplate")]
extern_conformance!(
    unsafe impl NSCoding for CPTabBarTemplate {}
);

#[cfg(feature = "CPTemplate")]
extern_conformance!(
    unsafe impl NSObjectProtocol for CPTabBarTemplate {}
);

#[cfg(feature = "CPTemplate")]
extern_conformance!(
    unsafe impl NSSecureCoding for CPTabBarTemplate {}
);

#[cfg(feature = "CPTemplate")]
impl CPTabBarTemplate {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        /// Initialize the tab bar with an array of templates. Each template in the array
        /// becomes a tab on the tab bar.
        ///
        /// The maximum number of tabs in the tab bar template is given by
        /// `maximumTabCount.`
        #[unsafe(method(initWithTemplates:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTemplates(
            this: Allocated<Self>,
            templates: &NSArray<CPTemplate>,
        ) -> Retained<Self>;

        /// The tab bar delegate is informed of tab bar events, like selecting a tab.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn CPTabBarTemplateDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn CPTabBarTemplateDelegate>>,
        );

        /// The maximum number of tabs that your app may display in a
        /// `CPTabBarTemplate,`depending on the entitlements that your app declares.
        ///
        ///
        /// Warning: The system will throw an exception if your app attempts to display more
        /// than this number of tabs in your tab bar template.
        #[unsafe(method(maximumTabCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumTabCount(mtm: MainThreadMarker) -> NSInteger;

        /// The currently-visible templates in the tab bar. Each template corresponds to
        /// a single tab on the tab bar.
        #[unsafe(method(templates))]
        #[unsafe(method_family = none)]
        pub unsafe fn templates(&self) -> Retained<NSArray<CPTemplate>>;

        /// The currently-selected template in the tab bar.
        #[unsafe(method(selectedTemplate))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectedTemplate(&self) -> Option<Retained<CPTemplate>>;

        /// Update the tabs displayed in this tab bar, replacing the currently-visible tabs.
        /// Each template in the array becomes a tab on the tab bar.
        #[unsafe(method(updateTemplates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateTemplates(&self, new_templates: &NSArray<CPTemplate>);

        /// Update the currently-selected tab in this tab bar template, switching to the first tab
        /// that is currently hosting
        /// `newTemplate.`
        /// Parameter `newTemplate`: The template that should become selected in the tab bar.
        #[unsafe(method(selectTemplate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectTemplate(&self, new_template: &CPTemplate);

        /// Update the currently-selected tab in this tab bar template, switching to the tab
        /// at the specified index.
        ///
        ///
        /// Parameter `index`: The index of the tab to select. This must be less than the number
        /// of tabs in this tab bar template.
        #[unsafe(method(selectTemplateAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectTemplateAtIndex(&self, index: NSInteger);
    );
}

extern_protocol!(
    /// The methods an object implements to act as the delegate for a tab bar template.
    ///
    /// ## Overview
    ///
    /// You use the `CPTabBarTemplateDelegate` protocol to respond to a tab bar template’s events. The protocol defines methods that the template calls in response to these events, and your implementation provides the appropriate behavior when the events occur. For example, reloading a tab’s contents when the user selects it to make sure it’s displaying the latest data.
    ///
    ///
    pub unsafe trait CPTabBarTemplateDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "CPTemplate")]
        /// The user has selected one of the tabs in the tab bar template, bringing the selected template to the foreground.
        #[unsafe(method(tabBarTemplate:didSelectTemplate:))]
        #[unsafe(method_family = none)]
        unsafe fn tabBarTemplate_didSelectTemplate(
            &self,
            tab_bar_template: &CPTabBarTemplate,
            selected_template: &CPTemplate,
        );
    }
);
