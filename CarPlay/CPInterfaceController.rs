//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-ui-kit")]
use objc2_ui_kit::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/carplay/carplayerrordomain?language=objc)
    pub static CarPlayErrorDomain: &'static NSString;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/carplay/cpinterfacecontroller?language=objc)
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CPInterfaceController;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for CPInterfaceController {}
);

impl CPInterfaceController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        /// The delegate for this interface controller.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn CPInterfaceControllerDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn CPInterfaceControllerDelegate>>,
        );

        /// Set the preferred interface style to UIUserInterfaceStyleDark for all templates. Set this value to YES prior to setting a root template
        /// or pushing any templates for first appearance to have style UIUserInterfaceStyleDark. The default value is NO which will allow templates to change between light and dark styles.
        #[unsafe(method(prefersDarkUserInterfaceStyle))]
        #[unsafe(method_family = none)]
        pub unsafe fn prefersDarkUserInterfaceStyle(&self) -> bool;

        /// Setter for [`prefersDarkUserInterfaceStyle`][Self::prefersDarkUserInterfaceStyle].
        #[unsafe(method(setPrefersDarkUserInterfaceStyle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrefersDarkUserInterfaceStyle(
            &self,
            prefers_dark_user_interface_style: bool,
        );

        #[cfg(all(feature = "CPTemplate", feature = "block2"))]
        /// Set the root template. If no existing templates exist in the template navigation hierarchy, the animated flag will be ignored.
        /// If there is an existing template navigation hierarchy, the existing stack will be replaced by the new root template.
        ///
        /// The completion block will be called after the template has been presented. If the template was presented successfully,
        /// the boolean parameter will be YES. Otherwise, the boolean parameter will be NO and an
        /// `NSError`will be provided describing the failure.
        ///
        ///
        /// Note: If the template presentation is not successful AND no completion block is specified, an exception will be thrown.
        #[unsafe(method(setRootTemplate:animated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRootTemplate_animated_completion(
            &self,
            root_template: &CPTemplate,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(all(feature = "CPTemplate", feature = "block2"))]
        /// Push a new template onto the template navigation hierarchy, showing it immediately.
        ///
        /// The completion block will be called after the template has been presented. If the template was presented successfully,
        /// the boolean parameter will be YES. Otherwise, the boolean parameter will be NO and an
        /// `NSError`will be provided describing the failure.
        ///
        ///
        /// Note: If the template presentation is not successful AND no completion block is specified, an exception will be thrown.
        #[unsafe(method(pushTemplate:animated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pushTemplate_animated_completion(
            &self,
            template_to_push: &CPTemplate,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Pop back a single level in the template navigation hierarchy.
        /// The completion block will be called after the pop completes.
        /// The success parameter in the completion block indicates if any template was popped.
        #[unsafe(method(popTemplateAnimated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn popTemplateAnimated_completion(
            &self,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Pop back to the first template in the template navigation hierarchy.
        /// The completion block will be called after the pop completes.
        /// The success parameter in the completion block indicates if any templates were popped.
        #[unsafe(method(popToRootTemplateAnimated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn popToRootTemplateAnimated_completion(
            &self,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(all(feature = "CPTemplate", feature = "block2"))]
        /// Pop back to a specified template.
        ///
        /// targetTemplate must exist in the current template navigation hierarchy.
        ///
        /// The completion block will be called after the pop completes.
        /// If the specified template does not exist in the template stack,
        /// the completion block will be called with a success parameter of NO and a non-nil NSError.
        #[unsafe(method(popToTemplate:animated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn popToTemplate_animated_completion(
            &self,
            target_template: &CPTemplate,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(all(feature = "CPTemplate", feature = "block2"))]
        /// Present a template modally over the navigation hierarchy. Only one template may be presented at a time.
        ///
        ///
        /// Note: Supported template types:
        /// `CPActionSheetTemplate,``CPAlertTemplate,``CPVoiceControlTemplate`The completion block will be called after the template has been presented. If the template was presented successfully,
        /// the boolean parameter will be YES. Otherwise, the boolean parameter will be NO and an
        /// `NSError`will be provided describing the failure.
        ///
        ///
        /// Note: If the template presentation is not successful AND no completion block is specified, an exception will be thrown.
        #[unsafe(method(presentTemplate:animated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentTemplate_animated_completion(
            &self,
            template_to_present: &CPTemplate,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Dismiss the current modally-presented template, optionally animating the dismissal.
        ///
        ///
        /// Note: If there is no current modally-presented template, this method will have no effect.
        ///
        /// The completion block will be called after the template has been dismissed. If the template was dismissed successfully,
        /// the boolean parameter will be YES. Otherwise, the boolean parameter will be NO and an
        /// `NSError`will be provided describing the failure.
        #[unsafe(method(dismissTemplateAnimated:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissTemplateAnimated_completion(
            &self,
            animated: bool,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(feature = "CPTemplate")]
        /// The current modally-presented template.
        ///
        ///
        /// Warning: Reading this property may synchronously perform an IPC call to retrieve the current presented template.
        #[unsafe(method(presentedTemplate))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentedTemplate(&self) -> Option<Retained<CPTemplate>>;

        #[cfg(feature = "CPTemplate")]
        /// Returns the root template.
        #[unsafe(method(rootTemplate))]
        #[unsafe(method_family = none)]
        pub unsafe fn rootTemplate(&self) -> Retained<CPTemplate>;

        #[cfg(feature = "CPTemplate")]
        /// The top template in the navigation hierarchy.
        ///
        ///
        /// Warning: Reading this property may synchronously perform an IPC call to retrieve the current top-most template.
        #[unsafe(method(topTemplate))]
        #[unsafe(method_family = none)]
        pub unsafe fn topTemplate(&self) -> Option<Retained<CPTemplate>>;

        #[cfg(feature = "CPTemplate")]
        /// The current stack of templates in the navigation hierarchy.
        ///
        ///
        /// Warning: Reading this property may synchronously perform an IPC call to retrieve the current stack of templates.
        #[unsafe(method(templates))]
        #[unsafe(method_family = none)]
        pub unsafe fn templates(&self) -> Retained<NSArray<CPTemplate>>;

        #[cfg(feature = "objc2-ui-kit")]
        /// The trait collection for the car's primary screen.
        ///
        /// Your app should use this trait collection when deriving metrics, like screen scale, for
        /// your templates. For example, images you display in any template should be sized to a
        /// display scale matching the scale of the
        /// `carTraitCollection,`not the scale of the
        /// iOS device's main screen.
        #[unsafe(method(carTraitCollection))]
        #[unsafe(method_family = none)]
        pub unsafe fn carTraitCollection(&self) -> Retained<UITraitCollection>;

        #[cfg(feature = "CPTemplate")]
        /// Set the root template. If no existing templates exist in the template navigation hierarchy, the animated flag will be ignored.
        /// If there is an existing template navigation hierarchy, the existing stack will be replaced by the new root template.
        #[deprecated]
        #[unsafe(method(setRootTemplate:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRootTemplate_animated(&self, root_template: &CPTemplate, animated: bool);

        #[cfg(feature = "CPTemplate")]
        /// Push a new template onto the template navigation hierarchy, showing it immediately.
        #[deprecated]
        #[unsafe(method(pushTemplate:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pushTemplate_animated(&self, template_to_push: &CPTemplate, animated: bool);

        /// Pop back a single level in the template navigation hierarchy.
        #[deprecated]
        #[unsafe(method(popTemplateAnimated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn popTemplateAnimated(&self, animated: bool);

        /// Pop back to the first template in the template navigation hierarchy.
        #[deprecated]
        #[unsafe(method(popToRootTemplateAnimated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn popToRootTemplateAnimated(&self, animated: bool);

        #[cfg(feature = "CPTemplate")]
        /// Pop back to a specified template.
        ///
        /// targetTemplate must exist in the current template navigation hierarchy.
        #[deprecated]
        #[unsafe(method(popToTemplate:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn popToTemplate_animated(&self, target_template: &CPTemplate, animated: bool);

        #[cfg(feature = "CPTemplate")]
        /// Present a template modally over the navigation hierarchy. Only one template may be presented at a time.
        ///
        ///
        /// Note: Supported template types:
        /// `CPActionSheetTemplate,``CPAlertTemplate,``CPVoiceControlTemplate`
        #[deprecated]
        #[unsafe(method(presentTemplate:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentTemplate_animated(
            &self,
            template_to_present: &CPTemplate,
            animated: bool,
        );

        /// Dismiss the current modally-presented template, optionally animating the dismissal.
        ///
        ///
        /// Note: If there is no current modally-presented template, this method will have no effect.
        #[deprecated]
        #[unsafe(method(dismissTemplateAnimated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissTemplateAnimated(&self, animated: bool);
    );
}

extern_protocol!(
    /// CPInterfaceControllerDelegate allows your app to observe template visibility lifecycles for
    /// the templates presented by your app.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/carplay/cpinterfacecontrollerdelegate?language=objc)
    pub unsafe trait CPInterfaceControllerDelegate:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(feature = "CPTemplate")]
        #[optional]
        #[unsafe(method(templateWillAppear:animated:))]
        #[unsafe(method_family = none)]
        unsafe fn templateWillAppear_animated(&self, a_template: &CPTemplate, animated: bool);

        #[cfg(feature = "CPTemplate")]
        #[optional]
        #[unsafe(method(templateDidAppear:animated:))]
        #[unsafe(method_family = none)]
        unsafe fn templateDidAppear_animated(&self, a_template: &CPTemplate, animated: bool);

        #[cfg(feature = "CPTemplate")]
        #[optional]
        #[unsafe(method(templateWillDisappear:animated:))]
        #[unsafe(method_family = none)]
        unsafe fn templateWillDisappear_animated(&self, a_template: &CPTemplate, animated: bool);

        #[cfg(feature = "CPTemplate")]
        #[optional]
        #[unsafe(method(templateDidDisappear:animated:))]
        #[unsafe(method_family = none)]
        unsafe fn templateDidDisappear_animated(&self, a_template: &CPTemplate, animated: bool);
    }
);

extern_protocol!(
    /// A set of methods that are called by the
    /// `UIApplication`singleton in response to CarPlay lifecycle events.
    ///
    ///
    /// This must be implemented by the same object that serves as your application's delegate object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/carplay/cpapplicationdelegate?language=objc)
    #[cfg(feature = "objc2-ui-kit")]
    #[deprecated]
    pub unsafe trait CPApplicationDelegate: UIApplicationDelegate {
        #[cfg(feature = "CPWindow")]
        /// The CarPlay screen has connected and is ready to present content.
        ///
        /// Your app should create its view controller and assign it to the
        /// `rootViewController`property
        /// of this window.
        ///
        ///
        /// Note: It is the responsibility of the delegate to maintain a reference to the interface controller beyond the scope of this method.
        #[deprecated]
        #[unsafe(method(application:didConnectCarInterfaceController:toWindow:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didConnectCarInterfaceController_toWindow(
            &self,
            application: &UIApplication,
            interface_controller: &CPInterfaceController,
            window: &CPWindow,
        );

        #[cfg(feature = "CPWindow")]
        /// The CarPlay screen has disconnected.
        #[deprecated]
        #[unsafe(method(application:didDisconnectCarInterfaceController:fromWindow:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didDisconnectCarInterfaceController_fromWindow(
            &self,
            application: &UIApplication,
            interface_controller: &CPInterfaceController,
            window: &CPWindow,
        );

        #[cfg(feature = "CPNavigationAlert")]
        /// If your application posts a
        /// `CPNavigationAlert`while backgrounded, a notification banner may be presented to the user.
        /// If the user taps on that banner, your application will launch on the car screen and this method will be called
        /// with the alert the user tapped.
        #[deprecated]
        #[optional]
        #[unsafe(method(application:didSelectNavigationAlert:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didSelectNavigationAlert(
            &self,
            application: &UIApplication,
            navigation_alert: &CPNavigationAlert,
        );

        #[cfg(feature = "CPManeuver")]
        /// If your application posts a
        /// `CPManeuver`while backgrounded, a notification banner may be presented to the user.
        /// If the user taps on that banner, your application will launch on the car screen and this method will be called
        /// with the maneuver the user tapped.
        #[deprecated]
        #[optional]
        #[unsafe(method(application:didSelectManeuver:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didSelectManeuver(
            &self,
            application: &UIApplication,
            maneuver: &CPManeuver,
        );
    }
);
