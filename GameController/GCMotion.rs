//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// A 3 dimensional acceleration vector measured as scalar multiples of earth's gravitational acceleration, G.
///
/// The azimuth direction is assumed to be (0, 0, 1), so a device held at rest with the z axis aligned with the azimuth
/// is assumed to have gravitation applying the vector (0, 0, -1).
///
/// Field: x X-axis acceleration as a scalar multiple of earth's gravitational acceleration, G.
/// Field: y Y-axis acceleration as a scalar multiple of earth's gravitational acceleration, G.
/// Field: z Z-axis acceleration as a scalar multiple of earth's gravitational acceleration, G.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcacceleration?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct GCAcceleration {
    pub x: c_double,
    pub y: c_double,
    pub z: c_double,
}

unsafe impl Encode for GCAcceleration {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <c_double>::ENCODING,
            <c_double>::ENCODING,
            <c_double>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for GCAcceleration {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure containing 3-axis rotation rate data.
///
/// Field: x   X-axis rotation rate in radians/second. The sign follows the right hand
/// rule (i.e. if the right hand is wrapped around the X axis such that the
/// tip of the thumb points toward positive X, a positive rotation is one
/// toward the tips of the other 4 fingers).
///
/// Field: y   Y-axis rotation rate in radians/second. The sign follows the right hand
/// rule (i.e. if the right hand is wrapped around the Y axis such that the
/// tip of the thumb points toward positive Y, a positive rotation is one
/// toward the tips of the other 4 fingers).
/// Field: z
/// Z-axis rotation rate in radians/second. The sign follows the right hand
/// rule (i.e. if the right hand is wrapped around the Z axis such that the
/// tip of the thumb points toward positive Z, a positive rotation is one
/// toward the tips of the other 4 fingers).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcrotationrate?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct GCRotationRate {
    pub x: c_double,
    pub y: c_double,
    pub z: c_double,
}

unsafe impl Encode for GCRotationRate {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <c_double>::ENCODING,
            <c_double>::ENCODING,
            <c_double>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for GCRotationRate {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure containing 3-axis rotation data. The angles are rotated in order or pitch then yaw then roll.
///
/// Field: pitch X-axis rotation in radians. The sign follows the right hand
/// rule (i.e. if the right hand is wrapped around the X axis such that the
/// tip of the thumb points toward positive X, a positive rotation is one
/// toward the tips of the other 4 fingers).
///
/// Field: yaw   Y-axis rotation in radians. The sign follows the right hand
/// rule (i.e. if the right hand is wrapped around the Y axis such that the
/// tip of the thumb points toward positive Y, a positive rotation is one
/// toward the tips of the other 4 fingers).
///
/// Field: roll  Z-axis rotation in radians. The sign follows the right hand
/// rule (i.e. if the right hand is wrapped around the Z axis such that the
/// tip of the thumb points toward positive Z, a positive rotation is one
/// toward the tips of the other 4 fingers).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gceulerangles?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct GCEulerAngles {
    pub pitch: c_double,
    pub yaw: c_double,
    pub roll: c_double,
}

unsafe impl Encode for GCEulerAngles {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <c_double>::ENCODING,
            <c_double>::ENCODING,
            <c_double>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for GCEulerAngles {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Represents a quaternion (one way of parameterizing attitude).
/// If q is an instance of GCQuaternion, mathematically it represents the following quaternion:
///
/// q.x*i + q.y*j + q.z*k + q.w
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcquaternion?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct GCQuaternion {
    pub x: c_double,
    pub y: c_double,
    pub z: c_double,
    pub w: c_double,
}

unsafe impl Encode for GCQuaternion {
    const ENCODING: Encoding = Encoding::Struct(
        "GCQuaternion",
        &[
            <c_double>::ENCODING,
            <c_double>::ENCODING,
            <c_double>::ENCODING,
            <c_double>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for GCQuaternion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Called whenever a motion value changed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcmotionvaluechangedhandler?language=objc)
#[cfg(feature = "block2")]
pub type GCMotionValueChangedHandler = *mut block2::DynBlock<dyn Fn(NonNull<GCMotion>)>;

extern_class!(
    /// A profile for getting motion input from a controller that has the ability to measure acceleration
    /// and rotation rate.
    ///
    /// You check for the availablity of motion inputs by getting the motion property
    /// of a controller. If that returns a nil value; motion is not available. A non-nil value is a valid
    /// GCMotion profile that is able to provide motion input.
    ///
    ///
    /// See: GCController.motion
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcmotion?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GCMotion;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GCMotion {}
);

impl GCMotion {
    extern_methods!(
        #[cfg(feature = "GCController")]
        /// A profile keeps a reference to the controller that it is mapping input from.
        ///
        ///
        /// See: GCController
        #[unsafe(method(controller))]
        #[unsafe(method_family = none)]
        pub unsafe fn controller(&self) -> Option<Retained<GCController>>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(valueChangedHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueChangedHandler(&self) -> GCMotionValueChangedHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`valueChangedHandler`][Self::valueChangedHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `value_changed_handler` must be a valid pointer or null.
        #[unsafe(method(setValueChangedHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValueChangedHandler(
            &self,
            value_changed_handler: GCMotionValueChangedHandler,
        );

        /// If this property is returns YES, you are responsible for setting sensorsActive to YES when you need motion data from the controller.
        ///
        /// Some controllers, such as the Siri Remote, automatically activate and deactivate motion sensors. In such a case, this property
        /// will return NO.
        ///
        ///
        /// See: sensorsActive
        #[unsafe(method(sensorsRequireManualActivation))]
        #[unsafe(method_family = none)]
        pub unsafe fn sensorsRequireManualActivation(&self) -> bool;

        /// Set this property to YES when you wish to receive motion data from the controller. When you set this property to NO, the motion sensors
        /// will be disabled and the GCMotion profile will not be updated.
        ///
        ///
        /// Note: It is highly recommended that you only enable sensor during the period of time you directly need motion data. Motion sensors
        /// can drain controller battery, device battery, and needlessly consume Bluetooth bandwidth.
        ///
        ///
        /// See: sensorsRequireManualActivation
        #[unsafe(method(sensorsActive))]
        #[unsafe(method_family = none)]
        pub unsafe fn sensorsActive(&self) -> bool;

        /// Setter for [`sensorsActive`][Self::sensorsActive].
        #[unsafe(method(setSensorsActive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSensorsActive(&self, sensors_active: bool);

        /// Returns YES if the controller is capable of reporting gravity and user acceleration separately.
        ///
        ///
        /// Note: Some controllers do not separate gravity from user acceleration, and only report the total acceleration of the controller.
        /// Query whether the connected controller has the ability to separate gravity and user acceleration, and it doesnâ€™t, use acceleration instead.
        ///
        ///
        /// See: acceleration
        #[unsafe(method(hasGravityAndUserAcceleration))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasGravityAndUserAcceleration(&self) -> bool;

        /// The gravity vector expressed in the controller's reference frame.
        ///
        /// Note that the total acceleration of the controller is equal to gravity plus userAcceleration.
        ///
        ///
        /// See: userAcceleration
        ///
        /// See: acceleration
        #[unsafe(method(gravity))]
        #[unsafe(method_family = none)]
        pub unsafe fn gravity(&self) -> GCAcceleration;

        /// The acceleration that the user is giving to the controller.
        ///
        /// Note that the total acceleration of the controller is equal to gravity plus userAcceleration.
        ///
        ///
        /// See: gravity
        ///
        /// See: acceleration
        #[unsafe(method(userAcceleration))]
        #[unsafe(method_family = none)]
        pub unsafe fn userAcceleration(&self) -> GCAcceleration;

        /// The total acceleration of the controller.
        ///
        ///
        /// See: gravity
        ///
        /// See: userAcceleration
        #[unsafe(method(acceleration))]
        #[unsafe(method_family = none)]
        pub unsafe fn acceleration(&self) -> GCAcceleration;

        /// The controller generating the motion data has sensors that can accurately determine the current attitude and rotation rate. If this is enabled the motion data for attitude and rotation rate are usable for inputs.
        #[deprecated = "Use -hasAttitude and -hasRotationRate methods instead"]
        #[unsafe(method(hasAttitudeAndRotationRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasAttitudeAndRotationRate(&self) -> bool;

        /// The controller generating the motion data has sensors that can accurately determine the current attitude. If this is enabled the motion data for attitude is usable for inputs.
        #[unsafe(method(hasAttitude))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasAttitude(&self) -> bool;

        /// The controller generating the motion data has sensors that can accurately determine the current rotation rate. If this is enabled the motion data for rotation rate is usable for inputs.
        #[unsafe(method(hasRotationRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasRotationRate(&self) -> bool;

        /// The current attitude of the controller.
        ///
        ///
        /// Note: Remotes without accurate attitude and rotation rate can not determine a stable attitude so the values will be (0,0,0,1) at all times.
        ///
        /// See: hasAttitude
        ///
        /// See: GCMicroGamepad
        #[unsafe(method(attitude))]
        #[unsafe(method_family = none)]
        pub unsafe fn attitude(&self) -> GCQuaternion;

        /// The current rotation rate of the controller.
        ///
        ///
        /// Note: Remotes without accurate attitude and rotation rate can not determine a stable rotation rate so the values will be (0,0,0) at all times.
        ///
        /// See: hasRotationRate
        ///
        /// See: GCMicroGamepad
        #[unsafe(method(rotationRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn rotationRate(&self) -> GCRotationRate;

        /// Sets the gravity vector expressed in the controller's reference frame.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: gravity
        #[unsafe(method(setGravity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGravity(&self, gravity: GCAcceleration);

        /// Sets the acceleration that the user is giving to the controller.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: userAcceleration
        #[unsafe(method(setUserAcceleration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserAcceleration(&self, user_acceleration: GCAcceleration);

        /// Sets the acceleration that the user is giving to the controller.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: userAcceleration
        #[unsafe(method(setAcceleration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAcceleration(&self, acceleration: GCAcceleration);

        /// Sets the current rotation rate of the controller.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: attitude
        #[unsafe(method(setAttitude:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAttitude(&self, attitude: GCQuaternion);

        /// Sets the current rotation rate of the controller.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: rotationRate
        #[unsafe(method(setRotationRate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRotationRate(&self, rotation_rate: GCRotationRate);

        /// Sets the state vector of the motion profile to a copy of the input motion profile's state vector.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: GCController.snapshot
        #[unsafe(method(setStateFromMotion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStateFromMotion(&self, motion: &GCMotion);
    );
}

/// Methods declared on superclass `NSObject`.
impl GCMotion {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
