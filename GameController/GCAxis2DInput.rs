//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// An object conforming to
    /// `GCAxis2DInput`represents an input that produces a
    /// pair of normalized values - between [-1, 1] - along two axes with fixed origin.
    /// The origin - a value of 0 - corresponds the neutral state of the input.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcaxis2dinput?language=objc)
    pub unsafe trait GCAxis2DInput: NSObjectProtocol {
        #[cfg(all(
            feature = "GCPhysicalInputElement",
            feature = "GCTypes",
            feature = "block2"
        ))]
        /// Set this block to be notified when the value of the axis input changes.
        ///
        ///
        /// Parameter `element`: the element that has been modified.
        ///
        /// Parameter `input`: the input that has been modified.
        ///
        /// Parameter `value`: the value the axis was set to at the time the valueChangedHandler fired.
        ///
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(valueDidChangeHandler))]
        #[unsafe(method_family = none)]
        unsafe fn valueDidChangeHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(
                NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                NonNull<ProtocolObject<dyn GCAxis2DInput>>,
                GCPoint2,
            ),
        >;

        #[cfg(all(
            feature = "GCPhysicalInputElement",
            feature = "GCTypes",
            feature = "block2"
        ))]
        /// Setter for [`valueDidChangeHandler`][Self::valueDidChangeHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setValueDidChangeHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn setValueDidChangeHandler(
            &self,
            value_did_change_handler: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                        NonNull<ProtocolObject<dyn GCAxis2DInput>>,
                        GCPoint2,
                    ),
                >,
            >,
        );

        #[cfg(feature = "GCTypes")]
        /// A pair of x,y normalized values for the axis input, each between -1 and 1
        /// (inclusive). The values are deadzoned and saturated before they are returned
        /// so there is no value outside the range.  Deadzoning does not remove values
        /// from the range; the full 0 to 1 magnitude of values are possible from the input.
        ///
        /// As an axis is often used in a digital sense, you can rely on a value of 0
        /// meaning the axis is inside the deadzone.  Any value greater than or less than
        /// zero is not in the deadzone.
        #[unsafe(method(value))]
        #[unsafe(method_family = none)]
        unsafe fn value(&self) -> GCPoint2;

        /// Check if the axis can support more than just digital values.
        ///
        /// Defaults to
        /// `YES`for most axis inputs.
        #[unsafe(method(isAnalog))]
        #[unsafe(method_family = none)]
        unsafe fn isAnalog(&self) -> bool;

        /// Check if the axis input value "rolls over" when reaching either the extreme
        /// high or low value.  For example, some dials can be rotated past the position
        /// that represents their maximum value causing the reported value to roll over.
        ///
        /// Defaults to
        /// `NO`for most axis elements.
        #[unsafe(method(canWrap))]
        #[unsafe(method_family = none)]
        unsafe fn canWrap(&self) -> bool;

        /// The timestamp of the last value.
        ///
        /// This time interval is not relative to any specific point in time.  You can
        /// subtract a previous timestamp from the current timestamp to determine the time
        /// (in seconds) between changes to the value.
        #[unsafe(method(lastValueTimestamp))]
        #[unsafe(method_family = none)]
        unsafe fn lastValueTimestamp(&self) -> NSTimeInterval;

        /// The interval (in seconds) between the timestamp of the last event and the
        /// current time.
        ///
        /// This should be treated as a lower bound of the event latency.  It may not
        /// include (wired or wireless) transmission latency, or latency accrued on
        /// the device before the event was transmitted to the host.
        #[unsafe(method(lastValueLatency))]
        #[unsafe(method_family = none)]
        unsafe fn lastValueLatency(&self) -> NSTimeInterval;

        #[cfg(feature = "GCPhysicalInputSource")]
        /// An object describing the physical action(s) the user performs to manipulate
        /// this input.
        #[unsafe(method(sources))]
        #[unsafe(method_family = none)]
        unsafe fn sources(&self) -> Retained<NSSet<ProtocolObject<dyn GCPhysicalInputSource>>>;
    }
);
