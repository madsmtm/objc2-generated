//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// An object conforming to
    /// `GCPressedStateInput`represents the pressed state of
    /// an element, typically a button.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcpressedstateinput?language=objc)
    pub unsafe trait GCPressedStateInput: NSObjectProtocol {
        #[cfg(all(feature = "GCPhysicalInputElement", feature = "block2"))]
        /// Set this block if you want to be notified when the pressed state changes.
        #[method(pressedDidChangeHandler)]
        unsafe fn pressedDidChangeHandler(
            &self,
        ) -> *mut block2::Block<
            dyn Fn(
                NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                NonNull<ProtocolObject<dyn GCPressedStateInput>>,
                Bool,
            ),
        >;

        #[cfg(all(feature = "GCPhysicalInputElement", feature = "block2"))]
        /// Setter for [`pressedDidChangeHandler`][Self::pressedDidChangeHandler].
        #[method(setPressedDidChangeHandler:)]
        unsafe fn setPressedDidChangeHandler(
            &self,
            pressed_did_change_handler: Option<
                &block2::Block<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                        NonNull<ProtocolObject<dyn GCPressedStateInput>>,
                        Bool,
                    ),
                >,
            >,
        );

        /// Buttons are mostly used in a digital sense, thus we have a recommended method
        /// for checking for pressed state instead of interpreting the value.
        ///
        /// As a general guideline a button is pressed if the value exceeds 0. However
        /// there may be hysteresis applied to counter noisy input values, thus incidental
        /// values around the threshold value may not trigger a change in pressed state.
        ///
        /// Other buttons may support two-stage actuation, where the button reports a
        /// value between 0 and 1 but is only considered pressed when its value is greater
        /// than some threshold other than 0.
        ///
        ///
        /// See: pressedDidChangeHandler
        #[method(isPressed)]
        unsafe fn isPressed(&self) -> bool;

        /// The timestamp of the last pressed state change.
        ///
        /// This time interval is not relative to any specific point in time.  You can
        /// subtract a previous timestamp from the current timestamp to determine the time
        /// (in seconds) between changes to the value.
        #[method(lastPressedStateTimestamp)]
        unsafe fn lastPressedStateTimestamp(&self) -> NSTimeInterval;

        /// The interval (in seconds) between the timestamp of the last pressed state
        /// change and the current time.
        ///
        /// This should be treated as a lower bound of the event latency.  It may not
        /// include (wired or wireless) transmission latency, or latency accrued on
        /// the device before the event was transmitted to the host.
        #[method(lastPressedStateLatency)]
        unsafe fn lastPressedStateLatency(&self) -> NSTimeInterval;

        #[cfg(feature = "GCPhysicalInputSource")]
        /// An object describing the physical action(s) the user performs to manipulate
        /// this input.
        #[method_id(sources)]
        #[unsafe(method_family = none)]
        unsafe fn sources(&self) -> Retained<NSSet<ProtocolObject<dyn GCPhysicalInputSource>>>;
    }
);
