//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// The name of the micro gamepad’s primary directional pad.
    ///
    /// ## Discussion
    ///
    /// For the second-generation Siri Remote and later, this represents the entire touch surface.
    ///
    ///
    /// The primary directional input surface for the directional gamepad
    ///
    ///
    /// Note: Equivalent to microgamepad.dpad
    ///
    ///
    /// Note: For the 1st generation and 2nd generation Siri Remotes, this represents touching anywhere on the entire touch surface.
    pub static GCInputMicroGamepadDpad: &'static NSString;
}

extern "C" {
    /// The name of the micro gamepad’s primary button.
    ///
    /// ## Discussion
    ///
    /// For the first-generation and second-generation Siri Remote and later, this represents the button on the entire touch surface.
    ///
    ///
    /// The primary button for the microgamepad
    ///
    ///
    /// Note: For the 1st generation and 2nd generation Siri Remotes, this represents pressing anywhere on the touch surface.
    pub static GCInputMicroGamepadButtonA: &'static NSString;
}

extern "C" {
    /// The name of the micro gamepad’s secondary button.
    ///
    /// ## Discussion
    ///
    /// For the first-generation and second-generation Siri Remote and later, this represents the play and pause button.
    ///
    ///
    /// The secondary button for the microgamepad
    ///
    ///
    /// Note: Equivalent to microgamepad.buttonX
    ///
    ///
    /// Note: For the 1st and 2nd generation Siri Remotes, this represents pressing the play/pause button.
    pub static GCInputMicroGamepadButtonX: &'static NSString;
}

extern "C" {
    /// The name of the micro gamepad’s menu button.
    ///
    /// ## Discussion
    ///
    /// For the first-generation Siri Remote, this represents the menu button. For the second-generation Siri Remote, this represents the back button.
    ///
    ///
    /// The primary menu button for the microgamepad
    ///
    ///
    /// Note: Equivalent to microgamepad.buttonMenu
    ///
    ///
    /// Note: For the 1st generation Siri Remote, this represents pressing the play/pause button. For the 2nd generation Siri Remote, this represents pressing the back button.
    ///
    ///
    /// Note: You should avoid polling this button every frame. tvOS will run a gesture recognizer on events before forwarding them to your application that can reduce the window
    /// to poll button changes. Instead, register a pressedChangedHandler or a valueChangedHandler.
    pub static GCInputMicroGamepadButtonMenu: &'static NSString;
}

/// Signature for the block that this profile calls when an element’s value changes.
///
/// Parameters:
/// - gamepad: The profile whose element value changes.
///
/// - element: The element in the profile whose value changes.
///
/// Set this block if you want to be notified when a value on a element changed. If multiple elements have changed this block will be called
/// for each element that changed. As elements in a collection, such as the axis in a dpad, tend to change at the same time and thus
/// will only call this once with the collection as the element.
///
///
/// Parameter `gamepad`: this gamepad that is being used to map the raw input data into logical values on controller elements such as the dpad or the buttons.
///
/// Parameter `element`: the element that has been modified.
#[cfg(all(
    feature = "GCControllerElement",
    feature = "GCPhysicalInputProfile",
    feature = "block2"
))]
pub type GCMicroGamepadValueChangedHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<GCMicroGamepad>, NonNull<GCControllerElement>)>;

extern_class!(
    /// A controller profile that supports the Siri Remote.
    ///
    /// ## Overview
    ///
    /// The micro gamepad controller profile supports the following input elements:
    ///
    /// - Two digital face buttons (A and X).
    ///
    /// - One analog directional pad (D-pad) that functions as a touchpad.
    ///
    /// Users can rotate game controllers that support the micro gamepad profile, switching them between landscape and portrait orientation. If you want to get directional values according to the orientation, set the [`allowsRotation`](https://developer.apple.com/documentation/gamecontroller/gcmicrogamepad/allowsrotation) property to [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/852bb015728eeba3bd6f23612e2132c5/media-3830807~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/484a6ffc804aba9b7e2d68ed5f16ad37/media-3830807%402x.png 2x" />
    ///     <img alt="An illustration of a Siri Remote with callouts for the digital face buttons, the Button menu, and the analog directional pad." src="https://docs-assets.developer.apple.com/published/852bb015728eeba3bd6f23612e2132c5/media-3830807~dark%402x.png" />
    /// </picture>
    ///
    ///
    ///
    #[unsafe(super(GCPhysicalInputProfile, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "GCPhysicalInputProfile")]
    pub struct GCMicroGamepad;
);

#[cfg(feature = "GCPhysicalInputProfile")]
extern_conformance!(
    unsafe impl NSObjectProtocol for GCMicroGamepad {}
);

#[cfg(feature = "GCPhysicalInputProfile")]
impl GCMicroGamepad {
    extern_methods!(
        #[cfg(feature = "GCController")]
        /// A profile keeps a reference to the controller that this profile is mapping input from.
        #[unsafe(method(controller))]
        #[unsafe(method_family = none)]
        pub unsafe fn controller(&self) -> Option<Retained<GCController>>;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(valueChangedHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueChangedHandler(&self) -> GCMicroGamepadValueChangedHandler;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// Setter for [`valueChangedHandler`][Self::valueChangedHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `value_changed_handler` must be a valid pointer or null.
        #[unsafe(method(setValueChangedHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValueChangedHandler(
            &self,
            value_changed_handler: GCMicroGamepadValueChangedHandler,
        );

        #[cfg(feature = "GCMicroGamepadSnapshot")]
        /// Polls the state vector of the controller and saves it to a snapshot. The snapshot is stored in a device independent
        /// format that can be serialized and used at a later date. This is useful for features such as quality assurance,
        /// save game or replay functionality among many.
        ///
        /// If your application is heavily multithreaded this may also be useful to guarantee atomicity of input handling as
        /// a snapshot will not change based on user input once it is taken.
        ///
        ///
        /// See: GCMicroGamepadSnapshot
        #[deprecated = "Use the -[GCController capture] method instead"]
        #[unsafe(method(saveSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveSnapshot(&self) -> Retained<GCMicroGamepadSnapshot>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// Optionally analog in the Micro profile. All the elements of this directional input are either analog or digital.
        #[unsafe(method(dpad))]
        #[unsafe(method_family = none)]
        pub unsafe fn dpad(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// The Micro profile has two buttons that are optionally analog in the Micro profile.
        /// Button A is the primary action button, it indicates affirmative action and should be used to advance in menus
        /// or perform the primary action in gameplay.
        #[unsafe(method(buttonA))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonA(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button X is the secondary action button, it indicates an alternate affirmative action and should be used to perform
        /// a secondary action. If there is no secondary action it should be used as equivalent to buttonA.
        ///
        /// Unlike on other profiles there is no negative button on this profile. Instead the menu button should be
        /// used to present menu content or to retreat in a menu flow.
        ///
        /// See: buttonA
        #[unsafe(method(buttonX))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonX(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button menu is the primary menu button, and should be used to enter the main menu and pause the game.
        #[unsafe(method(buttonMenu))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonMenu(&self) -> Retained<GCControllerButtonInput>;

        /// The Micro profile can use the raw position values of the touchpad on the remote as D-pad values, or it can create a virtual dpad centered around the first contact point with the surface.
        ///
        /// If NO; a smaller sliding window is created around the initial touch point and subsequent movement is relative to that center. Movement outside the window will slide the window with it to re-center it. This is great for surfaces where there is no clear sense of a middle and drift over time is an issue.
        ///
        /// If YES; the absolute values are used and any drift will have to managed manually either through user traning or by a developer using the dpad.
        ///
        /// The default value for this property is NO, meaning a sliding window is used for the dpad.
        #[unsafe(method(reportsAbsoluteDpadValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn reportsAbsoluteDpadValues(&self) -> bool;

        /// Setter for [`reportsAbsoluteDpadValues`][Self::reportsAbsoluteDpadValues].
        #[unsafe(method(setReportsAbsoluteDpadValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReportsAbsoluteDpadValues(&self, reports_absolute_dpad_values: bool);

        /// Allows the Micro profile to monitor the orientation of the controller, if the controller is positioned in landscape orientation, D-pad input values will be transposed 90 degrees to match the new orientation.
        ///
        /// The default value for this property is NO.
        #[unsafe(method(allowsRotation))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsRotation(&self) -> bool;

        /// Setter for [`allowsRotation`][Self::allowsRotation].
        #[unsafe(method(setAllowsRotation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsRotation(&self, allows_rotation: bool);

        /// Sets the state vector of the micro gamepad to a copy of the input micro gamepad's state vector.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: GCController.snapshot
        #[unsafe(method(setStateFromMicroGamepad:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStateFromMicroGamepad(&self, micro_gamepad: &GCMicroGamepad);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "GCPhysicalInputProfile")]
impl GCMicroGamepad {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
