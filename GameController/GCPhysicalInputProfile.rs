//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The base class for controller profiles that support physical buttons, thumbsticks, and directional pads.
    ///
    /// ## Overview
    ///
    /// This class provides properties and methods for accessing common elements of controllers, and for creating snapshots of profiles.
    ///
    ///
    /// A game controller profile representing physical buttons, thumbsticks, dpads, etc... on a controller.
    ///
    /// All controller profiles provide a base level of information about the controller they belong to.
    ///
    /// A profile maps the hardware notion of a controller into a logical controller. One that a developer can design for
    /// and depend on, no matter the underlying hardware.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GCPhysicalInputProfile;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GCPhysicalInputProfile {}
);

impl GCPhysicalInputProfile {
    extern_methods!(
        #[cfg(feature = "GCDevice")]
        /// A profile keeps a reference to the device that this profile is mapping input from
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub unsafe fn device(&self) -> Option<Retained<ProtocolObject<dyn GCDevice>>>;

        /// The last time elements of this profile were updated.
        #[unsafe(method(lastEventTimestamp))]
        #[unsafe(method_family = none)]
        pub unsafe fn lastEventTimestamp(&self) -> NSTimeInterval;

        /// Whether the user has remapped their physical input controls for this profile at the system level.
        ///
        ///
        /// On iOS and tvOS, users can remap their game controller inputs in Settings.
        #[unsafe(method(hasRemappedElements))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasRemappedElements(&self) -> bool;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// Set this block if you want to be notified when a value on a element changed. If multiple elements have changed this block will be called
        /// for each element that changed.
        ///
        ///
        /// Parameter `profile`: this profile that is being used to map the raw input data into logical values on controller elements such as the dpad or the buttons.
        ///
        /// Parameter `element`: the element that has been modified.
        ///
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(valueDidChangeHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueDidChangeHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(NonNull<GCPhysicalInputProfile>, NonNull<GCControllerElement>),
        >;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// Setter for [`valueDidChangeHandler`][Self::valueDidChangeHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setValueDidChangeHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValueDidChangeHandler(
            &self,
            value_did_change_handler: Option<
                &block2::DynBlock<
                    dyn Fn(NonNull<GCPhysicalInputProfile>, NonNull<GCControllerElement>),
                >,
            >,
        );

        #[cfg(feature = "GCControllerElement")]
        /// The following properties allow for runtime lookup of any input element on a profile, when provided with a valid alias.
        #[unsafe(method(elements))]
        #[unsafe(method_family = none)]
        pub unsafe fn elements(&self) -> Retained<NSDictionary<NSString, GCControllerElement>>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(buttons))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttons(&self) -> Retained<NSDictionary<NSString, GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerAxisInput", feature = "GCControllerElement"))]
        #[unsafe(method(axes))]
        #[unsafe(method_family = none)]
        pub unsafe fn axes(&self) -> Retained<NSDictionary<NSString, GCControllerAxisInput>>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        #[unsafe(method(dpads))]
        #[unsafe(method_family = none)]
        pub unsafe fn dpads(&self) -> Retained<NSDictionary<NSString, GCControllerDirectionPad>>;

        #[cfg(all(feature = "GCControllerElement", feature = "GCControllerTouchpad"))]
        #[unsafe(method(touchpads))]
        #[unsafe(method_family = none)]
        pub unsafe fn touchpads(&self) -> Retained<NSDictionary<NSString, GCControllerTouchpad>>;

        #[cfg(feature = "GCControllerElement")]
        /// The following properties allow for dynamic querying of the input elements available on a profile.
        #[unsafe(method(allElements))]
        #[unsafe(method_family = none)]
        pub unsafe fn allElements(&self) -> Retained<NSSet<GCControllerElement>>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(allButtons))]
        #[unsafe(method_family = none)]
        pub unsafe fn allButtons(&self) -> Retained<NSSet<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerAxisInput", feature = "GCControllerElement"))]
        #[unsafe(method(allAxes))]
        #[unsafe(method_family = none)]
        pub unsafe fn allAxes(&self) -> Retained<NSSet<GCControllerAxisInput>>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        #[unsafe(method(allDpads))]
        #[unsafe(method_family = none)]
        pub unsafe fn allDpads(&self) -> Retained<NSSet<GCControllerDirectionPad>>;

        #[cfg(all(feature = "GCControllerElement", feature = "GCControllerTouchpad"))]
        #[unsafe(method(allTouchpads))]
        #[unsafe(method_family = none)]
        pub unsafe fn allTouchpads(&self) -> Retained<NSSet<GCControllerTouchpad>>;

        #[cfg(feature = "GCControllerElement")]
        /// Profile elements can be accessed using keyed subscript notation, with a valid alias of its inputs.
        ///
        ///
        ///
        ///
        /// Note: Equivalent to -elements
        #[unsafe(method(objectForKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectForKeyedSubscript(
            &self,
            key: &NSString,
        ) -> Option<Retained<GCControllerElement>>;

        /// Polls the state vector of the physical input input and saves it to a new and writable instance of GCPhysicalInputProfile.
        ///
        /// If your application is heavily multithreaded this may also be useful to guarantee atomicity of input handling as
        /// a snapshot will not change based on user input once it is taken.
        ///
        ///
        /// See: snapshot
        ///
        /// Returns: A new physical input profile with the duplicated state vector of the current physical input
        #[unsafe(method(capture))]
        #[unsafe(method_family = none)]
        pub unsafe fn capture(&self) -> Retained<Self>;

        /// Sets the state vector of the physical input profile to a copy of the passed in physical input profile's state vector.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: GCController.snapshot
        #[unsafe(method(setStateFromPhysicalInput:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStateFromPhysicalInput(&self, physical_input: &GCPhysicalInputProfile);

        /// Returns the primary alias of the GCControllerElement that a given physical input maps to.
        ///
        ///
        /// If the user were to map a physical press of the A button of their game controller to the B button, then
        /// -[GCPhysicalInputProfile  mappedElementAliasForPhysicalInputName: GCInputButtonA] would return GCInputButtonB.
        /// Note that mappings can change anytime your app is backgrounded, so make sure you update any relevant visuals when
        /// returning to foreground.
        ///
        ///
        /// Parameter `inputName`: A GCInput string corresponding to the physical button you want the mapped element alias for.
        ///
        ///
        /// Returns: A GCInput string corresponding to the primary alias of the GCControllerElement that a given physical button maps to, or nil if there is no mapping.
        #[unsafe(method(mappedElementAliasForPhysicalInputName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mappedElementAliasForPhysicalInputName(
            &self,
            input_name: &NSString,
        ) -> Retained<NSString>;

        /// Returns a set of GCInput strings corresponding to physical inputs that are mapped to a given GCControllerElement.
        ///
        ///
        /// If the user mapped the physical press of the A button, the B button, and the X button to the B button, then
        /// -[GCPhysicalInputProfile mappedPhysicalInputNamesForElementAlias: GCInputButtonB] would return  [GCInputButtonA, GCInputButtonB, GCInputButtonX].
        /// Note that mappings can change anytime your app is backgrounded, so make sure you update any relevant visuals when
        /// returning to foreground.
        ///
        ///
        /// Parameter `elementAlias`: A GCInput string corresponding to an alias of the GCControllerElement you want the physical buttons for.
        ///
        ///
        /// Returns: A set of GCInput strings corresponding to physical inputs that are mapped to a given GCControllerElement, or an empty set if there are no mappings.
        #[unsafe(method(mappedPhysicalInputNamesForElementAlias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mappedPhysicalInputNamesForElementAlias(
            &self,
            element_alias: &NSString,
        ) -> Retained<NSSet<NSString>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GCPhysicalInputProfile {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
