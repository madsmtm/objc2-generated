//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Set this block if you want to be notified when a value on a element changed. If multiple elements have changed this block will be called
/// for each element that changed. As elements in a collection, such as the axis in a dpad, tend to change at the same time and thus
/// will only call this once with the collection as the element.
///
///
/// Parameter `gamepad`: this gamepad that is being used to map the raw input data into logical values on controller elements such as the dpad or the buttons.
///
/// Parameter `element`: the element that has been modified.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcextendedgamepadvaluechangedhandler?language=objc)
#[cfg(all(
    feature = "GCControllerElement",
    feature = "GCPhysicalInputProfile",
    feature = "block2"
))]
pub type GCExtendedGamepadValueChangedHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<GCExtendedGamepad>, NonNull<GCControllerElement>)>;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcextendedgamepad?language=objc)
    #[unsafe(super(GCPhysicalInputProfile, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "GCPhysicalInputProfile")]
    pub struct GCExtendedGamepad;
);

#[cfg(feature = "GCPhysicalInputProfile")]
extern_conformance!(
    unsafe impl NSObjectProtocol for GCExtendedGamepad {}
);

#[cfg(feature = "GCPhysicalInputProfile")]
impl GCExtendedGamepad {
    extern_methods!(
        #[cfg(feature = "GCController")]
        /// A profile keeps a reference to the controller that this profile is mapping input from.
        #[unsafe(method(controller))]
        #[unsafe(method_family = none)]
        pub unsafe fn controller(&self) -> Option<Retained<GCController>>;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(valueChangedHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueChangedHandler(&self) -> GCExtendedGamepadValueChangedHandler;

        #[cfg(all(feature = "GCControllerElement", feature = "block2"))]
        /// Setter for [`valueChangedHandler`][Self::valueChangedHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `value_changed_handler` must be a valid pointer or null.
        #[unsafe(method(setValueChangedHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValueChangedHandler(
            &self,
            value_changed_handler: GCExtendedGamepadValueChangedHandler,
        );

        #[cfg(feature = "GCExtendedGamepadSnapshot")]
        /// Polls the state vector of the controller and saves it to a snapshot. The snapshot is stored in a device independent
        /// format that can be serialized and used at a later date. This is useful for features such as quality assurance,
        /// save game or replay functionality among many.
        ///
        /// If your application is heavily multithreaded this may also be useful to guarantee atomicity of input handling as
        /// a snapshot will not change based on user input once it is taken.
        #[deprecated = "Use the -[GCController capture] method instead"]
        #[unsafe(method(saveSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveSnapshot(&self) -> Retained<GCExtendedGamepadSnapshot>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// Required to be analog in the Extended profile. All the elements of this directional input are thus analog.
        #[unsafe(method(dpad))]
        #[unsafe(method_family = none)]
        pub unsafe fn dpad(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// All face buttons are required to be analog in the Extended profile. These must be arranged
        /// in the diamond pattern given below:
        ///
        /// Y
        /// /
        /// \
        /// X   B
        /// \
        /// /
        /// A
        #[unsafe(method(buttonA))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonA(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(buttonB))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonB(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(buttonX))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonX(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(buttonY))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonY(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button menu is the primary menu button, and should be used to enter the main menu and pause the game.
        #[unsafe(method(buttonMenu))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonMenu(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button options is the secondary menu button. It should be used to enter a secondary menu, such as graphics and sound configuration, and pause the game.
        #[unsafe(method(buttonOptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonOptions(&self) -> Option<Retained<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Button home is a special menu button. If the system does not consume button home events, they will be passed to your application and should be used to enter a secondary menu, and pause the game.
        #[unsafe(method(buttonHome))]
        #[unsafe(method_family = none)]
        pub unsafe fn buttonHome(&self) -> Option<Retained<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// A thumbstick is a 2-axis control that is physically required to be analog. All the elements of this directional input are thus analog.
        #[unsafe(method(leftThumbstick))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftThumbstick(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerDirectionPad", feature = "GCControllerElement"))]
        /// A thumbstick is a 2-axis control that is physically required to be analog. All the elements of this directional input are thus analog.
        #[unsafe(method(rightThumbstick))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightThumbstick(&self) -> Retained<GCControllerDirectionPad>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Shoulder buttons are required to be analog inputs.
        #[unsafe(method(leftShoulder))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftShoulder(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Shoulder buttons are required to be analog inputs.
        #[unsafe(method(rightShoulder))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightShoulder(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// Triggers are required to be analog inputs. Common uses would be acceleration and decelleration in a driving game for example.
        #[unsafe(method(leftTrigger))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftTrigger(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(rightTrigger))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightTrigger(&self) -> Retained<GCControllerButtonInput>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        /// A thumbstick may also have a clickable component, which is treated as a non-analog button.
        #[unsafe(method(leftThumbstickButton))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftThumbstickButton(&self) -> Option<Retained<GCControllerButtonInput>>;

        #[cfg(all(feature = "GCControllerButtonInput", feature = "GCControllerElement"))]
        #[unsafe(method(rightThumbstickButton))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightThumbstickButton(&self) -> Option<Retained<GCControllerButtonInput>>;

        /// Sets the state vector of the extended gamepad to a copy of the input extended gamepad's state vector.
        ///
        ///
        /// Note: If the controller's snapshot flag is set to NO, this method has no effect.
        ///
        /// See: GCController.snapshot
        #[unsafe(method(setStateFromExtendedGamepad:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStateFromExtendedGamepad(&self, extended_gamepad: &GCExtendedGamepad);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "GCPhysicalInputProfile")]
impl GCExtendedGamepad {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
