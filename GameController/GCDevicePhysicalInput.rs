//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;

use crate::*;

extern_protocol!(
    /// An objecting conforming to
    /// `GCDevicePhysicalInput`provides properties and
    /// methods for accessing common physical elements - buttons, thumbsticks, dpads,
    /// etc - of a device.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamecontroller/gcdevicephysicalinput?language=objc)
    #[cfg(feature = "GCDevicePhysicalInputState")]
    pub unsafe trait GCDevicePhysicalInput: GCDevicePhysicalInputState {
        #[cfg(feature = "GCDevice")]
        /// The device that this profile is mapping input from.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        unsafe fn device(&self) -> Option<Retained<ProtocolObject<dyn GCDevice>>>;

        #[cfg(feature = "dispatch2")]
        /// The dispatch queue that element value change handlers and other callbacks are
        /// submitted on.
        ///
        /// The default queue is the
        /// `handlerQueue`of the associated
        /// `device.`Set
        /// this property if your application wants to receive input callbacks on a
        /// different queue.  You should set this property before configuring other
        /// callbacks.
        #[unsafe(method(queue))]
        #[unsafe(method_family = none)]
        unsafe fn queue(&self) -> Option<Retained<DispatchQueue>>;

        #[cfg(feature = "dispatch2")]
        /// Setter for [`queue`][Self::queue].
        #[unsafe(method(setQueue:))]
        #[unsafe(method_family = none)]
        unsafe fn setQueue(&self, queue: Option<&DispatchQueue>);

        #[cfg(all(feature = "GCPhysicalInputElement", feature = "block2"))]
        /// Set this block to be notified when a value on a element changed.  If multiple
        /// elements change this block will be called for each element that changed.
        ///
        /// The block is called on the
        /// `queue`configured for the physical input.
        ///
        ///
        /// Parameter `element`: The element that has been modified.
        ///
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        #[unsafe(method(elementValueDidChangeHandler))]
        #[unsafe(method_family = none)]
        unsafe fn elementValueDidChangeHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(
                NonNull<ProtocolObject<dyn GCDevicePhysicalInput>>,
                NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
            ),
        >;

        #[cfg(all(feature = "GCPhysicalInputElement", feature = "block2"))]
        /// Setter for [`elementValueDidChangeHandler`][Self::elementValueDidChangeHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setElementValueDidChangeHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn setElementValueDidChangeHandler(
            &self,
            element_value_did_change_handler: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<ProtocolObject<dyn GCDevicePhysicalInput>>,
                        NonNull<ProtocolObject<dyn GCPhysicalInputElement>>,
                    ),
                >,
            >,
        );

        /// Polls the current state vector of the physical input and saves it to a new
        /// instance.
        ///
        /// If your application is heavily multithreaded this may also be useful to
        /// guarantee atomicity of input handling as a snapshot will not change based on
        /// further device input once it is taken.
        ///
        ///
        /// Returns: An input state with the duplicated state vector of the current input.
        #[unsafe(method(capture))]
        #[unsafe(method_family = none)]
        unsafe fn capture(&self) -> Retained<ProtocolObject<dyn GCDevicePhysicalInputState>>;

        #[cfg(feature = "block2")]
        /// Set this block to be notified when a new input state is available.  Your
        /// handler should repeatedly call
        /// `-nextInputState`until it returns
        /// `nil`to
        /// drain the pending input states from the queue.
        ///
        /// physicalInput.inputStateQueueDepth = 20;
        /// physicalInput.inputStateAvailableHandler = ^(__kindof id
        /// <GCDevicePhysicalInput
        /// > physicalInput) {
        /// id
        /// <GCDevicePhysicalInputState
        /// , GCDevicePhysicalInputStateDiff> nextInputState;
        /// while ((nextInputState = [physicalInput nextInputState])) {
        ///
        /// // You can grab the individual states of all elements that your app
        /// // is interested in.
        /// id
        /// <GCButtonElement
        /// > buttonA = nextInputState.buttons[GCInputButtonA];
        /// BOOL buttonAPressed = buttonA.pressedInput.pressed;
        /// if (buttonAPressed) {
        /// // Handle button A pressed
        /// }
        ///
        /// // Your code can first query whether an element's input value changed
        /// // from the prior input state.
        /// GCDevicePhysicalInputElementChange buttonAChange = [nextInputState changeForElement:buttonA];
        /// if (buttonAChange == GCDevicePhysicalInputElementChanged) {
        /// // Handle button A input changed
        /// }
        ///
        /// // Or, your code can request an enumerator of elements with input
        /// // values that changed from the prior input state
        /// for (id
        /// <GCPhysicalInputElement
        /// > changedElement in nextInputState.changedElements) {
        ///
        /// }
        /// }
        /// };
        ///
        /// # Safety
        ///
        /// The returned block's argument must be a valid pointer.
        #[unsafe(method(inputStateAvailableHandler))]
        #[unsafe(method_family = none)]
        unsafe fn inputStateAvailableHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn GCDevicePhysicalInput>>)>;

        #[cfg(feature = "block2")]
        /// Setter for [`inputStateAvailableHandler`][Self::inputStateAvailableHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInputStateAvailableHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn setInputStateAvailableHandler(
            &self,
            input_state_available_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn GCDevicePhysicalInput>>)>,
            >,
        );

        /// The maximum number of input states to buffer.  If your application does not
        /// drain the pending input states in the queue before this limit is reached, older
        /// input states will be discarded - resulting in your application "missing" input
        /// state changes.
        ///
        /// The default value is
        /// `one`(no buffering).  Smaller values are ignored.  A
        /// value of
        /// `20`should be more than enough to ensure no input state changes
        /// are missed.
        #[unsafe(method(inputStateQueueDepth))]
        #[unsafe(method_family = none)]
        unsafe fn inputStateQueueDepth(&self) -> NSInteger;

        /// Setter for [`inputStateQueueDepth`][Self::inputStateQueueDepth].
        #[unsafe(method(setInputStateQueueDepth:))]
        #[unsafe(method_family = none)]
        unsafe fn setInputStateQueueDepth(&self, input_state_queue_depth: NSInteger);

        #[cfg(feature = "GCDevicePhysicalInputStateDiff")]
        /// Pop the oldest pending input state from the queue.  This method returns
        /// `nil`when there are no more input states pending.
        #[unsafe(method(nextInputState))]
        #[unsafe(method_family = none)]
        unsafe fn nextInputState(
            &self,
        ) -> Option<
            Retained<
                AnyObject, /* GCDevicePhysicalInputState+ GCDevicePhysicalInputStateDiff */
            >,
        >;
    }
);
