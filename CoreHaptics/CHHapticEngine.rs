//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-avf-audio")]
use objc2_avf_audio::*;
use objc2_foundation::*;

use crate::*;

/// A time constant used to schedule a command immediately.
pub const CHHapticTimeImmediate: NSTimeInterval = 0.0;
/// A typealias for a completion handler that the engine calls after starting or stopping.
/// A block which is called asynchronously when a call to start or stop the haptic engine completes.
///
/// Parameter `error`: If the call fails, this is set to a valid NSError describing the error.
///
/// All callbacks are delivered on an internal queue which guarantees proper delivery order and allows reentrant calls to the API.
#[cfg(feature = "block2")]
pub type CHHapticCompletionHandler = *mut block2::DynBlock<dyn Fn(*mut NSError)>;

/// Possible actions to take after the haptic engine finishes execution.
/// Constants indicating what the engine should do in response to the finished handler being called.
///
///
/// Stop the engine.  This is useful if the client knows that the client is about to go inactive.
///
///
/// Do not stop the engine.  This is useful if the client expects more activity.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CHHapticEngineFinishedAction(pub NSInteger);
impl CHHapticEngineFinishedAction {
    /// Stops the engine after it finishes playing all haptic patterns.
    #[doc(alias = "CHHapticEngineFinishedActionStopEngine")]
    pub const StopEngine: Self = Self(1);
    /// Keeps the engine running after it finishes playing all haptic patterns.
    #[doc(alias = "CHHapticEngineFinishedActionLeaveEngineRunning")]
    pub const LeaveEngineRunning: Self = Self(2);
}

unsafe impl Encode for CHHapticEngineFinishedAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CHHapticEngineFinishedAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type alias for a completion handler to execute after finishing haptic playback.
/// A block which is called asynchronously when the engine detects that all active pattern players have finished.  The
/// return value tells the system what action to take as a result of this (see `CHHapticEngineFinishedAction`).
///
/// Parameter `error`: If the engine detects the players have stopped due to an error, this is set to a valid NSError describing the error.
///
/// All callbacks are delivered on an internal queue which guarantees proper delivery order and allows reentrant calls to the API.
#[cfg(feature = "block2")]
pub type CHHapticEngineFinishedHandler =
    *mut block2::DynBlock<dyn Fn(*mut NSError) -> CHHapticEngineFinishedAction>;

/// The enumeration of reasons the haptic engine stopped running.
/// Constants indicating the reason why the CHHapticEngine has stopped.
///
///
/// The AVAudioSession bound to this engine has been interrupted.
///
///
/// The application owning this engine has been suspended (i.e., put into the background).
///
///
/// The engine has stopped due to an idle timeout when the engine's `autoShutdownEnabled` property was set to YES.
///
///
/// The engine has stopped due to a call to a `CHHapticEngineFinishedHandler` returning `CHHapticEngineFinishedActionStopEngine`.
///
///
/// The engine has stopped because the CHHapticEngine instance was destroyed.
///
///
/// The engine has stopped because the Game Controller associated with this engine disconnected.
///
///
/// An error has occurred.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CHHapticEngineStoppedReason(pub NSInteger);
impl CHHapticEngineStoppedReason {
    /// The system interrupted the audio session.
    ///
    /// ## Discussion
    ///
    /// Audio session interruptions occur due to interactions with other audio apps. For example, the system interrupts music playback when a user receives a phone call. When an interruption occurs, restart the engine before it starts another pattern player.
    ///
    ///
    #[doc(alias = "CHHapticEngineStoppedReasonAudioSessionInterrupt")]
    pub const AudioSessionInterrupt: Self = Self(1);
    /// The system suspended your app.
    ///
    /// ## Discussion
    ///
    /// This condition occurs if the system suspended your app while it was in the background. Restart the engine when your app returns to the foreground to ensure proper haptic playback.
    ///
    ///
    #[doc(alias = "CHHapticEngineStoppedReasonApplicationSuspended")]
    pub const ApplicationSuspended: Self = Self(2);
    /// The engine shut down because you’ve enabled automatic shutdown, and the engine reached its idle timeout.
    ///
    /// ## Discussion
    ///
    /// If there’s a time-critical pattern to play, restart the engine. Otherwise, do nothing and the engine will automatically restart when the next pattern plays.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Delegating engine restart to the system can add a slight delay to the start of the pattern.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "CHHapticEngineStoppedReasonIdleTimeout")]
    pub const IdleTimeout: Self = Self(3);
    /// You’ve asked the system to notify you when it shuts down the engine.
    ///
    /// ## Discussion
    ///
    /// Restart the engine before starting another pattern player.
    ///
    ///
    #[doc(alias = "CHHapticEngineStoppedReasonNotifyWhenFinished")]
    pub const NotifyWhenFinished: Self = Self(4);
    /// The system destroyed the engine.
    ///
    /// ## Discussion
    ///
    /// This reason typically indicates a programming error. Maintain a strong reference to the engine to for as long as you need to execute haptics.
    ///
    ///
    #[doc(alias = "CHHapticEngineStoppedReasonEngineDestroyed")]
    pub const EngineDestroyed: Self = Self(5);
    /// The engine stopped because the associated game controller disconnected from the device.
    #[doc(alias = "CHHapticEngineStoppedReasonGameControllerDisconnect")]
    pub const GameControllerDisconnect: Self = Self(6);
    /// A system error stopped the engine.
    ///
    /// ## Discussion
    ///
    /// Your app should attempt to restart the engine. If the restart attempt fails multiple times, treat the condition as fatal.
    ///
    ///
    #[doc(alias = "CHHapticEngineStoppedReasonSystemError")]
    pub const SystemError: Self = Self(-1);
}

unsafe impl Encode for CHHapticEngineStoppedReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CHHapticEngineStoppedReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A typealias for the block that the haptic engine calls after it stops due to an external cause.
///
/// ## Discussion
///
/// The system calls the stopped handler for when it’s stopped by an external event like an audio session interruption or an auto-shutdown.
///
/// <div class="warning">
///
/// ### Note
///  The stopped handler isn’t called if you explicitly stop the engine by calling the [`stopWithCompletionHandler:`](https://developer.apple.com/documentation/corehaptics/chhapticengine/stop(completionhandler:)) method.
///
///
///
/// </div>
///
/// A block which is called asynchronously when the engine has stopped due to external causes such as
/// an audio session interruption or autoShutdown.
///
/// Parameter `stoppedReason`: This constant indicates the reason why the engine stopped.
///
/// This handler is NOT called if the client directly calls stopWithCompletionHandler:.
/// All callbacks are delivered on an internal queue which guarantees proper delivery order and allows reentrant calls to the API.
#[cfg(feature = "block2")]
pub type CHHapticEngineStoppedHandler = *mut block2::DynBlock<dyn Fn(CHHapticEngineStoppedReason)>;

/// A typealias for the block that the haptic engine calls after being reset.
/// A block which is called asynchronously if the haptic engine has reset itself due a server failure.
///
/// In response to this handler, the app must reload all custom audio resources and recreate all necessary
/// pattern players.  The engine must of course be restarted.  CHHapticPatterns do not need to be re-created.
/// All callbacks are delivered on an internal queue which guarantees proper delivery order and allows reentrant calls to the API.
#[cfg(feature = "block2")]
pub type CHHapticEngineResetHandler = *mut block2::DynBlock<dyn Fn()>;

/// A type alias for a key that identifies the playback behavior of an audio resource.
pub type CHHapticAudioResourceKey = NSString;

extern "C" {
    /// A key for a Boolean value that indicates whether audio file playback fades in and out using an envelope.
    ///
    /// ## Discussion
    ///
    /// Fading, or ramping, the volume of an audio resource can prevent clicks during playback. It’s also useful in cases where the app modulates the envelope to use different attack and release times.
    ///
    /// The default value is [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    /// Keys used to configure the playback behavior of a custom waveform.
    ///
    /// Indicates whether the audio file playback should be ramped in and out with an envelope.  This can be useful for preventing clicks during playback,
    /// or for cases where the application wants to modulate this envelope to use different attack and release times.
    /// Value type: boolean.  Default is
    /// .
    ///
    /// Indicates whether the audio file will be looped when played back.  The default loop range is the entire file.
    /// Value type: boolean.  Default is
    /// .
    pub static CHHapticAudioResourceKeyUseVolumeEnvelope: &'static CHHapticAudioResourceKey;
}

extern "C" {
    /// A key for a Boolean value that indicates whether to loop audio playback.
    ///
    /// ## Discussion
    ///
    /// Set a [`true`](https://developer.apple.com/documentation/swift/true) value for this key to loop the contents of an audio file.
    ///
    /// The default value is [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    pub static CHHapticAudioResourceKeyLoopEnabled: &'static CHHapticAudioResourceKey;
}

extern_class!(
    /// An object that represents the connection to the haptic server.
    ///
    /// ## Overview
    ///
    /// If you want your app to play custom haptics, you need to create a haptic engine. The haptic engine establishes the connection between your app and the underlying device hardware. Even though you can define a haptic pattern without an engine, you need the engine to play that pattern.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/cedcd4ecf6e8ff4b966ed1e55d18f7fe/media-3242669~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/66a613deacd96bc7ac01d5a15e3eae73/media-3242669%402x.png 2x" />
    ///     <img alt="A dictionary defines a pattern, from which the haptic engine creates a pattern player for playing the haptic." src="https://docs-assets.developer.apple.com/published/cedcd4ecf6e8ff4b966ed1e55d18f7fe/media-3242669~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// Even though your app makes a request through the haptic engine, the operating system could still override the request with system services, like haptics from system notifications.
    ///
    /// ### Prepare Your App To Play Haptics
    ///
    /// To prepare your app to play haptics, follow these steps, as demonstrated in the code below:
    ///
    /// 1. Create a haptic engine instance. Maintain a strong reference to it so it doesn’t go out of scope while the haptic is playing.
    ///
    /// 2. Call the haptic engine’s [`startWithCompletionHandler:`](https://developer.apple.com/documentation/corehaptics/chhapticengine/start(completionhandler:)) for an asynchronous start, or [`startAndReturnError:`](https://developer.apple.com/documentation/corehaptics/chhapticengine/start()) to start the engine synchronously (immediately).
    ///
    /// 3. Stop the engine by calling [`stopWithCompletionHandler:`](https://developer.apple.com/documentation/corehaptics/chhapticengine/stop(completionhandler:)) when your app finishes haptic playback.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["do {", "    // 1. Create a haptic engine instance.", "    hapticEngine = try CHHapticEngine()", "", "    // 2. Start the haptic engine.", "    try hapticEngine.start()", "} catch let error {", "    print(\"Engine Error: \\(error)\")", "}", "", "// 3. Stop the engine.", "hapticEngine.stop(completionHandler: { (_) -> Void in", "    // Insert code to call after engine stops.", "})"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Create an error variable through which the engine returns error information.", "NSError* error = nil;", "", "// (1.) Create an instance of a haptic engine.", "self.hapticEngine = [[CHHapticEngine alloc] initAndReturnError:&error];", "", "// (2.) Start the haptic engine.", "[self.hapticEngine startAndReturnError:&error];", "", "// (3.) Stop the engine.", "[self.hapticEngine stopWithCompletionHandler:^(NSError* error){", "    // Insert code to call after engine stops.", "}];"], metadata: None }] }] })
    /// Although it’s possible to create content—[`CHHapticPattern`](https://developer.apple.com/documentation/corehaptics/chhapticpattern) instances—independent of a CHHapticEngine, your app must use an engine to play that content.
    ///
    ///
    /// Represents the connection with the haptic server.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CHHapticEngine;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for CHHapticEngine {}
);

impl CHHapticEngine {
    extern_methods!(
        #[cfg(feature = "CHHapticDeviceCapability")]
        /// Get the protocol that describes haptic and audio capabilities on this device.
        ///
        /// Detailed description on the capability protocol is in CHHapticDeviceCapability.h.
        #[unsafe(method(capabilitiesForHardware))]
        #[unsafe(method_family = none)]
        pub unsafe fn capabilitiesForHardware(
        ) -> Retained<ProtocolObject<dyn CHHapticDeviceCapability>>;

        /// The absolute time from which all current and future event times may be calculated.
        /// The units are seconds.
        #[unsafe(method(currentTime))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentTime(&self) -> NSTimeInterval;

        #[cfg(feature = "block2")]
        /// The engine will call this block when it has stopped due to external causes (such as
        /// an audio session interruption or the app going into the background).  It will NOT be called
        /// if the client calls stopWithCompletionHandler:.
        ///
        /// In general, callbacks arrive on a non-main thread and it is the client's responsibility to handle
        /// it in a thread-safe manner.
        #[unsafe(method(stoppedHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn stoppedHandler(&self) -> CHHapticEngineStoppedHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`stoppedHandler`][Self::stoppedHandler].
        ///
        /// # Safety
        ///
        /// `stopped_handler` must be a valid pointer.
        #[unsafe(method(setStoppedHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStoppedHandler(&self, stopped_handler: CHHapticEngineStoppedHandler);

        #[cfg(feature = "block2")]
        /// This block will called asynchronously if the haptic engine has to reset itself after a server failure.
        ///
        /// In response to this handler being called, the client must release all haptic pattern players
        /// and recreate them.  All CHHapticPattern objects and CHHapticEngine properties will have been preserved.
        /// In general, callbacks arrive on a non-main thread and it is the client's responsibility to handle
        /// it in a thread-safe manner.
        #[unsafe(method(resetHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn resetHandler(&self) -> CHHapticEngineResetHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`resetHandler`][Self::resetHandler].
        ///
        /// # Safety
        ///
        /// `reset_handler` must be a valid pointer.
        #[unsafe(method(setResetHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResetHandler(&self, reset_handler: CHHapticEngineResetHandler);

        /// If set to YES, the CHHapticEngine will ignore all events of type CHHapticEventTypeAudio and play only haptic events.
        ///
        /// This behavior change will only take effect after the engine is stopped and restarted.
        /// The default is NO.
        #[unsafe(method(playsHapticsOnly))]
        #[unsafe(method_family = none)]
        pub unsafe fn playsHapticsOnly(&self) -> bool;

        /// Setter for [`playsHapticsOnly`][Self::playsHapticsOnly].
        #[unsafe(method(setPlaysHapticsOnly:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPlaysHapticsOnly(&self, plays_haptics_only: bool);

        /// If set to YES, the CHHapticEngine will ignore all events of type CHHapticEventTypeHaptic and play only audio events.
        ///
        /// This behavior change will only take effect after the engine is stopped and restarted.
        /// The default is NO.
        #[unsafe(method(playsAudioOnly))]
        #[unsafe(method_family = none)]
        pub unsafe fn playsAudioOnly(&self) -> bool;

        /// Setter for [`playsAudioOnly`][Self::playsAudioOnly].
        #[unsafe(method(setPlaysAudioOnly:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPlaysAudioOnly(&self, plays_audio_only: bool);

        /// When set to YES, the CHHapticEngine mutes audio playback from its players.
        ///
        /// Default is NO.
        #[unsafe(method(isMutedForAudio))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMutedForAudio(&self) -> bool;

        /// Setter for [`isMutedForAudio`][Self::isMutedForAudio].
        #[unsafe(method(setIsMutedForAudio:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIsMutedForAudio(&self, is_muted_for_audio: bool);

        /// When set to YES, the CHHapticEngine mutes haptic playback from its players.
        ///
        /// Default is NO.
        #[unsafe(method(isMutedForHaptics))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMutedForHaptics(&self) -> bool;

        /// Setter for [`isMutedForHaptics`][Self::isMutedForHaptics].
        #[unsafe(method(setIsMutedForHaptics:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIsMutedForHaptics(&self, is_muted_for_haptics: bool);

        /// When auto shutdown is enabled, the haptic engine can start and stop the hardware dynamically,
        /// to conserve power.
        ///
        /// To conserve power, it is advised that the client stop the haptic engine when not in use.
        /// But when auto shutdown is enabled, the haptic engine will stop the hardware if it was running
        /// idle for a certain duration, and restart it later when required.
        /// Note that, because this operation is dynamic, it may affect the start times of the pattern players
        /// (e.g. `CHHapticPatternplayer`), if the engine has to resume from its shutdown state.
        ///
        /// This feature is disabled by default, but the client can enable it if needed.
        #[unsafe(method(isAutoShutdownEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAutoShutdownEnabled(&self) -> bool;

        /// Setter for [`isAutoShutdownEnabled`][Self::isAutoShutdownEnabled].
        #[unsafe(method(setAutoShutdownEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAutoShutdownEnabled(&self, auto_shutdown_enabled: bool);

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Option<Retained<Self>>;

        /// Create an instance of the CHHapticEngine.
        ///
        /// More than one instance may exist within a process.  Each will function independently of the others.
        /// CHHapticEngines created using this method will be associated with the device's internal haptics hardware system,
        /// if one exists.  For systems without internal haptics, this method will fail with the error `CHHapticErrorCodeNotSupported`.
        /// To access engine instances associated with external game controllers, see the GameController framework documentation
        /// for the `hapticEngines` property on the GCController class.
        #[unsafe(method(initAndReturnError:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initAndReturnError(
            this: Allocated<Self>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "objc2-avf-audio")]
        /// Create an instance of an CHHapticEngine and associate it with an audio session.  If 'audioSession' is nil,
        /// the engine will create its own.
        ///
        /// More than one instance may exist within a process.  Each will function independently of the others, but all
        /// CHHapticEngines which share an audio session will have identical audio behavior with regard to interruptions, etc.
        /// CHHapticEngines created using this method will be associated with the device's internal haptics hardware system,
        /// if one exists.  For systems without internal haptics, this method will fail with the error `CHHapticErrorCodeNotSupported`.
        /// To access engine instances associated with external game controllers, see the GameController framework documentation
        /// for the `hapticEngines` property on the GCController class.
        #[unsafe(method(initWithAudioSession:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAudioSession_error(
            this: Allocated<Self>,
            audio_session: Option<&AVAudioSession>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "block2")]
        /// Asynchronously start the engine. The handler will be called when the operation completes.
        ///
        /// The handler is guaranteed to be called on either success or failure.
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(startWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startWithCompletionHandler(
            &self,
            completion_handler: CHHapticCompletionHandler,
        );

        /// Start the engine and block until the engine has started.
        ///
        /// This method will return NO upon failure, and outError will be set to a valid NSError describing the error.
        #[unsafe(method(startAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn startAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "block2")]
        /// Asynchronously stop the engine.  The handler will be called when the operation completes.
        ///
        /// The handler is guaranteed to be called on either success or failure.
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(stopWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopWithCompletionHandler(
            &self,
            completion_handler: CHHapticCompletionHandler,
        );

        #[cfg(feature = "block2")]
        /// Tell the engine to asynchronously call the passed-in handler when all active pattern players associated
        /// with this engine have stopped.
        ///
        /// Parameter `finishedHandler`: The block that will be called asynchronously.  The return value of this block determines the action the
        /// engine will take when the block finishes (see `CHHapticEngineFinishedHandler`).
        ///
        /// If additional players are started after this call is made, they will delay the callback.
        /// If no players are active or the engine is stopped, the callback will happen immediately.
        ///
        /// # Safety
        ///
        /// `finished_handler` must be a valid pointer.
        #[unsafe(method(notifyWhenPlayersFinished:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notifyWhenPlayersFinished(
            &self,
            finished_handler: CHHapticEngineFinishedHandler,
        );

        #[cfg(all(feature = "CHHapticPattern", feature = "CHHapticPatternPlayer"))]
        /// Factory method for creating a CHHapticPatternPlayer from a CHHapticPattern.
        ///
        /// Parameter `pattern`: The pattern to be played.
        #[unsafe(method(createPlayerWithPattern:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn createPlayerWithPattern_error(
            &self,
            pattern: &CHHapticPattern,
        ) -> Result<Retained<ProtocolObject<dyn CHHapticPatternPlayer>>, Retained<NSError>>;

        #[cfg(all(feature = "CHHapticPattern", feature = "CHHapticPatternPlayer"))]
        /// Factory method for creating a CHHapticAdvancedPatternPlayer from a CHHapticPattern.
        ///
        /// Parameter `pattern`: The pattern to be played.
        #[unsafe(method(createAdvancedPlayerWithPattern:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn createAdvancedPlayerWithPattern_error(
            &self,
            pattern: &CHHapticPattern,
        ) -> Result<Retained<ProtocolObject<dyn CHHapticAdvancedPatternPlayer>>, Retained<NSError>>;

        #[cfg(feature = "CHHapticEvent")]
        /// Unregister and remove a previously-registered audio resource.
        ///
        /// Parameter `resourceID`: The resource ID that was returned when the resource was registered.
        ///
        /// Parameter `outError`: If the unregister operation fails, this will be set to a valid NSError describing the error.
        #[unsafe(method(unregisterAudioResource:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unregisterAudioResource_error(
            &self,
            resource_id: CHHapticAudioResourceID,
        ) -> Result<(), Retained<NSError>>;

        /// Simple one-shot call to play a pattern specified by a URL.
        ///
        /// Parameter `fileURL`: The URL of the file containing a haptic/audio pattern dictionary.
        ///
        /// Parameter `outError`: If the operation fails, this will be set to a valid NSError describing the error.
        ///
        /// The engine should be started prior to calling this method if low latency is desired. If this is not done,
        /// this method will start it, which can cause a significant delay.
        #[unsafe(method(playPatternFromURL:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn playPatternFromURL_error(
            &self,
            file_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        /// Simple one-shot call to play a pattern specified by NSData.
        ///
        /// Parameter `data`: The NSData containing a haptic/audio pattern dictionary.
        ///
        /// Parameter `outError`: If the operation fails, this will be set to a valid NSError describing the error.
        ///
        /// The engine should be started prior to calling this method if low latency is desired. If this is not done,
        /// this method will start it, which can cause a significant delay.
        #[unsafe(method(playPatternFromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn playPatternFromData_error(
            &self,
            data: &NSData,
        ) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CHHapticEngine {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
