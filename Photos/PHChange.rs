//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A description of a change that occurred in the photo library.
    ///
    /// ## Overview
    ///
    /// Photos provides [`PHChange`](https://developer.apple.com/documentation/photos/phchange) objects to notify your app of changes to the assets and collections managed by the Photos app. To receive change information, adopt the [`PHPhotoLibraryChangeObserver`](https://developer.apple.com/documentation/photos/phphotolibrarychangeobserver) protocol and register your observer with the shared [`PHPhotoLibrary`](https://developer.apple.com/documentation/photos/phphotolibrary) object.
    ///
    /// After Photos provides a change object, you use its methods to get a change details object. Call the [`changeDetailsForObject:`](https://developer.apple.com/documentation/photos/phchange/changedetailsforobject:) or [`changeDetails(for:)`](https://developer.apple.com/documentation/photos/phchange/changedetails(for:)-33a6n) method, passing an asset or collection object you’ve previously fetched or a fetch result containing several such objects. The resulting [`PHObjectChangeDetails`](https://developer.apple.com/documentation/photos/phobjectchangedetails) or [`PHFetchResultChangeDetails`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails) object describes any changes that have happened to the object or fetch result since you last fetched it.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PHChange;
);

unsafe impl Send for PHChange {}

unsafe impl Sync for PHChange {}

extern_conformance!(
    unsafe impl NSObjectProtocol for PHChange {}
);

impl PHChange {
    extern_methods!(
        #[cfg(feature = "PHObject")]
        #[unsafe(method(changeDetailsForObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn changeDetailsForObject(
            &self,
            object: &PHObject,
        ) -> Option<Retained<PHObjectChangeDetails>>;

        #[cfg(all(feature = "PHFetchResult", feature = "PHObject"))]
        /// # Safety
        ///
        /// `object` generic should be of the correct type.
        #[unsafe(method(changeDetailsForFetchResult:))]
        #[unsafe(method_family = none)]
        pub unsafe fn changeDetailsForFetchResult(
            &self,
            object: &PHFetchResult,
        ) -> Option<Retained<PHFetchResultChangeDetails>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl PHChange {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A description of changes that occurred in an asset or collection object.
    ///
    /// ## Overview
    ///
    /// A [`PHObjectChangeDetails`](https://developer.apple.com/documentation/photos/phobjectchangedetails) object provides detailed information about differences between two states of an asset or collection object—one that you previously obtained and an updated state that would result if you fetched that entity again. You observe changes by adopting the [`PHPhotoLibraryChangeObserver`](https://developer.apple.com/documentation/photos/phphotolibrarychangeobserver) protocol and registering your observer with the shared [`PHPhotoLibrary`](https://developer.apple.com/documentation/photos/phphotolibrary) object. When Photos notifies your observer of a change, you get change details by passing the object you’re interested in to the [`changeDetailsForObject:`](https://developer.apple.com/documentation/photos/phchange/changedetailsforobject:) method.
    ///
    /// For an asset collection or collection list, a [`PHObjectChangeDetails`](https://developer.apple.com/documentation/photos/phobjectchangedetails) object describe changes only to the collection’s properties. If you’re instead interested in changes to the collection’s membership, fetch the collection’s contents and use the [`changeDetails(for:)`](https://developer.apple.com/documentation/photos/phchange/changedetails(for:)-33a6n) method to track changes to the fetch result.
    ///
    /// <div class="warning">
    ///
    /// ### Warning
    ///  Don’t map [`changedIndexes`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails/changedindexes) directly to [`UICollectionView`](https://developer.apple.com/documentation/uikit/uicollectionview) item indices in batch updates. Use these indices to reconfigure the corresponding cells after [`performBatchUpdates:completion:`](https://developer.apple.com/documentation/uikit/uicollectionview/performbatchupdates(_:completion:)). [`UICollectionView`](https://developer.apple.com/documentation/uikit/uicollectionview) and [`UITableView`](https://developer.apple.com/documentation/uikit/uitableview) expect the [`changedIndexes`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails/changedindexes) to be in the _before_ state, while PhotoKit provides them in the _after_ state, resulting in a crash if your app performs insertions and deletions at the same time as the changes.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHObject")]
    pub struct PHObjectChangeDetails<ObjectType: ?Sized = AnyObject>;
);

#[cfg(feature = "PHObject")]
impl<ObjectType: ?Sized + Message + AsRef<PHObject>> PHObjectChangeDetails<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message + AsRef<PHObject>>(
        &self,
    ) -> &PHObjectChangeDetails<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "PHObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + AsRef<PHObject>> NSObjectProtocol
        for PHObjectChangeDetails<ObjectType>
    {
    }
);

#[cfg(feature = "PHObject")]
impl<ObjectType: Message + AsRef<PHObject>> PHObjectChangeDetails<ObjectType> {
    extern_methods!(
        #[unsafe(method(objectBeforeChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectBeforeChanges(&self) -> Retained<ObjectType>;

        #[unsafe(method(objectAfterChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAfterChanges(&self) -> Option<Retained<ObjectType>>;

        #[unsafe(method(assetContentChanged))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetContentChanged(&self) -> bool;

        #[unsafe(method(objectWasDeleted))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectWasDeleted(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "PHObject")]
impl<ObjectType: Message + AsRef<PHObject>> PHObjectChangeDetails<ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A description of changes that occurred in the set of asset or collection objects listed in a fetch result.
    ///
    /// ## Overview
    ///
    /// A [`PHFetchResultChangeDetails`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails) object provides detailed information about the differences between two fetch results—one that you previously obtained and an updated one that would result if you performed the same fetch again. The change details object provides information useful for updating a UI that lists the contents of a fetch result, such as the indexes of added, removed, and rearranged objects.
    ///
    /// ### Processing Changes in Order
    ///
    /// PhotoKit describes [`changedIndexes`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails/changedindexes) in the _after_ state, while [`UICollectionView`](https://developer.apple.com/documentation/uikit/uicollectionview)w’s [`performBatchUpdates:completion:`](https://developer.apple.com/documentation/uikit/uicollectionview/performbatchupdates(_:completion:)) expects them in the _before_ state. As a result, [`changedIndexes`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails/changedindexes) can’t be used safely inside [`performBatchUpdates:completion:`](https://developer.apple.com/documentation/uikit/uicollectionview/performbatchupdates(_:completion:)).
    ///
    /// Instead, use [`changedIndexes`](https://developer.apple.com/documentation/photos/phfetchresultchangedetails/changedindexes) _after_ and outside the [`performBatchUpdates:completion:`](https://developer.apple.com/documentation/uikit/uicollectionview/performbatchupdates(_:completion:)) call, reapplying the code used to configure cells in [`cellForItemAtIndexPath:`](https://developer.apple.com/documentation/uikit/uicollectionview/cellforitem(at:)) rather than telling [`UICollectionView`](https://developer.apple.com/documentation/uikit/uicollectionview) to reload.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let collectionView = UICollectionView()", "let fetchResultChangeDetails = PHFetchResultChangeDetails()", "let deletedCollectionIndicesBeforeChanges = IndexSet()", "let insertedCollectionIndicesAfterDeletions = IndexSet()", "let deletedPhotoPathsBeforeChanges: [IndexPath] = []", "let insertedPhotoPathsAfterDeletions: [IndexPath] = []", "", "collectionView.performBatchUpdates({ () -> Void in", "    if (!deletedCollectionIndicesBeforeChanges.isEmpty) {", "        collectionView.deleteSections(deletedCollectionIndicesBeforeChanges)", "    }", "    if (!insertedCollectionIndicesAfterDeletions.isEmpty) {", "        collectionView.insertSections(insertedCollectionIndicesAfterDeletions)", "    }", "    if (!deletedPhotoPathsBeforeChanges.isEmpty) {", "        collectionView.deleteItems(at: deletedPhotoPathsBeforeChanges)", "    }", "    if (!insertedPhotoPathsAfterDeletions.isEmpty) {", "        collectionView.insertItems(at: insertedPhotoPathsAfterDeletions)", "    }", "}, completion:nil)", "", "guard let changeIndices = fetchResultChangeDetails.changedIndexes else {", "    return", "}", "for indexSetElem in changeIndices {", "    let indexPath = IndexPath(item: indexSetElem, section: 0)", "    guard let changedCell = collectionView.cellForItem(at: indexPath) else {", "        break", "    }", "    // ... Configure changedCell here ...", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["@property (nonatomic, strong) UICollectionView* collectionView;", "// ...", "PHFetchResultChangeDetails* fetchResultChangeDetails;", "NSIndexSet* deletedCollectionIndicesBeforeChanges;", "NSIndexSet* insertedCollectionIndicesAfterDeletions;", "NSArray* deletedPhotoPathsBeforeChanges;", "NSArray* insertedPhotoPathsAfterDeletions;", "", "[self.collectionView performBatchUpdates:^{", "    if (deletedCollectionIndicesBeforeChanges.count > 0) {", "        [self.collectionView deleteSections:deletedCollectionIndicesBeforeChanges];", "    }", "    if (insertedCollectionIndicesAfterDeletions.count > 0) {", "        [self.collectionView insertSections:insertedCollectionIndicesAfterDeletions];", "    }", "    if (deletedPhotoPathsBeforeChanges.count > 0) {", "        [self.collectionView deleteItemsAtIndexPaths:deletedPhotoPathsBeforeChanges];", "    }", "    if (insertedPhotoPathsAfterDeletions) {", "        [self.collectionView insertItemsAtIndexPaths:insertedPhotoPathsAfterDeletions];", "    }", "} completion:nil];", "", "[fetchResultChangeDetails.changedIndexes enumerateIndexesUsingBlock:^(NSUInteger index, BOOL* stop) {", "    NSIndexPath* indexPath = [NSIndexPath indexPathWithItem:index inSection:0];", "    UICollectionViewCell* changedCell = [self.collectionView cellForItemAtIndexPath:indexPath];", "    if (changedCell) {", "        // ... Configure changedCell here ...", "    }", "    // Set *stop = YES to stop iteration early.", "}];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHObject")]
    pub struct PHFetchResultChangeDetails<ObjectType: ?Sized = AnyObject>;
);

#[cfg(feature = "PHObject")]
impl<ObjectType: ?Sized + Message + AsRef<PHObject>> PHFetchResultChangeDetails<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message + AsRef<PHObject>>(
        &self,
    ) -> &PHFetchResultChangeDetails<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "PHObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + AsRef<PHObject>> NSObjectProtocol
        for PHFetchResultChangeDetails<ObjectType>
    {
    }
);

#[cfg(feature = "PHObject")]
impl<ObjectType: Message + AsRef<PHObject>> PHFetchResultChangeDetails<ObjectType> {
    extern_methods!(
        #[cfg(feature = "PHFetchResult")]
        #[unsafe(method(fetchResultBeforeChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchResultBeforeChanges(&self) -> Retained<PHFetchResult<ObjectType>>;

        #[cfg(feature = "PHFetchResult")]
        #[unsafe(method(fetchResultAfterChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchResultAfterChanges(&self) -> Retained<PHFetchResult<ObjectType>>;

        #[unsafe(method(hasIncrementalChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasIncrementalChanges(&self) -> bool;

        #[unsafe(method(removedIndexes))]
        #[unsafe(method_family = none)]
        pub unsafe fn removedIndexes(&self) -> Option<Retained<NSIndexSet>>;

        #[unsafe(method(removedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn removedObjects(&self) -> Retained<NSArray<ObjectType>>;

        #[unsafe(method(insertedIndexes))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertedIndexes(&self) -> Option<Retained<NSIndexSet>>;

        #[unsafe(method(insertedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertedObjects(&self) -> Retained<NSArray<ObjectType>>;

        #[unsafe(method(changedIndexes))]
        #[unsafe(method_family = none)]
        pub unsafe fn changedIndexes(&self) -> Option<Retained<NSIndexSet>>;

        #[unsafe(method(changedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn changedObjects(&self) -> Retained<NSArray<ObjectType>>;

        #[cfg(feature = "block2")]
        #[unsafe(method(enumerateMovesWithBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateMovesWithBlock(
            &self,
            handler: &block2::DynBlock<dyn Fn(NSUInteger, NSUInteger)>,
        );

        #[unsafe(method(hasMoves))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasMoves(&self) -> bool;

        #[cfg(feature = "PHFetchResult")]
        #[unsafe(method(changeDetailsFromFetchResult:toFetchResult:changedObjects:))]
        #[unsafe(method_family = none)]
        pub unsafe fn changeDetailsFromFetchResult_toFetchResult_changedObjects(
            from_result: &PHFetchResult<ObjectType>,
            to_result: &PHFetchResult<ObjectType>,
            changed_objects: &NSArray<ObjectType>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "PHObject")]
impl<ObjectType: Message + AsRef<PHObject>> PHFetchResultChangeDetails<ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
