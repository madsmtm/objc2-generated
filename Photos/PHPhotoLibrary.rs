//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Information about your app’s authorization to access the user’s photo library.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PHAuthorizationStatus(pub NSInteger);
impl PHAuthorizationStatus {
    /// The user hasn’t set the app’s authorization status.
    ///
    /// ## Discussion
    ///
    /// The framework automatically prompts for user authorization when you attempt to fetch assets, asset collections, or collection lists. Alternatively, you may call the [`requestAuthorizationForAccessLevel:handler:`](https://developer.apple.com/documentation/photos/phphotolibrary/requestauthorization(for:handler:)) method to prompt the user for authorization at a time of your choosing.
    ///
    ///
    #[doc(alias = "PHAuthorizationStatusNotDetermined")]
    pub const NotDetermined: Self = Self(0);
    /// The app isn’t authorized to access the photo library, and the user can’t grant such permission.
    ///
    /// ## Discussion
    ///
    /// Parental controls or institutional configuration profiles can restrict the user’s ability to grant photo library access to an app.
    ///
    ///
    #[doc(alias = "PHAuthorizationStatusRestricted")]
    pub const Restricted: Self = Self(1);
    /// The user explicitly denied this app access to the photo library.
    #[doc(alias = "PHAuthorizationStatusDenied")]
    pub const Denied: Self = Self(2);
    /// The user explicitly granted this app access to the photo library.
    #[doc(alias = "PHAuthorizationStatusAuthorized")]
    pub const Authorized: Self = Self(3);
    /// The user authorized this app for limited photo library access.
    ///
    /// ## Discussion
    ///
    /// Use [`presentLimitedLibraryPickerFromViewController:`](https://developer.apple.com/documentation/photos/phphotolibrary/presentlimitedlibrarypicker(from:)) or [`presentLimitedLibraryPickerFromViewController:completionHandler:`](https://developer.apple.com/documentation/photos/phphotolibrary/presentlimitedlibrarypicker(from:completionhandler:)) to manually present the limited library picker.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Add the `PHPhotoLibraryPreventAutomaticLimitedAccessAlert` key with a Boolean value of `true` to your app’s `Info.plist` file to prevent the system from automatically presenting the limited library selection prompt.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "PHAuthorizationStatusLimited")]
    pub const Limited: Self = Self(4);
}

unsafe impl Encode for PHAuthorizationStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHAuthorizationStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The app’s level of access to the user’s photo library.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHAccessLevel(pub NSInteger);
impl PHAccessLevel {
    /// A value that indicates the app may only add to the user’s photo library.
    #[doc(alias = "PHAccessLevelAddOnly")]
    pub const AddOnly: Self = Self(1);
    /// A value that indicates the app can read from and write to the user’s photo library.
    #[doc(alias = "PHAccessLevelReadWrite")]
    pub const ReadWrite: Self = Self(2);
}

unsafe impl Encode for PHAccessLevel {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHAccessLevel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A protocol to adopt to have the system notify your app of changes to the photo library.
    ///
    /// ## Overview
    ///
    /// The [`PHPhotoLibraryChangeObserver`](https://developer.apple.com/documentation/photos/phphotolibrarychangeobserver) protocol notifies you of changes that occur in the photo library, regardless of whether those changes are made by your app, by a user in the Photos app, or by another app that uses the Photos framework. To receive change messages, register your observer with the [`registerChangeObserver:`](https://developer.apple.com/documentation/photos/phphotolibrary/register(_:)-6y3b9) method. For any assets or collections that you fetch, Photos sends change messages whenever those assets or collections change. Use this protocol to track changes across multiple parts of your app or respond to changes made in another app or extension.
    ///
    /// ### Handling Changes: An Example
    ///
    /// The example code below shows how you might implement this protocol in a view controller that uses a [`UICollectionView`](https://developer.apple.com/documentation/uikit/uicollectionview) interface to display the contents of an album. The view controller keeps a reference to the [`PHAssetCollection`](https://developer.apple.com/documentation/photos/phassetcollection) object representing the displayed album and the [`PHFetchResult`](https://developer.apple.com/documentation/photos/phfetchresult) object (returned by the [`fetchAssetsInAssetCollection:options:`](https://developer.apple.com/documentation/photos/phasset/fetchassets(in:options:)) method) listing the album’s contents. Then, in its [`photoLibraryDidChange:`](https://developer.apple.com/documentation/photos/phphotolibrarychangeobserver/photolibrarydidchange(_:)) method, the view controller checks for differences between the objects it fetched and the new state of the photo library, and updates its collection view accordingly.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func photoLibraryDidChange(_ changeInstance: PHChange) {", "    guard let collectionView = self.collectionView else { return }", "    // Change notifications may be made on a background queue.", "    // Re-dispatch to the main queue to update the UI.", "    DispatchQueue.main.sync {", "        // Check for changes to the displayed album itself", "        // (its existence and metadata, not its member assets).", "        if let albumChanges = changeInstance.changeDetails(for: assetCollection) {", "            // Fetch the new album and update the UI accordingly.", "            assetCollection = albumChanges.objectAfterChanges! as! PHAssetCollection", "            navigationController?.navigationItem.title = assetCollection.localizedTitle", "        }", "        // Check for changes to the list of assets (insertions, deletions, moves, or updates).", "        if let changes = changeInstance.changeDetails(for: fetchResult) {", "            // Keep the new fetch result for future use.", "            fetchResult = changes.fetchResultAfterChanges", "            if changes.hasIncrementalChanges {", "                // If there are incremental diffs, animate them in the collection view.", "                collectionView.performBatchUpdates({", "                    // For indexes to make sense, updates must be in this order:", "                    // delete, insert, reload, move.", "                    if let removed = changes.removedIndexes where removed.count > 0 {", "                        collectionView.deleteItems(at: removed.map { IndexPath(item: $0, section:0) })", "                    }", "                    if let inserted = changes.insertedIndexes where inserted.count > 0 {", "                        collectionView.insertItems(at: inserted.map { IndexPath(item: $0, section:0) })", "                    }", "                    if let changed = changes.changedIndexes where changed.count > 0 {", "                        collectionView.reloadItems(at: changed.map { IndexPath(item: $0, section:0) })", "                    }", "                    changes.enumerateMoves { fromIndex, toIndex in", "                        collectionView.moveItem(at: IndexPath(item: fromIndex, section: 0),", "                                                to: IndexPath(item: toIndex, section: 0))", "                    }", "                })", "            } else {", "                // Reload the collection view if incremental diffs aren't available.", "                collectionView.reloadData()", "            }", "        }", "    }", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (void)photoLibraryDidChange:(PHChange *)changeInfo {", "    // Change notifications may be made on a background queue.", "    // Re-dispatch to the main queue to update the UI.", "    dispatch_async(dispatch_get_main_queue(), ^{", "        // Check for changes to the displayed album itself", "        // (its existence and metadata, not its member assets).", "        PHObjectChangeDetails *albumChanges = [changeInfo changeDetailsForObject:self.displayedAlbum];", "        if (albumChanges) {", "            // Fetch the new album and update the UI accordingly.", "            self.displayedAlbum = [albumChanges objectAfterChanges];", "            self.navigationController.navigationItem.title = self.displayedAlbum.localizedTitle;", "        }", " ", "        // Check for changes to the list of assets (insertions, deletions, moves, or updates).", "        PHFetchResultChangeDetails *collectionChanges = [changeInfo changeDetailsForFetchResult:self.albumContents];", "        if (collectionChanges) {", "            // Keep the new fetch result for future use.", "            self.albumContents = collectionChanges.fetchResultAfterChanges;", " ", "            if (collectionChanges.hasIncrementalChanges)  {", "                // If there are incremental diffs, animate them in the collection view.", "                [self.collectionView performBatchUpdates:^{", "                    NSIndexSet *removed = collectionChanges.removedIndexes;", "                    if (removed.count) {", "                        [self.collectionView deleteItemsAtIndexPaths:[self indexPathsFromIndexSet:removed]];", "                    }", "                    NSIndexSet *inserted = collectionChanges.insertedIndexes;", "                    if (inserted.count) {", "                        [self.collectionView insertItemsAtIndexPaths:[self indexPathsFromIndexSet:inserted]];", "                    }", "                    NSIndexSet *changed = collectionChanges.changedIndexes;", "                    if (changed.count) {", "                        [self.collectionView reloadItemsAtIndexPaths:[self indexPathsFromIndexSet:changed]];", "                    }", "                    if (collectionChanges.hasMoves) {", "                        [collectionChanges enumerateMovesWithBlock:^(NSUInteger fromIndex, NSUInteger toIndex) {", "                            NSIndexPath *fromIndexPath = [NSIndexPath indexPathForItem:fromIndex inSection:0];", "                            NSIndexPath *toIndexPath = [NSIndexPath indexPathForItem:toIndex inSection:0];", "                            [self.collectionView moveItemAtIndexPath:fromIndexPath toIndexPath:toIndexPath];", "                        }];", "                    }", "                } completion:nil];", "            } else {", "                // Reload the collection view if incremental diffs aren't available.", "                [self.collectionView reloadData];", "            }", "        }", "    });", "}"], metadata: None }] }] })
    ///
    pub unsafe trait PHPhotoLibraryChangeObserver: NSObjectProtocol {
        #[cfg(feature = "PHChange")]
        #[unsafe(method(photoLibraryDidChange:))]
        #[unsafe(method_family = none)]
        unsafe fn photoLibraryDidChange(&self, change_instance: &PHChange);
    }
);

extern_protocol!(
    /// A protocol to adopt to have the system notify your app when the availability of a photo library changes.
    ///
    /// ## Overview
    ///
    /// Observing changes to the photo library’s availability is primarily of concern with Mac apps created using macOS and Mac Catalyst, where the library may reside on an external drive or in cloud storage.
    ///
    ///
    pub unsafe trait PHPhotoLibraryAvailabilityObserver: NSObjectProtocol {
        #[unsafe(method(photoLibraryDidBecomeUnavailable:))]
        #[unsafe(method_family = none)]
        unsafe fn photoLibraryDidBecomeUnavailable(&self, photo_library: &PHPhotoLibrary);
    }
);

extern_class!(
    /// An object that manages access and changes to the user’s photo library.
    ///
    /// ## Overview
    ///
    /// The object represents the entire set of assets and collections that the Photos app manages, including assets stored on the local device and those stored in iCloud Photos. Use this object for the following tasks:
    ///
    /// - Retrieving or verifying the user’s permission for your app to access Photos content
    ///
    /// - Making changes to assets and collections; for example, editing asset metadata or content, inserting new assets, or rearranging the members of a collection
    ///
    /// - Determining which records change since a previous state of the Photos library
    ///
    /// - Registering for update messages the system sends when the library changes
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PHPhotoLibrary;
);

unsafe impl Send for PHPhotoLibrary {}

unsafe impl Sync for PHPhotoLibrary {}

extern_conformance!(
    unsafe impl NSObjectProtocol for PHPhotoLibrary {}
);

impl PHPhotoLibrary {
    extern_methods!(
        #[unsafe(method(sharedPhotoLibrary))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedPhotoLibrary() -> Retained<PHPhotoLibrary>;

        /// Replaces
        /// `+authorizationStatus`to support add-only/read-write access level status
        #[unsafe(method(authorizationStatusForAccessLevel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn authorizationStatusForAccessLevel(
            access_level: PHAccessLevel,
        ) -> PHAuthorizationStatus;

        #[cfg(feature = "block2")]
        #[unsafe(method(requestAuthorizationForAccessLevel:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAuthorizationForAccessLevel_handler(
            access_level: PHAccessLevel,
            handler: &block2::DynBlock<dyn Fn(PHAuthorizationStatus)>,
        );

        /// Deprecated and replaced by authorizationStatusForAccessLevel:, will return
        /// `PHAuthorizationStatusAuthorized`if the user has chosen limited photo library access
        #[deprecated]
        #[unsafe(method(authorizationStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn authorizationStatus() -> PHAuthorizationStatus;

        #[cfg(feature = "block2")]
        #[deprecated]
        #[unsafe(method(requestAuthorization:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAuthorization(
            handler: &block2::DynBlock<dyn Fn(PHAuthorizationStatus)>,
        );

        #[unsafe(method(unavailabilityReason))]
        #[unsafe(method_family = none)]
        pub unsafe fn unavailabilityReason(&self) -> Option<Retained<NSError>>;

        #[unsafe(method(registerAvailabilityObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerAvailabilityObserver(
            &self,
            observer: &ProtocolObject<dyn PHPhotoLibraryAvailabilityObserver>,
        );

        #[unsafe(method(unregisterAvailabilityObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unregisterAvailabilityObserver(
            &self,
            observer: &ProtocolObject<dyn PHPhotoLibraryAvailabilityObserver>,
        );

        #[cfg(all(feature = "block2", feature = "dispatch2"))]
        /// # Safety
        ///
        /// `change_block` must be a valid pointer.
        #[unsafe(method(performChanges:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performChanges_completionHandler(
            &self,
            change_block: dispatch_block_t,
            completion_handler: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(feature = "dispatch2")]
        /// # Safety
        ///
        /// `change_block` must be a valid pointer.
        #[unsafe(method(performChangesAndWait:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn performChangesAndWait_error(
            &self,
            change_block: dispatch_block_t,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(registerChangeObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerChangeObserver(
            &self,
            observer: &ProtocolObject<dyn PHPhotoLibraryChangeObserver>,
        );

        #[unsafe(method(unregisterChangeObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unregisterChangeObserver(
            &self,
            observer: &ProtocolObject<dyn PHPhotoLibraryChangeObserver>,
        );

        #[cfg(all(
            feature = "PHPersistentChangeFetchResult",
            feature = "PHPersistentChangeToken"
        ))]
        #[unsafe(method(fetchPersistentChangesSinceToken:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchPersistentChangesSinceToken_error(
            &self,
            token: &PHPersistentChangeToken,
        ) -> Result<Retained<PHPersistentChangeFetchResult>, Retained<NSError>>;

        #[cfg(feature = "PHPersistentChangeToken")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(currentChangeToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentChangeToken(&self) -> Retained<PHPersistentChangeToken>;
    );
}

/// Methods declared on superclass `NSObject`.
impl PHPhotoLibrary {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
