//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An ordered list of assets or collections returned from a Photos fetch method.
    ///
    /// ## Overview
    ///
    /// When you use class methods on the [`PHAsset`](https://developer.apple.com/documentation/photos/phasset), [`PHCollection`](https://developer.apple.com/documentation/photos/phcollection), [`PHAssetCollection`](https://developer.apple.com/documentation/photos/phassetcollection), and [`PHCollectionList`](https://developer.apple.com/documentation/photos/phcollectionlist) classes to retrieve objects, Photos provides the resulting objects in a fetch result. You access the contents of a fetch result with the same methods and conventions used by the [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray) class. Unlike an [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray) object, however, a [`PHFetchResult`](https://developer.apple.com/documentation/photos/phfetchresult) object dynamically loads its contents from the Photos library as needed, providing optimal performance even when handling a large number of results.
    ///
    /// A fetch result provides thread-safe access to its contents. After a fetch, the fetch resultâ€™s [`count`](https://developer.apple.com/documentation/photos/phfetchresult/count) value is constant, and all objects in the fetch result keep the same [`localIdentifier`](https://developer.apple.com/documentation/photos/phobject/localidentifier) value. (To get updated content for a fetch, register a change observer with the shared [`PHPhotoLibrary`](https://developer.apple.com/documentation/photos/phphotolibrary) object.)
    ///
    /// A fetch result caches its contents, keeping a batch of objects around the most recently accessed index. Because objects outside of the batch are no longer cached, accessing these objects results in refetching those objects. This process can result in changes to values previously read from those objects.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PHFetchResult<ObjectType: ?Sized = AnyObject>;
);

impl<ObjectType: ?Sized + Message> PHFetchResult<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(
        &self,
    ) -> &PHFetchResult<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSCopying for PHFetchResult<ObjectType> {}
);

unsafe impl<ObjectType: ?Sized + Message> CopyingHelper for PHFetchResult<ObjectType> {
    type Result = Self;
}

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for PHFetchResult<ObjectType> {}
);

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for PHFetchResult<ObjectType> {}
);

impl<ObjectType: Message> PHFetchResult<ObjectType> {
    extern_methods!(
        #[unsafe(method(count))]
        #[unsafe(method_family = none)]
        pub unsafe fn count(&self) -> NSUInteger;

        #[unsafe(method(objectAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndex(&self, index: NSUInteger) -> Retained<ObjectType>;

        #[unsafe(method(objectAtIndexedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndexedSubscript(&self, idx: NSUInteger) -> Retained<ObjectType>;

        #[unsafe(method(containsObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn containsObject(&self, an_object: &ObjectType) -> bool;

        #[unsafe(method(indexOfObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexOfObject(&self, an_object: &ObjectType) -> NSUInteger;

        #[unsafe(method(indexOfObject:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexOfObject_inRange(
            &self,
            an_object: &ObjectType,
            range: NSRange,
        ) -> NSUInteger;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(firstObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn firstObject(&self) -> Option<Retained<ObjectType>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(lastObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn lastObject(&self) -> Option<Retained<ObjectType>>;

        #[unsafe(method(objectsAtIndexes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectsAtIndexes(
            &self,
            indexes: &NSIndexSet,
        ) -> Retained<NSArray<ObjectType>>;

        #[cfg(feature = "block2")]
        #[unsafe(method(enumerateObjectsUsingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateObjectsUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NSUInteger, NonNull<Bool>)>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(enumerateObjectsWithOptions:usingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateObjectsWithOptions_usingBlock(
            &self,
            opts: NSEnumerationOptions,
            block: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NSUInteger, NonNull<Bool>)>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(enumerateObjectsAtIndexes:options:usingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateObjectsAtIndexes_options_usingBlock(
            &self,
            s: &NSIndexSet,
            opts: NSEnumerationOptions,
            block: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NSUInteger, NonNull<Bool>)>,
        );

        #[cfg(feature = "PhotosTypes")]
        #[unsafe(method(countOfAssetsWithMediaType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn countOfAssetsWithMediaType(&self, media_type: PHAssetMediaType)
            -> NSUInteger;
    );
}

/// Methods declared on superclass `NSObject`.
impl<ObjectType: Message> PHFetchResult<ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
