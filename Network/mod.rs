// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "Network", kind = "framework")]
extern "C" {}

#[cfg(feature = "FoundationExtension")]
#[path = "FoundationExtension.rs"]
mod __FoundationExtension;

#[cfg(all(feature = "FoundationExtension", feature = "objc2"))]
pub use self::__FoundationExtension::NSURLSessionConfigurationNetwork;
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwtxtrecord?language=objc)
#[doc(alias = "nw_txt_record_t")]
#[repr(C)]
pub struct NWTxtRecord {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWTxtRecord {}
);

/// An enumeration of possible find results when trying to find a key-value
/// pair in the TXT record object.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_find_key_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_txt_record_find_key_t(pub c_uint);
impl nw_txt_record_find_key_t {
    /// to RFC 1464, a key is invalid if it is an empty string, contains
    /// non-ASCII characters, or has length greater than UINT8_MAX.
    #[doc(alias = "nw_txt_record_find_key_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_txt_record_find_key_not_present")]
    pub const not_present: Self = Self(1);
    #[doc(alias = "nw_txt_record_find_key_no_value")]
    pub const no_value: Self = Self(2);
    #[doc(alias = "nw_txt_record_find_key_empty_value")]
    pub const empty_value: Self = Self(3);
    #[doc(alias = "nw_txt_record_find_key_non_empty_value")]
    pub const non_empty_value: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_txt_record_find_key_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_txt_record_find_key_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWTxtRecord {
    /// Create a new TXT record object from a buffer of bytes. If the buffer
    /// follows the key-value pair format as defined in RFC 1464, the TXT record
    /// object will be created as a dictionary. Otherwise, it is created as a
    /// TXT record buffer.
    ///
    ///
    /// Parameter `txt_bytes`: The pointer to the buffer.
    ///
    ///
    /// Parameter `txt_len`: The length of the buffer.
    ///
    ///
    /// Returns: An instantiated TXT record object.
    /// Callers are responsible for deallocating using nw_release(obj) or
    /// [obj release]. These objects support ARC.
    /// Returns NULL on failure. Fails if txt_bytes is NULL or if txt_len is 0.
    ///
    /// # Safety
    ///
    /// `txt_bytes` must be a valid pointer.
    #[doc(alias = "nw_txt_record_create_with_bytes")]
    #[inline]
    pub unsafe fn with_bytes(txt_bytes: NonNull<u8>, txt_len: usize) -> NWRetained<NWTxtRecord> {
        extern "C-unwind" {
            fn nw_txt_record_create_with_bytes(
                txt_bytes: NonNull<u8>,
                txt_len: usize,
            ) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_txt_record_create_with_bytes(txt_bytes, txt_len) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create an empty TXT record dictionary.
    ///
    ///
    /// Returns: An empty TXT record dictionary.
    /// Callers are responsible for deallocating using nw_release(obj) or
    /// [obj release]. These objects support ARC.
    #[doc(alias = "nw_txt_record_create_dictionary")]
    #[inline]
    pub fn new_dictionary() -> NWRetained<NWTxtRecord> {
        extern "C-unwind" {
            fn nw_txt_record_create_dictionary() -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_txt_record_create_dictionary() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create a deep copy of an existing TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object to be copied.
    ///
    ///
    /// Returns: A deep copy of the TXT record object.
    /// Callers are responsible for deallocating using nw_release(obj) or
    /// [obj release]. These objects support ARC.
    #[doc(alias = "nw_txt_record_copy")]
    #[inline]
    pub fn copy(txt_record: Option<&NWTxtRecord>) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_txt_record_copy(txt_record: Option<&NWTxtRecord>)
                -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_txt_record_copy(txt_record) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Find a key-value pair in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key of the key-value pair.
    ///
    ///
    /// Returns: An nw_txt_record_find_key_t representing the type of the key-value pair found.
    /// The key may be invalid, may not exist, have no associated value, have an
    /// empty associated value, or have a non-empty associated value.
    #[doc(alias = "nw_txt_record_find_key")]
    #[inline]
    pub fn find_key(&self, key: &CStr) -> nw_txt_record_find_key_t {
        extern "C-unwind" {
            fn nw_txt_record_find_key(
                txt_record: &NWTxtRecord,
                key: NonNull<c_char>,
            ) -> nw_txt_record_find_key_t;
        }
        unsafe { nw_txt_record_find_key(self, NonNull::new(key.as_ptr().cast_mut()).unwrap()) }
    }
}

/// Access a value in the TXT record object with its key. Attempts to access
/// or modify the TXT record object from within the block are prohibited.
///
///
/// Parameter `key`: The key of the value.
///
///
/// Parameter `found`: An nw_txt_record_find_key_t representing the type of the key-value pair found.
/// The key may be invalid, may not exist, have no associated value, have an
/// empty associated value, or have a non-empty associated value.
///
///
/// Parameter `value`: The value corresponding to the key. If the key does not exist or has no
/// associated value, value will be NULL. Note that the bytes pointed to by
/// value are only valid within the scope of the block.
///
///
/// Parameter `value_len`: The length of the value. If the key does not exist or has no associated
/// value, value_len will be 0.
///
///
/// Returns: An arbitrary return value defined by the user. For example, the user may
/// want to return true if the operation succeeds.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_access_key_t?language=objc)
pub type nw_txt_record_access_key_t = *mut block2::DynBlock<
    dyn Fn(NonNull<c_char>, nw_txt_record_find_key_t, *const u8, usize) -> bool,
>;

impl NWTxtRecord {
    /// Access a value in the TXT record object with its key. Attempts to access
    /// or modify the TXT record object from within the block are prohibited.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `access_value`: The block that will be used to access the value of the given key.
    ///
    ///
    /// Returns: The return value of the access_value block. This is an arbitrary return
    /// value defined by the user.
    ///
    /// # Safety
    ///
    /// `access_value` must be a valid pointer.
    #[doc(alias = "nw_txt_record_access_key")]
    #[inline]
    pub unsafe fn access_key(&self, key: &CStr, access_value: nw_txt_record_access_key_t) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_access_key(
                txt_record: &NWTxtRecord,
                key: NonNull<c_char>,
                access_value: nw_txt_record_access_key_t,
            ) -> bool;
        }
        unsafe {
            nw_txt_record_access_key(
                self,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
                access_value,
            )
        }
    }

    /// Set a key-value pair on the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key that will be inserted. If the key already exists in the TXT
    /// record object, the existing key-value pair will be replaced.
    ///
    ///
    /// Parameter `value`: The value that will be inserted. If value is set to NULL, then the key
    /// will be inserted with no value.
    ///
    ///
    /// Parameter `value_len`: The length of the value will be inserted. If value is set to zero, then the
    /// key will be inserted with a zero-length value. Inserting a NULL value
    /// with a non-zero length will fail.
    ///
    ///
    /// Returns: A boolean indicating if the key-value pair was inserted successfully.
    /// Returns false if the key is invalid. A key is invalid if it is an empty
    /// string, contains non-ASCII characters, or has length greater than
    /// UINT8_MAX.
    ///
    /// # Safety
    ///
    /// `value` must be a valid pointer or null.
    #[doc(alias = "nw_txt_record_set_key")]
    #[inline]
    pub unsafe fn set_key(&self, key: &CStr, value: *const u8, value_len: usize) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_set_key(
                txt_record: &NWTxtRecord,
                key: NonNull<c_char>,
                value: *const u8,
                value_len: usize,
            ) -> bool;
        }
        unsafe {
            nw_txt_record_set_key(
                self,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
                value,
                value_len,
            )
        }
    }

    /// Removes a key-value pair in the TXT record object given its key.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `key`: The key corresponding to the key-value pair.
    ///
    ///
    /// Returns: A boolean indicating if the key-value pair specified by the given key
    /// was removed. Returns false if the key is invalid or not present in the
    /// TXT dictionary. A key is invalid if it is an empty string, contains
    /// non-ASCII characters, or has length greater than UINT8_MAX.
    #[doc(alias = "nw_txt_record_remove_key")]
    #[inline]
    pub fn remove_key(&self, key: &CStr) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_remove_key(txt_record: &NWTxtRecord, key: NonNull<c_char>) -> bool;
        }
        unsafe { nw_txt_record_remove_key(self, NonNull::new(key.as_ptr().cast_mut()).unwrap()) }
    }

    /// Count the number of keys in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: A TXT record object.
    ///
    ///
    /// Returns: The number of keys in the TXT record object.
    #[doc(alias = "nw_txt_record_get_key_count")]
    #[inline]
    pub fn key_count(txt_record: Option<&NWTxtRecord>) -> usize {
        extern "C-unwind" {
            fn nw_txt_record_get_key_count(txt_record: Option<&NWTxtRecord>) -> usize;
        }
        unsafe { nw_txt_record_get_key_count(txt_record) }
    }
}

/// A block to access the raw TXT record inside the TXT record object. For
/// example, the user can copy the raw TXT record into another buffer in the
/// block, or read its contents.
///
///
/// Parameter `raw_txt_record`: The raw TXT record inside the TXT record object. Note that the bytes
/// pointed to by raw_txt_record is only valid within the scope of the block.
///
///
/// Parameter `len`: The length of the raw TXT record.
///
///
/// Returns: A user-defined return value. For example, the user may want to return a
/// boolean indicating if the operation succeeds.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_access_bytes_t?language=objc)
pub type nw_txt_record_access_bytes_t = *mut block2::DynBlock<dyn Fn(NonNull<u8>, usize) -> bool>;

impl NWTxtRecord {
    /// Access the raw TXT record inside the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `access_bytes`: The block that will be used to access the raw TXT record inside the TXT
    /// record object.
    ///
    ///
    /// Returns: The return value of the access_bytes block, which is defined by the user.
    /// For example, the user may want to return a boolean indicating if the
    /// operation succeeds.
    ///
    /// # Safety
    ///
    /// `access_bytes` must be a valid pointer.
    #[doc(alias = "nw_txt_record_access_bytes")]
    #[inline]
    pub unsafe fn access_bytes(&self, access_bytes: nw_txt_record_access_bytes_t) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_access_bytes(
                txt_record: &NWTxtRecord,
                access_bytes: nw_txt_record_access_bytes_t,
            ) -> bool;
        }
        unsafe { nw_txt_record_access_bytes(self, access_bytes) }
    }
}

/// A block that can be applied to every key-value pair in the TXT record
/// object.
///
///
/// Parameter `key`: The key of the current iterating key-value pair. Note that key is only
/// valid within the scope of the block.
///
///
/// Parameter `found`: An nw_txt_record_find_key_t representing the type of the key-value pair found.
/// The key may be invalid, may not exist, have no associated value, have an
/// empty associated value, or have a non-empty associated value.
///
///
/// Parameter `value`: The value of the current iterating key-value pair. Note that value is
/// only valid within the scope of the block.
///
///
/// Parameter `value_len`: The length of the value.
///
///
/// Returns: A boolean indicating whether iteration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_txt_record_applier_t?language=objc)
pub type nw_txt_record_applier_t = *mut block2::DynBlock<
    dyn Fn(NonNull<c_char>, nw_txt_record_find_key_t, NonNull<u8>, usize) -> bool,
>;

impl NWTxtRecord {
    /// Apply the block to every key-value pair in the TXT record object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Parameter `applier`: The block that will be applied to the entire TXT record object.
    ///
    ///
    /// Returns: A boolean indicating whether iteration of the TXT record object
    /// completed successfully. Iteration will only fail if the applier block
    /// returns false.
    ///
    /// # Safety
    ///
    /// `applier` must be a valid pointer.
    #[doc(alias = "nw_txt_record_apply")]
    #[inline]
    pub unsafe fn apply(&self, applier: nw_txt_record_applier_t) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_apply(
                txt_record: &NWTxtRecord,
                applier: nw_txt_record_applier_t,
            ) -> bool;
        }
        unsafe { nw_txt_record_apply(self, applier) }
    }

    /// Check if the two TXT record objects are equal.
    ///
    ///
    /// Parameter `left`: The first TXT record object to be compared.
    ///
    ///
    /// Parameter `right`: The second TXT record object to be compared.
    ///
    ///
    /// Returns: A boolean indicating if the two TXT record objects are equal. Two TXT
    /// record objects are equal if they contain the same set of key-value pairs,
    /// where keys are compared case-insensitively. For example, "ABC=1" and
    /// "abc=1" are identical key-value pairs. The ordering of the key-value
    /// pairs does not matter.
    #[doc(alias = "nw_txt_record_is_equal")]
    #[inline]
    pub fn is_equal(left: Option<&NWTxtRecord>, right: Option<&NWTxtRecord>) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_is_equal(
                left: Option<&NWTxtRecord>,
                right: Option<&NWTxtRecord>,
            ) -> bool;
        }
        unsafe { nw_txt_record_is_equal(left, right) }
    }

    /// Check whether the TXT record is a dictionary or a buffer.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object.
    ///
    ///
    /// Returns: A boolean indicating whether the TXT record is a dictionary or a buffer.
    /// If true, the TXT record is a dictionary. If false, the TXT record is a
    /// buffer.
    #[doc(alias = "nw_txt_record_is_dictionary")]
    #[inline]
    pub fn is_dictionary(&self) -> bool {
        extern "C-unwind" {
            fn nw_txt_record_is_dictionary(txt_record: &NWTxtRecord) -> bool;
        }
        unsafe { nw_txt_record_is_dictionary(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwadvertisedescriptor?language=objc)
#[doc(alias = "nw_advertise_descriptor_t")]
#[repr(C)]
pub struct NWAdvertiseDescriptor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWAdvertiseDescriptor {}
);

impl NWAdvertiseDescriptor {
    /// Creates a new advertise descriptor object based on a Bonjour service type
    /// and optional domain. This object can be used with listener objects to
    /// specify the service the listener should advertise.
    ///
    /// If the name is unspecified, the default name for the device will be used.
    /// If the domain is unspecified, the default domains for registration will be
    /// used. If the listener is local only, the domain 'local.' will be used
    /// regardless of the parameter passed to domain.
    ///
    ///
    /// Parameter `name`: An optional Bonjour service name.
    ///
    ///
    /// Parameter `type`: A Bonjour service type.
    ///
    ///
    /// Parameter `domain`: An optional Bonjour service domain.
    ///
    ///
    /// Returns: An instantiated browse descriptor object.
    #[doc(alias = "nw_advertise_descriptor_create_bonjour_service")]
    #[inline]
    pub fn new_bonjour_service(
        name: Option<&CStr>,
        r#type: &CStr,
        domain: Option<&CStr>,
    ) -> Option<NWRetained<NWAdvertiseDescriptor>> {
        extern "C-unwind" {
            fn nw_advertise_descriptor_create_bonjour_service(
                name: *const c_char,
                r#type: NonNull<c_char>,
                domain: *const c_char,
            ) -> Option<NonNull<NWAdvertiseDescriptor>>;
        }
        let ret = unsafe {
            nw_advertise_descriptor_create_bonjour_service(
                name.map(|ptr| ptr.as_ptr()).unwrap_or_else(core::ptr::null),
                NonNull::new(r#type.as_ptr().cast_mut()).unwrap(),
                domain
                    .map(|ptr| ptr.as_ptr())
                    .unwrap_or_else(core::ptr::null),
            )
        };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Set the TXT record for the advertise descriptor's service. You must call
    /// nw_listener_set_advertise_descriptor to update the listener's advertising
    /// afterwards in order for these changes to take effect.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor to modify.
    ///
    ///
    /// Parameter `txt_record`: A pointer to the TXT record.
    ///
    ///
    /// Parameter `txt_length`: The length of the TXT record. The total size of a typical DNS-SD TXT record
    /// is intended to be small - 200 bytes or less. Using TXT records larger than
    /// 1300 bytes is not recommended at this time.
    ///
    /// # Safety
    ///
    /// `txt_record` must be a valid pointer or null.
    #[doc(alias = "nw_advertise_descriptor_set_txt_record")]
    #[inline]
    pub unsafe fn set_txt_record(&self, txt_record: *const c_void, txt_length: usize) {
        extern "C-unwind" {
            fn nw_advertise_descriptor_set_txt_record(
                advertise_descriptor: &NWAdvertiseDescriptor,
                txt_record: *const c_void,
                txt_length: usize,
            );
        }
        unsafe { nw_advertise_descriptor_set_txt_record(self, txt_record, txt_length) }
    }

    /// Disable auto-rename for the Bonjour service registration.
    /// Auto-rename is enabled by default.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor to modify.
    ///
    ///
    /// Parameter `no_auto_rename`: A boolean indicating if auto-rename should be disabled.
    #[doc(alias = "nw_advertise_descriptor_set_no_auto_rename")]
    #[inline]
    pub fn set_no_auto_rename(&self, no_auto_rename: bool) {
        extern "C-unwind" {
            fn nw_advertise_descriptor_set_no_auto_rename(
                advertise_descriptor: &NWAdvertiseDescriptor,
                no_auto_rename: bool,
            );
        }
        unsafe { nw_advertise_descriptor_set_no_auto_rename(self, no_auto_rename) }
    }

    /// Check if auto-rename has been disabled for the Bonjour service
    /// registration.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Returns: A boolean indicating if auto-rename is disabled.
    #[doc(alias = "nw_advertise_descriptor_get_no_auto_rename")]
    #[inline]
    pub fn no_auto_rename(&self) -> bool {
        extern "C-unwind" {
            fn nw_advertise_descriptor_get_no_auto_rename(
                advertise_descriptor: &NWAdvertiseDescriptor,
            ) -> bool;
        }
        unsafe { nw_advertise_descriptor_get_no_auto_rename(self) }
    }

    /// Set the TXT record object on the advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Parameter `txt_record`: The TXT record object. If txt_record is NULL, the advertise_descriptor's
    /// current TXT record object will be removed.
    #[doc(alias = "nw_advertise_descriptor_set_txt_record_object")]
    #[inline]
    pub fn set_txt_record_object(&self, txt_record: Option<&NWTxtRecord>) {
        extern "C-unwind" {
            fn nw_advertise_descriptor_set_txt_record_object(
                advertise_descriptor: &NWAdvertiseDescriptor,
                txt_record: Option<&NWTxtRecord>,
            );
        }
        unsafe { nw_advertise_descriptor_set_txt_record_object(self, txt_record) }
    }

    /// Copies the TXT record object from the advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise descriptor object.
    ///
    ///
    /// Returns: A copy of the TXT record object, or NULL if the advertise descriptor
    /// does not have an associated TXT record.
    #[doc(alias = "nw_advertise_descriptor_copy_txt_record_object")]
    #[inline]
    pub fn txt_record_object(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_advertise_descriptor_copy_txt_record_object(
                advertise_descriptor: &NWAdvertiseDescriptor,
            ) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_advertise_descriptor_copy_txt_record_object(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Creates an advertise descriptor for application service discovery.
    ///
    ///
    /// Parameter `application_service_name`: The service name to advertise.
    ///
    ///
    /// Returns: An instantiated advertise descriptor object.
    #[doc(alias = "nw_advertise_descriptor_create_application_service")]
    #[inline]
    pub fn new_application_service(
        application_service_name: &CStr,
    ) -> NWRetained<NWAdvertiseDescriptor> {
        extern "C-unwind" {
            fn nw_advertise_descriptor_create_application_service(
                application_service_name: NonNull<c_char>,
            ) -> Option<NonNull<NWAdvertiseDescriptor>>;
        }
        let ret = unsafe {
            nw_advertise_descriptor_create_application_service(
                NonNull::new(application_service_name.as_ptr().cast_mut()).unwrap(),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns the service name of an application service advertise descriptor.
    ///
    ///
    /// Parameter `advertise_descriptor`: An advertise descriptor object.
    ///
    ///
    /// Returns: The service name or NULL if the advertise descriptor is not of the correct type.
    #[doc(alias = "nw_advertise_descriptor_get_application_service_name")]
    #[inline]
    pub fn application_service_name(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_advertise_descriptor_get_application_service_name(
                advertise_descriptor: &NWAdvertiseDescriptor,
            ) -> *const c_char;
        }
        unsafe { nw_advertise_descriptor_get_application_service_name(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwprotocoldefinition?language=objc)
#[doc(alias = "nw_protocol_definition_t")]
#[repr(C)]
pub struct NWProtocolDefinition {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWProtocolDefinition {}
);

impl NWProtocolDefinition {
    /// Compare two protocol definitions to check if they represent the same protocol.
    ///
    ///
    /// Parameter `definition1`: The first definition to compare
    ///
    ///
    /// Parameter `definition2`: The second definition to compare
    ///
    ///
    /// Returns: Returns true if the definitions represent the same protocol, false otherwise.
    #[doc(alias = "nw_protocol_definition_is_equal")]
    #[inline]
    pub fn is_equal(&self, definition2: &NWProtocolDefinition) -> bool {
        extern "C-unwind" {
            fn nw_protocol_definition_is_equal(
                definition1: &NWProtocolDefinition,
                definition2: &NWProtocolDefinition,
            ) -> bool;
        }
        unsafe { nw_protocol_definition_is_equal(self, definition2) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwprotocoloptions?language=objc)
#[doc(alias = "nw_protocol_options_t")]
#[repr(C)]
pub struct NWProtocolOptions {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWProtocolOptions {}
);

impl NWProtocolOptions {
    /// Retrieve the protocol definition for a given options object.
    ///
    ///
    /// Parameter `options`: The protocol options to check
    ///
    ///
    /// Returns: Returns a reference-counted protocol definition object.
    #[doc(alias = "nw_protocol_options_copy_definition")]
    #[inline]
    pub fn definition(&self) -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_options_copy_definition(
                options: &NWProtocolOptions,
            ) -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_options_copy_definition(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwprotocolmetadata?language=objc)
#[doc(alias = "nw_protocol_metadata_t")]
#[repr(C)]
pub struct NWProtocolMetadata {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWProtocolMetadata {}
);

impl NWProtocolMetadata {
    /// Retrieve the protocol definition for a given metadata object.
    ///
    ///
    /// Parameter `metadata`: The protocol metadata to check
    ///
    ///
    /// Returns: Returns a reference-counted protocol definition object.
    #[doc(alias = "nw_protocol_metadata_copy_definition")]
    #[inline]
    pub fn definition(&self) -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_metadata_copy_definition(
                metadata: &NWProtocolMetadata,
            ) -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_metadata_copy_definition(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwinterface?language=objc)
#[doc(alias = "nw_interface_t")]
#[repr(C)]
pub struct NWInterface {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWInterface {}
);

/// Interface types represent the underlying media for a network link, such as Wi-Fi or
/// Cellular.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_interface_type_t(pub c_uint);
impl nw_interface_type_t {
    #[doc(alias = "nw_interface_type_other")]
    pub const other: Self = Self(0);
    #[doc(alias = "nw_interface_type_wifi")]
    pub const wifi: Self = Self(1);
    #[doc(alias = "nw_interface_type_cellular")]
    pub const cellular: Self = Self(2);
    #[doc(alias = "nw_interface_type_wired")]
    pub const wired: Self = Self(3);
    #[doc(alias = "nw_interface_type_loopback")]
    pub const loopback: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_interface_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_interface_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWInterface {
    /// Retrieves the type of an interface. This only accesses the type of the specific
    /// interface being queried, and will not take into account types used by interfaces
    /// that traffic will eventually be routed through. That is, if the interface is a virtual
    /// interface (such as a VPN) that eventually forwards traffic through Wi-Fi, the type
    /// will be nw_interface_type_other, not nw_interface_type_wifi.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the type of the interface.
    #[doc(alias = "nw_interface_get_type")]
    #[inline]
    pub fn r#type(&self) -> nw_interface_type_t {
        extern "C-unwind" {
            fn nw_interface_get_type(interface: &NWInterface) -> nw_interface_type_t;
        }
        unsafe { nw_interface_get_type(self) }
    }
}

/// Interface radio types represent the radio technology for a network link.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_interface_radio_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_interface_radio_type_t(pub c_uint);
impl nw_interface_radio_type_t {
    #[doc(alias = "nw_interface_radio_type_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_interface_radio_type_wifi_b")]
    pub const wifi_b: Self = Self(1);
    #[doc(alias = "nw_interface_radio_type_wifi_a")]
    pub const wifi_a: Self = Self(2);
    #[doc(alias = "nw_interface_radio_type_wifi_g")]
    pub const wifi_g: Self = Self(3);
    #[doc(alias = "nw_interface_radio_type_wifi_n")]
    pub const wifi_n: Self = Self(4);
    #[doc(alias = "nw_interface_radio_type_wifi_ac")]
    pub const wifi_ac: Self = Self(5);
    #[doc(alias = "nw_interface_radio_type_wifi_ax")]
    pub const wifi_ax: Self = Self(6);
    #[doc(alias = "nw_interface_radio_type_cell_lte")]
    pub const cell_lte: Self = Self(0x80);
    #[doc(alias = "nw_interface_radio_type_cell_endc_sub6")]
    pub const cell_endc_sub6: Self = Self(0x81);
    #[doc(alias = "nw_interface_radio_type_cell_endc_mmw")]
    pub const cell_endc_mmw: Self = Self(0x82);
    #[doc(alias = "nw_interface_radio_type_cell_nr_sa_sub6")]
    pub const cell_nr_sa_sub6: Self = Self(0x83);
    #[doc(alias = "nw_interface_radio_type_cell_nr_sa_mmw")]
    pub const cell_nr_sa_mmw: Self = Self(0x84);
    #[doc(alias = "nw_interface_radio_type_cell_wcdma")]
    pub const cell_wcdma: Self = Self(0x85);
    #[doc(alias = "nw_interface_radio_type_cell_gsm")]
    pub const cell_gsm: Self = Self(0x86);
    #[doc(alias = "nw_interface_radio_type_cell_cdma")]
    pub const cell_cdma: Self = Self(0x87);
    #[doc(alias = "nw_interface_radio_type_cell_evdo")]
    pub const cell_evdo: Self = Self(0x88);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_interface_radio_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_interface_radio_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWInterface {
    /// Retrieves the name of an interface, to be used for reference or logging
    /// purposes.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the name of the interface as a NULL-terminated C string,
    /// or NULL if the interface is NULL.
    #[doc(alias = "nw_interface_get_name")]
    #[inline]
    pub fn name(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_interface_get_name(interface: &NWInterface) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_interface_get_name(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the index of an interface, to be used for reference or logging
    /// purposes. This is the same value as provided by if_nametoindex.
    ///
    ///
    /// Parameter `interface`: The interface object to check.
    ///
    ///
    /// Returns: Returns the index of the interface, or 0 if the interface is NULL.
    #[doc(alias = "nw_interface_get_index")]
    #[inline]
    pub fn index(&self) -> u32 {
        extern "C-unwind" {
            fn nw_interface_get_index(interface: &NWInterface) -> u32;
        }
        unsafe { nw_interface_get_index(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwendpoint?language=objc)
#[doc(alias = "nw_endpoint_t")]
#[repr(C)]
pub struct NWEndpoint {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWEndpoint {}
);

unsafe impl Send for NWEndpoint {}

unsafe impl Sync for NWEndpoint {}

/// Endpoint types represent a well-known form of endpoint. Values may be
/// added to this enumeration, and some custom endpoint types may use
/// values not defined in this enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_endpoint_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_endpoint_type_t(pub c_uint);
impl nw_endpoint_type_t {
    #[doc(alias = "nw_endpoint_type_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_endpoint_type_address")]
    pub const address: Self = Self(1);
    #[doc(alias = "nw_endpoint_type_host")]
    pub const host: Self = Self(2);
    #[doc(alias = "nw_endpoint_type_bonjour_service")]
    pub const bonjour_service: Self = Self(3);
    #[doc(alias = "nw_endpoint_type_url")]
    pub const url: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_endpoint_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_endpoint_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWEndpoint {
    /// Retrieves the type of a network endpoint.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object for which to get the type.
    ///
    ///
    /// Returns: Returns the type of the network endpoint.
    #[doc(alias = "nw_endpoint_get_type")]
    #[inline]
    pub fn r#type(&self) -> nw_endpoint_type_t {
        extern "C-unwind" {
            fn nw_endpoint_get_type(endpoint: &NWEndpoint) -> nw_endpoint_type_t;
        }
        unsafe { nw_endpoint_get_type(self) }
    }

    /// Creates a network endpoint with a hostname and port. The hostname
    /// may be a string-encoding of an IP address, in which case the
    /// the endpoint will be treated as an endpoint with the type
    /// nw_endpoint_type_address. Otherwise, the endpoint will have the
    /// type nw_endpoint_type_host.
    ///
    ///
    /// Parameter `hostname`: A hostname, such as "www.example.com", or "2607:ffff::1234:abcd".
    ///
    ///
    /// Parameter `port`: A port number as a C string, such as "443", or a service
    /// name, such as "https".
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_endpoint_create_host")]
    #[inline]
    pub fn new_host(hostname: &CStr, port: &CStr) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_host(
                hostname: NonNull<c_char>,
                port: NonNull<c_char>,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe {
            nw_endpoint_create_host(
                NonNull::new(hostname.as_ptr().cast_mut()).unwrap(),
                NonNull::new(port.as_ptr().cast_mut()).unwrap(),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the hostname string for a network endpoint with
    /// the type nw_endpoint_type_host, nw_endpoint_type_address,
    /// or nw_endpoint_type_url.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the hostname string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_host,
    /// nw_endpoint_type_address, or nw_endpoint_type_url.
    #[doc(alias = "nw_endpoint_get_hostname")]
    #[inline]
    pub fn hostname(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_hostname(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_hostname(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns an allocated port string for a network endpoint with
    /// the type nw_endpoint_type_host or nw_endpoint_type_address.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the port string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_host or
    /// nw_endpoint_type_address. This string must be freed with free().
    #[doc(alias = "nw_endpoint_copy_port_string")]
    #[inline]
    pub fn port_string(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_copy_port_string(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_copy_port_string(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the port for a network endpoint with the type
    /// nw_endpoint_type_url, nw_endpoint_type_host, or nw_endpoint_type_address.
    /// The port will be returned in Host Byte Order.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the port for the endpoint, or 0 if the endpoint is not
    /// of type nw_endpoint_type_host or nw_endpoint_type_address.
    /// The port will be returned in Host Byte Order.
    #[doc(alias = "nw_endpoint_get_port")]
    #[inline]
    pub fn port(&self) -> u16 {
        extern "C-unwind" {
            fn nw_endpoint_get_port(endpoint: &NWEndpoint) -> u16;
        }
        unsafe { nw_endpoint_get_port(self) }
    }

    /// Creates a network endpoint with a sockaddr struct. The endpoint
    /// will have the type nw_endpoint_type_address.
    ///
    ///
    /// Parameter `address`: An address stored as a sockaddr.
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `address` must be a valid pointer.
    #[doc(alias = "nw_endpoint_create_address")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn new_address(address: NonNull<libc::sockaddr>) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_address(
                address: NonNull<libc::sockaddr>,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_endpoint_create_address(address) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns an allocated IP address string for a network endpoint with
    /// the type nw_endpoint_type_address.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the IP address string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_address.
    /// This string must be freed with free().
    #[doc(alias = "nw_endpoint_copy_address_string")]
    #[inline]
    pub fn address_string(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_copy_address_string(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_copy_address_string(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the sockaddr struct for a network endpoint with
    /// the type nw_endpoint_type_address.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the sockaddr struct for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_address.
    #[doc(alias = "nw_endpoint_get_address")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn address(&self) -> NonNull<libc::sockaddr> {
        extern "C-unwind" {
            fn nw_endpoint_get_address(endpoint: &NWEndpoint) -> Option<NonNull<libc::sockaddr>>;
        }
        let ret = unsafe { nw_endpoint_get_address(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Creates a network endpoint for a Bonjour Service name, type, and
    /// domain. The endpoint will have the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `name`: The Bonjour Service name, such as "example".
    ///
    ///
    /// Parameter `type`: The Bonjour Service type, such as "_http._tcp".
    ///
    ///
    /// Parameter `domain`: The Bonjour Service domain, such as "local".
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_endpoint_create_bonjour_service")]
    #[inline]
    pub fn new_bonjour_service(
        name: &CStr,
        r#type: &CStr,
        domain: &CStr,
    ) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_bonjour_service(
                name: NonNull<c_char>,
                r#type: NonNull<c_char>,
                domain: NonNull<c_char>,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe {
            nw_endpoint_create_bonjour_service(
                NonNull::new(name.as_ptr().cast_mut()).unwrap(),
                NonNull::new(r#type.as_ptr().cast_mut()).unwrap(),
                NonNull::new(domain.as_ptr().cast_mut()).unwrap(),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the Bonjour Service name string for a network
    /// endpoint with the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the Bonjour Service name string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_bonjour_service.
    #[doc(alias = "nw_endpoint_get_bonjour_service_name")]
    #[inline]
    pub fn bonjour_service_name(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_bonjour_service_name(
                endpoint: &NWEndpoint,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_bonjour_service_name(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the Bonjour Service type string for a network
    /// endpoint with the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the Bonjour Service type string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_bonjour_service.
    #[doc(alias = "nw_endpoint_get_bonjour_service_type")]
    #[inline]
    pub fn bonjour_service_type(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_bonjour_service_type(
                endpoint: &NWEndpoint,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_bonjour_service_type(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the Bonjour Service domain string for a network
    /// endpoint with the type nw_endpoint_type_bonjour_service.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns the Bonjour Service domain string for the endpoint, or NULL
    /// if the endpoint is not of type nw_endpoint_type_bonjour_service.
    #[doc(alias = "nw_endpoint_get_bonjour_service_domain")]
    #[inline]
    pub fn bonjour_service_domain(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_bonjour_service_domain(
                endpoint: &NWEndpoint,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_bonjour_service_domain(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Creates a network endpoint with a URL. The endpoint will have the type
    /// nw_endpoint_type_url.
    ///
    ///
    /// Parameter `url`: The URL string.
    ///
    ///
    /// Returns: Returns an allocated nw_endpoint_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters, or due to URL parsing failure.
    #[doc(alias = "nw_endpoint_create_url")]
    #[inline]
    pub fn new_url(url: &CStr) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_endpoint_create_url(url: NonNull<c_char>) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_endpoint_create_url(NonNull::new(url.as_ptr().cast_mut()).unwrap()) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the URL string from a network endpoint of type
    /// nw_endpoint_type_url.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: The URL string, or NULL if the endpoint is not of type
    /// nw_endpoint_type_url.
    #[doc(alias = "nw_endpoint_get_url")]
    #[inline]
    pub fn url(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_endpoint_get_url(endpoint: &NWEndpoint) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_endpoint_get_url(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Retrieves the TXT record associated with the endpoint, if present.
    /// TXT records can be populated during browsing and connection
    /// establishment.
    ///
    ///
    /// Parameter `endpoint`: The endpoint object.
    ///
    ///
    /// Returns: Returns a retained nw_txt_record_t object if a TXT record
    /// is associated with this endpoint, or NULL otherwise.
    #[doc(alias = "nw_endpoint_copy_txt_record")]
    #[inline]
    pub fn txt_record(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_endpoint_copy_txt_record(endpoint: &NWEndpoint) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_endpoint_copy_txt_record(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Retrieves a signed data blob associated with an endpoint.
    ///
    ///
    /// Parameter `endpoint`: The endpoint to modify.
    ///
    ///
    /// Parameter `out_signature_length`: A pointer to a size_t that will take the length of the signature.
    ///
    ///
    /// Returns: Returns a pointer to a buffer of bytes containing a signature,
    /// or NULL if the endpoint is not signed.
    #[doc(alias = "nw_endpoint_get_signature")]
    #[inline]
    pub fn signature(&self, out_signature_length: &mut usize) -> *const u8 {
        extern "C-unwind" {
            fn nw_endpoint_get_signature(
                endpoint: &NWEndpoint,
                out_signature_length: &mut usize,
            ) -> *const u8;
        }
        unsafe { nw_endpoint_get_signature(self, out_signature_length) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwresolverconfig?language=objc)
#[doc(alias = "nw_resolver_config_t")]
#[repr(C)]
pub struct NWResolverConfig {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWResolverConfig {}
);

impl NWResolverConfig {
    /// Creates a DNS-over-HTTPS (DoH) resolver configuration. The provided
    /// URL describes the location of the DNS server, such as
    /// "https://dnsserver.example.net/dns-query". See RFC 8484.
    ///
    ///
    /// Parameter `url_endpoint`: The URL template of the DoH server as an endpoint.
    ///
    ///
    /// Returns: Returns an allocated nw_resolver_config_t object on success.
    #[doc(alias = "nw_resolver_config_create_https")]
    #[inline]
    pub fn new_https(url_endpoint: &NWEndpoint) -> NWRetained<NWResolverConfig> {
        extern "C-unwind" {
            fn nw_resolver_config_create_https(
                url_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWResolverConfig>>;
        }
        let ret = unsafe { nw_resolver_config_create_https(url_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a DNS-over-TLS (DoT) resolver configuration. The hostname
    /// of the provided endpoint will be used to validate the TLS certificate of the server.
    /// See RFC 7858.
    ///
    ///
    /// Parameter `server_endpoint`: A host endpoint identifying the DoT server.
    ///
    ///
    /// Returns: Returns an allocated nw_resolver_config_t object on success.
    #[doc(alias = "nw_resolver_config_create_tls")]
    #[inline]
    pub fn new_tls(server_endpoint: &NWEndpoint) -> NWRetained<NWResolverConfig> {
        extern "C-unwind" {
            fn nw_resolver_config_create_tls(
                server_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWResolverConfig>>;
        }
        let ret = unsafe { nw_resolver_config_create_tls(server_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Modifies the resolver configuration by adding a DNS server address as an endpoint.
    ///
    ///
    /// Parameter `config`: A resolver config object.
    ///
    ///
    /// Parameter `server_address`: A server address to assign to the configuration, as an endpoint.
    #[doc(alias = "nw_resolver_config_add_server_address")]
    #[inline]
    pub fn add_server_address(&self, server_address: &NWEndpoint) {
        extern "C-unwind" {
            fn nw_resolver_config_add_server_address(
                config: &NWResolverConfig,
                server_address: &NWEndpoint,
            );
        }
        unsafe { nw_resolver_config_add_server_address(self, server_address) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwproxyconfig?language=objc)
#[doc(alias = "nw_proxy_config_t")]
#[repr(C)]
pub struct NWProxyConfig {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWProxyConfig {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwrelayhop?language=objc)
#[doc(alias = "nw_relay_hop_t")]
#[repr(C)]
pub struct NWRelayHop {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWRelayHop {}
);

impl NWRelayHop {
    /// Creates a configuration for a secure relay. A relay is a proxy that is accessible using
    /// HTTP/3, HTTP/2, or both, and uses the CONNECT method to proxy TCP or UDP
    /// connections. At least one of `http3_relay_endpoint` and
    /// `http2_relay_endpoint` must be non-null.
    ///
    ///
    /// Parameter `http3_relay_endpoint`: A URL or host endpoint identifying the relay server accessible using HTTP/3.
    ///
    ///
    /// Parameter `http2_relay_endpoint`: A URL or host endpoint identifying the relay server accessible using HTTP/2.
    ///
    ///
    /// Parameter `relay_tls_options`: Optional TLS options to use for the TLS handshake to the relay. If this is null, default
    /// TLS options will be used.
    ///
    ///
    /// Returns: Returns an allocated `nw_relay_hop_t` object on success.
    #[doc(alias = "nw_relay_hop_create")]
    #[inline]
    pub fn new(
        http3_relay_endpoint: Option<&NWEndpoint>,
        http2_relay_endpoint: Option<&NWEndpoint>,
        relay_tls_options: Option<&NWProtocolOptions>,
    ) -> NWRetained<NWRelayHop> {
        extern "C-unwind" {
            fn nw_relay_hop_create(
                http3_relay_endpoint: Option<&NWEndpoint>,
                http2_relay_endpoint: Option<&NWEndpoint>,
                relay_tls_options: Option<&NWProtocolOptions>,
            ) -> Option<NonNull<NWRelayHop>>;
        }
        let ret = unsafe {
            nw_relay_hop_create(
                http3_relay_endpoint,
                http2_relay_endpoint,
                relay_tls_options,
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Adds additional HTTP headers to send as part of CONNECT requests to the
    /// relay.
    ///
    ///
    /// Parameter `relay_hop`: The proxy hop object.
    ///
    ///
    /// Parameter `field_name`: The HTTP header field name.
    ///
    ///
    /// Parameter `field_value`: The HTTP header field value.
    #[doc(alias = "nw_relay_hop_add_additional_http_header_field")]
    #[inline]
    pub fn add_additional_http_header_field(&self, field_name: &CStr, field_value: &CStr) {
        extern "C-unwind" {
            fn nw_relay_hop_add_additional_http_header_field(
                relay_hop: &NWRelayHop,
                field_name: NonNull<c_char>,
                field_value: NonNull<c_char>,
            );
        }
        unsafe {
            nw_relay_hop_add_additional_http_header_field(
                self,
                NonNull::new(field_name.as_ptr().cast_mut()).unwrap(),
                NonNull::new(field_value.as_ptr().cast_mut()).unwrap(),
            )
        }
    }
}

impl NWProxyConfig {
    /// Creates a proxy configuration with one or two secure relay hops.
    ///
    ///
    /// Parameter `first_hop`: The first or only relay hop.
    ///
    ///
    /// Parameter `second_hop`: An optional second relay hop.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    #[doc(alias = "nw_proxy_config_create_relay")]
    #[inline]
    pub fn new_relay(
        first_hop: &NWRelayHop,
        second_hop: Option<&NWRelayHop>,
    ) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_relay(
                first_hop: &NWRelayHop,
                second_hop: Option<&NWRelayHop>,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe { nw_proxy_config_create_relay(first_hop, second_hop) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a proxy configuration for an Oblivious HTTP relay and gateway. Note that
    /// Oblivious HTTP proxy configurations must also have specific match domains specified
    /// using `nw_proxy_config_add_match_domain`.
    ///
    ///
    /// Parameter `relay`: The Oblivious HTTP relay hop.
    ///
    ///
    /// Parameter `relay_resource_path`: The HTTP path to use for requests to the Oblivious HTTP relay that will forward requests to the gateway.
    ///
    ///
    /// Parameter `gateway_key_config`: The key configuration for the Oblivious HTTP gateway, or a list of key configurations where each configuration
    /// is prefixed with a two-byte length in network byte order.
    ///
    ///
    /// Parameter `gateway_key_config_length`: The length of the buffer in `gateway_key_config`.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    ///
    /// # Safety
    ///
    /// `gateway_key_config` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_create_oblivious_http")]
    #[inline]
    pub unsafe fn new_oblivious_http(
        relay: &NWRelayHop,
        relay_resource_path: &CStr,
        gateway_key_config: NonNull<u8>,
        gateway_key_config_length: usize,
    ) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_oblivious_http(
                relay: &NWRelayHop,
                relay_resource_path: NonNull<c_char>,
                gateway_key_config: NonNull<u8>,
                gateway_key_config_length: usize,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe {
            nw_proxy_config_create_oblivious_http(
                relay,
                NonNull::new(relay_resource_path.as_ptr().cast_mut()).unwrap(),
                gateway_key_config,
                gateway_key_config_length,
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a legacy HTTP CONNECT proxy configuration for a proxy server accessible
    /// using HTTP/1.1. This proxy will only relay TCP connections.
    ///
    ///
    /// Parameter `proxy_endpoint`: A host endpoint identifying the proxy server accessible using HTTP/1.1.
    ///
    ///
    /// Parameter `proxy_tls_options`: Optional TLS options to use for a TLS handshake to the relay. If no options are provided,
    /// the proxy will be accessed using cleartext HTTP.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    #[doc(alias = "nw_proxy_config_create_http_connect")]
    #[inline]
    pub fn new_http_connect(
        proxy_endpoint: &NWEndpoint,
        proxy_tls_options: Option<&NWProtocolOptions>,
    ) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_http_connect(
                proxy_endpoint: &NWEndpoint,
                proxy_tls_options: Option<&NWProtocolOptions>,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe { nw_proxy_config_create_http_connect(proxy_endpoint, proxy_tls_options) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a SOCKSv5 proxy configuration.
    ///
    ///
    /// Parameter `proxy_endpoint`: A host endpoint identifying the SOCKS proxy server.
    ///
    ///
    /// Returns: Returns an allocated `nw_proxy_config_t` object on success.
    #[doc(alias = "nw_proxy_config_create_socksv5")]
    #[inline]
    pub fn new_socksv5(proxy_endpoint: &NWEndpoint) -> NWRetained<NWProxyConfig> {
        extern "C-unwind" {
            fn nw_proxy_config_create_socksv5(
                proxy_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWProxyConfig>>;
        }
        let ret = unsafe { nw_proxy_config_create_socksv5(proxy_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Configures a username and password to use with a proxy configuration.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Parameter `username`: A proxy authentication username.
    ///
    ///
    /// Parameter `password`: A proxy authentication password.
    #[doc(alias = "nw_proxy_config_set_username_and_password")]
    #[inline]
    pub fn set_username_and_password(&self, username: &CStr, password: Option<&CStr>) {
        extern "C-unwind" {
            fn nw_proxy_config_set_username_and_password(
                proxy_config: &NWProxyConfig,
                username: NonNull<c_char>,
                password: *const c_char,
            );
        }
        unsafe {
            nw_proxy_config_set_username_and_password(
                self,
                NonNull::new(username.as_ptr().cast_mut()).unwrap(),
                password
                    .map(|ptr| ptr.as_ptr())
                    .unwrap_or_else(core::ptr::null),
            )
        }
    }

    /// Set whether or not a proxy configuration allows failover to non-proxied connections.
    /// Failover is not allowed by default.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Parameter `failover_allowed`: A Boolean indicating if failover is allowed.
    #[doc(alias = "nw_proxy_config_set_failover_allowed")]
    #[inline]
    pub fn set_failover_allowed(&self, failover_allowed: bool) {
        extern "C-unwind" {
            fn nw_proxy_config_set_failover_allowed(
                proxy_config: &NWProxyConfig,
                failover_allowed: bool,
            );
        }
        unsafe { nw_proxy_config_set_failover_allowed(self, failover_allowed) }
    }

    /// Check whether or not a proxy configuration allows failover to non-proxied connections.
    ///
    ///
    /// Parameter `proxy_config`: The proxy configuration object.
    ///
    ///
    /// Returns: A Boolean indicating if failover is allowed.
    #[doc(alias = "nw_proxy_config_get_failover_allowed")]
    #[inline]
    pub fn failover_allowed(&self) -> bool {
        extern "C-unwind" {
            fn nw_proxy_config_get_failover_allowed(proxy_config: &NWProxyConfig) -> bool;
        }
        unsafe { nw_proxy_config_get_failover_allowed(self) }
    }

    /// Adds a domain to define which hosts should use the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `match_domain`: The domain suffix to match hostnames against, as a string.
    #[doc(alias = "nw_proxy_config_add_match_domain")]
    #[inline]
    pub fn add_match_domain(&self, match_domain: &CStr) {
        extern "C-unwind" {
            fn nw_proxy_config_add_match_domain(
                config: &NWProxyConfig,
                match_domain: NonNull<c_char>,
            );
        }
        unsafe {
            nw_proxy_config_add_match_domain(
                self,
                NonNull::new(match_domain.as_ptr().cast_mut()).unwrap(),
            )
        }
    }

    /// Clears all match domains defined for the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    #[doc(alias = "nw_proxy_config_clear_match_domains")]
    #[inline]
    pub fn clear_match_domains(&self) {
        extern "C-unwind" {
            fn nw_proxy_config_clear_match_domains(config: &NWProxyConfig);
        }
        unsafe { nw_proxy_config_clear_match_domains(self) }
    }

    /// Adds a domain to define which hosts should not use the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `excluded_domain`: The domain suffix to match hostnames against, as a string.
    #[doc(alias = "nw_proxy_config_add_excluded_domain")]
    #[inline]
    pub fn add_excluded_domain(&self, excluded_domain: &CStr) {
        extern "C-unwind" {
            fn nw_proxy_config_add_excluded_domain(
                config: &NWProxyConfig,
                excluded_domain: NonNull<c_char>,
            );
        }
        unsafe {
            nw_proxy_config_add_excluded_domain(
                self,
                NonNull::new(excluded_domain.as_ptr().cast_mut()).unwrap(),
            )
        }
    }

    /// Clears all excluded domains defined for the proxy.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    #[doc(alias = "nw_proxy_config_clear_excluded_domains")]
    #[inline]
    pub fn clear_excluded_domains(&self) {
        extern "C-unwind" {
            fn nw_proxy_config_clear_excluded_domains(config: &NWProxyConfig);
        }
        unsafe { nw_proxy_config_clear_excluded_domains(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_proxy_domain_enumerator_t?language=objc)
pub type nw_proxy_domain_enumerator_t = *mut block2::DynBlock<dyn Fn(NonNull<c_char>)>;

impl NWProxyConfig {
    /// Enumerate all match domains set on the proxy configuration.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `enumerator`: A block that will get invoked for every domain that was added to the proxy configuration.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_enumerate_match_domains")]
    #[inline]
    pub unsafe fn enumerate_match_domains(&self, enumerator: nw_proxy_domain_enumerator_t) {
        extern "C-unwind" {
            fn nw_proxy_config_enumerate_match_domains(
                config: &NWProxyConfig,
                enumerator: nw_proxy_domain_enumerator_t,
            );
        }
        unsafe { nw_proxy_config_enumerate_match_domains(self, enumerator) }
    }

    /// Enumerate all excluded domains set on the proxy configuration.
    ///
    ///
    /// Parameter `config`: The proxy configuration object.
    ///
    ///
    /// Parameter `enumerator`: A block that will get invoked for every domain that was added to the proxy configuration.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_proxy_config_enumerate_excluded_domains")]
    #[inline]
    pub unsafe fn enumerate_excluded_domains(&self, enumerator: nw_proxy_domain_enumerator_t) {
        extern "C-unwind" {
            fn nw_proxy_config_enumerate_excluded_domains(
                config: &NWProxyConfig,
                enumerator: nw_proxy_domain_enumerator_t,
            );
        }
        unsafe { nw_proxy_config_enumerate_excluded_domains(self, enumerator) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwprivacycontext?language=objc)
#[doc(alias = "nw_privacy_context_t")]
#[repr(C)]
pub struct NWPrivacyContext {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWPrivacyContext {}
);

impl NWPrivacyContext {
    /// Create a new privacy context. This object can be added to connections and listeners
    /// by setting the privacy context on the nw_parameters_t. Each privacy context can have
    /// unique settings for logging and resolution, and implicitly has an isolated cache for
    /// items like TLS sessions.
    ///
    ///
    /// Parameter `description`: A string description used for logging.
    ///
    ///
    /// Returns: Returns an allocated nw_privacy_context_t object on success.
    #[doc(alias = "nw_privacy_context_create")]
    #[inline]
    pub fn new(description: &CStr) -> NWRetained<NWPrivacyContext> {
        extern "C-unwind" {
            fn nw_privacy_context_create(
                description: NonNull<c_char>,
            ) -> Option<NonNull<NWPrivacyContext>>;
        }
        let ret = unsafe {
            nw_privacy_context_create(NonNull::new(description.as_ptr().cast_mut()).unwrap())
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_privacy_context_default_context?language=objc)
    pub static _nw_privacy_context_default_context: &'static NWPrivacyContext;
}

impl NWPrivacyContext {
    /// Flush any cached state stored in this privacy context. The act of flushing the
    /// cache may be asynchronous, which means that it will take effect shortly after the
    /// function is invoked.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to flush.
    #[doc(alias = "nw_privacy_context_flush_cache")]
    #[inline]
    pub fn flush_cache(&self) {
        extern "C-unwind" {
            fn nw_privacy_context_flush_cache(privacy_context: &NWPrivacyContext);
        }
        unsafe { nw_privacy_context_flush_cache(self) }
    }

    /// Disable logging for connections and listeners associated with this context. Logging
    /// may not be disabled on the default privacy context.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context on which to disable logging.
    #[doc(alias = "nw_privacy_context_disable_logging")]
    #[inline]
    pub fn disable_logging(&self) {
        extern "C-unwind" {
            fn nw_privacy_context_disable_logging(privacy_context: &NWPrivacyContext);
        }
        unsafe { nw_privacy_context_disable_logging(self) }
    }

    /// Require that any DNS name resolution occurring for connections
    /// associated with this context use encrypted transports, such as TLS or HTTPS.
    /// Any unencrypted queries will be blocked if require_encrypted_name_resolution
    /// is set to true. Optionally, a fallback resolver config can be provided to use
    /// instead of blocking queries when require_encrypted_name_resolution is set to
    /// true.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    ///
    /// Parameter `require_encrypted_name_resolution`: If true, require that any name resolution using DNS is performed
    /// with encryption. If false, allow cleartext resolution. Defaults to false.
    ///
    ///
    /// Parameter `fallback_resolver_config`: An optional resolver configuration to use if no other encrypted DNS resolver
    /// is already configured for the query. This will only take effect if
    /// require_encrypted_name_resolution is set to true. If this configuration is
    /// NULL and require_encrypted_name_resolution is set to true, all cleartext
    /// name resolution will be blocked.
    #[doc(alias = "nw_privacy_context_require_encrypted_name_resolution")]
    #[inline]
    pub fn require_encrypted_name_resolution(
        &self,
        require_encrypted_name_resolution: bool,
        fallback_resolver_config: Option<&NWResolverConfig>,
    ) {
        extern "C-unwind" {
            fn nw_privacy_context_require_encrypted_name_resolution(
                privacy_context: &NWPrivacyContext,
                require_encrypted_name_resolution: bool,
                fallback_resolver_config: Option<&NWResolverConfig>,
            );
        }
        unsafe {
            nw_privacy_context_require_encrypted_name_resolution(
                self,
                require_encrypted_name_resolution,
                fallback_resolver_config,
            )
        }
    }

    /// Add a proxy configuration to apply to all connections that participate in this
    /// context. If set on `NW_DEFAULT_PRIVACY_CONTEXT`, this will additionally
    /// apply to other networking APIs used by the calling process.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    ///
    ///
    /// Parameter `proxy_config`: A proxy configuration object to apply to all connections that use this context.
    #[doc(alias = "nw_privacy_context_add_proxy")]
    #[inline]
    pub fn add_proxy(&self, proxy_config: &NWProxyConfig) {
        extern "C-unwind" {
            fn nw_privacy_context_add_proxy(
                privacy_context: &NWPrivacyContext,
                proxy_config: &NWProxyConfig,
            );
        }
        unsafe { nw_privacy_context_add_proxy(self, proxy_config) }
    }

    /// Clear out any proxies added using `nw_privacy_context_add_proxy`.
    ///
    ///
    /// Parameter `privacy_context`: A privacy context to modify. This can include the default privacy context.
    #[doc(alias = "nw_privacy_context_clear_proxies")]
    #[inline]
    pub fn clear_proxies(&self) {
        extern "C-unwind" {
            fn nw_privacy_context_clear_proxies(privacy_context: &NWPrivacyContext);
        }
        unsafe { nw_privacy_context_clear_proxies(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwparameters?language=objc)
#[doc(alias = "nw_parameters_t")]
#[repr(C)]
pub struct NWParameters {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWParameters {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwprotocolstack?language=objc)
#[doc(alias = "nw_protocol_stack_t")]
#[repr(C)]
pub struct NWProtocolStack {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWProtocolStack {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_configure_protocol_block_t?language=objc)
pub type nw_parameters_configure_protocol_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWProtocolOptions>)>;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_parameters_configure_protocol_default_configuration?language=objc)
    pub static _nw_parameters_configure_protocol_default_configuration:
        nw_parameters_configure_protocol_block_t;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_parameters_configure_protocol_disable?language=objc)
    pub static _nw_parameters_configure_protocol_disable: nw_parameters_configure_protocol_block_t;
}

impl NWParameters {
    /// Creates a parameters object that is configured for TLS and TCP. The caller can use
    /// the default configuration for TLS and TCP, or set specific options for each protocol,
    /// or disable TLS.
    ///
    ///
    /// Parameter `configure_tls`: A block to configure TLS. To use the default TLS configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. To disable TLS, pass
    /// NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Parameter `configure_tcp`: A block to configure TCP. To use the default TCP configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. It is invalid to try
    /// to disable TCP using NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// - `configure_tls` must be a valid pointer.
    /// - `configure_tcp` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_secure_tcp")]
    #[inline]
    pub unsafe fn new_secure_tcp(
        configure_tls: nw_parameters_configure_protocol_block_t,
        configure_tcp: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_secure_tcp(
                configure_tls: nw_parameters_configure_protocol_block_t,
                configure_tcp: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_secure_tcp(configure_tls, configure_tcp) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a parameters object that is configured for DTLS and UDP. The caller can use
    /// the default configuration for DTLS and UDP, or set specific options for each protocol,
    /// or disable DTLS.
    ///
    ///
    /// Parameter `configure_dtls`: A block to configure DTLS. To use the default DTLS configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. To disable DTLS, pass
    /// NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Parameter `configure_udp`: A block to configure UDP. To use the default UDP configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. It is invalid to try
    /// to disable UDP using NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// - `configure_dtls` must be a valid pointer.
    /// - `configure_udp` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_secure_udp")]
    #[inline]
    pub unsafe fn new_secure_udp(
        configure_dtls: nw_parameters_configure_protocol_block_t,
        configure_udp: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_secure_udp(
                configure_dtls: nw_parameters_configure_protocol_block_t,
                configure_udp: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_secure_udp(configure_dtls, configure_udp) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a parameters object that is configured for a custom IP protocol.
    /// This allows the caller to create connections and listeners that send
    /// and receive IP datagrams where the protocol header contained by the IP
    /// datagram is identified by the provided protocol number. Protocols already
    /// registered by the system, such as TCP and UDP, will not be allowed.
    ///
    /// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
    /// entitlement.
    ///
    ///
    /// Parameter `custom_ip_protocol_number`: The protocol number identifying a protocol carried by IP, as defined
    /// in RFC 5237.
    ///
    ///
    /// Parameter `configure_ip`: A block to configure IP. To use the default IP configuration, pass
    /// NW_PARAMETERS_DEFAULT_CONFIGURATION. To configure specific options, pass a custom
    /// block and operate on the nw_protocol_options_t object. It is invalid to try
    /// to disable IP using NW_PARAMETERS_DISABLE_PROTOCOL.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `configure_ip` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_custom_ip")]
    #[inline]
    pub unsafe fn new_custom_ip(
        custom_ip_protocol_number: u8,
        configure_ip: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_custom_ip(
                custom_ip_protocol_number: u8,
                configure_ip: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret =
            unsafe { nw_parameters_create_custom_ip(custom_ip_protocol_number, configure_ip) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a parameters object that is configured for QUIC. The caller must
    /// pass in a block to configure options.
    ///
    ///
    /// Parameter `configure_quic`: A block to configure QUIC. The caller must pass a custom
    /// block to configure the QUIC options.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    ///
    /// # Safety
    ///
    /// `configure_quic` must be a valid pointer.
    #[doc(alias = "nw_parameters_create_quic")]
    #[inline]
    pub unsafe fn new_quic(
        configure_quic: nw_parameters_configure_protocol_block_t,
    ) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_quic(
                configure_quic: nw_parameters_configure_protocol_block_t,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_quic(configure_quic) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates default parameters for use with application services.
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_parameters_create_application_service")]
    #[inline]
    pub fn new_application_service() -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create_application_service() -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create_application_service() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a generic parameters object. Note that in order to use parameters
    /// with an nw_connection_t or an nw_listener_t, the parameters must have protocols
    /// added into the default nw_protocol_stack_t. Clients using standard protocol
    /// configurations should use nw_parameters_create_secure_tcp() or
    /// nw_parameters_create_secure_udp().
    ///
    ///
    /// Returns: Returns an allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_parameters_create")]
    #[inline]
    pub fn new() -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_create() -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_create() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a deep copy of a parameters object that can be modified.
    ///
    ///
    /// Parameter `parameters`: The existing parameters object to copy
    ///
    ///
    /// Returns: Returns a newly allocated nw_parameters_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_parameters_copy")]
    #[inline]
    pub fn copy(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_parameters_copy(parameters: &NWParameters) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_parameters_copy(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Set a privacy context on the parameters, which will be associated
    /// with connections and listeners. The privacy context allows
    /// using separate caches for different sets of connections, as well as
    /// restricting how connection-specific information is logged and shared
    /// on the network.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `privacy_context`: The privacy context to associate with connections and listeners that use
    /// these parameters.
    #[doc(alias = "nw_parameters_set_privacy_context")]
    #[inline]
    pub fn set_privacy_context(&self, privacy_context: &NWPrivacyContext) {
        extern "C-unwind" {
            fn nw_parameters_set_privacy_context(
                parameters: &NWParameters,
                privacy_context: &NWPrivacyContext,
            );
        }
        unsafe { nw_parameters_set_privacy_context(self, privacy_context) }
    }
}

/// Attribution values can be used to indicate who determined the network content being accessed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_attribution_t?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_parameters_attribution_t(pub u8);
impl nw_parameters_attribution_t {
    #[doc(alias = "nw_parameters_attribution_developer")]
    pub const developer: Self = Self(1);
    #[doc(alias = "nw_parameters_attribution_user")]
    pub const user: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_parameters_attribution_t {
    const ENCODING: Encoding = u8::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_parameters_attribution_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// In order to help differentiate communication with domains requested by the user from those requested by the
    /// developer, attribution may be used. Attribution defaults to nw_parameters_attribution_developer. Setting
    /// attribution to nw_parameters_attribution_user indicates that the networking performed using these parameters
    /// is directed to content specified by the user, not the developer.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `attribution`: The entity to attribute the network operations to.
    #[doc(alias = "nw_parameters_set_attribution")]
    #[inline]
    pub fn set_attribution(&self, attribution: nw_parameters_attribution_t) {
        extern "C-unwind" {
            fn nw_parameters_set_attribution(
                parameters: &NWParameters,
                attribution: nw_parameters_attribution_t,
            );
        }
        unsafe { nw_parameters_set_attribution(self, attribution) }
    }

    /// Returns the attribution set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns the attribution property of the parameters.
    #[doc(alias = "nw_parameters_get_attribution")]
    #[inline]
    pub fn attribution(&self) -> nw_parameters_attribution_t {
        extern "C-unwind" {
            fn nw_parameters_get_attribution(
                parameters: &NWParameters,
            ) -> nw_parameters_attribution_t;
        }
        unsafe { nw_parameters_get_attribution(self) }
    }

    /// Require any connections or listeners using these parameters to use
    /// the provided network interface, or none if NULL is passed.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface`: The interface to require for connections or listeners, or NULL to
    /// allow any interface.
    #[doc(alias = "nw_parameters_require_interface")]
    #[inline]
    pub fn require_interface(&self, interface: Option<&NWInterface>) {
        extern "C-unwind" {
            fn nw_parameters_require_interface(
                parameters: &NWParameters,
                interface: Option<&NWInterface>,
            );
        }
        unsafe { nw_parameters_require_interface(self, interface) }
    }

    /// Access the required network interface set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the interface that is required by the parameters, or
    /// NULL if no interface is required.
    #[doc(alias = "nw_parameters_copy_required_interface")]
    #[inline]
    pub fn required_interface(&self) -> Option<NWRetained<NWInterface>> {
        extern "C-unwind" {
            fn nw_parameters_copy_required_interface(
                parameters: &NWParameters,
            ) -> Option<NonNull<NWInterface>>;
        }
        let ret = unsafe { nw_parameters_copy_required_interface(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// the provided network interface.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface`: The interface to prohibit for connections or listeners.
    #[doc(alias = "nw_parameters_prohibit_interface")]
    #[inline]
    pub fn prohibit_interface(&self, interface: &NWInterface) {
        extern "C-unwind" {
            fn nw_parameters_prohibit_interface(parameters: &NWParameters, interface: &NWInterface);
        }
        unsafe { nw_parameters_prohibit_interface(self, interface) }
    }

    /// Clear any interfaces that had been prohibited.
    ///
    ///
    /// Parameter `parameters`: The parameters object to modify
    #[doc(alias = "nw_parameters_clear_prohibited_interfaces")]
    #[inline]
    pub fn clear_prohibited_interfaces(&self) {
        extern "C-unwind" {
            fn nw_parameters_clear_prohibited_interfaces(parameters: &NWParameters);
        }
        unsafe { nw_parameters_clear_prohibited_interfaces(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_iterate_interfaces_block_t?language=objc)
pub type nw_parameters_iterate_interfaces_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWInterface>) -> bool>;

impl NWParameters {
    /// List all prohibited network interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the interfaces prohibited by the parameters. Returning
    /// true from the block will continue to iterate, and returning false will stop
    /// iterating.
    ///
    /// # Safety
    ///
    /// `iterate_block` must be a valid pointer.
    #[doc(alias = "nw_parameters_iterate_prohibited_interfaces")]
    #[inline]
    pub unsafe fn iterate_prohibited_interfaces(
        &self,
        iterate_block: nw_parameters_iterate_interfaces_block_t,
    ) {
        extern "C-unwind" {
            fn nw_parameters_iterate_prohibited_interfaces(
                parameters: &NWParameters,
                iterate_block: nw_parameters_iterate_interfaces_block_t,
            );
        }
        unsafe { nw_parameters_iterate_prohibited_interfaces(self, iterate_block) }
    }

    /// Require any connections or listeners using these parameters to use
    /// the provided network interface type.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface_type`: The interface type to require for connections or listeners.
    #[doc(alias = "nw_parameters_set_required_interface_type")]
    #[inline]
    pub fn set_required_interface_type(&self, interface_type: nw_interface_type_t) {
        extern "C-unwind" {
            fn nw_parameters_set_required_interface_type(
                parameters: &NWParameters,
                interface_type: nw_interface_type_t,
            );
        }
        unsafe { nw_parameters_set_required_interface_type(self, interface_type) }
    }

    /// Access the required network interface type set on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the interface type that is required by the parameters, or
    /// nw_interface_type_other_t if no interface type is required.
    #[doc(alias = "nw_parameters_get_required_interface_type")]
    #[inline]
    pub fn required_interface_type(&self) -> nw_interface_type_t {
        extern "C-unwind" {
            fn nw_parameters_get_required_interface_type(
                parameters: &NWParameters,
            ) -> nw_interface_type_t;
        }
        unsafe { nw_parameters_get_required_interface_type(self) }
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// the provided network interface type.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `interface_type`: The interface type to prohibit for connections or listeners.
    #[doc(alias = "nw_parameters_prohibit_interface_type")]
    #[inline]
    pub fn prohibit_interface_type(&self, interface_type: nw_interface_type_t) {
        extern "C-unwind" {
            fn nw_parameters_prohibit_interface_type(
                parameters: &NWParameters,
                interface_type: nw_interface_type_t,
            );
        }
        unsafe { nw_parameters_prohibit_interface_type(self, interface_type) }
    }

    /// Clear any interface types that had been prohibited.
    ///
    ///
    /// Parameter `parameters`: The parameters object to modify
    #[doc(alias = "nw_parameters_clear_prohibited_interface_types")]
    #[inline]
    pub fn clear_prohibited_interface_types(&self) {
        extern "C-unwind" {
            fn nw_parameters_clear_prohibited_interface_types(parameters: &NWParameters);
        }
        unsafe { nw_parameters_clear_prohibited_interface_types(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_iterate_interface_types_block_t?language=objc)
pub type nw_parameters_iterate_interface_types_block_t =
    *mut block2::DynBlock<dyn Fn(nw_interface_type_t) -> bool>;

impl NWParameters {
    /// List all prohibited network interface types.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the interface types prohibited by the parameters. Returning
    /// true from the block will continue to iterate, and returning false will stop
    /// iterating.
    ///
    /// # Safety
    ///
    /// `iterate_block` must be a valid pointer.
    #[doc(alias = "nw_parameters_iterate_prohibited_interface_types")]
    #[inline]
    pub unsafe fn iterate_prohibited_interface_types(
        &self,
        iterate_block: nw_parameters_iterate_interface_types_block_t,
    ) {
        extern "C-unwind" {
            fn nw_parameters_iterate_prohibited_interface_types(
                parameters: &NWParameters,
                iterate_block: nw_parameters_iterate_interface_types_block_t,
            );
        }
        unsafe { nw_parameters_iterate_prohibited_interface_types(self, iterate_block) }
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// a network interface that is considered expensive by the system.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `prohibit_expensive`: If true, prohibit the use of any expensive interfaces. If false,
    /// allow expensive interfaces. Defaults to false.
    #[doc(alias = "nw_parameters_set_prohibit_expensive")]
    #[inline]
    pub fn set_prohibit_expensive(&self, prohibit_expensive: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_prohibit_expensive(
                parameters: &NWParameters,
                prohibit_expensive: bool,
            );
        }
        unsafe { nw_parameters_set_prohibit_expensive(self, prohibit_expensive) }
    }

    /// Check if the parameters prohibit expensive interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if expensive interfaces are prohibited, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_prohibit_expensive")]
    #[inline]
    pub fn prohibit_expensive(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_prohibit_expensive(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_prohibit_expensive(self) }
    }

    /// Prohibit any connections or listeners using these parameters from using
    /// a network interface that is considered constrained by the system.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `prohibit_constrained`: If true, prohibit the use of any constrained interfaces. If false,
    /// allow constrained interfaces. Defaults to false.
    #[doc(alias = "nw_parameters_set_prohibit_constrained")]
    #[inline]
    pub fn set_prohibit_constrained(&self, prohibit_constrained: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_prohibit_constrained(
                parameters: &NWParameters,
                prohibit_constrained: bool,
            );
        }
        unsafe { nw_parameters_set_prohibit_constrained(self, prohibit_constrained) }
    }

    /// Check if the parameters prohibit constrained interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if constrained interfaces are prohibited, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_prohibit_constrained")]
    #[inline]
    pub fn prohibit_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_prohibit_constrained(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_prohibit_constrained(self) }
    }

    /// Explicitly allow connectivity over ultra-constrained interfaces. Without
    /// this being set, connections are not allowed to use these interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `allow_ultra_constrained`: Whether or not ultra-constrained interfaces are allowed.
    #[doc(alias = "nw_parameters_set_allow_ultra_constrained")]
    #[inline]
    pub fn set_allow_ultra_constrained(&self, allow_ultra_constrained: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_allow_ultra_constrained(
                parameters: &NWParameters,
                allow_ultra_constrained: bool,
            );
        }
        unsafe { nw_parameters_set_allow_ultra_constrained(self, allow_ultra_constrained) }
    }

    /// Check if the parameters explicitly allow connectivity over
    /// ultra-constrained interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns whether or not ultra-constrained interfaces are allowed.
    #[doc(alias = "nw_parameters_get_allow_ultra_constrained")]
    #[inline]
    pub fn allow_ultra_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_allow_ultra_constrained(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_allow_ultra_constrained(self) }
    }

    /// Allow any connections using these parameters to reuse
    /// local addresses already in use by other connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `reuse_local_address`: If true, allow the reuse of local addresses. If false,
    /// disallow the reuse of local addresses. Defaults to false.
    #[doc(alias = "nw_parameters_set_reuse_local_address")]
    #[inline]
    pub fn set_reuse_local_address(&self, reuse_local_address: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_reuse_local_address(
                parameters: &NWParameters,
                reuse_local_address: bool,
            );
        }
        unsafe { nw_parameters_set_reuse_local_address(self, reuse_local_address) }
    }

    /// Check if the parameters allow local address reuse.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if local address reuse is allowed, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_reuse_local_address")]
    #[inline]
    pub fn reuse_local_address(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_reuse_local_address(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_reuse_local_address(self) }
    }

    /// Specify a specific endpoint to use as the local endpoint.
    /// For connections, this will be used to initiate traffic;
    /// for listeners, this will be used for receiving incoming
    /// connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `local_endpoint`: The endpoint to set as the local endpoint. Pass NULL to
    /// clear the local endpoint.
    #[doc(alias = "nw_parameters_set_local_endpoint")]
    #[inline]
    pub fn set_local_endpoint(&self, local_endpoint: Option<&NWEndpoint>) {
        extern "C-unwind" {
            fn nw_parameters_set_local_endpoint(
                parameters: &NWParameters,
                local_endpoint: Option<&NWEndpoint>,
            );
        }
        unsafe { nw_parameters_set_local_endpoint(self, local_endpoint) }
    }

    /// Extract the local endpoint set on the connection.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Returns: Returns the endpoint that is set in the parameters, or
    /// NULL if no local endpoint is set.
    #[doc(alias = "nw_parameters_copy_local_endpoint")]
    #[inline]
    pub fn local_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_parameters_copy_local_endpoint(
                parameters: &NWParameters,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_parameters_copy_local_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Allow the inclusion of peer-to-peer interfaces when
    /// listening or establishing outbound connections. This parameter
    /// will not take effect if a specific interface is required.
    /// This parameter is applicable when advertising a Bonjour service
    /// on a listener, or connecting to a Bonjour service.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `include_peer_to_peer`: If true, allow advertising, resolving, and connecting over
    /// peer-to-peer interfaces. Defaults to false.
    #[doc(alias = "nw_parameters_set_include_peer_to_peer")]
    #[inline]
    pub fn set_include_peer_to_peer(&self, include_peer_to_peer: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_include_peer_to_peer(
                parameters: &NWParameters,
                include_peer_to_peer: bool,
            );
        }
        unsafe { nw_parameters_set_include_peer_to_peer(self, include_peer_to_peer) }
    }

    /// Check if the parameters allow the inclusion of
    /// peer-to-peer interfaces.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if peer-to-peer interfaces are allowed,
    /// or false otherwise.
    #[doc(alias = "nw_parameters_get_include_peer_to_peer")]
    #[inline]
    pub fn include_peer_to_peer(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_include_peer_to_peer(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_include_peer_to_peer(self) }
    }

    /// Use fast open for an outbound connection, which may be done at any
    /// protocol level. Use of fast open requires that the caller send
    /// idempotent data on the connection before the connection may move
    /// into the ready state. As a side effect, this may implicitly enable
    /// fast open or early data for protocols in the stack, even if they did not
    /// have fast open explicitly enabled on them (such as the option to enable
    /// TCP Fast Open).
    ///
    /// NOTE: Use of this API may have security implications for application data.
    /// In particular, TLS early data is replayable by a network attacker. Callers must
    /// account for this when sending data before the handshake is confirmed. See
    /// RFC 8446 for more information. Callers MUST NOT enable fast open without
    /// a specific application profile that defines its use.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `fast_open_enabled`: If true, indicate that fast open is requested and that idempotent data
    /// MUST be sent by the caller on the connection. If false,
    /// disallow the fast open at the top level protocol. Defaults to false.
    #[doc(alias = "nw_parameters_set_fast_open_enabled")]
    #[inline]
    pub fn set_fast_open_enabled(&self, fast_open_enabled: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_fast_open_enabled(
                parameters: &NWParameters,
                fast_open_enabled: bool,
            );
        }
        unsafe { nw_parameters_set_fast_open_enabled(self, fast_open_enabled) }
    }

    /// Check if the parameters allow the use of fast open for the top level
    /// protocol.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if fast open is allowed for the top level protocol, or
    /// false otherwise.
    #[doc(alias = "nw_parameters_get_fast_open_enabled")]
    #[inline]
    pub fn fast_open_enabled(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_fast_open_enabled(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_fast_open_enabled(self) }
    }
}

/// The network service class represents the network queuing priority to use
/// for traffic generated by a connection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_service_class_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_service_class_t(pub c_uint);
impl nw_service_class_t {
    #[doc(alias = "nw_service_class_best_effort")]
    pub const best_effort: Self = Self(0);
    #[doc(alias = "nw_service_class_background")]
    pub const background: Self = Self(1);
    #[doc(alias = "nw_service_class_interactive_video")]
    pub const interactive_video: Self = Self(2);
    #[doc(alias = "nw_service_class_interactive_voice")]
    pub const interactive_voice: Self = Self(3);
    #[doc(alias = "nw_service_class_responsive_data")]
    pub const responsive_data: Self = Self(4);
    #[doc(alias = "nw_service_class_signaling")]
    pub const signaling: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_service_class_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_service_class_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// Set the data service class to use for connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `service_class`: The service class value to use for connections. Defaults to nw_service_class_best_effort.
    #[doc(alias = "nw_parameters_set_service_class")]
    #[inline]
    pub fn set_service_class(&self, service_class: nw_service_class_t) {
        extern "C-unwind" {
            fn nw_parameters_set_service_class(
                parameters: &NWParameters,
                service_class: nw_service_class_t,
            );
        }
        unsafe { nw_parameters_set_service_class(self, service_class) }
    }

    /// Check the service class configured on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the effective service class configured on the parameters.
    #[doc(alias = "nw_parameters_get_service_class")]
    #[inline]
    pub fn service_class(&self) -> nw_service_class_t {
        extern "C-unwind" {
            fn nw_parameters_get_service_class(parameters: &NWParameters) -> nw_service_class_t;
        }
        unsafe { nw_parameters_get_service_class(self) }
    }
}

/// Multipath services represent the modes of multipath usage that are
/// allowed for connections.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_multipath_service_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_multipath_service_t(pub c_uint);
impl nw_multipath_service_t {
    #[doc(alias = "nw_multipath_service_disabled")]
    pub const disabled: Self = Self(0);
    #[doc(alias = "nw_multipath_service_handover")]
    pub const handover: Self = Self(1);
    #[doc(alias = "nw_multipath_service_interactive")]
    pub const interactive: Self = Self(2);
    #[doc(alias = "nw_multipath_service_aggregate")]
    pub const aggregate: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_multipath_service_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_multipath_service_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// Set the multipath service to use for connections.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `multipath_service`: The multipath service value to use for connections. Defaults to nw_multipath_service_disabled.
    #[doc(alias = "nw_parameters_set_multipath_service")]
    #[inline]
    pub fn set_multipath_service(&self, multipath_service: nw_multipath_service_t) {
        extern "C-unwind" {
            fn nw_parameters_set_multipath_service(
                parameters: &NWParameters,
                multipath_service: nw_multipath_service_t,
            );
        }
        unsafe { nw_parameters_set_multipath_service(self, multipath_service) }
    }

    /// Check the multipath service mode configured on the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns the multipath service configured on the parameters.
    #[doc(alias = "nw_parameters_get_multipath_service")]
    #[inline]
    pub fn multipath_service(&self) -> nw_multipath_service_t {
        extern "C-unwind" {
            fn nw_parameters_get_multipath_service(
                parameters: &NWParameters,
            ) -> nw_multipath_service_t;
        }
        unsafe { nw_parameters_get_multipath_service(self) }
    }

    /// Retrieve the default protocol stack from a parameters object.
    /// Every parameters object will have a default protocol stack. For
    /// parameters created with a convenience initializer, this protocol
    /// stack will be pre-populated. For parameters created with the generic
    /// initializers, the stack will be empty.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns an nw_protocol_stack_t object that can be inspected and modified.
    #[doc(alias = "nw_parameters_copy_default_protocol_stack")]
    #[inline]
    pub fn default_protocol_stack(&self) -> NWRetained<NWProtocolStack> {
        extern "C-unwind" {
            fn nw_parameters_copy_default_protocol_stack(
                parameters: &NWParameters,
            ) -> Option<NonNull<NWProtocolStack>>;
        }
        let ret = unsafe { nw_parameters_copy_default_protocol_stack(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolStack {
    /// Prepend an application-layer protocol onto the top of a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    ///
    /// Parameter `protocol`: The protocol options to add to the stack, which contain the definition of the
    /// protocol to add.
    #[doc(alias = "nw_protocol_stack_prepend_application_protocol")]
    #[inline]
    pub fn prepend_application_protocol(&self, protocol: &NWProtocolOptions) {
        extern "C-unwind" {
            fn nw_protocol_stack_prepend_application_protocol(
                stack: &NWProtocolStack,
                protocol: &NWProtocolOptions,
            );
        }
        unsafe { nw_protocol_stack_prepend_application_protocol(self, protocol) }
    }

    /// Remove all application-layer protocols from a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    #[doc(alias = "nw_protocol_stack_clear_application_protocols")]
    #[inline]
    pub fn clear_application_protocols(&self) {
        extern "C-unwind" {
            fn nw_protocol_stack_clear_application_protocols(stack: &NWProtocolStack);
        }
        unsafe { nw_protocol_stack_clear_application_protocols(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_protocol_stack_iterate_protocols_block_t?language=objc)
pub type nw_protocol_stack_iterate_protocols_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWProtocolOptions>)>;

impl NWProtocolStack {
    /// List all application protocols attached to a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Parameter `iterate_block`: A block that will return the protocols attached to the stack.
    ///
    /// # Safety
    ///
    /// `iterate_block` must be a valid pointer.
    #[doc(alias = "nw_protocol_stack_iterate_application_protocols")]
    #[inline]
    pub unsafe fn iterate_application_protocols(
        &self,
        iterate_block: nw_protocol_stack_iterate_protocols_block_t,
    ) {
        extern "C-unwind" {
            fn nw_protocol_stack_iterate_application_protocols(
                stack: &NWProtocolStack,
                iterate_block: nw_protocol_stack_iterate_protocols_block_t,
            );
        }
        unsafe { nw_protocol_stack_iterate_application_protocols(self, iterate_block) }
    }

    /// Access the transport-layer protocol used in a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Returns: Returns the transport protocol currently set in the protocol stack,
    /// or NULL if no transport protocol is set.
    #[doc(alias = "nw_protocol_stack_copy_transport_protocol")]
    #[inline]
    pub fn transport_protocol(&self) -> Option<NWRetained<NWProtocolOptions>> {
        extern "C-unwind" {
            fn nw_protocol_stack_copy_transport_protocol(
                stack: &NWProtocolStack,
            ) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_protocol_stack_copy_transport_protocol(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Set the transport-layer protocol to use for a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to modify
    ///
    ///
    /// Parameter `protocol`: The protocol options to set into the stack, which contain the definition of the
    /// protocol.
    #[doc(alias = "nw_protocol_stack_set_transport_protocol")]
    #[inline]
    pub fn set_transport_protocol(&self, protocol: &NWProtocolOptions) {
        extern "C-unwind" {
            fn nw_protocol_stack_set_transport_protocol(
                stack: &NWProtocolStack,
                protocol: &NWProtocolOptions,
            );
        }
        unsafe { nw_protocol_stack_set_transport_protocol(self, protocol) }
    }

    /// Access the internet-layer protocol used in a protocol stack.
    ///
    ///
    /// Parameter `stack`: The protocol stack to check
    ///
    ///
    /// Returns: Returns the internet protocol currently set in the protocol stack,
    /// or NULL if no internet protocol is set. Note that this will generally
    /// be NULL, unless a specific IP family is being selected.
    #[doc(alias = "nw_protocol_stack_copy_internet_protocol")]
    #[inline]
    pub fn internet_protocol(&self) -> Option<NWRetained<NWProtocolOptions>> {
        extern "C-unwind" {
            fn nw_protocol_stack_copy_internet_protocol(
                stack: &NWProtocolStack,
            ) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_protocol_stack_copy_internet_protocol(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

impl NWParameters {
    /// Set to true to limit inbound connections to peers attached to the
    /// local link only. Defaults to false.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure
    ///
    ///
    /// Parameter `local_only`: True to limit connections to the local link only.
    #[doc(alias = "nw_parameters_set_local_only")]
    #[inline]
    pub fn set_local_only(&self, local_only: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_local_only(parameters: &NWParameters, local_only: bool);
        }
        unsafe { nw_parameters_set_local_only(self, local_only) }
    }

    /// Indicates whether or not the parameters limit connections to the local
    /// link only.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check
    ///
    ///
    /// Returns: Returns true if the parameters limit inbound connections to the local link.
    #[doc(alias = "nw_parameters_get_local_only")]
    #[inline]
    pub fn local_only(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_local_only(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_local_only(self) }
    }

    /// Set to true to attempt connections without using proxies, only using any configured proxies if the connections
    /// cannot otherwise be completed. Defaults to false.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `prefer_no_proxy`: True to cause connections to be attempted without proxies.
    #[doc(alias = "nw_parameters_set_prefer_no_proxy")]
    #[inline]
    pub fn set_prefer_no_proxy(&self, prefer_no_proxy: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_prefer_no_proxy(parameters: &NWParameters, prefer_no_proxy: bool);
        }
        unsafe { nw_parameters_set_prefer_no_proxy(self, prefer_no_proxy) }
    }

    /// Indicates whether or not the parameters cause connections to be attempted without proxies, only using proxies
    /// if connections cannot otherwise be completed.
    ///
    ///
    /// Parameter `parameters`: The parameters to get the property from.
    ///
    ///
    /// Returns: Returns true if the parameters cause connections to be attempted without proxies, only using proxies if
    /// connections cannot otherwise be completed.
    #[doc(alias = "nw_parameters_get_prefer_no_proxy")]
    #[inline]
    pub fn prefer_no_proxy(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_get_prefer_no_proxy(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_get_prefer_no_proxy(self) }
    }
}

/// Expired DNS behavior defines whether or not a connection will allow the use
/// of expired DNS answers during connection establishment.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_parameters_expired_dns_behavior_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_parameters_expired_dns_behavior_t(pub c_uint);
impl nw_parameters_expired_dns_behavior_t {
    #[doc(alias = "nw_parameters_expired_dns_behavior_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "nw_parameters_expired_dns_behavior_allow")]
    pub const allow: Self = Self(1);
    #[doc(alias = "nw_parameters_expired_dns_behavior_prohibit")]
    pub const prohibit: Self = Self(2);
    /// This should only be set for hostnames whose resolutions are not expected to change across networks.
    #[doc(alias = "nw_parameters_expired_dns_behavior_persistent")]
    pub const persistent: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_parameters_expired_dns_behavior_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_parameters_expired_dns_behavior_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWParameters {
    /// Allow or prohibit the use of expired DNS answers during connection establishment.
    /// If allowed, a DNS answer that was previously returned may be re-used for new
    /// connections even after the answers are considered expired. A query for fresh answers
    /// will be sent in parallel, and the fresh answers will be used as alternate addresses
    /// in case the expired answers do not result in successful connections.
    ///
    /// By default, this value is nw_parameters_expired_dns_behavior_default, which allows
    /// the system to determine if it is appropriate to use expired answers.
    ///
    ///
    /// Parameter `parameters`: The parameters to modify.
    ///
    ///
    /// Parameter `expired_dns_behavior`: Allow, prohibit, or use system default behavior for expired DNS answers.
    #[doc(alias = "nw_parameters_set_expired_dns_behavior")]
    #[inline]
    pub fn set_expired_dns_behavior(
        &self,
        expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
    ) {
        extern "C-unwind" {
            fn nw_parameters_set_expired_dns_behavior(
                parameters: &NWParameters,
                expired_dns_behavior: nw_parameters_expired_dns_behavior_t,
            );
        }
        unsafe { nw_parameters_set_expired_dns_behavior(self, expired_dns_behavior) }
    }

    /// Check the effective expired DNS behavior of a connection.
    /// See nw_parameters_set_expired_dns_behavior() for a discussion on the use of expired
    /// DNS answers.
    ///
    ///
    /// Parameter `parameters`: The parameters to check.
    ///
    ///
    /// Returns: Returns the current effective expired DNS answer behavior.
    #[doc(alias = "nw_parameters_get_expired_dns_behavior")]
    #[inline]
    pub fn expired_dns_behavior(&self) -> nw_parameters_expired_dns_behavior_t {
        extern "C-unwind" {
            fn nw_parameters_get_expired_dns_behavior(
                parameters: &NWParameters,
            ) -> nw_parameters_expired_dns_behavior_t;
        }
        unsafe { nw_parameters_get_expired_dns_behavior(self) }
    }

    /// Require to do or not to do DNSSEC validation when resolving the endpoint, before
    /// making a connection.
    ///
    ///
    /// Parameter `parameters`: The parameters object to configure.
    ///
    ///
    /// Parameter `requires_dnssec_validation`: A boolean value that indicates if DNSSEC validation should be required
    /// when doing DNS resolution for the endpoint.
    ///
    ///
    /// DNSSEC validation only takes effect if making a connection to an
    /// endpoint that requires domain name resolution, such as:
    /// <code>
    /// nw_endpoint_type_host
    /// </code>
    /// <code>
    /// nw_endpoint_type_url
    /// </code>
    ///
    /// 1. If this property is not set or is set to false on the parameters, DNSSEC
    /// validation will not be required.
    ///
    /// 2. If this property is set to true and no additional DNSSEC
    /// configuration is set on the parameters, the default behavior will be
    /// followed: Only DNSSEC secure and DNSSEC insecure resolved result will be
    /// used to establish a connection.
    ///
    /// 3. If this property is set to true and additional DNSSEC configuration
    /// is set on the parameters, the behavior specified by that configuration
    /// will be followed.
    #[doc(alias = "nw_parameters_set_requires_dnssec_validation")]
    #[inline]
    pub fn set_requires_dnssec_validation(&self, requires_dnssec_validation: bool) {
        extern "C-unwind" {
            fn nw_parameters_set_requires_dnssec_validation(
                parameters: &NWParameters,
                requires_dnssec_validation: bool,
            );
        }
        unsafe { nw_parameters_set_requires_dnssec_validation(self, requires_dnssec_validation) }
    }

    /// Check if DNSSEC validation is required.
    ///
    ///
    /// Parameter `parameters`: The parameters object to check.
    ///
    ///
    /// Returns: Returns true if DNSSEC validation is required, false otherwise.
    #[doc(alias = "nw_parameters_requires_dnssec_validation")]
    #[inline]
    pub fn requires_dnssec_validation(&self) -> bool {
        extern "C-unwind" {
            fn nw_parameters_requires_dnssec_validation(parameters: &NWParameters) -> bool;
        }
        unsafe { nw_parameters_requires_dnssec_validation(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwbrowsedescriptor?language=objc)
#[doc(alias = "nw_browse_descriptor_t")]
#[repr(C)]
pub struct NWBrowseDescriptor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWBrowseDescriptor {}
);

impl NWBrowseDescriptor {
    /// Creates a new browse descriptor object on a Bonjour service type and
    /// domain.
    ///
    ///
    /// Parameter `type`: A Bonjour service type.
    ///
    ///
    /// Parameter `domain`: An optional Bonjour service domain. If the domain is unspecified, the
    /// default domains for browsing will be used.
    ///
    ///
    /// Returns: An instantiated browse descriptor object.
    #[doc(alias = "nw_browse_descriptor_create_bonjour_service")]
    #[inline]
    pub fn new_bonjour_service(
        r#type: &CStr,
        domain: Option<&CStr>,
    ) -> NWRetained<NWBrowseDescriptor> {
        extern "C-unwind" {
            fn nw_browse_descriptor_create_bonjour_service(
                r#type: NonNull<c_char>,
                domain: *const c_char,
            ) -> Option<NonNull<NWBrowseDescriptor>>;
        }
        let ret = unsafe {
            nw_browse_descriptor_create_bonjour_service(
                NonNull::new(r#type.as_ptr().cast_mut()).unwrap(),
                domain
                    .map(|ptr| ptr.as_ptr())
                    .unwrap_or_else(core::ptr::null),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns the service type of a browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service type.
    #[doc(alias = "nw_browse_descriptor_get_bonjour_service_type")]
    #[inline]
    pub fn bonjour_service_type(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_bonjour_service_type(
                descriptor: &NWBrowseDescriptor,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_browse_descriptor_get_bonjour_service_type(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns the service domain of a browse descriptor, or NULL if NULL was
    /// provided while creating the descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service domain.
    #[doc(alias = "nw_browse_descriptor_get_bonjour_service_domain")]
    #[inline]
    pub fn bonjour_service_domain(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_bonjour_service_domain(
                descriptor: &NWBrowseDescriptor,
            ) -> *const c_char;
        }
        unsafe { nw_browse_descriptor_get_bonjour_service_domain(self) }
    }

    /// Set a flag to allow or prohibit the browser from querying for TXT records
    /// while browsing. This flag should only be set if the client needs information
    /// from the TXT record during browsing, and may increase network traffic. By
    /// default, the browser will not automatically query for TXT records.
    ///
    ///
    /// Parameter `descriptor`: The browse descriptor object.
    ///
    ///
    /// Parameter `include_txt_record`: A flag indicating whether results should include a TXT record. If true,
    /// the browser will query for TXT records. If false, the browser will not
    /// query for TXT records.
    #[doc(alias = "nw_browse_descriptor_set_include_txt_record")]
    #[inline]
    pub fn set_include_txt_record(&self, include_txt_record: bool) {
        extern "C-unwind" {
            fn nw_browse_descriptor_set_include_txt_record(
                descriptor: &NWBrowseDescriptor,
                include_txt_record: bool,
            );
        }
        unsafe { nw_browse_descriptor_set_include_txt_record(self, include_txt_record) }
    }

    /// Check whether the browser is allowed to query for TXT records.
    ///
    ///
    /// Parameter `descriptor`: The browse descriptor to check.
    ///
    ///
    /// Returns: Whether the browser is allowed to query for TXT records.
    #[doc(alias = "nw_browse_descriptor_get_include_txt_record")]
    #[inline]
    pub fn include_txt_record(&self) -> bool {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_include_txt_record(descriptor: &NWBrowseDescriptor)
                -> bool;
        }
        unsafe { nw_browse_descriptor_get_include_txt_record(self) }
    }

    /// Creates a browse descriptor for application service discovery.
    ///
    ///
    /// Parameter `application_service_name`: The service name to browse for.
    ///
    ///
    /// Returns: An instantiated browse descriptor object.
    #[doc(alias = "nw_browse_descriptor_create_application_service")]
    #[inline]
    pub fn new_application_service(
        application_service_name: &CStr,
    ) -> NWRetained<NWBrowseDescriptor> {
        extern "C-unwind" {
            fn nw_browse_descriptor_create_application_service(
                application_service_name: NonNull<c_char>,
            ) -> Option<NonNull<NWBrowseDescriptor>>;
        }
        let ret = unsafe {
            nw_browse_descriptor_create_application_service(
                NonNull::new(application_service_name.as_ptr().cast_mut()).unwrap(),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns the service name of an application service browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object.
    ///
    ///
    /// Returns: The service name.
    #[doc(alias = "nw_browse_descriptor_get_application_service_name")]
    #[inline]
    pub fn application_service_name(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_browse_descriptor_get_application_service_name(
                descriptor: &NWBrowseDescriptor,
            ) -> *const c_char;
        }
        unsafe { nw_browse_descriptor_get_application_service_name(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwbrowseresult?language=objc)
#[doc(alias = "nw_browse_result_t")]
#[repr(C)]
pub struct NWBrowseResult {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWBrowseResult {}
);

/// A nw_browse_result_change_t describes all changes that occurred between
/// two browse results. Call nw_browse_result_get_changes() to get the
/// changes between an old and a new browse result.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_t?language=objc)
pub type nw_browse_result_change_t = u64;

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_invalid?language=objc)
pub const nw_browse_result_change_invalid: c_uint = 0x00;
/// are identical.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_identical?language=objc)
pub const nw_browse_result_change_identical: c_uint = 0x01;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_result_added?language=objc)
pub const nw_browse_result_change_result_added: c_uint = 0x02;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_result_removed?language=objc)
pub const nw_browse_result_change_result_removed: c_uint = 0x04;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_interface_added?language=objc)
pub const nw_browse_result_change_interface_added: c_uint = 0x08;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_interface_removed?language=objc)
pub const nw_browse_result_change_interface_removed: c_uint = 0x10;
/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_change_txt_record_changed?language=objc)
pub const nw_browse_result_change_txt_record_changed: c_uint = 0x20;

impl NWBrowseResult {
    /// Copies the endpoint associated with the browse result object.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: The associated endpoint.
    #[doc(alias = "nw_browse_result_copy_endpoint")]
    #[inline]
    pub fn endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_browse_result_copy_endpoint(
                result: &NWBrowseResult,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_browse_result_copy_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Determines the set of all changes that occurred between an old and a new
    /// browse result. For example, if the return value of this function matches
    /// with nw_browse_result_change_interface_added and nw_browse_result_change_txt_record_changed,
    /// the caller can expect new_result to include a new interface and an updated
    /// txt record that was not present in old_result.
    ///
    ///
    /// Parameter `old_result`: The old result.
    ///
    ///
    /// Parameter `new_result`: The new result.
    ///
    ///
    /// Returns: A nw_browse_result_change_t describing all changes that occurred.
    #[doc(alias = "nw_browse_result_get_changes")]
    #[inline]
    pub fn changes(
        old_result: Option<&NWBrowseResult>,
        new_result: Option<&NWBrowseResult>,
    ) -> nw_browse_result_change_t {
        extern "C-unwind" {
            fn nw_browse_result_get_changes(
                old_result: Option<&NWBrowseResult>,
                new_result: Option<&NWBrowseResult>,
            ) -> nw_browse_result_change_t;
        }
        unsafe { nw_browse_result_get_changes(old_result, new_result) }
    }

    /// Returns the number of interfaces on this browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: The number of interfaces available.
    #[doc(alias = "nw_browse_result_get_interfaces_count")]
    #[inline]
    pub fn interfaces_count(&self) -> usize {
        extern "C-unwind" {
            fn nw_browse_result_get_interfaces_count(result: &NWBrowseResult) -> usize;
        }
        unsafe { nw_browse_result_get_interfaces_count(self) }
    }

    /// Copies the TXT record object from the browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Returns: A copy of the TXT record object, or NULL if the browse result does not
    /// have an associated TXT record.
    #[doc(alias = "nw_browse_result_copy_txt_record_object")]
    #[inline]
    pub fn txt_record_object(&self) -> Option<NWRetained<NWTxtRecord>> {
        extern "C-unwind" {
            fn nw_browse_result_copy_txt_record_object(
                result: &NWBrowseResult,
            ) -> Option<NonNull<NWTxtRecord>>;
        }
        let ret = unsafe { nw_browse_result_copy_txt_record_object(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

/// A block that can be applied to every interface in the browse result.
///
///
/// Parameter `interface`: The interface object.
///
///
/// Returns: A boolean value that indicating if enumeration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browse_result_enumerate_interface_t?language=objc)
pub type nw_browse_result_enumerate_interface_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWInterface>) -> bool>;

impl NWBrowseResult {
    /// Enumerates the list of interfaces on this browse result.
    ///
    ///
    /// Parameter `result`: The browse result object.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_browse_result_enumerate_interfaces")]
    #[inline]
    pub unsafe fn enumerate_interfaces(&self, enumerator: nw_browse_result_enumerate_interface_t) {
        extern "C-unwind" {
            fn nw_browse_result_enumerate_interfaces(
                result: &NWBrowseResult,
                enumerator: nw_browse_result_enumerate_interface_t,
            );
        }
        unsafe { nw_browse_result_enumerate_interfaces(self, enumerator) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwerror?language=objc)
#[doc(alias = "nw_error_t")]
#[repr(C)]
pub struct NWError {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWError {}
);

/// The enumeration of network error domains.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_error_domain_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_error_domain_t(pub c_uint);
impl nw_error_domain_t {
    #[doc(alias = "nw_error_domain_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_error_domain_posix")]
    pub const posix: Self = Self(1);
    #[doc(alias = "nw_error_domain_dns")]
    pub const dns: Self = Self(2);
    #[doc(alias = "nw_error_domain_tls")]
    pub const tls: Self = Self(3);
    #[doc(alias = "nw_error_domain_wifi_aware")]
    pub const wifi_aware: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_error_domain_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_error_domain_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWError {
    /// Given a reference to a nw_error, returns the error domain.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The error domain.
    #[doc(alias = "nw_error_get_error_domain")]
    #[inline]
    pub fn error_domain(&self) -> nw_error_domain_t {
        extern "C-unwind" {
            fn nw_error_get_error_domain(error: &NWError) -> nw_error_domain_t;
        }
        unsafe { nw_error_get_error_domain(self) }
    }

    /// Given a reference to a nw_error, returns the error code.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The error code.
    #[doc(alias = "nw_error_get_error_code")]
    #[inline]
    pub fn error_code(&self) -> c_int {
        extern "C-unwind" {
            fn nw_error_get_error_code(error: &NWError) -> c_int;
        }
        unsafe { nw_error_get_error_code(self) }
    }
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_posix.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomainposix?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainPOSIX: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_posix.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomaindns?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainDNS: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_tls.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomaintls?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainTLS: &'static CFString;
}

extern "C" {
    /// CFErrorRef domain corresponding to nw_error_domain_wifi_aware.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/knwerrordomainwifiaware?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kNWErrorDomainWiFiAware: &'static CFString;
}

impl NWError {
    /// Given a reference to nw_error, returns a CFErrorRef representing the same error.
    ///
    ///
    /// Parameter `error`: A reference to the nw_error.
    ///
    ///
    /// Returns: The CFErrorRef. The caller is responsible for calling CFRelease on the returned value.
    #[doc(alias = "nw_error_copy_cf_error")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn cf_error(&self) -> CFRetained<CFError> {
        extern "C-unwind" {
            fn nw_error_copy_cf_error(error: &NWError) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe { nw_error_copy_cf_error(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwbrowser?language=objc)
#[doc(alias = "nw_browser_t")]
#[repr(C)]
pub struct NWBrowser {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWBrowser {}
);

/// Browser states sent by nw_browser_set_state_changed_handler.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_browser_state_t(pub c_uint);
impl nw_browser_state_t {
    /// This state will never be delivered in the browser's state update
    /// handler and can be treated as an unexpected value.
    #[doc(alias = "nw_browser_state_invalid")]
    pub const invalid: Self = Self(0);
    /// endpoint updates. All callbacks from the browse_results_changed_handler
    /// occur when the browser is in this state.
    #[doc(alias = "nw_browser_state_ready")]
    pub const ready: Self = Self(1);
    /// You should not try to call nw_browser_start() on the browser to restart
    /// it. Instead, cancel the browser and create a new browser object.
    #[doc(alias = "nw_browser_state_failed")]
    pub const failed: Self = Self(2);
    /// the caller. You should not try to call nw_browser_start() on the
    /// browser to restart it. Instead, create a new browser object.
    #[doc(alias = "nw_browser_state_cancelled")]
    pub const cancelled: Self = Self(3);
    /// Results will not be delivered until the browser moves into the ready
    /// state. A browser can move from the ready state into the waiting state.
    /// The associated error indicates why the browser is unable to browse.
    #[doc(alias = "nw_browser_state_waiting")]
    pub const waiting: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_browser_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_browser_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWBrowser {
    /// Creates a new browser object, which can be used to browse for results
    /// matching a browse descriptor.
    ///
    ///
    /// Parameter `descriptor`: A browse descriptor object that describes the type of service for which
    /// to browse.
    ///
    ///
    /// Parameter `parameters`: Optional parameters to use for the new browser. If NULL, an empty parameters
    /// object is created internally.
    ///
    ///
    /// Returns: An instantiated browser object.
    #[doc(alias = "nw_browser_create")]
    #[inline]
    pub fn new(
        descriptor: &NWBrowseDescriptor,
        parameters: Option<&NWParameters>,
    ) -> NWRetained<NWBrowser> {
        extern "C-unwind" {
            fn nw_browser_create(
                descriptor: &NWBrowseDescriptor,
                parameters: Option<&NWParameters>,
            ) -> Option<NonNull<NWBrowser>>;
        }
        let ret = unsafe { nw_browser_create(descriptor, parameters) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_browser_start().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `queue`: The client's callback queue.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "nw_browser_set_queue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_browser_set_queue(browser: &NWBrowser, queue: &DispatchQueue);
        }
        unsafe { nw_browser_set_queue(self, queue) }
    }
}

/// A block called to notify the user of any browse results that changed. To get
/// the specific list of changes that occurred, call nw_browse_result_get_changes()
/// with the old and new result.
///
///
/// Parameter `old_result`: The old value of the browse result. This value was previously provided to
/// an invocation of the browse_results_changed_handler().
///
///
/// Parameter `new_result`: The new value of the browse result. This is a new instance of the result
/// and replaces old_result.
///
///
/// Parameter `batch_complete`: A flag indicating if this is the last change in this batch. If
/// batch_complete is true, the browser has no more immediate changes to
/// report to the user, who should perform any pending UI updates. If
/// batch_complete is false, the browser has more updates queued, which will
/// be delivered in subsequent invocations of the browse_results_changed_handler().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_browse_results_changed_handler_t?language=objc)
pub type nw_browser_browse_results_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWBrowseResult>, NonNull<NWBrowseResult>, bool)>;

impl NWBrowser {
    /// Sets a callback handler to be invoked when the browser gets an update
    /// for changed browse results. This function must be called before starting
    /// the browser and must not be called after starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `handler`: The callback handler that fires when the browser gets an update for a
    /// changed browse result.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_browser_set_browse_results_changed_handler")]
    #[inline]
    pub unsafe fn set_browse_results_changed_handler(
        &self,
        handler: nw_browser_browse_results_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_browser_set_browse_results_changed_handler(
                browser: &NWBrowser,
                handler: nw_browser_browse_results_changed_handler_t,
            );
        }
        unsafe { nw_browser_set_browse_results_changed_handler(self, handler) }
    }
}

/// A block called when the browser changes state.
///
///
/// Parameter `state`: The new state of the browser.
///
///
/// Parameter `error`: An optional error that is associated with the new state. For example, if the
/// browser encounters a DNS error, the callback will pass nw_browser_state_failed
/// as the new state and the DNS error as the error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_browser_state_changed_handler_t?language=objc)
pub type nw_browser_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_browser_state_t, *mut NWError)>;

impl NWBrowser {
    /// Sets the state changed handler. For clients that need to perform cleanup
    /// when the browser has been cancelled, the nw_browser_state_cancelled state
    /// will be delivered last. This function must be called before starting the
    /// browser and must not be called after starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Parameter `state_changed_handler`: The state changed handler to call when the browser state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `state_changed_handler` must be a valid pointer or null.
    #[doc(alias = "nw_browser_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(
        &self,
        state_changed_handler: nw_browser_state_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_browser_set_state_changed_handler(
                browser: &NWBrowser,
                state_changed_handler: nw_browser_state_changed_handler_t,
            );
        }
        unsafe { nw_browser_set_state_changed_handler(self, state_changed_handler) }
    }

    /// Starts the browser, which begins browsing for available endpoints.
    /// You must call nw_browser_set_queue() before starting the browser.
    ///
    ///
    /// Parameter `browser`: The browser object.
    #[doc(alias = "nw_browser_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_browser_start(browser: &NWBrowser);
        }
        unsafe { nw_browser_start(self) }
    }

    /// Cancels the browser. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller
    /// will be a state update with a value of nw_browser_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated
    /// memory or objects.
    ///
    ///
    /// Parameter `browser`: The browser object.
    #[doc(alias = "nw_browser_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_browser_cancel(browser: &NWBrowser);
        }
        unsafe { nw_browser_cancel(self) }
    }

    /// Returns a copy of the parameters passed to nw_browser_create().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Returns: Returns an nw_parameters_t object.
    #[doc(alias = "nw_browser_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_browser_copy_parameters(browser: &NWBrowser) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_browser_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns a copy of the browse_descriptor passed to nw_browser_create().
    ///
    ///
    /// Parameter `browser`: The browser object.
    ///
    ///
    /// Returns: Returns a copy of the browse_descriptor passed to nw_browser_create().
    #[doc(alias = "nw_browser_copy_browse_descriptor")]
    #[inline]
    pub fn browse_descriptor(&self) -> NWRetained<NWBrowseDescriptor> {
        extern "C-unwind" {
            fn nw_browser_copy_browse_descriptor(
                browser: &NWBrowser,
            ) -> Option<NonNull<NWBrowseDescriptor>>;
        }
        let ret = unsafe { nw_browser_copy_browse_descriptor(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwpath?language=objc)
#[doc(alias = "nw_path_t")]
#[repr(C)]
pub struct NWPath {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWPath {}
);

/// A network path status indicates if there is a usable route available upon which to
/// send and receive data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_status_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_path_status_t(pub c_uint);
impl nw_path_status_t {
    #[doc(alias = "nw_path_status_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_path_status_satisfied")]
    pub const satisfied: Self = Self(1);
    #[doc(alias = "nw_path_status_unsatisfied")]
    pub const unsatisfied: Self = Self(2);
    #[doc(alias = "nw_path_status_satisfiable")]
    pub const satisfiable: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_path_status_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_path_status_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWPath {
    /// Retrieves the status of a path. The status of a specific path object will never
    /// change, as the path object itself is static. If there is a network change, the
    /// object that generated the path object will generate a new path object.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns the status of the path, or nw_path_status_invalid if the object is NULL.
    #[doc(alias = "nw_path_get_status")]
    #[inline]
    pub fn status(&self) -> nw_path_status_t {
        extern "C-unwind" {
            fn nw_path_get_status(path: &NWPath) -> nw_path_status_t;
        }
        unsafe { nw_path_get_status(self) }
    }
}

/// A network path unsatisfied reason may indicate the reason the path is currently unsatisfied for some conditions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_unsatisfied_reason_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_path_unsatisfied_reason_t(pub c_uint);
impl nw_path_unsatisfied_reason_t {
    #[doc(alias = "nw_path_unsatisfied_reason_not_available")]
    pub const not_available: Self = Self(0);
    #[doc(alias = "nw_path_unsatisfied_reason_cellular_denied")]
    pub const cellular_denied: Self = Self(1);
    #[doc(alias = "nw_path_unsatisfied_reason_wifi_denied")]
    pub const wifi_denied: Self = Self(2);
    #[doc(alias = "nw_path_unsatisfied_reason_local_network_denied")]
    pub const local_network_denied: Self = Self(3);
    #[doc(alias = "nw_path_unsatisfied_reason_vpn_inactive")]
    pub const vpn_inactive: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_path_unsatisfied_reason_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_path_unsatisfied_reason_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWPath {
    /// Retrieves a reason the path is not satisfied. In some cases, the reason helps to
    /// determine why the path is not satisfied. While the path may be unsatisfied for more
    /// than one reason, only the first reason will be given. In many cases, the path may be
    /// unsatisfied with no reason available.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns a reason the path is unsatisfied or nw_path_unsatisfied_reason_not_available if a reason is not available.
    #[doc(alias = "nw_path_get_unsatisfied_reason")]
    #[inline]
    pub fn unsatisfied_reason(&self) -> nw_path_unsatisfied_reason_t {
        extern "C-unwind" {
            fn nw_path_get_unsatisfied_reason(path: &NWPath) -> nw_path_unsatisfied_reason_t;
        }
        unsafe { nw_path_get_unsatisfied_reason(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_enumerate_interfaces_block_t?language=objc)
pub type nw_path_enumerate_interfaces_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWInterface>) -> bool>;

impl NWPath {
    /// List all interfaces associated with the path.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block that will return the interfaces associated with the path. Returning
    /// true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_path_enumerate_interfaces")]
    #[inline]
    pub unsafe fn enumerate_interfaces(
        &self,
        enumerate_block: nw_path_enumerate_interfaces_block_t,
    ) {
        extern "C-unwind" {
            fn nw_path_enumerate_interfaces(
                path: &NWPath,
                enumerate_block: nw_path_enumerate_interfaces_block_t,
            );
        }
        unsafe { nw_path_enumerate_interfaces(self, enumerate_block) }
    }

    /// Compares two network path objects and checks if their content is equal.
    /// If they are not equal, they represent two different network states.
    ///
    ///
    /// Parameter `path`: The first path object to compare.
    ///
    ///
    /// Parameter `other_path`: The second path object to compare.
    ///
    ///
    /// Returns: Returns true if the paths are equivalent, or false if there is any difference
    /// between the paths.
    #[doc(alias = "nw_path_is_equal")]
    #[inline]
    pub fn is_equal(&self, other_path: &NWPath) -> bool {
        extern "C-unwind" {
            fn nw_path_is_equal(path: &NWPath, other_path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_equal(self, other_path) }
    }

    /// Checks if the path uses any network interfaces that are considered expensive
    /// to the user, such as, but not limited to, a cellular network.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered expensive,
    /// false otherwise.
    #[doc(alias = "nw_path_is_expensive")]
    #[inline]
    pub fn is_expensive(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_is_expensive(path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_expensive(self) }
    }

    /// Checks if the path uses any network interfaces that are considered constrained
    /// to the user.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered constrained,
    /// false otherwise.
    #[doc(alias = "nw_path_is_constrained")]
    #[inline]
    pub fn is_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_is_constrained(path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_constrained(self) }
    }

    /// Checks if the path uses any network interfaces that are considered ultra-constrained.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface that is considered ultra-constrained,
    /// false otherwise.
    #[doc(alias = "nw_path_is_ultra_constrained")]
    #[inline]
    pub fn is_ultra_constrained(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_is_ultra_constrained(path: &NWPath) -> bool;
        }
        unsafe { nw_path_is_ultra_constrained(self) }
    }

    /// Checks if the path uses a network interface that supports IPv4 connectivity.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses a network interface that supports IPv4,
    /// false otherwise.
    #[doc(alias = "nw_path_has_ipv4")]
    #[inline]
    pub fn has_ipv4(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_has_ipv4(path: &NWPath) -> bool;
        }
        unsafe { nw_path_has_ipv4(self) }
    }

    /// Checks if the path uses a network interface that supports IPv6 connectivity.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses a network interface that supports IPv6,
    /// false otherwise.
    #[doc(alias = "nw_path_has_ipv6")]
    #[inline]
    pub fn has_ipv6(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_has_ipv6(path: &NWPath) -> bool;
        }
        unsafe { nw_path_has_ipv6(self) }
    }

    /// Checks if the path has a DNS server configuration set.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path has a DNS server configuration set,
    /// false otherwise.
    #[doc(alias = "nw_path_has_dns")]
    #[inline]
    pub fn has_dns(&self) -> bool {
        extern "C-unwind" {
            fn nw_path_has_dns(path: &NWPath) -> bool;
        }
        unsafe { nw_path_has_dns(self) }
    }

    /// Checks if the path uses a network interface with the specified type.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns true if the path uses any network interface with the specified type,
    /// false otherwise.
    #[doc(alias = "nw_path_uses_interface_type")]
    #[inline]
    pub fn uses_interface_type(&self, interface_type: nw_interface_type_t) -> bool {
        extern "C-unwind" {
            fn nw_path_uses_interface_type(
                path: &NWPath,
                interface_type: nw_interface_type_t,
            ) -> bool;
        }
        unsafe { nw_path_uses_interface_type(self, interface_type) }
    }

    /// Retrieve the local endpoint that is being used, if present. If this path
    /// is the path from an nw_connection_t, it represents the address that data
    /// is sent from.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns an endpoint that is assigned as the local endpoint for this path,
    /// or NULL if the path does not have a fixed local endpoint.
    #[doc(alias = "nw_path_copy_effective_local_endpoint")]
    #[inline]
    pub fn effective_local_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_path_copy_effective_local_endpoint(path: &NWPath) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_path_copy_effective_local_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Retrieve the remote endpoint that is being used, if present. If this path
    /// is the path from an nw_connection_t, it represents the address that data
    /// is sent to.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns an endpoint that is assigned as the remote endpoint for this path,
    /// or NULL if the path does not have a fixed remote endpoint.
    #[doc(alias = "nw_path_copy_effective_remote_endpoint")]
    #[inline]
    pub fn effective_remote_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_path_copy_effective_remote_endpoint(path: &NWPath)
                -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_path_copy_effective_remote_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_enumerate_gateways_block_t?language=objc)
pub type nw_path_enumerate_gateways_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWEndpoint>) -> bool>;

impl NWPath {
    /// List the IP addresses of the routers acting as the gateways for the path.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block that will return the gateways associated with the path. Returning
    /// true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_path_enumerate_gateways")]
    #[inline]
    pub unsafe fn enumerate_gateways(&self, enumerate_block: nw_path_enumerate_gateways_block_t) {
        extern "C-unwind" {
            fn nw_path_enumerate_gateways(
                path: &NWPath,
                enumerate_block: nw_path_enumerate_gateways_block_t,
            );
        }
        unsafe { nw_path_enumerate_gateways(self, enumerate_block) }
    }
}

/// Link quality measurement is a representation of the expected capabilities of the link layer network
/// attachment. Use this value to tune initial values for algorithms that can scale with the
/// capabilities of the network. Do not use this value to gate connection attempts or to override
/// adjustments that would be made based on actual network performance.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_link_quality_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_link_quality_t(pub c_uint);
impl nw_link_quality_t {
    #[doc(alias = "nw_link_quality_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_link_quality_minimal")]
    pub const minimal: Self = Self(10);
    #[doc(alias = "nw_link_quality_moderate")]
    pub const moderate: Self = Self(20);
    #[doc(alias = "nw_link_quality_good")]
    pub const good: Self = Self(30);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_link_quality_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_link_quality_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWPath {
    /// Fetches the link quality measurement for the interface.
    /// Link quality measurement is a representation of the expected capabilities of the link layer network
    /// attachment. Use this value to tune initial values for algorithms that can scale with the
    /// capabilities of the network. Do not use this value to gate connection attempts or to override
    /// adjustments that would be made based on actual network performance.
    ///
    ///
    /// Parameter `path`: The path object to check.
    ///
    ///
    /// Returns: Returns the link quality measurement of the link layer network attachment.
    /// Returns nw_link_quality_unknown if there is no measurement available.
    #[doc(alias = "nw_path_get_link_quality")]
    #[inline]
    pub fn link_quality(&self) -> nw_link_quality_t {
        extern "C-unwind" {
            fn nw_path_get_link_quality(path: &NWPath) -> nw_link_quality_t;
        }
        unsafe { nw_path_get_link_quality(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwcontentcontext?language=objc)
#[doc(alias = "nw_content_context_t")]
#[repr(C)]
pub struct NWContentContext {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWContentContext {}
);

impl NWContentContext {
    /// Create a context object to represent properties associated with
    /// networking content. If the same context object is associated with multiple
    /// content blobs, then those pieces of content will be considered to be continuations
    /// of the same message.
    ///
    /// Parameter `context_identifier`: A string description of the context
    ///
    /// Returns: Returns a new context context object
    #[doc(alias = "nw_content_context_create")]
    #[inline]
    pub fn new(context_identifier: &CStr) -> NWRetained<NWContentContext> {
        extern "C-unwind" {
            fn nw_content_context_create(
                context_identifier: NonNull<c_char>,
            ) -> Option<NonNull<NWContentContext>>;
        }
        let ret = unsafe {
            nw_content_context_create(NonNull::new(context_identifier.as_ptr().cast_mut()).unwrap())
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the identifier description.
    ///
    /// Returns: Returns the context's identifier string.
    #[doc(alias = "nw_content_context_get_identifier")]
    #[inline]
    pub fn identifier(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_content_context_get_identifier(
                context: &NWContentContext,
            ) -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_content_context_get_identifier(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Check if this is the final context for a connection. When receiving,
    /// once a final context is complete, the connection is "read closed" and will not
    /// receive more content. See nw_content_context_set_is_final() for a description
    /// of how to set is_final for sending contexts.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns true if the context is the final context for a connection.
    #[doc(alias = "nw_content_context_get_is_final")]
    #[inline]
    pub fn is_final(&self) -> bool {
        extern "C-unwind" {
            fn nw_content_context_get_is_final(context: &NWContentContext) -> bool;
        }
        unsafe { nw_content_context_get_is_final(self) }
    }

    /// Mark whether or not this context is the final context for a
    /// connection. When sending, marking a context as final will perform
    /// a "write close" once the context is complete, indicating that no more content
    /// will be sent. As a convenience for sending a final context, use
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `is_final`: If set to true, mark the context as the final context to send on a connection.
    #[doc(alias = "nw_content_context_set_is_final")]
    #[inline]
    pub fn set_is_final(&self, is_final: bool) {
        extern "C-unwind" {
            fn nw_content_context_set_is_final(context: &NWContentContext, is_final: bool);
        }
        unsafe { nw_content_context_set_is_final(self, is_final) }
    }

    /// Retrieve the number of milliseconds after which the content will expire.
    /// See nw_content_context_set_expiration_milliseconds for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns content expiration, or 0 if not set.
    #[doc(alias = "nw_content_context_get_expiration_milliseconds")]
    #[inline]
    pub fn expiration_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_content_context_get_expiration_milliseconds(context: &NWContentContext) -> u64;
        }
        unsafe { nw_content_context_get_expiration_milliseconds(self) }
    }

    /// Set an expiration (in milliseconds) after which content may be dropped.
    /// If the expiration time is reached, the content may not be sent. If the value is
    /// 0, there is no expiration for the content. The expiration timer starts when the
    /// content is enqueued using nw_connection_send().
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `expiration_milliseconds`: The number of milliseconds after which content will expire
    #[doc(alias = "nw_content_context_set_expiration_milliseconds")]
    #[inline]
    pub fn set_expiration_milliseconds(&self, expiration_milliseconds: u64) {
        extern "C-unwind" {
            fn nw_content_context_set_expiration_milliseconds(
                context: &NWContentContext,
                expiration_milliseconds: u64,
            );
        }
        unsafe { nw_content_context_set_expiration_milliseconds(self, expiration_milliseconds) }
    }

    /// Get the relative priority for the content. See
    /// nw_content_context_set_relative_priority for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns the relative priority, between 0.0 (lowest priority)
    /// to 1.0 (highest priority). The default value is 0.5.
    #[doc(alias = "nw_content_context_get_relative_priority")]
    #[inline]
    pub fn relative_priority(&self) -> c_double {
        extern "C-unwind" {
            fn nw_content_context_get_relative_priority(context: &NWContentContext) -> c_double;
        }
        unsafe { nw_content_context_get_relative_priority(self) }
    }

    /// Set A relative priority of the content, compared to other
    /// content on the same connection. Priorities range from 0.0 (lowest
    /// priority) to 1.0 (highest priority), where content with higher
    /// priority will scheduled first if all else is equal.
    /// The default value is 0.5.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `relative_priority`: The relative priority of the content, between
    /// 0.0 (lowest priority) to 1.0 (highest priority).
    #[doc(alias = "nw_content_context_set_relative_priority")]
    #[inline]
    pub fn set_relative_priority(&self, relative_priority: c_double) {
        extern "C-unwind" {
            fn nw_content_context_set_relative_priority(
                context: &NWContentContext,
                relative_priority: c_double,
            );
        }
        unsafe { nw_content_context_set_relative_priority(self, relative_priority) }
    }

    /// Set a context as an antecedent to this content context.
    /// The associated content will not be sent until all of its antecedents have been
    /// completed. If any of the antecedents fail with an error, this content will
    /// fail as well.
    ///
    /// Parameter `context`: The context object
    ///
    /// Parameter `antecedent_context`: A context associated with content that should precede
    /// this content.
    #[doc(alias = "nw_content_context_set_antecedent")]
    #[inline]
    pub fn set_antecedent(&self, antecedent_context: Option<&NWContentContext>) {
        extern "C-unwind" {
            fn nw_content_context_set_antecedent(
                context: &NWContentContext,
                antecedent_context: Option<&NWContentContext>,
            );
        }
        unsafe { nw_content_context_set_antecedent(self, antecedent_context) }
    }

    /// Copy the optional content context that must be sent prior to this
    /// content. See nw_content_context_set_antecedent for further discussion.
    ///
    /// Parameter `context`: The context object
    ///
    /// Returns: Returns a context object set as the antecedent, or NULL.
    #[doc(alias = "nw_content_context_copy_antecedent")]
    #[inline]
    pub fn antecedent(&self) -> Option<NWRetained<NWContentContext>> {
        extern "C-unwind" {
            fn nw_content_context_copy_antecedent(
                context: &NWContentContext,
            ) -> Option<NonNull<NWContentContext>>;
        }
        let ret = unsafe { nw_content_context_copy_antecedent(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Set protocol-specific metadata to a parent content context. If
    /// metadata for the same protocol is set multiple times, the most recently
    /// set metadata will be applied.
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `protocol_metadata`: The per-protocol metadata context object to set
    #[doc(alias = "nw_content_context_set_metadata_for_protocol")]
    #[inline]
    pub fn set_metadata_for_protocol(&self, protocol_metadata: &NWProtocolMetadata) {
        extern "C-unwind" {
            fn nw_content_context_set_metadata_for_protocol(
                context: &NWContentContext,
                protocol_metadata: &NWProtocolMetadata,
            );
        }
        unsafe { nw_content_context_set_metadata_for_protocol(self, protocol_metadata) }
    }

    /// Copy the per-protocol metadata from a parent content context
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `protocol`: The definition identifier of the protocol to retrieve metadata for
    ///
    /// Returns: Returns the metadata registered for the protocol, or NULL if there is none
    #[doc(alias = "nw_content_context_copy_protocol_metadata")]
    #[inline]
    pub fn protocol_metadata(
        &self,
        protocol: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_content_context_copy_protocol_metadata(
                context: &NWContentContext,
                protocol: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_content_context_copy_protocol_metadata(self, protocol) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Access all per-protocol metadata objects from a parent content context
    ///
    /// Parameter `context`: The context context parent object
    ///
    /// Parameter `foreach_block`: A block in which protocol definition and metadata will be sent
    #[doc(alias = "nw_content_context_foreach_protocol_metadata")]
    #[inline]
    pub fn foreach_protocol_metadata(
        &self,
        foreach_block: &block2::DynBlock<
            dyn Fn(NonNull<NWProtocolDefinition>, NonNull<NWProtocolMetadata>),
        >,
    ) {
        extern "C-unwind" {
            fn nw_content_context_foreach_protocol_metadata(
                context: &NWContentContext,
                foreach_block: &block2::DynBlock<
                    dyn Fn(NonNull<NWProtocolDefinition>, NonNull<NWProtocolMetadata>),
                >,
            );
        }
        unsafe { nw_content_context_foreach_protocol_metadata(self, foreach_block) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwconnection?language=objc)
#[doc(alias = "nw_connection_t")]
#[repr(C)]
pub struct NWConnection {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWConnection {}
);

/// Connection states sent by nw_connection_set_state_changed_handler.
/// States generally progress forward and do not move backwards, with the
/// exception of preparing and waiting, which may alternate before the connection
/// becomes ready or failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_connection_state_t(pub c_uint);
impl nw_connection_state_t {
    /// will never be delivered in the connection's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_connection_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_connection_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_connection_state_preparing")]
    pub const preparing: Self = Self(2);
    #[doc(alias = "nw_connection_state_ready")]
    pub const ready: Self = Self(3);
    #[doc(alias = "nw_connection_state_failed")]
    pub const failed: Self = Self(4);
    #[doc(alias = "nw_connection_state_cancelled")]
    pub const cancelled: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_connection_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_connection_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWConnection {
    /// Creates a networking connection to an endpoint.
    ///
    ///
    /// Parameter `endpoint`: The remote endpoint to connect to.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the connection. The data mode,
    /// either datagram or stream, must be set.
    ///
    ///
    /// Returns: Returns an allocated nw_connection_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_create")]
    #[inline]
    pub fn new(endpoint: &NWEndpoint, parameters: &NWParameters) -> NWRetained<NWConnection> {
        extern "C-unwind" {
            fn nw_connection_create(
                endpoint: &NWEndpoint,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWConnection>>;
        }
        let ret = unsafe { nw_connection_create(endpoint, parameters) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the remote endpoint for a connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns an nw_endpoint_t object on success.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_copy_endpoint")]
    #[inline]
    pub fn endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_connection_copy_endpoint(
                connection: &NWConnection,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_connection_copy_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieves the parameters for a connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns an nw_parameters_t object on success.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_connection_copy_parameters(
                connection: &NWConnection,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_connection_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_state_changed_handler_t?language=objc)
pub type nw_connection_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_connection_state_t, *mut NWError)>;

impl NWConnection {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// connection has been cancelled, the nw_connection_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the connection state changes.
    /// Pass NULL to remove the state changed handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(&self, handler: nw_connection_state_changed_handler_t) {
        extern "C-unwind" {
            fn nw_connection_set_state_changed_handler(
                connection: &NWConnection,
                handler: nw_connection_state_changed_handler_t,
            );
        }
        unsafe { nw_connection_set_state_changed_handler(self, handler) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_boolean_event_handler_t?language=objc)
pub type nw_connection_boolean_event_handler_t = *mut block2::DynBlock<dyn Fn(bool)>;

impl NWConnection {
    /// Define a callback to be fired when the viability of the connection changes.
    /// This indicates whether or not read and write calls will succeed on a ready
    /// connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the connection viability changes. The value will
    /// be true when the connection is viable, and false otherwise.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_viability_changed_handler")]
    #[inline]
    pub unsafe fn set_viability_changed_handler(
        &self,
        handler: nw_connection_boolean_event_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_set_viability_changed_handler(
                connection: &NWConnection,
                handler: nw_connection_boolean_event_handler_t,
            );
        }
        unsafe { nw_connection_set_viability_changed_handler(self, handler) }
    }

    /// Define a callback to be fired when a better path is available or not.
    /// This indicates whether or not a preferred path is available for the
    /// connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the better path availability changes. The value
    /// will be true when a better path is available, and false otherwise.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_better_path_available_handler")]
    #[inline]
    pub unsafe fn set_better_path_available_handler(
        &self,
        handler: nw_connection_boolean_event_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_set_better_path_available_handler(
                connection: &NWConnection,
                handler: nw_connection_boolean_event_handler_t,
            );
        }
        unsafe { nw_connection_set_better_path_available_handler(self, handler) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_path_event_handler_t?language=objc)
pub type nw_connection_path_event_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWPath>)>;

impl NWConnection {
    /// Define a callback to be fired when the connection's path changes.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the connection's path changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_set_path_changed_handler")]
    #[inline]
    pub unsafe fn set_path_changed_handler(&self, handler: nw_connection_path_event_handler_t) {
        extern "C-unwind" {
            fn nw_connection_set_path_changed_handler(
                connection: &NWConnection,
                handler: nw_connection_path_event_handler_t,
            );
        }
        unsafe { nw_connection_set_path_changed_handler(self, handler) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_connection_start().
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "nw_connection_set_queue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_connection_set_queue(connection: &NWConnection, queue: &DispatchQueue);
        }
        unsafe { nw_connection_set_queue(self, queue) }
    }

    /// Starts the connection, which will cause the connection
    /// to evaluate its path, do resolution, and try to become
    /// readable and writable. Once started, a connection
    /// must be cancelled using nw_connection_cancel() or
    /// nw_connection_force_cancel() when it is no longer needed.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_connection_start(connection: &NWConnection);
        }
        unsafe { nw_connection_start(self) }
    }

    /// Connections in the waiting state will normally re-attempt
    /// on network changes. Call nw_connection_restart() to force
    /// a connection in the waiting state to retry connection
    /// establishment even without a network change. Calls to restart
    /// for connections that are not in the waiting state will be
    /// ignored.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_restart")]
    #[inline]
    pub fn restart(&self) {
        extern "C-unwind" {
            fn nw_connection_restart(connection: &NWConnection);
        }
        unsafe { nw_connection_restart(self) }
    }

    /// Cancel the connection. This will close the connection, and negotiate over the network
    /// if applicable for the protocol. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller will be a state
    /// update with a value of nw_connection_state_cancelled. Once this update is delivered, the
    /// caller may clean up any associated memory or objects.
    ///
    /// Outstanding sends and receives will receive errors before the state changes to cancelled.
    /// There is no guarantee that any outstanding sends that have not yet delivered send completion handlers
    /// will send data before the connection is closed.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_connection_cancel(connection: &NWConnection);
        }
        unsafe { nw_connection_cancel(self) }
    }

    /// A variant of nw_connection_cancel() that indicates that the protocol stack should
    /// not close gracefully, but close as quickly as possible without negotiation. For example,
    /// a force close would lead to TCP RST packets being sent, as opposed to negotiating with
    /// FIN packets.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_force_cancel")]
    #[inline]
    pub fn force_cancel(&self) {
        extern "C-unwind" {
            fn nw_connection_force_cancel(connection: &NWConnection);
        }
        unsafe { nw_connection_force_cancel(self) }
    }

    /// Cancel the currently connected endpoint, causing the connection
    /// to fall through to the next endpoint if available, or fail if no
    /// more endpoints are available. This is primarily useful for connections
    /// which do not have reliable handshakes, such as UDP. If data is sent
    /// on the connection with no response, canceling the current endpoint
    /// will allow another address or interface to be attempted.
    ///
    ///
    /// Parameter `connection`: The connection object.
    #[doc(alias = "nw_connection_cancel_current_endpoint")]
    #[inline]
    pub fn cancel_current_endpoint(&self) {
        extern "C-unwind" {
            fn nw_connection_cancel_current_endpoint(connection: &NWConnection);
        }
        unsafe { nw_connection_cancel_current_endpoint(self) }
    }
}

/// A receive completion is invoked exactly once for a call to nw_connection_receive().
/// The completion indicates that the requested content has been received (in which case
/// the content is delivered), or else an error has occurred.
///
///
/// Parameter `content`: The received content, which has a length constrained by the call to nw_connection_receive().
/// The content may be NULL in two cases: (1) the receive context (logical message) is now complete,
/// and the callback is only delivering the completed event; or, (2) the connection encountered
/// an error and there is no data to deliver. Note that the content may be non-NULL even in the
/// case of an error if there was some data received before the error was encountered. The caller
/// should process all content it receives, and not necessarily ignore data in case of errors.
///
///
/// Parameter `context`: The context (logical message) associated with the received content. This includes protocol metadata
/// that lets the caller introspect information about the received content (such as flags on an IP packet).
/// When the message has been completely received, the context will be delivered along with the
/// is_complete flag.
///
/// For datagram protocols such as UDP, the context represents the properties of a single received
/// datagram.
///
/// For protocols that only have a single context for the entire connection, such as stream protocols
/// like TCP, the context will be marked as "final", which can be accessed with
/// nw_content_context_get_is_final(). Once a final context is marked as complete, the recipient
/// may assume that the connection has been closed in the receiving direction (a "read close"). For
/// TCP, this represents receiving a FIN.
///
///
/// Parameter `is_complete`: An indication that this context (logical message) is now complete. Until this flag is
/// set, the recipient should assume that there may be more bytes to read for this context.
/// Note that even when reading datagrams, as from UDP, the context may be read in multiple
/// chunks if the maximum_length was smaller than the full length of the message.
///
/// If is_complete is marked and the received context is the final context for connection,
/// the caller may assume that the connection has been closed in the receiving direction.
///
///
/// Parameter `error`: An error will be sent if an error was encountered while trying to receive on the connection.
/// There may still be content delivered along with the error, but this content may be shorter
/// than the requested ranges. An error will be sent for any outstanding receive calls when the
/// connection is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_receive_completion_t?language=objc)
#[cfg(feature = "dispatch2")]
pub type nw_connection_receive_completion_t =
    *mut block2::DynBlock<dyn Fn(*mut DispatchData, *mut NWContentContext, bool, *mut NWError)>;

impl NWConnection {
    /// Receive data from a connection. This may be called before the connection
    /// is ready, in which case the receive request will be queued until the
    /// connection is ready. The completion handler will be invoked exactly
    /// once for each call, so the client must call this function multiple
    /// times to receive multiple chunks of data. For protocols that
    /// support flow control, such as TCP, calling receive opens the receive
    /// window. If the client stops calling receive, the receive window will
    /// fill up and the remote peer will stop sending.
    ///
    ///
    /// Parameter `connection`: The connection object on which to receive data. The connection should
    /// be in the ready state.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum length to receive from the connection, until the content
    /// is complete. Content will be delivered when at least the minimum is available,
    /// or the content is complete, whichever comes first.
    ///
    ///
    /// Parameter `maximum_length`: The maximum length to receive from the connection.
    ///
    ///
    /// Parameter `completion`: A callback to be called when content has been received.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_receive")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn receive(
        &self,
        minimum_incomplete_length: u32,
        maximum_length: u32,
        completion: nw_connection_receive_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_receive(
                connection: &NWConnection,
                minimum_incomplete_length: u32,
                maximum_length: u32,
                completion: nw_connection_receive_completion_t,
            );
        }
        unsafe {
            nw_connection_receive(self, minimum_incomplete_length, maximum_length, completion)
        }
    }

    /// Receive a single atomic message from a connection. The completion
    /// handler will be invoked exactly once for each call, so the client
    /// must call this function multiple times to receive multiple messages.
    ///
    ///
    /// Parameter `connection`: The connection object on which to receive the message. The connection
    /// should be in the ready state.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the message has been received, or an error
    /// has occurred.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_receive_message")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn receive_message(&self, completion: nw_connection_receive_completion_t) {
        extern "C-unwind" {
            fn nw_connection_receive_message(
                connection: &NWConnection,
                completion: nw_connection_receive_completion_t,
            );
        }
        unsafe { nw_connection_receive_message(self, completion) }
    }
}

/// A send completion is invoked exactly once for a call to nw_connection_send().
/// The completion indicates that the sent content has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be sent if the associated content could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the connection
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_send_completion_t?language=objc)
pub type nw_connection_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_connection_send_idempotent_content?language=objc)
    pub static _nw_connection_send_idempotent_content: nw_connection_send_completion_t;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_default_message?language=objc)
    pub static _nw_content_context_default_message: &'static NWContentContext;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_final_send?language=objc)
    pub static _nw_content_context_final_send: &'static NWContentContext;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/network/_nw_content_context_default_stream?language=objc)
    pub static _nw_content_context_default_stream: &'static NWContentContext;
}

impl NWConnection {
    /// Send data on a connection. This may be called before the connection is ready,
    /// in which case the send will be enqueued until the connection is ready to send.
    /// This is an asynchronous send and the completion block can be used to
    /// determine when the send is complete. There is nothing preventing a client
    /// from issuing an excessive number of outstanding sends. To minimize memory
    /// footprint and excessive latency as a consequence of buffer bloat, it is
    /// advisable to keep a low number of outstanding sends. The completion block
    /// can be used to pace subsequent sends.
    ///
    ///
    /// Parameter `connection`: The connection object on which to send data.
    ///
    ///
    /// Parameter `content`: A data object to send. This may be NULL only if this send is marking a context
    /// (a message or complete connection) as complete in the sending direction.
    ///
    ///
    /// Parameter `context`: The context associated with the content, which represents a logical message
    /// to be sent on the connection. All content sent within a single context will
    /// be sent as an in-order unit, up until the point that the context is marked
    /// complete (see is_complete). Once a context is marked complete, it may be re-used
    /// as a new logical message. Protocols like TCP that cannot send multiple
    /// independent messages at once (serial streams) will only start processing a new
    /// context once the prior context has been marked complete.
    ///
    /// The context can hold protocol metadata to define how to send content, such
    /// as flags for IP packets.
    ///
    /// The context also can define properties that allow a message to ordered relative
    /// to other messages if multiple messages are queued. These properties include
    /// relative priority, expiration, and antecedent relationships. Some protocols
    /// support re-ordering messages within a single connection. For other protocols
    /// that do not, like TCP, these properties still take effect when enqueuing data
    /// into the stream's send buffer. The ordering of messages applies to the first
    /// calls to send on a given context.
    ///
    /// In order to close a connection on the sending side (a "write close"), send
    /// a context that is marked as "final" and mark is_complete. The convenience definition
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT may be used to define the default final context
    /// for a connection. If the caller wants to treat the entire connection as a single
    /// stream, with only one context, set NW_CONNECTION_FINAL_MESSAGE_CONTEXT for all
    /// sends; marking is_complete on the final send call will send a "write close".
    /// Using NW_CONNECTION_DEFAULT_STREAM_CONTEXT has the same behavior as sending
    /// NW_CONNECTION_FINAL_MESSAGE_CONTEXT.
    ///
    /// To send basic datagrams on a connection, use NW_CONNECTION_DEFAULT_MESSAGE_CONTEXT
    /// and pass is_complete as true for each datagram.
    ///
    /// To send data as a single stream on a connection, use NW_CONNECTION_DEFAULT_STREAM_CONTEXT
    /// and pass is_complete as true only to mark the end of the stream.
    ///
    ///
    /// Parameter `is_complete`: A flag indicating if the caller's sending context (logical message) is now complete.
    ///
    /// Until a context is marked complete, content sent for other contexts may not
    /// be sent immediately (if the protocol requires sending bytes serially, like TCP).
    ///
    /// For datagram protocols, like UDP, is_complete indicates that the content represents
    /// a complete datagram.
    ///
    /// When sending directly on streaming protocols like TCP, is_complete can be used to
    /// indicate that the connection should send a "write close" (a TCP FIN) if the sending
    /// context is the final context on the connection. Specifically, to send a "write close",
    /// pass NW_CONNECTION_FINAL_MESSAGE_CONTEXT or NW_CONNECTION_DEFAULT_STREAM_CONTEXT for the
    /// context (or create a custom context and set nw_content_context_set_is_final()), and pass
    /// true for is_complete.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the data has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has either been sent or it has been
    /// enqueued to be sent.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_send")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn send(
        &self,
        content: Option<&DispatchData>,
        context: &NWContentContext,
        is_complete: bool,
        completion: nw_connection_send_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_send(
                connection: &NWConnection,
                content: Option<&DispatchData>,
                context: &NWContentContext,
                is_complete: bool,
                completion: nw_connection_send_completion_t,
            );
        }
        unsafe { nw_connection_send(self, content, context, is_complete, completion) }
    }

    /// Batch several send and/or receive operations together, to hint to
    /// the connection that multiple send or receive operations are expected
    /// in quick succession.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `batch_block`: The batch block will be invoked immediately upon calling this function.
    /// The client may call nw_connection_send() or nw_connection_receive()
    /// multiple times within the block, and the connection will attempt to
    /// batch these operations when the block returns.
    ///
    /// # Safety
    ///
    /// `batch_block` must be a valid pointer.
    #[doc(alias = "nw_connection_batch")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn batch(&self, batch_block: dispatch_block_t) {
        extern "C-unwind" {
            fn nw_connection_batch(connection: &NWConnection, batch_block: dispatch_block_t);
        }
        unsafe { nw_connection_batch(self, batch_block) }
    }

    /// Copy a human-readable description of the connection.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a human-readable string description of the connection.
    /// The caller must call free() on the string.
    #[doc(alias = "nw_connection_copy_description")]
    #[inline]
    pub fn description(&self) -> NonNull<c_char> {
        extern "C-unwind" {
            fn nw_connection_copy_description(connection: &NWConnection)
                -> Option<NonNull<c_char>>;
        }
        let ret = unsafe { nw_connection_copy_description(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Copy the current path for a connection. If a connection is
    /// established, this will reflect the connected path.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a retained path object, or NULL if the connection
    /// has not been started or has been cancelled.
    #[doc(alias = "nw_connection_copy_current_path")]
    #[inline]
    pub fn current_path(&self) -> Option<NWRetained<NWPath>> {
        extern "C-unwind" {
            fn nw_connection_copy_current_path(
                connection: &NWConnection,
            ) -> Option<NonNull<NWPath>>;
        }
        let ret = unsafe { nw_connection_copy_current_path(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the connection-wide metadata for a specific protocol.
    /// This allows the caller to introspect per-protocol state,
    /// only once the connection has been established. This
    /// metadata is also available when receiving data through
    /// the content context.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Parameter `definition`: The protocol definition for which metadata will be returned.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object, or NULL if the connection
    /// has not been established yet or is cancelled.
    #[doc(alias = "nw_connection_copy_protocol_metadata")]
    #[inline]
    pub fn protocol_metadata(
        &self,
        definition: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_connection_copy_protocol_metadata(
                connection: &NWConnection,
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_connection_copy_protocol_metadata(self, definition) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Check for the maximum datagram size that can be written
    /// on the connection. Any datagrams written should be less
    /// than or equal to this size.
    ///
    ///
    /// Parameter `connection`: The connection object.
    ///
    ///
    /// Returns: Returns a datagram size based on the current MTU and the
    /// overhead of the protocols being used.
    #[doc(alias = "nw_connection_get_maximum_datagram_size")]
    #[inline]
    pub fn maximum_datagram_size(&self) -> u32 {
        extern "C-unwind" {
            fn nw_connection_get_maximum_datagram_size(connection: &NWConnection) -> u32;
        }
        unsafe { nw_connection_get_maximum_datagram_size(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwgroupdescriptor?language=objc)
#[doc(alias = "nw_group_descriptor_t")]
#[repr(C)]
pub struct NWGroupDescriptor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWGroupDescriptor {}
);

impl NWGroupDescriptor {
    /// Creates a new group descriptor object based on an endpoint
    /// to which communication will be established using a multiplexing protocol,
    /// represented as an nw_endpoint containing the remote endpoint
    /// to use for communication.
    ///
    ///
    /// Parameter `remote_endpoint`: An endpoint that can be used for communication over a multiplexing protocol.
    ///
    ///
    /// Returns: An instantiated group descriptor object or nil if the specified
    /// endpoint is not valid.
    #[doc(alias = "nw_group_descriptor_create_multiplex")]
    #[inline]
    pub fn new_multiplex(remote_endpoint: &NWEndpoint) -> NWRetained<NWGroupDescriptor> {
        extern "C-unwind" {
            fn nw_group_descriptor_create_multiplex(
                remote_endpoint: &NWEndpoint,
            ) -> Option<NonNull<NWGroupDescriptor>>;
        }
        let ret = unsafe { nw_group_descriptor_create_multiplex(remote_endpoint) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a new group descriptor object based on a multicast group,
    /// represented as an address endpoint.
    ///
    ///
    /// Parameter `multicast_group`: An address endpoint that contains a multicast group to join.
    ///
    ///
    /// Returns: An instantiated group descriptor object or nil if the specified
    /// endpoint is not an address endpoint representing a valid multicast
    /// group.
    #[doc(alias = "nw_group_descriptor_create_multicast")]
    #[inline]
    pub fn new_multicast(multicast_group: &NWEndpoint) -> NWRetained<NWGroupDescriptor> {
        extern "C-unwind" {
            fn nw_group_descriptor_create_multicast(
                multicast_group: &NWEndpoint,
            ) -> Option<NonNull<NWGroupDescriptor>>;
        }
        let ret = unsafe { nw_group_descriptor_create_multicast(multicast_group) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Add an additional endpoint to a given group descriptor.
    ///
    ///
    /// Parameter `descriptor`: A group descriptor.
    ///
    ///
    /// Parameter `endpoint`: An endpoint to add to the group.
    ///
    ///
    /// Returns: Returns true if the endpoint was added, false if the endpoint was
    /// not of a valid type and therefore not added.
    #[doc(alias = "nw_group_descriptor_add_endpoint")]
    #[inline]
    pub fn add_endpoint(&self, endpoint: &NWEndpoint) -> bool {
        extern "C-unwind" {
            fn nw_group_descriptor_add_endpoint(
                descriptor: &NWGroupDescriptor,
                endpoint: &NWEndpoint,
            ) -> bool;
        }
        unsafe { nw_group_descriptor_add_endpoint(self, endpoint) }
    }
}

/// A block called to enumerate the endpoints that are members of a group.
///
///
/// Parameter `endpoint`: A member of a group.
///
///
/// Returns: Returning true from the block will continue enumeration, and returning
/// false will stop enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_group_descriptor_enumerate_endpoints_block_t?language=objc)
pub type nw_group_descriptor_enumerate_endpoints_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWEndpoint>) -> bool>;

impl NWGroupDescriptor {
    /// List all endpoints associated with the group descriptor.
    ///
    ///
    /// Parameter `descriptor`: The group descriptor object to check.
    ///
    ///
    /// Parameter `enumerate_block`: A block to which the endpoints associated with the descriptor will be passed.
    /// Returning true from the block will continue to enumerate, and returning false will stop
    /// enumerating.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_group_descriptor_enumerate_endpoints")]
    #[inline]
    pub unsafe fn enumerate_endpoints(
        &self,
        enumerate_block: nw_group_descriptor_enumerate_endpoints_block_t,
    ) {
        extern "C-unwind" {
            fn nw_group_descriptor_enumerate_endpoints(
                descriptor: &NWGroupDescriptor,
                enumerate_block: nw_group_descriptor_enumerate_endpoints_block_t,
            );
        }
        unsafe { nw_group_descriptor_enumerate_endpoints(self, enumerate_block) }
    }

    /// Require a particular source for this multicast group descriptor.
    ///
    ///
    /// Parameter `multicast_descriptor`: The multicast group descriptor to modify.
    ///
    ///
    /// Parameter `source`: An endpoint describing the source for this descriptor.
    #[doc(alias = "nw_multicast_group_descriptor_set_specific_source")]
    #[inline]
    pub fn multicast_set_specific_source(&self, source: &NWEndpoint) {
        extern "C-unwind" {
            fn nw_multicast_group_descriptor_set_specific_source(
                multicast_descriptor: &NWGroupDescriptor,
                source: &NWEndpoint,
            );
        }
        unsafe { nw_multicast_group_descriptor_set_specific_source(self, source) }
    }

    /// Disable receiving unicast traffic for a connection group that is also receiving multicast traffic.
    ///
    ///
    /// Parameter `multicast_descriptor`: The multicast group descriptor to modify.
    ///
    ///
    /// Parameter `disable_unicast_traffic`: A boolean indicating if receiving unicast traffic should be disabled.
    #[doc(alias = "nw_multicast_group_descriptor_set_disable_unicast_traffic")]
    #[inline]
    pub fn multicast_set_disable_unicast_traffic(&self, disable_unicast_traffic: bool) {
        extern "C-unwind" {
            fn nw_multicast_group_descriptor_set_disable_unicast_traffic(
                multicast_descriptor: &NWGroupDescriptor,
                disable_unicast_traffic: bool,
            );
        }
        unsafe {
            nw_multicast_group_descriptor_set_disable_unicast_traffic(self, disable_unicast_traffic)
        }
    }

    /// Check if receiving unicast traffic has been disabled for a multicast connection group.
    ///
    ///
    /// Parameter `multicast_descriptor`: The multicast group descriptor to check.
    ///
    ///
    /// Returns: A boolean indicating if receiving unicast traffic should be disabled.
    #[doc(alias = "nw_multicast_group_descriptor_get_disable_unicast_traffic")]
    #[inline]
    pub fn multicast_disable_unicast_traffic(&self) -> bool {
        extern "C-unwind" {
            fn nw_multicast_group_descriptor_get_disable_unicast_traffic(
                multicast_descriptor: &NWGroupDescriptor,
            ) -> bool;
        }
        unsafe { nw_multicast_group_descriptor_get_disable_unicast_traffic(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwconnectiongroup?language=objc)
#[doc(alias = "nw_connection_group_t")]
#[repr(C)]
pub struct NWConnectionGroup {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWConnectionGroup {}
);

/// Connection Group states sent by nw_connection_group_set_state_changed_handler.
/// States progress forward and do not move backwards.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_connection_group_state_t(pub c_uint);
impl nw_connection_group_state_t {
    /// This state will never be delivered in the connection group's state update
    /// handler and can be treated as an unexpected value.
    #[doc(alias = "nw_connection_group_state_invalid")]
    pub const invalid: Self = Self(0);
    /// before being able to receive and process incoming messages.
    #[doc(alias = "nw_connection_group_state_waiting")]
    pub const waiting: Self = Self(1);
    /// process incoming messages.
    #[doc(alias = "nw_connection_group_state_ready")]
    pub const ready: Self = Self(2);
    /// You should cancel the connection group and create a new connection group object
    /// if you wish to continue processing incoming messages.
    #[doc(alias = "nw_connection_group_state_failed")]
    pub const failed: Self = Self(3);
    /// the user. You should create a new connection group object if you wish to continue
    /// processing incoming messages.
    #[doc(alias = "nw_connection_group_state_cancelled")]
    pub const cancelled: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_connection_group_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_connection_group_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWConnectionGroup {
    /// Creates a new connection group object to use for communication with
    /// a group descriptor using protocols described by parameters.
    ///
    ///
    /// Parameter `group_descriptor`: A group descriptor. For example, a descriptor of type nw_group_type_multicast
    /// defines one or more multicast groups to automatically join.
    ///
    ///
    /// Parameter `parameters`: Parameters to use for the new connection group. This includes the protocols that
    /// will be used to delineate complete messages for processing. For multicast
    /// joining, all available interfaces will be joined as prohibited or required.
    ///
    ///
    /// Returns: Returns an allocated nw_connection_group_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_group_create")]
    #[inline]
    pub fn new(
        group_descriptor: &NWGroupDescriptor,
        parameters: &NWParameters,
    ) -> NWRetained<NWConnectionGroup> {
        extern "C-unwind" {
            fn nw_connection_group_create(
                group_descriptor: &NWGroupDescriptor,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWConnectionGroup>>;
        }
        let ret = unsafe { nw_connection_group_create(group_descriptor, parameters) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Gets the group descriptor with which the connection group was created.
    ///
    ///
    /// Parameter `group`: The connection group to check.
    ///
    ///
    /// Returns: Returns the descriptor with which the connection group was created.
    #[doc(alias = "nw_connection_group_copy_descriptor")]
    #[inline]
    pub fn descriptor(&self) -> NWRetained<NWGroupDescriptor> {
        extern "C-unwind" {
            fn nw_connection_group_copy_descriptor(
                group: &NWConnectionGroup,
            ) -> Option<NonNull<NWGroupDescriptor>>;
        }
        let ret = unsafe { nw_connection_group_copy_descriptor(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Returns a copy of the parameters passed to nw_connection_group_create.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Returns: Returns an nw_parameters_t object.
    #[doc(alias = "nw_connection_group_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_connection_group_copy_parameters(
                group: &NWConnectionGroup,
            ) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_connection_group_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_connection_group_start().
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `queue`: The client's callback queue.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "nw_connection_group_set_queue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_connection_group_set_queue(group: &NWConnectionGroup, queue: &DispatchQueue);
        }
        unsafe { nw_connection_group_set_queue(self, queue) }
    }
}

/// A block called when the connection group changes state.
///
///
/// Parameter `state`: The new state of the connection group.
///
///
/// Parameter `error`: An optional error that is associated with the new state.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_state_changed_handler_t?language=objc)
pub type nw_connection_group_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_connection_group_state_t, *mut NWError)>;

impl NWConnectionGroup {
    /// Sets the state changed handler. For clients that need to perform cleanup
    /// when the connection group has been cancelled, the nw_connection_group_state_cancelled state
    /// will be delivered last. This function must not be called after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `state_changed_handler`: The state changed handler to call when the connection group state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `state_changed_handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_group_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(
        &self,
        state_changed_handler: nw_connection_group_state_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_set_state_changed_handler(
                group: &NWConnectionGroup,
                state_changed_handler: nw_connection_group_state_changed_handler_t,
            );
        }
        unsafe { nw_connection_group_set_state_changed_handler(self, state_changed_handler) }
    }
}

/// A block called when a new inbound message arrives at the connection group. A client
/// may reply to this message within the handler or it may choose to save the
/// content context representing this message and provide a response
/// at a later time. If an inbound context is deallocated without providing a response,
/// the message is considered dropped and any internal state associated with the
/// endpoint that sent that message will be removed.
///
///
/// Parameter `content`: The content associated with the body of the inbound message. If there is no
/// body for this message `content` will be `nil`.
///
///
/// Parameter `context`: The content context representing this inbound message.
///
///
/// Parameter `is_complete`: True if the inbound message is complete and any content provided represents
/// the entirety of the inbound message's body. If false, the inbound message context
/// may be converted to a connection associated with this message and read
/// the remainder of the body, or an appropriate error may be selected and sent in
/// response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_receive_handler_t?language=objc)
#[cfg(feature = "dispatch2")]
pub type nw_connection_group_receive_handler_t =
    *mut block2::DynBlock<dyn Fn(*mut DispatchData, NonNull<NWContentContext>, bool)>;

impl NWConnectionGroup {
    /// Sets the handler to be invoked whenever a new inbound message
    /// arrives at the connection group. This function must not be called after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `maximum_message_size`: The maximum message size that should be delivered as a complete message. Any
    /// inbound messages larger than this size will be delivered as a partial message and
    /// an application may convert the inbound message to an `nw_connection` to read
    /// any remaining data for that message until it is complete.
    ///
    ///
    /// Parameter `reject_oversized_messages`: True if messages larger than maximum_message_size should be treated as errors
    /// and the connection group should automatically reply to such messages. False if the
    /// connection group should deliver such messages as incomplete and allow the application
    /// to inspect the message prior to accepting or rejecting it.
    ///
    ///
    /// Parameter `receive_handler`: The handler to call upon arrival of a new inbound message.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// `receive_handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_group_set_receive_handler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_receive_handler(
        &self,
        maximum_message_size: u32,
        reject_oversized_messages: bool,
        receive_handler: nw_connection_group_receive_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_set_receive_handler(
                group: &NWConnectionGroup,
                maximum_message_size: u32,
                reject_oversized_messages: bool,
                receive_handler: nw_connection_group_receive_handler_t,
            );
        }
        unsafe {
            nw_connection_group_set_receive_handler(
                self,
                maximum_message_size,
                reject_oversized_messages,
                receive_handler,
            )
        }
    }

    /// Starts the connection group, which begins listening for and processing incoming messages.
    /// You must call nw_connection_group_set_queue() and set a receive handler with
    /// nw_connection_group_set_receive_handler() before starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    #[doc(alias = "nw_connection_group_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_connection_group_start(group: &NWConnectionGroup);
        }
        unsafe { nw_connection_group_start(self) }
    }

    /// Cancels the connection group. The process of cancellation will be completed
    /// asynchronously, and the final callback event delivered to the caller
    /// will be a state update with a value of nw_connection_group_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated
    /// memory or objects.
    ///
    ///
    /// Parameter `group`: The connection group object.
    #[doc(alias = "nw_connection_group_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_connection_group_cancel(group: &NWConnectionGroup);
        }
        unsafe { nw_connection_group_cancel(self) }
    }

    /// Copy the remote endpoint corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the remote endpoint, or nil if the context is not a valid
    /// inbound message received from this connection group.
    #[doc(alias = "nw_connection_group_copy_remote_endpoint_for_message")]
    #[inline]
    pub fn remote_endpoint_for_message(
        &self,
        context: &NWContentContext,
    ) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_remote_endpoint_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_connection_group_copy_remote_endpoint_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the local endpoint corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the local endpoint, or nil if the context is not a valid
    /// inbound message received from this connection group.
    #[doc(alias = "nw_connection_group_copy_local_endpoint_for_message")]
    #[inline]
    pub fn local_endpoint_for_message(
        &self,
        context: &NWContentContext,
    ) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_local_endpoint_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_connection_group_copy_local_endpoint_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the path associated with a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the path associated with the provided message, or nil if the context
    /// is not a valid inbound message received from this connection group.
    #[doc(alias = "nw_connection_group_copy_path_for_message")]
    #[inline]
    pub fn path_for_message(&self, context: &NWContentContext) -> Option<NWRetained<NWPath>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_path_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWPath>>;
        }
        let ret = unsafe { nw_connection_group_copy_path_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Copy the metadata corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `definition`: The protocol definition for which metadata will be returned.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object, or NULL if not found.
    #[doc(alias = "nw_connection_group_copy_protocol_metadata_for_message")]
    #[inline]
    pub fn protocol_metadata_for_message(
        &self,
        context: &NWContentContext,
        definition: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_protocol_metadata_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe {
            nw_connection_group_copy_protocol_metadata_for_message(self, context, definition)
        };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Extract a connection corresponding to an inbound message from the
    /// connection group. Once extracted, subsequent messages from this
    /// remote endpoint on this connection will no longer be handled by the
    /// connection group. The connection may be used to read the remainder
    /// of a partial message or to send a large response with support for partial
    /// messages and backpressure.
    /// Any incoming messages from this remote endpoint which were saved from
    /// the receive handler may no longer be valid after a connection is returned.
    /// An extracted connection must have a queue set and be started before it can be used.
    ///
    ///
    /// Parameter `group`: The connection group object from which the context was received. If the context was
    /// not received from this connection group, the extraction will fail.
    ///
    ///
    /// Parameter `context`: A content context representing an inbound message received from this connection group.
    ///
    ///
    /// Returns: Returns the connection associated with the provided message, or nil if the extraction
    /// fails. Extraction will fail if the provided message is not an inbound message from
    /// this connection group.
    #[doc(alias = "nw_connection_group_extract_connection_for_message")]
    #[inline]
    pub fn extract_connection_for_message(
        &self,
        context: &NWContentContext,
    ) -> Option<NWRetained<NWConnection>> {
        extern "C-unwind" {
            fn nw_connection_group_extract_connection_for_message(
                group: &NWConnectionGroup,
                context: &NWContentContext,
            ) -> Option<NonNull<NWConnection>>;
        }
        let ret = unsafe { nw_connection_group_extract_connection_for_message(self, context) };
        ret.map(|ret| unsafe { NWRetained::retain(ret) })
    }

    /// Send data in response to an inbound message received by a connection group.
    ///
    ///
    /// Parameter `group`: The connection group object from which the reply_context was received.
    ///
    ///
    /// Parameter `inbound_message`: The inbound message received by the connection group for which this is a response.
    /// An inbound message may be replied to exactly once.
    ///
    ///
    /// Parameter `outbound_message`: The outbound message to send in response to the message received by the connection group.
    ///
    /// The response context can also hold protocol metadata to define how to
    /// send content, such as flags for IP packets.
    ///
    /// If the context is marked as "final", the  connection group will expect that no further communication is
    /// expected during this connection with the peer and may close the underlying transport.
    /// Subsequent connection attempts from the peer will continue to be delivered as incoming messages.
    ///
    ///
    /// Parameter `content`: A data object to send as the message body. This may be NULL if the outgoing
    /// context represents a metadata only message that contains no body data.
    #[doc(alias = "nw_connection_group_reply")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub fn reply(
        &self,
        inbound_message: &NWContentContext,
        outbound_message: &NWContentContext,
        content: Option<&DispatchData>,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_reply(
                group: &NWConnectionGroup,
                inbound_message: &NWContentContext,
                outbound_message: &NWContentContext,
                content: Option<&DispatchData>,
            );
        }
        unsafe { nw_connection_group_reply(self, inbound_message, outbound_message, content) }
    }

    /// Extract a connection from the connection group. For a multiplex connection group, this means that
    /// a new stream is opened and the corresponding nw_connection_t object is returned. For non-multiplex
    /// connection groups, a connection to the specified endpoint will be returned if allowed by the group descriptor.
    ///
    /// The connection can be re-inserted into the group later. Once reinserted, the connection group
    /// will handle subsequent messages from this remote endpoint.
    /// An extracted connection must have a queue set and be started before it can be used.
    ///
    ///
    /// Parameter `group`: The connection group object from which to extract a connection.
    ///
    ///
    /// Parameter `endpoint`: The endpoint to use as the remote endpoint for the extracted connection, if applicable.
    /// For connection groups with multiplex group descriptors, this should be nil.
    ///
    ///
    /// Parameter `protocol_options`: The protocol options to apply to the extracted connection. May be nil if not applicable.
    ///
    ///
    /// Returns: Returns the connection from the connection group.
    #[doc(alias = "nw_connection_group_extract_connection")]
    #[inline]
    pub fn extract_connection(
        &self,
        endpoint: Option<&NWEndpoint>,
        protocol_options: Option<&NWProtocolOptions>,
    ) -> Option<NWRetained<NWConnection>> {
        extern "C-unwind" {
            fn nw_connection_group_extract_connection(
                group: &NWConnectionGroup,
                endpoint: Option<&NWEndpoint>,
                protocol_options: Option<&NWProtocolOptions>,
            ) -> Option<NonNull<NWConnection>>;
        }
        let ret =
            unsafe { nw_connection_group_extract_connection(self, endpoint, protocol_options) };
        ret.map(|ret| unsafe { NWRetained::retain(ret) })
    }

    /// Reinsert a connection into a connection group. Once reinserted, the connection group
    /// will handle subsequent messages from this remote endpoint, and any outstanding reads on
    /// the connection will be cancelled.
    ///
    ///
    /// Parameter `group`: The connection group object from which the connection was extracted. If the connection was
    /// not extracted from this connection group, the reinsertion will fail.
    ///
    ///
    /// Parameter `connection`: A connection that was extracted from this connection group.
    ///
    ///
    /// Returns: Returns true if the reinsertion was successful. Reinsertion will fail if the provided connection was
    /// not extracted from this connection group.
    #[doc(alias = "nw_connection_group_reinsert_extracted_connection")]
    #[inline]
    pub fn reinsert_extracted_connection(&self, connection: &NWConnection) -> bool {
        extern "C-unwind" {
            fn nw_connection_group_reinsert_extracted_connection(
                group: &NWConnectionGroup,
                connection: &NWConnection,
            ) -> bool;
        }
        unsafe { nw_connection_group_reinsert_extracted_connection(self, connection) }
    }
}

/// A send completion is invoked exactly once for a call to nw_connection_group_send_message().
/// The completion indicates that the sent content has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be delivered if the associated content could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the connection
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_send_completion_t?language=objc)
pub type nw_connection_group_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

impl NWConnectionGroup {
    /// Send data that is not in response to an inbound message. This outgoing
    /// message will be sent from the local endpoint on which the connection group is
    /// listening for incoming messages.
    ///
    /// This is an asynchronous send and the completion block can be used to
    /// determine when the send is complete. There is nothing preventing a client
    /// from issuing an excessive number of outstanding sends. To minimize memory
    /// footprint and excessive latency as a consequence of buffer bloat, it is
    /// advisable to keep a low number of outstanding sends. The completion block
    /// can be used to pace subsequent sends.
    ///
    ///
    /// Parameter `group`: The connection group object from which to send the outbound data.
    ///
    ///
    /// Parameter `content`: A data object to send as the message body. This may be NULL if the outgoing
    /// context represents a metadata only message that contains no body data.
    ///
    ///
    /// Parameter `endpoint`: The destination endpoint to which the outbound message should be sent. If the
    /// endpoint is NULL, the message will be sent to all members of the group.
    ///
    ///
    /// Parameter `context`: An outbound message to send from the connection group.
    ///
    /// The context can also hold protocol metadata to define how to send content,
    /// such as flags for IP packets.
    ///
    /// If the context is marked as "final", the  connection group will expect that no further communication is
    /// expected during this connection with the peer and may close the underlying transport.
    /// Subsequent connection attempts from the peer will be delivered as incoming messages.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the message has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has either been sent or it has been
    /// enqueued to be sent.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_connection_group_send_message")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn send_message(
        &self,
        content: Option<&DispatchData>,
        endpoint: Option<&NWEndpoint>,
        context: &NWContentContext,
        completion: nw_connection_group_send_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_send_message(
                group: &NWConnectionGroup,
                content: Option<&DispatchData>,
                endpoint: Option<&NWEndpoint>,
                context: &NWContentContext,
                completion: nw_connection_group_send_completion_t,
            );
        }
        unsafe { nw_connection_group_send_message(self, content, endpoint, context, completion) }
    }
}

/// A block called with a new connection when a multiplex group receives a new stream. If a new connection
/// handler is set the user must handle connections received by this handler. There are three possible
/// actions to take and one of these three actions must be taken.
/// 1) Take over the ownership of the connection. In this case, the connection is used by the client to
/// send and receive data as any other connection would be used. The client may insert this
/// connection back into the connection group at a later point if so desired.
/// The connection must have a queue set and be started before it can be used.
/// 2) If you want the connection group to handle this connection, simply insert this connection back into
/// the connection group right away.
/// 3) If you don't want to accept this connection, simply cancel the connection.
///
///
/// Parameter `connection`: The connection representing the new stream on this multiplexing protocol
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_connection_group_new_connection_handler_t?language=objc)
pub type nw_connection_group_new_connection_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWConnection>)>;

impl NWConnectionGroup {
    /// Sets the new connection handler to be invoked whenever a new inbound connection
    /// is received by the connection group. This function must not be called
    /// after starting the connection group.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `new_connection_handler`: The new connection handler to call upon receipt of a new inbound connection.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// `new_connection_handler` must be a valid pointer or null.
    #[doc(alias = "nw_connection_group_set_new_connection_handler")]
    #[inline]
    pub unsafe fn set_new_connection_handler(
        &self,
        new_connection_handler: nw_connection_group_new_connection_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_group_set_new_connection_handler(
                group: &NWConnectionGroup,
                new_connection_handler: nw_connection_group_new_connection_handler_t,
            );
        }
        unsafe { nw_connection_group_set_new_connection_handler(self, new_connection_handler) }
    }

    /// Copy the metadata corresponding to a given inbound connection group message.
    ///
    ///
    /// Parameter `group`: The connection group object.
    ///
    ///
    /// Parameter `definition`: The protocol definition for which metadata will be returned.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object, or NULL if the connection
    /// group has not been established yet or is cancelled.
    #[doc(alias = "nw_connection_group_copy_protocol_metadata")]
    #[inline]
    pub fn protocol_metadata(
        &self,
        definition: &NWProtocolDefinition,
    ) -> Option<NWRetained<NWProtocolMetadata>> {
        extern "C-unwind" {
            fn nw_connection_group_copy_protocol_metadata(
                group: &NWConnectionGroup,
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_connection_group_copy_protocol_metadata(self, definition) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwestablishmentreport?language=objc)
#[doc(alias = "nw_establishment_report_t")]
#[repr(C)]
pub struct NWEstablishmentReport {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWEstablishmentReport {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_establishment_report_access_block_t?language=objc)
pub type nw_establishment_report_access_block_t =
    *mut block2::DynBlock<dyn Fn(*mut NWEstablishmentReport)>;

impl NWConnection {
    /// Access the establishment report for a connection. The report will be
    /// NULL until the connection is in the "ready" state.
    ///
    /// The callback block will be invoked exactly once on the provided queue.
    ///
    ///
    /// Parameter `connection`: An established connection.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the access_block.
    ///
    ///
    /// Parameter `access_block`: A block to invoke with the establishment report, which may be NULL if the
    /// connection not ready.
    ///
    /// # Safety
    ///
    /// - `queue` possibly has additional threading requirements.
    /// - `access_block` must be a valid pointer.
    #[doc(alias = "nw_connection_access_establishment_report")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn access_establishment_report(
        &self,
        queue: &DispatchQueue,
        access_block: nw_establishment_report_access_block_t,
    ) {
        extern "C-unwind" {
            fn nw_connection_access_establishment_report(
                connection: &NWConnection,
                queue: &DispatchQueue,
                access_block: nw_establishment_report_access_block_t,
            );
        }
        unsafe { nw_connection_access_establishment_report(self, queue, access_block) }
    }
}

impl NWEstablishmentReport {
    /// Retrieve the duration of the connection's establishment. This is
    /// the total time in milliseconds from when the connection attempt began
    /// until the connection becomes ready, including resolution, proxy
    /// evaluation, and protocol handshakes.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of milliseconds the connection took to establish.
    #[doc(alias = "nw_establishment_report_get_duration_milliseconds")]
    #[inline]
    pub fn duration_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_establishment_report_get_duration_milliseconds(
                report: &NWEstablishmentReport,
            ) -> u64;
        }
        unsafe { nw_establishment_report_get_duration_milliseconds(self) }
    }

    /// Retrieve the delay from calling start() after which the successful connection
    /// attempt began. For connections that succeed on the first attempt, this value
    /// will be 0. For connections that move into the "waiting" state, this
    /// value will be greater than 0.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of milliseconds from connection start to the beginning
    /// of the successful connection attempt.
    #[doc(alias = "nw_establishment_report_get_attempt_started_after_milliseconds")]
    #[inline]
    pub fn attempt_started_after_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_establishment_report_get_attempt_started_after_milliseconds(
                report: &NWEstablishmentReport,
            ) -> u64;
        }
        unsafe { nw_establishment_report_get_attempt_started_after_milliseconds(self) }
    }

    /// Retrieve the number of connection attempts made before the successful
    /// attempt. For connections that succeed on the first attempt, this value
    /// will be 0. For connections that move into the "waiting" state, this
    /// value will be greater than 0.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns the number of connection attempts made before the successful attempt.
    #[doc(alias = "nw_establishment_report_get_previous_attempt_count")]
    #[inline]
    pub fn previous_attempt_count(&self) -> u32 {
        extern "C-unwind" {
            fn nw_establishment_report_get_previous_attempt_count(
                report: &NWEstablishmentReport,
            ) -> u32;
        }
        unsafe { nw_establishment_report_get_previous_attempt_count(self) }
    }

    /// Check if the connection used a proxy during establishment.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns true if the connection used a proxy, false otherwise.
    #[doc(alias = "nw_establishment_report_get_used_proxy")]
    #[inline]
    pub fn used_proxy(&self) -> bool {
        extern "C-unwind" {
            fn nw_establishment_report_get_used_proxy(report: &NWEstablishmentReport) -> bool;
        }
        unsafe { nw_establishment_report_get_used_proxy(self) }
    }

    /// Check if a proxy configuration applied to the connection,
    /// even if the connection did not end up using a proxy for the
    /// successful attempt.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns true if a proxy configuration applied to the connection,
    /// false otherwise.
    #[doc(alias = "nw_establishment_report_get_proxy_configured")]
    #[inline]
    pub fn proxy_configured(&self) -> bool {
        extern "C-unwind" {
            fn nw_establishment_report_get_proxy_configured(report: &NWEstablishmentReport)
                -> bool;
        }
        unsafe { nw_establishment_report_get_proxy_configured(self) }
    }

    /// Access the endpoint of the proxy used by a connection, if applicable.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Returns: Returns an allocated endpoint object if a proxy was used by the connection,
    /// or NULL if no proxy was used.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_establishment_report_copy_proxy_endpoint")]
    #[inline]
    pub fn proxy_endpoint(&self) -> Option<NWRetained<NWEndpoint>> {
        extern "C-unwind" {
            fn nw_establishment_report_copy_proxy_endpoint(
                report: &NWEstablishmentReport,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_establishment_report_copy_proxy_endpoint(self) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwresolutionreport?language=objc)
#[doc(alias = "nw_resolution_report_t")]
#[repr(C)]
pub struct NWResolutionReport {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWResolutionReport {}
);

/// The source of a resolution indicates if the set of endpoints was resolved
/// locally using a cache, or sent a query over the network.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_source_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_report_resolution_source_t(pub c_uint);
impl nw_report_resolution_source_t {
    #[doc(alias = "nw_report_resolution_source_query")]
    pub const query: Self = Self(1);
    #[doc(alias = "nw_report_resolution_source_cache")]
    pub const cache: Self = Self(2);
    #[doc(alias = "nw_report_resolution_source_expired_cache")]
    pub const expired_cache: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_report_resolution_source_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_report_resolution_source_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWResolutionReport {
    /// Check the source of a resolution, such as query or cache.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The source of the resolution (query or cache).
    #[doc(alias = "nw_resolution_report_get_source")]
    #[inline]
    pub fn source(&self) -> nw_report_resolution_source_t {
        extern "C-unwind" {
            fn nw_resolution_report_get_source(
                resolution_report: &NWResolutionReport,
            ) -> nw_report_resolution_source_t;
        }
        unsafe { nw_resolution_report_get_source(self) }
    }

    /// Get the number of milliseconds spent on this resolution step.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The number of milliseconds spent on this resolution step.
    #[doc(alias = "nw_resolution_report_get_milliseconds")]
    #[inline]
    pub fn milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_resolution_report_get_milliseconds(resolution_report: &NWResolutionReport)
                -> u64;
        }
        unsafe { nw_resolution_report_get_milliseconds(self) }
    }

    /// Get the number of resolved endpoints discovered by the resolution step.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The number of resolved endpoints discovered by the resolution step.
    #[doc(alias = "nw_resolution_report_get_endpoint_count")]
    #[inline]
    pub fn endpoint_count(&self) -> u32 {
        extern "C-unwind" {
            fn nw_resolution_report_get_endpoint_count(
                resolution_report: &NWResolutionReport,
            ) -> u32;
        }
        unsafe { nw_resolution_report_get_endpoint_count(self) }
    }

    /// Copy the resolved endpoint that led to a successful connection.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The resolved endpoint that led to a successful connection.
    #[doc(alias = "nw_resolution_report_copy_successful_endpoint")]
    #[inline]
    pub fn successful_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_resolution_report_copy_successful_endpoint(
                resolution_report: &NWResolutionReport,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_resolution_report_copy_successful_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Copy first resolved endpoint attempted, which may be the same as the successful endpoint.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The first resolved endpoint attempted.
    #[doc(alias = "nw_resolution_report_copy_preferred_endpoint")]
    #[inline]
    pub fn preferred_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_resolution_report_copy_preferred_endpoint(
                resolution_report: &NWResolutionReport,
            ) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_resolution_report_copy_preferred_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// The protocol used for endpoint resolution.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_protocol_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_report_resolution_protocol_t(pub c_uint);
impl nw_report_resolution_protocol_t {
    #[doc(alias = "nw_report_resolution_protocol_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_report_resolution_protocol_udp")]
    pub const udp: Self = Self(1);
    #[doc(alias = "nw_report_resolution_protocol_tcp")]
    pub const tcp: Self = Self(2);
    #[doc(alias = "nw_report_resolution_protocol_tls")]
    pub const tls: Self = Self(3);
    #[doc(alias = "nw_report_resolution_protocol_https")]
    pub const https: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_report_resolution_protocol_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_report_resolution_protocol_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWResolutionReport {
    /// Check the protocol used for endpoint resolution.
    ///
    ///
    /// Parameter `resolution_report`: A resolution report.
    ///
    ///
    /// Returns: The protocol used for endpoint resolution.
    #[doc(alias = "nw_resolution_report_get_protocol")]
    #[inline]
    pub fn protocol(&self) -> nw_report_resolution_protocol_t {
        extern "C-unwind" {
            fn nw_resolution_report_get_protocol(
                resolution_report: &NWResolutionReport,
            ) -> nw_report_resolution_protocol_t;
        }
        unsafe { nw_resolution_report_get_protocol(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_enumerator_t?language=objc)
pub type nw_report_resolution_enumerator_t = *mut block2::DynBlock<
    dyn Fn(
        nw_report_resolution_source_t,
        u64,
        u32,
        NonNull<NWEndpoint>,
        NonNull<NWEndpoint>,
    ) -> bool,
>;

impl NWEstablishmentReport {
    /// Enumerate the steps of connection establishment that involved endpoint
    /// resolution, such as DNS hostname resolution and Bonjour service resolution.
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each step of resolution
    /// used during connection establishment.
    ///
    /// The values passed to the enumerator are:
    /// - source: The source of the resolution (query or cache).
    /// - milliseconds: The number of milliseconds spent on this resolution step.
    /// - endpoint_count: The number of resolved endpoints discovered by the resolution step.
    /// - successful_endpoint: The resolved endpoint that led to a successful connection.
    /// - preferred_endpoint: The first resolved endpoint attempted, which may be the same as the successful_endpoint.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_establishment_report_enumerate_resolutions")]
    #[inline]
    pub unsafe fn enumerate_resolutions(&self, enumerate_block: nw_report_resolution_enumerator_t) {
        extern "C-unwind" {
            fn nw_establishment_report_enumerate_resolutions(
                report: &NWEstablishmentReport,
                enumerate_block: nw_report_resolution_enumerator_t,
            );
        }
        unsafe { nw_establishment_report_enumerate_resolutions(self, enumerate_block) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_resolution_report_enumerator_t?language=objc)
pub type nw_report_resolution_report_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWResolutionReport>) -> bool>;

impl NWEstablishmentReport {
    /// Enumerate the steps of connection establishment that involved endpoint
    /// resolution, such as DNS hostname resolution and Bonjour service resolution.
    /// This variant provides resolution report objects, which allow more detailed
    /// access to information.
    ///
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each step of resolution
    /// used during connection establishment. Each block contains a nw_resolution_report_t.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_establishment_report_enumerate_resolution_reports")]
    #[inline]
    pub unsafe fn enumerate_resolution_reports(
        &self,
        enumerate_block: nw_report_resolution_report_enumerator_t,
    ) {
        extern "C-unwind" {
            fn nw_establishment_report_enumerate_resolution_reports(
                report: &NWEstablishmentReport,
                enumerate_block: nw_report_resolution_report_enumerator_t,
            );
        }
        unsafe { nw_establishment_report_enumerate_resolution_reports(self, enumerate_block) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_report_protocol_enumerator_t?language=objc)
pub type nw_report_protocol_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWProtocolDefinition>, u64, u64) -> bool>;

impl NWEstablishmentReport {
    /// Enumerate the protocols used in the established connection.
    /// The provided block will be called inline zero or more times.
    ///
    ///
    /// Parameter `report`: An establishment report.
    ///
    ///
    /// Parameter `enumerate_block`: A block to be invoked zero or more times, once for each protocol
    /// used in the established connection.
    ///
    /// The values passed to the enumerator are:
    /// - protocol: The protocol definition.
    /// - handshake_milliseconds: The number of milliseconds spent on the protocol's handshake.
    /// - handshake_rtt_milliseconds: The round trip time in milliseconds measured by the protocol's handshake.
    ///
    /// Returning true from the block indicates that the enumeration should continue.
    /// Returning false indicates that the enumeration should stop.
    ///
    /// # Safety
    ///
    /// `enumerate_block` must be a valid pointer.
    #[doc(alias = "nw_establishment_report_enumerate_protocols")]
    #[inline]
    pub unsafe fn enumerate_protocols(&self, enumerate_block: nw_report_protocol_enumerator_t) {
        extern "C-unwind" {
            fn nw_establishment_report_enumerate_protocols(
                report: &NWEstablishmentReport,
                enumerate_block: nw_report_protocol_enumerator_t,
            );
        }
        unsafe { nw_establishment_report_enumerate_protocols(self, enumerate_block) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwdatatransferreport?language=objc)
#[doc(alias = "nw_data_transfer_report_t")]
#[repr(C)]
pub struct NWDataTransferReport {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWDataTransferReport {}
);

impl NWConnection {
    /// Create a new data transfer report on a connection. Multiple
    /// reports may be created for a single connection. The report begins
    /// capturing data when the connection becomes ready, or when the
    /// report is created (whichever occurs last).
    ///
    /// Call nw_data_transfer_report_collect() to complete collection of
    /// report, after which point the details of the report will be available.
    ///
    ///
    /// Parameter `connection`: A connection object, in or before the ready state.
    ///
    ///
    /// Returns: Returns an allocated nw_data_transfer_report_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_connection_create_new_data_transfer_report")]
    #[inline]
    pub fn new_data_transfer_report(&self) -> NWRetained<NWDataTransferReport> {
        extern "C-unwind" {
            fn nw_connection_create_new_data_transfer_report(
                connection: &NWConnection,
            ) -> Option<NonNull<NWDataTransferReport>>;
        }
        let ret = unsafe { nw_connection_create_new_data_transfer_report(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// The state of a Data Transfer Report indicates whether or not the contents
/// have been collected, and are ready to be accessed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_data_transfer_report_state_t(pub c_uint);
impl nw_data_transfer_report_state_t {
    #[doc(alias = "nw_data_transfer_report_state_collecting")]
    pub const collecting: Self = Self(1);
    #[doc(alias = "nw_data_transfer_report_state_collected")]
    pub const collected: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_data_transfer_report_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_data_transfer_report_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWDataTransferReport {
    /// Access the state of a data transfer report. Once a report
    /// is "collected", individual fields may be read.
    ///
    ///
    /// Parameter `report`: A data transfer report to check.
    ///
    ///
    /// Returns: Returns the current state of the data transfer report.
    #[doc(alias = "nw_data_transfer_report_get_state")]
    #[inline]
    pub fn state(&self) -> nw_data_transfer_report_state_t {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_state(
                report: &NWDataTransferReport,
            ) -> nw_data_transfer_report_state_t;
        }
        unsafe { nw_data_transfer_report_get_state(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_data_transfer_report_collect_block_t?language=objc)
pub type nw_data_transfer_report_collect_block_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWDataTransferReport>)>;

impl NWDataTransferReport {
    /// Mark a data transfer report as complete, and request collection of
    /// values. Once the report has been collected, the callback block
    /// will be invoked exactly once on the provided dispatch queue.
    ///
    /// If a connection is cancelled or fails prior to the report being collected,
    /// the report will automatically be collected. Calling
    /// nw_data_transfer_report_collect() will be redundant but not harmful.
    ///
    ///
    /// Parameter `report`: A data transfer report to check.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the collect_block.
    ///
    ///
    /// Parameter `collect_block`: A block to invoke once the report has been collected.
    ///
    /// # Safety
    ///
    /// - `queue` possibly has additional threading requirements.
    /// - `collect_block` must be a valid pointer.
    #[doc(alias = "nw_data_transfer_report_collect")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn collect(
        &self,
        queue: &DispatchQueue,
        collect_block: nw_data_transfer_report_collect_block_t,
    ) {
        extern "C-unwind" {
            fn nw_data_transfer_report_collect(
                report: &NWDataTransferReport,
                queue: &DispatchQueue,
                collect_block: nw_data_transfer_report_collect_block_t,
            );
        }
        unsafe { nw_data_transfer_report_collect(self, queue, collect_block) }
    }
}

extern "C" {
    /// Pass NW_ALL_PATHS to data transfer report accessors to sum
    /// values across paths where applicable. For values that cannot
    /// sum, the value of the primary path is used.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/network/_nw_data_transfer_report_all_paths?language=objc)
    pub static _nw_data_transfer_report_all_paths: u32;
}

impl NWDataTransferReport {
    /// Retrieve the duration of the data transfer report. This is a length
    /// of time in milliseconds which can be used to calculate throughput
    /// when compared to application and transport byte counts.
    ///
    /// The start time is calculated from when the report was created, or the connection
    /// became ready if the connection was not ready when the report was created.
    /// The duration ends when the report is collected, or the connection fails
    /// or is cancelled.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Returns: Returns the duration of the data transport report in milliseconds, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_duration_milliseconds")]
    #[inline]
    pub fn duration_milliseconds(&self) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_duration_milliseconds(
                report: &NWDataTransferReport,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_duration_milliseconds(self) }
    }

    /// Retrieve the number of paths used by the connection for the
    /// duration of the report. Any value greater than or equal to 0 and
    /// less than this count may be used as a "path_index" for retrieving
    /// specific details from the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Returns: Returns the number of paths used by the connection, which
    /// limits the value of the "path_index" parameter used in other report
    /// functions. Returns 0 if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_path_count")]
    #[inline]
    pub fn path_count(&self) -> u32 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_path_count(report: &NWDataTransferReport) -> u32;
        }
        unsafe { nw_data_transfer_report_get_path_count(self) }
    }

    /// Retrieve the number of IP packets received on a given path for the
    /// duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of IP packets received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_ip_packet_count")]
    #[inline]
    pub fn received_ip_packet_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_ip_packet_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_received_ip_packet_count(self, path_index) }
    }

    /// Retrieve the number of IP packets sent on a given path for the
    /// duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of IP packets sent, or 0 if the report is not
    /// in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_ip_packet_count")]
    #[inline]
    pub fn sent_ip_packet_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_ip_packet_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_sent_ip_packet_count(self, path_index) }
    }

    /// Retrieve the number of transport protocol bytes (such as TCP stream bytes)
    /// received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of transport protocol bytes received, or 0 if the
    /// report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_transport_byte_count")]
    #[inline]
    pub fn received_transport_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_transport_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_received_transport_byte_count(self, path_index) }
    }

    /// Retrieve the number of duplicate transport protocol bytes (such as
    /// duplicate TCP bytes) received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of duplicate transport protocol bytes received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_transport_duplicate_byte_count")]
    #[inline]
    pub fn received_transport_duplicate_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_transport_duplicate_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe {
            nw_data_transfer_report_get_received_transport_duplicate_byte_count(self, path_index)
        }
    }

    /// Retrieve the number of out-of-order transport protocol bytes (such as
    /// out-of-order TCP bytes) received on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of out-of-order transport protocol bytes received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_transport_out_of_order_byte_count")]
    #[inline]
    pub fn received_transport_out_of_order_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_transport_out_of_order_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe {
            nw_data_transfer_report_get_received_transport_out_of_order_byte_count(self, path_index)
        }
    }

    /// Retrieve the number of transport protocol bytes (such as TCP stream bytes)
    /// sent on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of transport protocol bytes sent, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_transport_byte_count")]
    #[inline]
    pub fn sent_transport_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_transport_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_sent_transport_byte_count(self, path_index) }
    }

    /// Retrieve the number of retransmitted transport protocol bytes (such as
    /// retransmitted TCP bytes) sent on a given path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of retransmitted transport protocol bytes sent, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_transport_retransmitted_byte_count")]
    #[inline]
    pub fn sent_transport_retransmitted_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe {
            nw_data_transfer_report_get_sent_transport_retransmitted_byte_count(self, path_index)
        }
    }

    /// Retrieve the smoothed average for the transport protocol's round trip time
    /// (RTT) on a given path for the duration of the report, measured in milliseconds.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the smoothed RTT as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds")]
    #[inline]
    pub fn transport_smoothed_rtt_milliseconds(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_transport_smoothed_rtt_milliseconds(self, path_index) }
    }

    /// Retrieve the minimum (best) round trip time (RTT) on a given path for
    /// the duration of the report, measured in milliseconds.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the minimum RTT as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_transport_minimum_rtt_milliseconds")]
    #[inline]
    pub fn transport_minimum_rtt_milliseconds(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_transport_minimum_rtt_milliseconds(self, path_index) }
    }

    /// Retrieve the variance of the round trip time (RTT) on a given path for
    /// the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// For non-multipath connections, pass 0 as the path index to access
    /// the single path. Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the RTT variance as measured by the transport protocol, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_transport_rtt_variance")]
    #[inline]
    pub fn transport_rtt_variance(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_transport_rtt_variance(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_transport_rtt_variance(self, path_index) }
    }

    /// Retrieve the number of application bytes received on a given
    /// path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of application bytes received, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_received_application_byte_count")]
    #[inline]
    pub fn received_application_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_received_application_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_received_application_byte_count(self, path_index) }
    }

    /// Retrieve the number of application bytes sent on a given
    /// path for the duration of the report.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function returns
    /// the sum of all paths.
    ///
    ///
    /// Returns: Returns the number of application bytes sent, or 0
    /// if the report is not in the "collected" state.
    #[doc(alias = "nw_data_transfer_report_get_sent_application_byte_count")]
    #[inline]
    pub fn sent_application_byte_count(&self, path_index: u32) -> u64 {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_sent_application_byte_count(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> u64;
        }
        unsafe { nw_data_transfer_report_get_sent_application_byte_count(self, path_index) }
    }

    /// Retrieve the interface used for data transfer for a given
    /// path used by a connection.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns a retained nw_interface_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails if the report is not yet collected.
    #[doc(alias = "nw_data_transfer_report_copy_path_interface")]
    #[inline]
    pub fn path_interface(&self, path_index: u32) -> NWRetained<NWInterface> {
        extern "C-unwind" {
            fn nw_data_transfer_report_copy_path_interface(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> Option<NonNull<NWInterface>>;
        }
        let ret = unsafe { nw_data_transfer_report_copy_path_interface(self, path_index) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Retrieve the radio type used for data transfer for a given
    /// path used by a connection.
    ///
    ///
    /// Parameter `report`: A data transfer report in the "collected" state.
    ///
    ///
    /// Parameter `path_index`: The index for the path over which data is transferred.
    /// Passing NW_ALL_PATHS for this function is
    /// equivalent to passing 0.
    ///
    ///
    /// Returns: Returns the radio type used for the specified path.
    /// Returns nw_interface_radio_type_unknown on failure.
    /// Fails if the report is not yet collected.
    #[doc(alias = "nw_data_transfer_report_get_path_radio_type")]
    #[inline]
    pub fn path_radio_type(&self, path_index: u32) -> nw_interface_radio_type_t {
        extern "C-unwind" {
            fn nw_data_transfer_report_get_path_radio_type(
                report: &NWDataTransferReport,
                path_index: u32,
            ) -> nw_interface_radio_type_t;
        }
        unsafe { nw_data_transfer_report_get_path_radio_type(self, path_index) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwethernetchannel?language=objc)
#[doc(alias = "nw_ethernet_channel_t")]
#[repr(C)]
pub struct NWEthernetChannel {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWEthernetChannel {}
);

/// Channel states sent by nw_ethernet_channel_set_state_changed_handler.
/// States generally progress forward and do not move backwards, with the
/// exception of preparing and waiting, which may alternate before the channel
/// becomes ready or failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ethernet_channel_state_t(pub c_uint);
impl nw_ethernet_channel_state_t {
    /// will never be delivered in the channel's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_ethernet_channel_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_ethernet_channel_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_ethernet_channel_state_preparing")]
    pub const preparing: Self = Self(2);
    #[doc(alias = "nw_ethernet_channel_state_ready")]
    pub const ready: Self = Self(3);
    #[doc(alias = "nw_ethernet_channel_state_failed")]
    pub const failed: Self = Self(4);
    #[doc(alias = "nw_ethernet_channel_state_cancelled")]
    pub const cancelled: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ethernet_channel_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ethernet_channel_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWEthernetChannel {
    /// Creates an Ethernet channel with a custom EtherType.
    ///
    ///
    /// Parameter `ether_type`: The custom EtherType to be used for all Ethernet frames in this channel. The
    /// EtherType is the two-octet field in an Ethernet frame, indicating the protocol
    /// encapsulated in the payload of the frame.  This parameter is in little-endian
    /// byte order.  Only custom EtherType values are supported. This parameter cannot
    /// be an EtherType already handled by the system, such as IPv4, IPv6, ARP, VLAN Tag,
    /// or 802.1x.
    ///
    /// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
    /// entitlement.
    ///
    ///
    /// Parameter `interface`: The interface on which this custom Ethernet channel will be allowed.
    ///
    ///
    /// Returns: Returns an allocated nw_ethernet_channel_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_ethernet_channel_create")]
    #[inline]
    pub fn new(ether_type: u16, interface: &NWInterface) -> NWRetained<NWEthernetChannel> {
        extern "C-unwind" {
            fn nw_ethernet_channel_create(
                ether_type: u16,
                interface: &NWInterface,
            ) -> Option<NonNull<NWEthernetChannel>>;
        }
        let ret = unsafe { nw_ethernet_channel_create(ether_type, interface) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates an Ethernet channel with a custom EtherType and networking parameters
    ///
    ///
    /// Parameter `ether_type`: The custom EtherType to be used for all Ethernet frames in this channel. The
    /// EtherType is the two-octet field in an Ethernet frame, indicating the protocol
    /// encapsulated in the payload of the frame.  This parameter is in little-endian
    /// byte order.  Only custom EtherType values are supported. This parameter cannot
    /// be an EtherType already handled by the system, such as IPv4, IPv6, ARP, VLAN Tag,
    /// or 802.1x.
    ///
    /// Calling processes must hold the "com.apple.developer.networking.custom-protocol"
    /// entitlement.
    ///
    ///
    /// Parameter `interface`: The interface on which this custom Ethernet channel will be allowed.
    ///
    ///
    /// Parameter `parameters`: nw_parameters_t that allows caller to specify networking parameters such as custom context and queue.
    ///
    ///
    /// Returns: Returns an allocated nw_ethernet_channel_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_ethernet_channel_create_with_parameters")]
    #[inline]
    pub fn with_parameters(
        ether_type: u16,
        interface: &NWInterface,
        parameters: &NWParameters,
    ) -> NWRetained<NWEthernetChannel> {
        extern "C-unwind" {
            fn nw_ethernet_channel_create_with_parameters(
                ether_type: u16,
                interface: &NWInterface,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWEthernetChannel>>;
        }
        let ret = unsafe {
            nw_ethernet_channel_create_with_parameters(ether_type, interface, parameters)
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// A state change handler to handle state changes.
///
///
/// Parameter `state`: The current state.
///
///
/// Parameter `error`: error if present, indicates the reason of the failure.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_state_changed_handler_t?language=objc)
pub type nw_ethernet_channel_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_ethernet_channel_state_t, *mut NWError)>;

impl NWEthernetChannel {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// channel has been cancelled, the nw_ethernet_channel_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the channel state changes.
    /// Pass NULL to remove the state changed handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_ethernet_channel_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(
        &self,
        handler: nw_ethernet_channel_state_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_ethernet_channel_set_state_changed_handler(
                ethernet_channel: &NWEthernetChannel,
                handler: nw_ethernet_channel_state_changed_handler_t,
            );
        }
        unsafe { nw_ethernet_channel_set_state_changed_handler(self, handler) }
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_ethernet_channel_start().
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "nw_ethernet_channel_set_queue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_ethernet_channel_set_queue(
                ethernet_channel: &NWEthernetChannel,
                queue: &DispatchQueue,
            );
        }
        unsafe { nw_ethernet_channel_set_queue(self, queue) }
    }

    /// Returns the maximum payload size that can be written
    /// on the channel. Any payloads written must be less than
    /// or equal to this size.  Payloads exceeding this size will be
    /// dropped by 'nw_ethernet_channel_send()'.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    ///
    ///
    /// Returns: Returns a payload size based on the current MTU of the channel.
    #[doc(alias = "nw_ethernet_channel_get_maximum_payload_size")]
    #[inline]
    pub fn maximum_payload_size(&self) -> u32 {
        extern "C-unwind" {
            fn nw_ethernet_channel_get_maximum_payload_size(
                ethernet_channel: &NWEthernetChannel,
            ) -> u32;
        }
        unsafe { nw_ethernet_channel_get_maximum_payload_size(self) }
    }

    /// Starts the Ethernet channel, which will cause the channel to evaluate
    /// its path, and try to become readable and writable.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    #[doc(alias = "nw_ethernet_channel_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_ethernet_channel_start(ethernet_channel: &NWEthernetChannel);
        }
        unsafe { nw_ethernet_channel_start(self) }
    }

    /// Cancel the Ethernet channel. This will close the channel. The process of cancellation will be
    /// completed asynchronously, and the final callback event delivered to the caller will be
    /// a state update with a value of nw_ethernet_channel_state_cancelled. Once this update is
    /// delivered, the caller may clean up any associated memory or objects.
    ///
    /// Outstanding sends and receives will receive errors before the state changes to cancelled.
    /// There is no guarantee that any outstanding sends that have not yet delivered
    /// completion handlers will send data before the channel is closed.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object.
    #[doc(alias = "nw_ethernet_channel_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_ethernet_channel_cancel(ethernet_channel: &NWEthernetChannel);
        }
        unsafe { nw_ethernet_channel_cancel(self) }
    }
}

/// Address for an Ethernet Frame.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nwethernetaddress?language=objc)
#[doc(alias = "nw_ethernet_address_t")]
pub type NWEthernetAddress = [c_uchar; 6];

/// This receive handler is invoked when a frame of the set EtherType is received from the Ethernet
/// channel.
///
///
/// Parameter `content`: The received Ethernet payload, which has a length constrained by the maximum Ethernet frame size
/// of 1518 minus Ethernet header size of (18/14 bytes with/without vlan tag).
///
///
/// Parameter `vlan_tag`: The vlan tag of the frame, 0 if there is no vlan tag.  This parameter is in little-endian
/// byte order.
///
///
/// Parameter `local_address`: The local Ethernet address in the received Ethernet frame header.
///
///
/// Parameter `remote_address`: The remote Ethernet address in the received Ethernet frame header.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_receive_handler_t?language=objc)
#[cfg(feature = "dispatch2")]
pub type nw_ethernet_channel_receive_handler_t = *mut block2::DynBlock<
    dyn Fn(NonNull<DispatchData>, u16, NonNull<NWEthernetAddress>, NonNull<NWEthernetAddress>),
>;

impl NWEthernetChannel {
    /// Sets the Ethernet channel receive handler. Should be called before nw_ethernet_channel_start.
    ///
    ///
    /// Parameter `ethernet_channel`: The Ethernet channel object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the Ethernet channel receives a new frame.
    /// Pass NULL to remove the receive handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_ethernet_channel_set_receive_handler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_receive_handler(&self, handler: nw_ethernet_channel_receive_handler_t) {
        extern "C-unwind" {
            fn nw_ethernet_channel_set_receive_handler(
                ethernet_channel: &NWEthernetChannel,
                handler: nw_ethernet_channel_receive_handler_t,
            );
        }
        unsafe { nw_ethernet_channel_set_receive_handler(self, handler) }
    }
}

/// A send completion is invoked exactly once for a call to nw_ethernet_channel_send().
/// The completion indicates that the sent Ethernet frame has been processed by the stack
/// (not necessarily that it has left the host), or else an error has occurred during
/// sending.
///
///
/// Parameter `error`: An error will be sent if the associated frame could not be fully sent before an
/// error occurred. An error will be sent for any outstanding sends when the channel
/// is cancelled.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ethernet_channel_send_completion_t?language=objc)
pub type nw_ethernet_channel_send_completion_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

impl NWEthernetChannel {
    /// Send an Ethernet frame on a channel.  This must be called after the channel
    /// becomes ready.  This is an asynchronous send and the completion block can be used
    /// to determine when the send is complete.
    ///
    ///
    /// Parameter `ethernet_channel`: The ethernet_channel object on which to send frame.
    ///
    ///
    /// Parameter `content`: An Ethernet payload to send.
    ///
    ///
    /// Parameter `vlan_tag`: The vlan tag of the frame.  If vlan_tag is specified, the 802.1Q tag will be included.
    /// TPID will be set to 0x8100 followed by the specified 16-bit vlan_tag (only the highest
    /// 3-bit class of service field is supported.  The remaining 13 bits must be set to zero).
    /// Pass 0 to omit the vlan tag for this frame.
    ///
    ///
    /// Parameter `remote_address`: Remote Ethernet address for this Ethernet frame.  This is a required parameter.
    /// Note that the local Ethernet address will be the Ethernet address of the specified
    /// interface of this Ethernet channel.
    ///
    ///
    /// Parameter `completion`: A callback to be called when the data has been sent, or an error has occurred.
    /// This callback does not indicate that the remote side has acknowledged the data.
    /// This callback does indicate that the data has been sent.
    ///
    /// # Safety
    ///
    /// `completion` must be a valid pointer.
    #[doc(alias = "nw_ethernet_channel_send")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn send(
        &self,
        content: &DispatchData,
        vlan_tag: u16,
        remote_address: &mut NWEthernetAddress,
        completion: nw_ethernet_channel_send_completion_t,
    ) {
        extern "C-unwind" {
            fn nw_ethernet_channel_send(
                ethernet_channel: &NWEthernetChannel,
                content: &DispatchData,
                vlan_tag: u16,
                remote_address: &mut NWEthernetAddress,
                completion: nw_ethernet_channel_send_completion_t,
            );
        }
        unsafe { nw_ethernet_channel_send(self, content, vlan_tag, remote_address, completion) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwframer?language=objc)
#[doc(alias = "nw_framer_t")]
#[repr(C)]
pub struct NWFramer {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWFramer {}
);

/// A framer message is an instance of protocol metadata associated
/// with the definition of a framer, created by nw_framer_create_definition().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nwframermessage?language=objc)
#[doc(alias = "nw_framer_message_t")]
pub type NWFramerMessage = NWProtocolMetadata;

impl NWProtocolDefinition {
    /// Create an instance of a framer message on which per-
    /// message options can be configured when sending data
    /// on a connection. This is intended to be used by the
    /// application above the connection to send message data
    /// down to the framer protocol instance.
    ///
    ///
    /// Parameter `definition`: The framer protocol definition, as retrieved from
    /// nw_protocol_options_copy_definition() on the framer options.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object.
    #[doc(alias = "nw_framer_protocol_create_message")]
    #[inline]
    pub fn new_framer_message(&self) -> NWRetained<NWFramerMessage> {
        extern "C-unwind" {
            fn nw_framer_protocol_create_message(
                definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWFramerMessage>>;
        }
        let ret = unsafe { nw_framer_protocol_create_message(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is a framer protocol
    /// message. This indicates whether or not it is compatible
    /// with the framer message setters and accessors.
    ///
    ///
    /// Parameter `metadata`: The protocol metadata to check.
    ///
    ///
    /// Returns: Returns true if the metadata is associated with a framer
    /// protocol definition, false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_framer_message")]
    #[inline]
    pub fn is_framer_message(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_framer_message(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_framer_message(self) }
    }
}

impl NWFramer {
    /// Create a framer message, given a framer instance. This
    /// is intended to be used within the implementation of
    /// the framer protocol to create messages that are delivered
    /// as input to the application.
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Returns: Returns a retained framer message object.
    #[doc(alias = "nw_framer_message_create")]
    #[inline]
    pub fn new_message(&self) -> NWRetained<NWFramerMessage> {
        extern "C-unwind" {
            fn nw_framer_message_create(framer: &NWFramer) -> Option<NonNull<NWFramerMessage>>;
        }
        let ret = unsafe { nw_framer_message_create(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// A block to be invoked when a value stored in a framer message is disposed.
/// If the value was created using malloc(), for example, it should be freed here.
///
///
/// Parameter `value`: A pointer to the stored message value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_message_dispose_value_t?language=objc)
pub type nw_framer_message_dispose_value_t = *mut block2::DynBlock<dyn Fn(NonNull<c_void>)>;

impl NWFramerMessage {
    /// Set a key-value pair on a framer message, with a custom
    /// dispose function for the value.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A pointer to the value to store.
    ///
    ///
    /// Parameter `dispose_value`: A block to invoke to dispose the stored value.
    ///
    /// # Safety
    ///
    /// - `value` must be a valid pointer or null.
    /// - `dispose_value` must be a valid pointer or null.
    #[doc(alias = "nw_framer_message_set_value")]
    #[inline]
    pub unsafe fn framer_set_value(
        message: &NWFramerMessage,
        key: &CStr,
        value: *mut c_void,
        dispose_value: nw_framer_message_dispose_value_t,
    ) {
        extern "C-unwind" {
            fn nw_framer_message_set_value(
                message: &NWFramerMessage,
                key: NonNull<c_char>,
                value: *mut c_void,
                dispose_value: nw_framer_message_dispose_value_t,
            );
        }
        unsafe {
            nw_framer_message_set_value(
                message,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
                value,
                dispose_value,
            )
        }
    }

    /// Access the value with a key on a framer message.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `access_value`: A block to invoke inline with the pointer to the stored value.
    /// This pointer may be NULL if no value is stored for the key.
    ///
    ///
    /// Returns: Returns the boolean value returned by the access_value block,
    /// or else false if the parameters were invalid.
    #[doc(alias = "nw_framer_message_access_value")]
    #[inline]
    pub fn framer_access_value(
        message: &NWFramerMessage,
        key: &CStr,
        access_value: &block2::DynBlock<dyn Fn(*const c_void) -> bool>,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_message_access_value(
                message: &NWFramerMessage,
                key: NonNull<c_char>,
                access_value: &block2::DynBlock<dyn Fn(*const c_void) -> bool>,
            ) -> bool;
        }
        unsafe {
            nw_framer_message_access_value(
                message,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
                access_value,
            )
        }
    }

    /// Set a key-value pair on a framer message, where the
    /// value is a reference-counted object.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A reference counted object to store.
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "nw_framer_message_set_object_value")]
    #[cfg(feature = "objc2")]
    #[inline]
    pub unsafe fn framer_set_object_value(
        message: &NWFramerMessage,
        key: &CStr,
        value: Option<&AnyObject>,
    ) {
        extern "C-unwind" {
            fn nw_framer_message_set_object_value(
                message: &NWFramerMessage,
                key: NonNull<c_char>,
                value: Option<&AnyObject>,
            );
        }
        unsafe {
            nw_framer_message_set_object_value(
                message,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
                value,
            )
        }
    }

    /// Copy the stored object value using a key on a framer message.
    ///
    ///
    /// Parameter `message`: The framer message object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Returns: Returns a reference counted object with a +1 reference count,
    /// or NULL if no value was found for the specified key.
    #[doc(alias = "nw_framer_message_copy_object_value")]
    #[cfg(feature = "objc2")]
    #[inline]
    pub fn framer_copy_object_value(
        message: &NWFramerMessage,
        key: &CStr,
    ) -> Option<Retained<AnyObject>> {
        extern "C-unwind" {
            fn nw_framer_message_copy_object_value(
                message: &NWFramerMessage,
                key: NonNull<c_char>,
            ) -> *mut AnyObject;
        }
        let ret = unsafe {
            nw_framer_message_copy_object_value(
                message,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
            )
        };
        unsafe { Retained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_start_result_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_framer_start_result_t(pub c_uint);
impl nw_framer_start_result_t {
    #[doc(alias = "nw_framer_start_result_ready")]
    pub const ready: Self = Self(1);
    #[doc(alias = "nw_framer_start_result_will_mark_ready")]
    pub const will_mark_ready: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_framer_start_result_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_framer_start_result_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A block to be invoked when starting a new instance of the framer
/// protocol. This may occur more than once for a single nw_connection.
///
///
/// Parameter `framer`: A new instance of the framer protocol. This handle should be used
/// to set callbacks, such as with nw_framer_set_input_handler()
/// and nw_framer_set_output_handler(); and to perform actions, such
/// as nw_framer_deliver_input() and nw_framer_write_output().
///
///
/// Returns: Return whether or not the start should implicitly mark the protocol
/// as "ready" using nw_framer_start_result_ready, or that the protocol
/// will call nw_framer_mark_ready() later using
/// nw_framer_start_result_will_mark_ready.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_start_handler_t?language=objc)
pub type nw_framer_start_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>) -> nw_framer_start_result_t>;

impl NWProtocolDefinition {
    /// Create a protocol definition for a custom framer protocol.
    ///
    ///
    /// Parameter `identifier`: A string identifier used to name this framer protocol. This does not
    /// define uniqueness, and is primarily used for logging and debugging.
    ///
    ///
    /// Parameter `flags`: Flags to describe extended options on framer protocol behavior,
    /// all prefixed with "NW_FRAMER_CREATE_FLAGS_".
    ///
    ///
    /// Parameter `start_handler`: A block to be invoked when starting a new instance of the framer
    /// protocol. This may occur more than once for a single nw_connection.
    ///
    ///
    /// Returns: Returns a retained protocol definition that can be used with protocol
    /// options and metadata.
    ///
    /// # Safety
    ///
    /// `start_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_create_definition")]
    #[inline]
    pub unsafe fn framer(
        identifier: &CStr,
        flags: u32,
        start_handler: nw_framer_start_handler_t,
    ) -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_framer_create_definition(
                identifier: NonNull<c_char>,
                flags: u32,
                start_handler: nw_framer_start_handler_t,
            ) -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe {
            nw_framer_create_definition(
                NonNull::new(identifier.as_ptr().cast_mut()).unwrap(),
                flags,
                start_handler,
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolOptions {
    /// Create protocol options from a framer definition. This object can
    /// be added to an nw_protocol_stack_t to be used in an nw_connection_t
    /// or an nw_listener_t.
    ///
    ///
    /// Parameter `framer_definition`: A protocol definition created with nw_framer_create_definition().
    ///
    ///
    /// Returns: Returns a retained protocol options object to add into a protocol
    /// stack.
    #[doc(alias = "nw_framer_create_options")]
    #[inline]
    pub fn framer(framer_definition: &NWProtocolDefinition) -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_framer_create_options(
                framer_definition: &NWProtocolDefinition,
            ) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_framer_create_options(framer_definition) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Set a key-value pair on framer options, where the
    /// value is a reference-counted object.
    ///
    ///
    /// Parameter `options`: The framer options object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Parameter `value`: A reference counted object to store.
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "nw_framer_options_set_object_value")]
    #[cfg(feature = "objc2")]
    #[inline]
    pub unsafe fn framer_set_object_value(&self, key: &CStr, value: Option<&AnyObject>) {
        extern "C-unwind" {
            fn nw_framer_options_set_object_value(
                options: &NWProtocolOptions,
                key: NonNull<c_char>,
                value: Option<&AnyObject>,
            );
        }
        unsafe {
            nw_framer_options_set_object_value(
                self,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
                value,
            )
        }
    }

    /// Copy the stored object value using a key on framer options.
    ///
    ///
    /// Parameter `options`: The framer options object.
    ///
    ///
    /// Parameter `key`: The string key to identify the value.
    ///
    ///
    /// Returns: Returns a reference counted object with a +1 reference count,
    /// or NULL if no value was found for the specified key.
    #[doc(alias = "nw_framer_options_copy_object_value")]
    #[cfg(feature = "objc2")]
    #[inline]
    pub fn framer_copy_object_value(&self, key: &CStr) -> Option<Retained<AnyObject>> {
        extern "C-unwind" {
            fn nw_framer_options_copy_object_value(
                options: &NWProtocolOptions,
                key: NonNull<c_char>,
            ) -> *mut AnyObject;
        }
        let ret = unsafe {
            nw_framer_options_copy_object_value(
                self,
                NonNull::new(key.as_ptr().cast_mut()).unwrap(),
            )
        };
        unsafe { Retained::from_raw(ret) }
    }
}

/// A handler block to be invoked whenever new input
/// data is available to be parsed. When this block is
/// run, the implementation should call functions like
/// nw_framer_parse_input() and nw_framer_deliver_input().
///
/// Each invocation represents new data being available
/// to read from the network. This data may be insufficient
/// to complete a message, or may contain multiple messages.
/// Implementations are expected to try to parse messages
/// in a loop until parsing fails to read enough to continue.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Returns: Return a hint of the number of bytes that should be present
/// before invoking this handler again. Returning 0 indicates
/// that the handler should be invoked once any data is available.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_input_handler_t?language=objc)
pub type nw_framer_input_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>) -> usize>;

impl NWFramer {
    /// Set a handler block to be invoked whenever new input
    /// data is available to be parsed. When this block is
    /// run, the implementation should call functions like
    /// nw_framer_parse_input() and nw_framer_deliver_input().
    ///
    /// Input events are edge triggered. The input_handler block
    /// should continue to call nw_framer_parse_input()
    /// until nw_framer_parse_input() can no longer produce
    /// enough bytes to satisfy the request, or the protocol
    /// needs to wait for some other event to continue processing
    /// later.
    ///
    /// This setter is required, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `input_handler`: The block to invoke whenever new input data is available.
    ///
    /// # Safety
    ///
    /// `input_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_input_handler")]
    #[inline]
    pub unsafe fn set_input_handler(&self, input_handler: nw_framer_input_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_input_handler(
                framer: &NWFramer,
                input_handler: nw_framer_input_handler_t,
            );
        }
        unsafe { nw_framer_set_input_handler(self, input_handler) }
    }
}

/// A handler block to be invoked whenever an output
/// message is ready to be sent. When this block is
/// run, the implementation should call functions like
/// nw_framer_parse_output() and nw_framer_write_output().
///
/// Each invocation represents a single complete or partial
/// message that is being sent. The implementation is
/// expected to write this message or let it be dropped
/// in this handler.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Parameter `message`: The framer message being sent.
///
///
/// Parameter `message_length`: The length of the data associated with this message send.
/// If the message is not complete, the length represents the
/// partial message length being sent, which may be smaller
/// than the complete message length.
///
///
/// Parameter `is_complete`: A boolean indicating whether or not the message is now complete.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_output_handler_t?language=objc)
pub type nw_framer_output_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>, NonNull<NWFramerMessage>, usize, bool)>;

impl NWFramer {
    /// Set a handler block to be invoked whenever an output
    /// message is ready to be sent. When this block is
    /// run, the implementation should call functions like
    /// nw_framer_parse_output() and nw_framer_write_output().
    ///
    /// This setter is required, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `output_handler`: The block to invoke whenever a new output message is ready
    /// to be sent.
    ///
    /// # Safety
    ///
    /// `output_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_output_handler")]
    #[inline]
    pub unsafe fn set_output_handler(&self, output_handler: nw_framer_output_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_output_handler(
                framer: &NWFramer,
                output_handler: nw_framer_output_handler_t,
            );
        }
        unsafe { nw_framer_set_output_handler(self, output_handler) }
    }
}

/// A handler block to be invoked whenever the wakeup timer
/// set via nw_framer_schedule_wakeup() fires. This is intended to
/// be used for sending keepalives or other control traffic.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_wakeup_handler_t?language=objc)
pub type nw_framer_wakeup_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>)>;

impl NWFramer {
    /// Set a handler block to be invoked whenever the wakeup timer
    /// set via nw_framer_schedule_wakeup() fires. This is intended to
    /// be used for sending keepalives or other control traffic.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `wakeup_handler`: The block to invoke whenever the timeout set by
    /// nw_framer_schedule_wakeup() is reached.
    ///
    /// # Safety
    ///
    /// `wakeup_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_wakeup_handler")]
    #[inline]
    pub unsafe fn set_wakeup_handler(&self, wakeup_handler: nw_framer_wakeup_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_wakeup_handler(
                framer: &NWFramer,
                wakeup_handler: nw_framer_wakeup_handler_t,
            );
        }
        unsafe { nw_framer_set_wakeup_handler(self, wakeup_handler) }
    }
}

/// A handler block to be invoked when the connection
/// is being disconnected, to allow the framer implementation
/// a chance to send any final data.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
///
/// Returns: Return true if the framer is done and the connection
/// can be fully disconnected, or false the stop should
/// be delayed. If false, the implementation must later
/// call nw_framer_mark_failed_with_error().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_stop_handler_t?language=objc)
pub type nw_framer_stop_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>) -> bool>;

impl NWFramer {
    /// Set a handler block to be invoked when the connection
    /// is being disconnected, to allow the framer implementation
    /// a chance to send any final data.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `stop_handler`: The block to invoke when the connection is disconnected.
    ///
    /// # Safety
    ///
    /// `stop_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_stop_handler")]
    #[inline]
    pub unsafe fn set_stop_handler(&self, stop_handler: nw_framer_stop_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_stop_handler(
                framer: &NWFramer,
                stop_handler: nw_framer_stop_handler_t,
            );
        }
        unsafe { nw_framer_set_stop_handler(self, stop_handler) }
    }
}

/// A handler block to be invoked when the protocol stack
/// is being torn down and deallocated. This is the opportunity
/// for the framer implementation to release any state it may
/// have saved.
///
///
/// Parameter `framer`: The instance of the framer protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_cleanup_handler_t?language=objc)
pub type nw_framer_cleanup_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWFramer>)>;

impl NWFramer {
    /// Set a handler block to be invoked when the protocol stack
    /// is being torn down and deallocated. This is the opportunity
    /// for the framer implementation to release any state it may
    /// have saved.
    ///
    /// This setter is optional, and must only be set from within
    /// the invocation of a nw_framer_start_handler_t.
    ///
    ///
    /// Parameter `framer`: The framer instance object, passed via the
    /// nw_framer_start_handler_t block.
    ///
    ///
    /// Parameter `cleanup_handler`: The block to invoke when the protocol stack is being deallocated.
    ///
    /// # Safety
    ///
    /// `cleanup_handler` must be a valid pointer.
    #[doc(alias = "nw_framer_set_cleanup_handler")]
    #[inline]
    pub unsafe fn set_cleanup_handler(&self, cleanup_handler: nw_framer_cleanup_handler_t) {
        extern "C-unwind" {
            fn nw_framer_set_cleanup_handler(
                framer: &NWFramer,
                cleanup_handler: nw_framer_cleanup_handler_t,
            );
        }
        unsafe { nw_framer_set_cleanup_handler(self, cleanup_handler) }
    }

    /// Mark the connection associated with the framer instance
    /// as ready (see nw_connection_state_ready). This is intended
    /// to be used by protocols that require a handshake before being
    /// able to send application data. This should only be called
    /// if the return value to the nw_framer_start_handler_t block
    /// was nw_framer_start_result_will_call_ready.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    #[doc(alias = "nw_framer_mark_ready")]
    #[inline]
    pub fn mark_ready(&self) {
        extern "C-unwind" {
            fn nw_framer_mark_ready(framer: &NWFramer);
        }
        unsafe { nw_framer_mark_ready(self) }
    }

    /// Dynamically add a protocol to a connection establishment
    /// attempt "above" the framer protocol. This means that the
    /// protocol above will start running once the framer becomes
    /// ready by calling nw_framer_mark_ready(). This can only
    /// be used with framers that return a value of
    /// nw_framer_start_result_will_call_ready to their start
    /// handlers. An example of using this functionality is
    /// adding a security protocol, like TLS, above a framer
    /// once that framer completes its initial handshake.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `protocol_options`: Protocol options for an application protocol to dynamically
    /// add "above" the framer.
    ///
    ///
    /// Returns: Returns true if the protocol was successfully added,
    /// or false it it could not be added. This will fail if
    /// the framer is already marked ready.
    #[doc(alias = "nw_framer_prepend_application_protocol")]
    #[inline]
    pub fn prepend_application_protocol(&self, protocol_options: &NWProtocolOptions) -> bool {
        extern "C-unwind" {
            fn nw_framer_prepend_application_protocol(
                framer: &NWFramer,
                protocol_options: &NWProtocolOptions,
            ) -> bool;
        }
        unsafe { nw_framer_prepend_application_protocol(self, protocol_options) }
    }

    /// Mark the connection associated with the framer instance
    /// as failed (see nw_connection_state_failed).
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `error_code`: An error code to describe why the connection failed.
    #[doc(alias = "nw_framer_mark_failed_with_error")]
    #[inline]
    pub fn mark_failed_with_error(&self, error_code: c_int) {
        extern "C-unwind" {
            fn nw_framer_mark_failed_with_error(framer: &NWFramer, error_code: c_int);
        }
        unsafe { nw_framer_mark_failed_with_error(self, error_code) }
    }
}

/// A completion block that is invoked inline to parse available
/// bytes, either input or output. This is the way a framer can
/// access the underlying buffer for data being sent or received.
/// The block has a side effect of advancing the parsing cursor
/// by the number of bytes specified in the return value.
///
///
/// Parameter `buffer`: The buffer of bytes being sent or received.
///
///
/// Parameter `buffer_length`: The number of valid bytes in buffer.
///
///
/// Parameter `is_complete`: The boolean indicating if this section of the buffer indicates
/// the end of a message or stream.
///
///
/// Returns: Return the number of bytes by which to advance the input or
/// output cursor. For example, if nw_framer_parse_input() is called
/// and the completion returns 0, calling nw_framer_parse_input() again
/// will allow the implementation to start parsing again at the same
/// start location. However, if the completion returns 10, the next
/// call to nw_framer_parse_input() will return bytes starting from 10
/// bytes beyond the previous call.
///
/// The cursors also define the offsets at which data being delivered
/// or written using nw_framer_deliver_input_no_copy() and
/// nw_framer_write_output_no_copy() will start.
///
/// The returned value for incrementing the cursor may be larger than
/// the length of the buffer just parsed. This allows an implementation
/// to "skip" ahead by a number of bytes if it knows it does not
/// need to parse more.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_parse_completion_t?language=objc)
pub type nw_framer_parse_completion_t =
    *mut block2::DynBlock<dyn Fn(*mut u8, usize, bool) -> usize>;

impl NWFramer {
    /// Parse currently available input from the location of the input
    /// cursor in the stream or message being parsed.
    ///
    /// The parse completion block will always be invoked inline exactly once.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum number of bytes to parse. If this amount is
    /// not available, the parse completion block will be invoked
    /// with 0 bytes.
    ///
    ///
    /// Parameter `maximum_length`: The maximum number of bytes to parse as a contiguous buffer.
    /// If temp_buffer is not NULL, then this represents the length
    /// of valid bytes in temp_buffer.
    ///
    ///
    /// Parameter `temp_buffer`: A buffer provided by the caller to copy parse bytes into.
    /// If it is not NULL, it must have at least maximum_length bytes
    /// available, and any parsed bytes will be copied into the buffer.
    /// Any data stored in temp_buffer will be overwritten.
    /// If it is NULL, the buffer provided in the completion will not
    /// copy unless a copy is required to provide the minimum bytes
    /// as a contiguous buffer. The temp_buffer allows the caller to
    /// guarantee alignment properties of the buffer it parses.
    ///
    ///
    /// Parameter `parse`: The completion that provides the bytes to parse, which will
    /// be called exactly once.
    ///
    ///
    /// Returns: Returns true if the parse succeeded, or false if not enough
    /// bytes were available.
    ///
    /// # Safety
    ///
    /// - `temp_buffer` must be a valid pointer or null.
    /// - `parse` must be a valid pointer.
    #[doc(alias = "nw_framer_parse_input")]
    #[inline]
    pub unsafe fn parse_input(
        &self,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_parse_input(
                framer: &NWFramer,
                minimum_incomplete_length: usize,
                maximum_length: usize,
                temp_buffer: *mut u8,
                parse: nw_framer_parse_completion_t,
            ) -> bool;
        }
        unsafe {
            nw_framer_parse_input(
                self,
                minimum_incomplete_length,
                maximum_length,
                temp_buffer,
                parse,
            )
        }
    }

    /// Deliver arbitrary data to the application. This is intended to
    /// deliver any data that is generated or transformed by the
    /// protocol instance. It will incur a copy of bytes.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `input_buffer`: The bytes to deliver to the application. This must be non-NULL.
    /// If an empty message needs to be delivered, use
    /// nw_framer_deliver_input_no_copy().
    ///
    ///
    /// Parameter `input_length`: The length of input_buffer. This must be non-zero.
    ///
    ///
    /// Parameter `message`: The message to associate with the received data.
    ///
    ///
    /// Parameter `is_complete`: A boolean indicating whether or not this data represents
    /// the end of the message.
    ///
    /// # Safety
    ///
    /// `input_buffer` must be a valid pointer.
    #[doc(alias = "nw_framer_deliver_input")]
    #[inline]
    pub unsafe fn deliver_input(
        &self,
        input_buffer: NonNull<u8>,
        input_length: usize,
        message: &NWFramerMessage,
        is_complete: bool,
    ) {
        extern "C-unwind" {
            fn nw_framer_deliver_input(
                framer: &NWFramer,
                input_buffer: NonNull<u8>,
                input_length: usize,
                message: &NWFramerMessage,
                is_complete: bool,
            );
        }
        unsafe { nw_framer_deliver_input(self, input_buffer, input_length, message, is_complete) }
    }

    /// Deliver bytes directly to the application without any
    /// transformation or copy. The bytes will start at the current
    /// input cursor used for parsing, and will implicitly advance
    /// the cursor by the length being delivered.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `input_length`: The number of input bytes to deliver. This will advance
    /// the parsing cursor by the specified number of bytes.
    ///
    /// The length may be 0, which can be used to indicate the
    /// end of the message if is_complete is set.
    ///
    ///
    /// Parameter `message`: The message to associate with the received data.
    ///
    ///
    /// Parameter `is_complete`: A boolean indicating whether or not this data represents
    /// the end of the message.
    ///
    ///
    /// Returns: Returns true if the input was delivered immediately, or
    /// false if it will be delivered once more bytes become available.
    #[doc(alias = "nw_framer_deliver_input_no_copy")]
    #[inline]
    pub fn deliver_input_no_copy(
        &self,
        input_length: usize,
        message: &NWFramerMessage,
        is_complete: bool,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_deliver_input_no_copy(
                framer: &NWFramer,
                input_length: usize,
                message: &NWFramerMessage,
                is_complete: bool,
            ) -> bool;
        }
        unsafe { nw_framer_deliver_input_no_copy(self, input_length, message, is_complete) }
    }

    /// Mark the input side of the framer as a pass-through, which
    /// means the framer will not be notified of any further input
    /// data.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    #[doc(alias = "nw_framer_pass_through_input")]
    #[inline]
    pub fn pass_through_input(&self) {
        extern "C-unwind" {
            fn nw_framer_pass_through_input(framer: &NWFramer);
        }
        unsafe { nw_framer_pass_through_input(self) }
    }

    /// Parse currently available output from a message from the location
    /// of the output cursor in the message being parsed.
    ///
    /// The parse completion block will always be invoked inline exactly once.
    ///
    /// This function must only be called from within the output handler
    /// set with nw_framer_set_output_handler().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `minimum_incomplete_length`: The minimum number of bytes to parse. If this amount is
    /// not available, the parse completion block will be invoked
    /// with 0 bytes.
    ///
    ///
    /// Parameter `maximum_length`: The maximum number of bytes to parse as a contiguous buffer.
    /// If temp_buffer is not NULL, then this represents the length
    /// of valid bytes in temp_buffer.
    ///
    ///
    /// Parameter `temp_buffer`: A buffer provided by the caller to copy parse bytes into.
    /// If it is not NULL, it must have at least maximum_length bytes
    /// available, and any parsed bytes will be copied into the buffer.
    /// Any data stored in temp_buffer will be overwritten.
    /// If it is NULL, the buffer provided in the completion will not
    /// copy unless a copy is required to provide the minimum bytes
    /// as a contiguous buffer. The temp_buffer allows the caller to
    /// guarantee alignment properties of the buffer it parses.
    ///
    ///
    /// Parameter `parse`: The completion that provides the bytes to parse, which will
    /// be called exactly once.
    ///
    ///
    /// Returns: Returns true if the parse succeeded, or false if not enough
    /// bytes were available.
    ///
    /// # Safety
    ///
    /// - `temp_buffer` must be a valid pointer or null.
    /// - `parse` must be a valid pointer.
    #[doc(alias = "nw_framer_parse_output")]
    #[inline]
    pub unsafe fn parse_output(
        &self,
        minimum_incomplete_length: usize,
        maximum_length: usize,
        temp_buffer: *mut u8,
        parse: nw_framer_parse_completion_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_framer_parse_output(
                framer: &NWFramer,
                minimum_incomplete_length: usize,
                maximum_length: usize,
                temp_buffer: *mut u8,
                parse: nw_framer_parse_completion_t,
            ) -> bool;
        }
        unsafe {
            nw_framer_parse_output(
                self,
                minimum_incomplete_length,
                maximum_length,
                temp_buffer,
                parse,
            )
        }
    }

    /// Write arbitrary bytes as part of an outbound message. This
    /// is intended to be used for adding headers around application
    /// data, or writing any other data that is generated or transformed
    /// by the protocol instance. It does not pass along data directly
    /// from the application.
    ///
    /// This variant will copy bytes.
    ///
    /// This function may be called as part of any framer callback,
    /// not just the output handler.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_buffer`: The bytes to write.
    ///
    ///
    /// Parameter `output_length`: The length of output_buffer.
    ///
    /// # Safety
    ///
    /// `output_buffer` must be a valid pointer.
    #[doc(alias = "nw_framer_write_output")]
    #[inline]
    pub unsafe fn write_output(&self, output_buffer: NonNull<u8>, output_length: usize) {
        extern "C-unwind" {
            fn nw_framer_write_output(
                framer: &NWFramer,
                output_buffer: NonNull<u8>,
                output_length: usize,
            );
        }
        unsafe { nw_framer_write_output(self, output_buffer, output_length) }
    }

    /// Write arbitrary bytes as part of an outbound message. This
    /// is intended to be used for adding headers around application
    /// data, or writing any other data that is generated or transformed
    /// by the protocol instance. It does not pass along data directly
    /// from the application.
    ///
    /// This variant is the same as nw_framer_write_output(), but allows
    /// the implementation to pass its buffer as a dispatch_data_t to
    /// avoid a copy.
    ///
    /// This function may be called as part of any framer callback,
    /// not just the output handler.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_data`: A dispatch_data_t to write.
    #[doc(alias = "nw_framer_write_output_data")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub fn write_output_data(&self, output_data: &DispatchData) {
        extern "C-unwind" {
            fn nw_framer_write_output_data(framer: &NWFramer, output_data: &DispatchData);
        }
        unsafe { nw_framer_write_output_data(self, output_data) }
    }

    /// Write bytes directly from the application without any
    /// transformation or copy. The bytes will start at the current
    /// output cursor used for parsing, and will implicitly advance
    /// the cursor by the length being written.
    ///
    /// This function must only be called from within the output handler
    /// set with nw_framer_set_output_handler().
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `output_length`: The number of application bytes to write. This will advance
    /// the parsing cursor by the specified number of bytes.
    ///
    ///
    /// Returns: Returns true if the write could be completed, otherwise
    /// false if the call was made from an invalid context
    /// or with an invalid number of bytes.
    #[doc(alias = "nw_framer_write_output_no_copy")]
    #[inline]
    pub fn write_output_no_copy(&self, output_length: usize) -> bool {
        extern "C-unwind" {
            fn nw_framer_write_output_no_copy(framer: &NWFramer, output_length: usize) -> bool;
        }
        unsafe { nw_framer_write_output_no_copy(self, output_length) }
    }

    /// Mark the output side of the framer as a pass-through, which
    /// means the framer will not be notified of any further output
    /// data.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    #[doc(alias = "nw_framer_pass_through_output")]
    #[inline]
    pub fn pass_through_output(&self) {
        extern "C-unwind" {
            fn nw_framer_pass_through_output(framer: &NWFramer);
        }
        unsafe { nw_framer_pass_through_output(self) }
    }

    /// Schedule a wakeup on the framer instance for a number of
    /// milliseconds into the future. If this is called multiple
    /// times before the timeout is reached, the new value replaces
    /// the previous value.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `milliseconds`: The number of milliseconds into the future at which to
    /// invoke the wakeup handler. Pass the reserved value
    /// NW_FRAMER_WAKEUP_TIME_FOREVER to push the wakeup timer
    /// out to "forever", effectively unscheduling the timer.
    #[doc(alias = "nw_framer_schedule_wakeup")]
    #[inline]
    pub fn schedule_wakeup(&self, milliseconds: u64) {
        extern "C-unwind" {
            fn nw_framer_schedule_wakeup(framer: &NWFramer, milliseconds: u64);
        }
        unsafe { nw_framer_schedule_wakeup(self, milliseconds) }
    }
}

/// A block to perform actions on a framer's scheduling context.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_framer_block_t?language=objc)
pub type nw_framer_block_t = *mut block2::DynBlock<dyn Fn()>;

impl NWFramer {
    /// Schedule a block asynchronously on the framer instance. This
    /// must be used anytime the caller wants to perform any other
    /// action on the framer instance while not directly in the call stack
    /// of a callback from the framer.
    ///
    ///
    /// Parameter `framer`: The framer instance object.
    ///
    ///
    /// Parameter `async_block`: A block to execute on the correct scheduling context for the
    /// framer instance.
    ///
    /// # Safety
    ///
    /// `async_block` must be a valid pointer.
    #[doc(alias = "nw_framer_async")]
    #[inline]
    pub unsafe fn r#async(&self, async_block: nw_framer_block_t) {
        extern "C-unwind" {
            fn nw_framer_async(framer: &NWFramer, async_block: nw_framer_block_t);
        }
        unsafe { nw_framer_async(self, async_block) }
    }

    /// Access the remote endpoint being used for a given
    /// instance of a framer.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained endpoint object representing
    /// the remote side of a connection.
    #[doc(alias = "nw_framer_copy_remote_endpoint")]
    #[inline]
    pub fn remote_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_framer_copy_remote_endpoint(framer: &NWFramer) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_framer_copy_remote_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the local endpoint being used for a given
    /// instance of a framer.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained endpoint object representing
    /// the local side of a connection.
    #[doc(alias = "nw_framer_copy_local_endpoint")]
    #[inline]
    pub fn local_endpoint(&self) -> NWRetained<NWEndpoint> {
        extern "C-unwind" {
            fn nw_framer_copy_local_endpoint(framer: &NWFramer) -> Option<NonNull<NWEndpoint>>;
        }
        let ret = unsafe { nw_framer_copy_local_endpoint(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the parameters being used for a given
    /// instance of a framer.
    ///
    /// To ensure thread safety, this function can only be called
    /// in one of the callback blocks invoked on the framer, or
    /// in a block passed to nw_framer_async().
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained parameters object.
    #[doc(alias = "nw_framer_copy_parameters")]
    #[inline]
    pub fn parameters(&self) -> NWRetained<NWParameters> {
        extern "C-unwind" {
            fn nw_framer_copy_parameters(framer: &NWFramer) -> Option<NonNull<NWParameters>>;
        }
        let ret = unsafe { nw_framer_copy_parameters(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Access the protocol options being used for a given
    /// instance of a framer.
    ///
    ///
    /// Parameter `framer`: The framer instance.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_framer_copy_options")]
    #[inline]
    pub fn options(&self) -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_framer_copy_options(framer: &NWFramer) -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_framer_copy_options(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolDefinition {
    /// Access the definition of the default system protocol implementation
    /// of IP (Internet Protocol). This protocol can be used
    /// as part of a connection's protocol stack as the internet protocol.
    ///
    ///
    /// Returns: Returns a retained protocol definition object.
    #[doc(alias = "nw_protocol_copy_ip_definition")]
    #[inline]
    pub fn ip() -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_copy_ip_definition() -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_copy_ip_definition() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

/// A specific version of the Internet Protocol.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ip_version_t(pub c_uint);
impl nw_ip_version_t {
    #[doc(alias = "nw_ip_version_any")]
    pub const any: Self = Self(0);
    #[doc(alias = "nw_ip_version_4")]
    pub const version_4: Self = Self(4);
    #[doc(alias = "nw_ip_version_6")]
    pub const version_6: Self = Self(6);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_version_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolOptions {
    /// Specify a single version of the Internet Protocol to allow.
    /// Setting this value will constrain which address endpoints can
    /// be used, and will filter DNS results during connection establishment.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `version`: A specific, restricted IP version.
    #[doc(alias = "nw_ip_options_set_version")]
    #[inline]
    pub fn ip_set_version(&self, version: nw_ip_version_t) {
        extern "C-unwind" {
            fn nw_ip_options_set_version(options: &NWProtocolOptions, version: nw_ip_version_t);
        }
        unsafe { nw_ip_options_set_version(self, version) }
    }

    /// Configure the IP hop limit (or 'TTL' for IPv4).
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `hop_limit`: The hop limit to set on outgoing IP packets.
    #[doc(alias = "nw_ip_options_set_hop_limit")]
    #[inline]
    pub fn ip_set_hop_limit(&self, hop_limit: u8) {
        extern "C-unwind" {
            fn nw_ip_options_set_hop_limit(options: &NWProtocolOptions, hop_limit: u8);
        }
        unsafe { nw_ip_options_set_hop_limit(self, hop_limit) }
    }

    /// Configure IP to use the minimum MTU value, which
    /// is 1280 bytes for IPv6. This value has no effect for
    /// IPv4.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `use_minimum_mtu`: A boolean indicating that the IP should use
    /// its minimum MTU value.
    #[doc(alias = "nw_ip_options_set_use_minimum_mtu")]
    #[inline]
    pub fn ip_set_use_minimum_mtu(&self, use_minimum_mtu: bool) {
        extern "C-unwind" {
            fn nw_ip_options_set_use_minimum_mtu(
                options: &NWProtocolOptions,
                use_minimum_mtu: bool,
            );
        }
        unsafe { nw_ip_options_set_use_minimum_mtu(self, use_minimum_mtu) }
    }

    /// Configure IP to disable fragmentation on outgoing
    /// packets.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `disable_fragmentation`: A boolean indicating that the IP should use
    /// disable fragmentation on outgoing packets.
    #[doc(alias = "nw_ip_options_set_disable_fragmentation")]
    #[inline]
    pub fn ip_set_disable_fragmentation(&self, disable_fragmentation: bool) {
        extern "C-unwind" {
            fn nw_ip_options_set_disable_fragmentation(
                options: &NWProtocolOptions,
                disable_fragmentation: bool,
            );
        }
        unsafe { nw_ip_options_set_disable_fragmentation(self, disable_fragmentation) }
    }

    /// Configure IP to calculate receive time for inbound
    /// packets.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `calculate_receive_time`: A boolean indicating that the IP packets
    /// should mark their receive time in IP metadata.
    #[doc(alias = "nw_ip_options_set_calculate_receive_time")]
    #[inline]
    pub fn ip_set_calculate_receive_time(&self, calculate_receive_time: bool) {
        extern "C-unwind" {
            fn nw_ip_options_set_calculate_receive_time(
                options: &NWProtocolOptions,
                calculate_receive_time: bool,
            );
        }
        unsafe { nw_ip_options_set_calculate_receive_time(self, calculate_receive_time) }
    }
}

/// Preference for local addresses selection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_local_address_preference_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ip_local_address_preference_t(pub c_uint);
impl nw_ip_local_address_preference_t {
    #[doc(alias = "nw_ip_local_address_preference_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "nw_ip_local_address_preference_temporary")]
    pub const temporary: Self = Self(1);
    #[doc(alias = "nw_ip_local_address_preference_stable")]
    pub const stable: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_local_address_preference_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_local_address_preference_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolOptions {
    /// Specify a preference for how to select local addresses for outbound
    /// connections.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `preference`: Preference for how to select local addresses.
    #[doc(alias = "nw_ip_options_set_local_address_preference")]
    #[inline]
    pub fn ip_set_local_address_preference(&self, preference: nw_ip_local_address_preference_t) {
        extern "C-unwind" {
            fn nw_ip_options_set_local_address_preference(
                options: &NWProtocolOptions,
                preference: nw_ip_local_address_preference_t,
            );
        }
        unsafe { nw_ip_options_set_local_address_preference(self, preference) }
    }

    /// If a multicast packet is sent to a group to which the sending host itself
    /// belongs (on the outgoing interface), a copy of the datagram is, by default,
    /// looped back by the IP layer for local delivery.
    /// Setting the disable_multicast_loopback option disables this behavior and,
    /// if set, multicast packets will not be looped back to the sender.
    /// Only applies to multicast packets.
    ///
    ///
    /// Parameter `options`: An IP protocol options object.
    ///
    ///
    /// Parameter `disable_multicast_loopback`: If multicast loopback should be disabled.
    #[doc(alias = "nw_ip_options_set_disable_multicast_loopback")]
    #[inline]
    pub fn ip_set_disable_multicast_loopback(&self, disable_multicast_loopback: bool) {
        extern "C-unwind" {
            fn nw_ip_options_set_disable_multicast_loopback(
                options: &NWProtocolOptions,
                disable_multicast_loopback: bool,
            );
        }
        unsafe { nw_ip_options_set_disable_multicast_loopback(self, disable_multicast_loopback) }
    }
}

impl NWProtocolMetadata {
    /// Create an instance of IP metadata that can be used
    /// to configure per-packet options when sending data
    /// on a connection.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object.
    #[doc(alias = "nw_ip_create_metadata")]
    #[inline]
    pub fn ip() -> NWRetained<NWProtocolMetadata> {
        extern "C-unwind" {
            fn nw_ip_create_metadata() -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_ip_create_metadata() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of IP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system IP,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_ip")]
    #[inline]
    pub fn is_ip(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_ip(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_ip(self) }
    }
}

/// ECN flags marked in IP headers to indicate congestion.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ip_ecn_flag_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ip_ecn_flag_t(pub c_uint);
impl nw_ip_ecn_flag_t {
    #[doc(alias = "nw_ip_ecn_flag_non_ect")]
    pub const non_ect: Self = Self(0);
    #[doc(alias = "nw_ip_ecn_flag_ect_0")]
    pub const ect_0: Self = Self(2);
    #[doc(alias = "nw_ip_ecn_flag_ect_1")]
    pub const ect_1: Self = Self(1);
    #[doc(alias = "nw_ip_ecn_flag_ce")]
    pub const ce: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ip_ecn_flag_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ip_ecn_flag_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolMetadata {
    /// Sets ECN flags on IP metadata. This will take effect if
    /// applied to any sent content.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Parameter `ecn_flag`: The ECN flag to apply to packets.
    #[doc(alias = "nw_ip_metadata_set_ecn_flag")]
    #[inline]
    pub fn ip_set_ecn_flag(&self, ecn_flag: nw_ip_ecn_flag_t) {
        extern "C-unwind" {
            fn nw_ip_metadata_set_ecn_flag(
                metadata: &NWProtocolMetadata,
                ecn_flag: nw_ip_ecn_flag_t,
            );
        }
        unsafe { nw_ip_metadata_set_ecn_flag(self, ecn_flag) }
    }

    /// Gets ECN flags from IP metadata. This will be set only
    /// for metadata associated with received content.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Returns: Returns the ECN flag received from a packet.
    #[doc(alias = "nw_ip_metadata_get_ecn_flag")]
    #[inline]
    pub fn ip_ecn_flag(&self) -> nw_ip_ecn_flag_t {
        extern "C-unwind" {
            fn nw_ip_metadata_get_ecn_flag(metadata: &NWProtocolMetadata) -> nw_ip_ecn_flag_t;
        }
        unsafe { nw_ip_metadata_get_ecn_flag(self) }
    }

    /// Sets service class on IP metadata. This will not generally
    /// translate into TOS or Traffic Class bits unless the network
    /// explicitly supports it, but it will impact local queuing of
    /// packets.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Parameter `service_class`: The service class to apply to packets.
    #[doc(alias = "nw_ip_metadata_set_service_class")]
    #[inline]
    pub fn ip_set_service_class(&self, service_class: nw_service_class_t) {
        extern "C-unwind" {
            fn nw_ip_metadata_set_service_class(
                metadata: &NWProtocolMetadata,
                service_class: nw_service_class_t,
            );
        }
        unsafe { nw_ip_metadata_set_service_class(self, service_class) }
    }

    /// Gets service class from IP metadata. This reflects the value
    /// set using nw_ip_metadata_set_service_class. It will not
    /// be received from the network.
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Returns: Returns the service class set on a packet.
    #[doc(alias = "nw_ip_metadata_get_service_class")]
    #[inline]
    pub fn ip_service_class(&self) -> nw_service_class_t {
        extern "C-unwind" {
            fn nw_ip_metadata_get_service_class(
                metadata: &NWProtocolMetadata,
            ) -> nw_service_class_t;
        }
        unsafe { nw_ip_metadata_get_service_class(self) }
    }

    /// Access the time at which a packet was received. This is
    /// useful for calculating precise timing for round-trip-time
    /// estimates. Same as clock_gettime_nsec_np(CLOCK_MONOTONIC_RAW).
    ///
    /// The receive time will be 0 unless timestamps have been enabled
    /// using nw_ip_options_set_calculate_receive_time().
    ///
    ///
    /// Parameter `metadata`: An IP metadata object.
    ///
    ///
    /// Returns: Returns the time that the packet was received.
    #[doc(alias = "nw_ip_metadata_get_receive_time")]
    #[inline]
    pub fn ip_receive_time(&self) -> u64 {
        extern "C-unwind" {
            fn nw_ip_metadata_get_receive_time(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_ip_metadata_get_receive_time(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwlistener?language=objc)
#[doc(alias = "nw_listener_t")]
#[repr(C)]
pub struct NWListener {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWListener {}
);

/// Listener states sent by nw_listener_set_state_changed_handler.
/// States progress forward and do not move backwards.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_state_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_listener_state_t(pub c_uint);
impl nw_listener_state_t {
    /// will never be delivered in the listener's state update handler, and can be treated as
    /// an unexpected value.
    #[doc(alias = "nw_listener_state_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_listener_state_waiting")]
    pub const waiting: Self = Self(1);
    #[doc(alias = "nw_listener_state_ready")]
    pub const ready: Self = Self(2);
    #[doc(alias = "nw_listener_state_failed")]
    pub const failed: Self = Self(3);
    #[doc(alias = "nw_listener_state_cancelled")]
    pub const cancelled: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_listener_state_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_listener_state_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWListener {
    /// Creates a networking listener bound to a specified local port.
    ///
    ///
    /// Parameter `port`: A port number as a C string, such as "443", or a service
    /// name, such as "https".
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
    /// used for the listener.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_listener_create_with_port")]
    #[inline]
    pub fn with_port(port: &CStr, parameters: &NWParameters) -> Option<NWRetained<NWListener>> {
        extern "C-unwind" {
            fn nw_listener_create_with_port(
                port: NonNull<c_char>,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe {
            nw_listener_create_with_port(
                NonNull::new(port.as_ptr().cast_mut()).unwrap(),
                parameters,
            )
        };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Creates a network listener from a launchd key.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
    /// used for the listener. Since launchd creates the listening sockets, these
    /// parameters may not be applied in all cases.
    ///
    ///
    /// Parameter `launchd_key`: The name of the socket entry as specified in the launchd.plist.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    #[doc(alias = "nw_listener_create_with_launchd_key")]
    #[inline]
    pub fn with_launchd_key(
        parameters: &NWParameters,
        launchd_key: &CStr,
    ) -> NWRetained<NWListener> {
        extern "C-unwind" {
            fn nw_listener_create_with_launchd_key(
                parameters: &NWParameters,
                launchd_key: NonNull<c_char>,
            ) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe {
            nw_listener_create_with_launchd_key(
                parameters,
                NonNull::new(launchd_key.as_ptr().cast_mut()).unwrap(),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Creates a networking listener. The listener will be assigned a random
    /// port upon which to listen unless otherwise specified by the parameters.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. These include the protocols to be
    /// used for the listener.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_listener_create")]
    #[inline]
    pub fn new(parameters: &NWParameters) -> Option<NWRetained<NWListener>> {
        extern "C-unwind" {
            fn nw_listener_create(parameters: &NWParameters) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe { nw_listener_create(parameters) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Creates a networking listener based on an existing
    /// multiplexing connection. If there are multiple protocols
    /// in the connection that support listening for incoming flows,
    /// the listener will be hooked up the highest in the stack
    /// (the closest to the reading and writing of the client data).
    ///
    ///
    /// Parameter `connection`: An existing connection that has a multiplexing protocol
    /// that supports receiving new connections.
    ///
    ///
    /// Parameter `parameters`: The parameters to use for the listener. The protocol stack
    /// defined in the parameters must be able to join a protocol
    /// in the connection that supports listening protocols.
    ///
    ///
    /// Returns: Returns an allocated nw_listener_t object on success. Use nw_release() to deallocate.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_listener_create_with_connection")]
    #[inline]
    pub fn with_connection(
        connection: &NWConnection,
        parameters: &NWParameters,
    ) -> Option<NWRetained<NWListener>> {
        extern "C-unwind" {
            fn nw_listener_create_with_connection(
                connection: &NWConnection,
                parameters: &NWParameters,
            ) -> Option<NonNull<NWListener>>;
        }
        let ret = unsafe { nw_listener_create_with_connection(connection, parameters) };
        ret.map(|ret| unsafe { NWRetained::from_raw(ret) })
    }

    /// Sets the client callback queue, on which blocks for events will
    /// be scheduled. This must be done before calling nw_listener_start().
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `queue`: The client's dispatch queue.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "nw_listener_set_queue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_listener_set_queue(listener: &NWListener, queue: &DispatchQueue);
        }
        unsafe { nw_listener_set_queue(self, queue) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_state_changed_handler_t?language=objc)
pub type nw_listener_state_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(nw_listener_state_t, *mut NWError)>;

impl NWListener {
    /// Sets the state change handler. For clients that need to perform cleanup when the
    /// connection has been cancelled, the nw_listener_state_cancelled state will
    /// be delivered last.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The state changed handler to call when the listener state changes.
    /// Pass NULL to remove the event handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_state_changed_handler")]
    #[inline]
    pub unsafe fn set_state_changed_handler(&self, handler: nw_listener_state_changed_handler_t) {
        extern "C-unwind" {
            fn nw_listener_set_state_changed_handler(
                listener: &NWListener,
                handler: nw_listener_state_changed_handler_t,
            );
        }
        unsafe { nw_listener_set_state_changed_handler(self, handler) }
    }
}

/// The block called to notify client of a new connection.
///
///
/// Parameter `connection`: The new connection object. This connection is not yet started. Set the
/// event handler and other settings on the connection before calling start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_new_connection_handler_t?language=objc)
pub type nw_listener_new_connection_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWConnection>)>;

impl NWListener {
    /// Sets the client new connection handler. Must be called before
    /// nw_listener_start.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener receives a new connection.
    /// Pass NULL to remove the new connection handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_new_connection_handler")]
    #[inline]
    pub unsafe fn set_new_connection_handler(&self, handler: nw_listener_new_connection_handler_t) {
        extern "C-unwind" {
            fn nw_listener_set_new_connection_handler(
                listener: &NWListener,
                handler: nw_listener_new_connection_handler_t,
            );
        }
        unsafe { nw_listener_set_new_connection_handler(self, handler) }
    }
}

/// The block called to notify the client of a new connection group.
///
///
/// Parameter `connection_group`: The new connection group object. This connection group is not yet started. Set the
/// event handler and other settings on the connection group before calling start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_new_connection_group_handler_t?language=objc)
pub type nw_listener_new_connection_group_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWConnectionGroup>)>;

impl NWListener {
    /// Sets a new connection group handler to be called upon receiving an incoming
    /// connection that has a multiplexing protocol in its connected protocol stack.
    /// Must be called before nw_listener_start. Note that this handler is mutually
    /// exclusive with the new connection handler that is set via
    /// nw_listener_set_new_connection_handler. Only one of these handlers may
    /// be set at one time.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener receives a new connection group.
    /// Pass NULL to remove the new connection group handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_new_connection_group_handler")]
    #[inline]
    pub unsafe fn set_new_connection_group_handler(
        &self,
        handler: nw_listener_new_connection_group_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_listener_set_new_connection_group_handler(
                listener: &NWListener,
                handler: nw_listener_new_connection_group_handler_t,
            );
        }
        unsafe { nw_listener_set_new_connection_group_handler(self, handler) }
    }

    /// Gets the listener new connection limit. The default value is
    /// NW_LISTENER_INFINITE_CONNECTION_LIMIT which indicates that
    /// the listener should not limit incoming connections. If the value
    /// is not NW_LISTENER_INFINITE_CONNECTION_LIMIT, it will be decremented
    /// by 1 every time a new connection is created. When the value becomes
    /// 0, new connection handlers will no longer be invoked until
    /// nw_listener_set_new_connection_limit() is invoked with a value
    /// that is greater than 0. Incoming connections will eventually be rejected
    /// if nw_listener_set_new_connection_limit() is not called after the connection
    /// limit reaches 0.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Returns: Returns current new connection limit
    #[doc(alias = "nw_listener_get_new_connection_limit")]
    #[inline]
    pub fn new_connection_limit(&self) -> u32 {
        extern "C-unwind" {
            fn nw_listener_get_new_connection_limit(listener: &NWListener) -> u32;
        }
        unsafe { nw_listener_get_new_connection_limit(self) }
    }

    /// Sets the listener new connection limit. Use the value NW_LISTENER_INFINITE_CONNECTION_LIMIT
    /// to disable connection limits. If the value is not NW_LISTENER_INFINITE_CONNECTION_LIMIT,
    /// it will be decremented by 1 every time a new connection is created. When the value becomes
    /// 0, new connection handlers will no longer be invoked until
    /// nw_listener_set_new_connection_limit() is invoked with a value
    /// that is greater than 0. Incoming connections will eventually be rejected
    /// if nw_listener_set_new_connection_limit() is not called after the connection
    /// limit reaches 0.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `new_connection_limit`: The new connection limit. Pass NW_LISTENER_INFINITE_CONNECTION_LIMIT
    /// to disable new connection limiting.
    #[doc(alias = "nw_listener_set_new_connection_limit")]
    #[inline]
    pub fn set_new_connection_limit(&self, new_connection_limit: u32) {
        extern "C-unwind" {
            fn nw_listener_set_new_connection_limit(
                listener: &NWListener,
                new_connection_limit: u32,
            );
        }
        unsafe { nw_listener_set_new_connection_limit(self, new_connection_limit) }
    }

    /// Describes the bonjour service the listener should register. Setting the
    /// advertise descriptor more than once may be used to update the TXT record.
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `advertise_descriptor`: The advertise_descriptor or NULL to prevent or remove registration of a service.
    #[doc(alias = "nw_listener_set_advertise_descriptor")]
    #[inline]
    pub fn set_advertise_descriptor(&self, advertise_descriptor: Option<&NWAdvertiseDescriptor>) {
        extern "C-unwind" {
            fn nw_listener_set_advertise_descriptor(
                listener: &NWListener,
                advertise_descriptor: Option<&NWAdvertiseDescriptor>,
            );
        }
        unsafe { nw_listener_set_advertise_descriptor(self, advertise_descriptor) }
    }
}

/// A block called to notify client of a change in advertised endpoints.
///
///
/// Parameter `advertised_endpoint`: An endpoint that is has been added or removed from the list of advertised
/// endpoints for the listener.
///
///
/// Parameter `added`: A boolean indicating if the endpoint is being added or removed. If added,
/// the value with be true; if removed, the value will be false.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_listener_advertised_endpoint_changed_handler_t?language=objc)
pub type nw_listener_advertised_endpoint_changed_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWEndpoint>, bool)>;

impl NWListener {
    /// Sets the client advertised endpoint changed handler. The handler will be
    /// invoked for listeners which have called nw_listener_set_advertise_descriptor().
    ///
    ///
    /// Parameter `listener`: The listener object.
    ///
    ///
    /// Parameter `handler`: The event handler to call when the listener adds or removes an advertised endpoint.
    /// Pass NULL to remove the handler.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer or null.
    #[doc(alias = "nw_listener_set_advertised_endpoint_changed_handler")]
    #[inline]
    pub unsafe fn set_advertised_endpoint_changed_handler(
        &self,
        handler: nw_listener_advertised_endpoint_changed_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_listener_set_advertised_endpoint_changed_handler(
                listener: &NWListener,
                handler: nw_listener_advertised_endpoint_changed_handler_t,
            );
        }
        unsafe { nw_listener_set_advertised_endpoint_changed_handler(self, handler) }
    }

    /// Gets the local port as a number in host byte order. If the listener was created with a
    /// port of 0 (let the system assign a port), nw_listener_get_port will return 0 until the
    /// listener is in the ready state.
    ///
    ///
    /// Parameter `listener`: The listener to get the local port of.
    ///
    ///
    /// Returns: Returns a port in host byte order.
    #[doc(alias = "nw_listener_get_port")]
    #[inline]
    pub fn port(&self) -> u16 {
        extern "C-unwind" {
            fn nw_listener_get_port(listener: &NWListener) -> u16;
        }
        unsafe { nw_listener_get_port(self) }
    }

    /// Starts the listener, which will cause the listener
    /// to start listening for inbound connections.
    ///
    ///
    /// Parameter `listener`: The listener object.
    #[doc(alias = "nw_listener_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_listener_start(listener: &NWListener);
        }
        unsafe { nw_listener_start(self) }
    }

    /// Cancel the listener. This will de-register the listener from the system. The process
    /// of cancellation will be completed asynchronously, and the final callback event
    /// delivered to the caller will be a state update with a value of nw_listener_state_cancelled.
    /// Once this update is delivered, the caller may clean up any associated memory or objects.
    ///
    ///
    /// Parameter `listener`: The listener object.
    #[doc(alias = "nw_listener_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_listener_cancel(listener: &NWListener);
        }
        unsafe { nw_listener_cancel(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwpathmonitor?language=objc)
#[doc(alias = "nw_path_monitor_t")]
#[repr(C)]
pub struct NWPathMonitor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWPathMonitor {}
);

impl NWPathMonitor {
    /// Create a default path monitor, that will allow the enumeration of all available
    /// interfaces on the system.
    ///
    ///
    /// Returns: Returns an allocated nw_path_monitor_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_path_monitor_create")]
    #[inline]
    pub fn new() -> NWRetained<NWPathMonitor> {
        extern "C-unwind" {
            fn nw_path_monitor_create() -> Option<NonNull<NWPathMonitor>>;
        }
        let ret = unsafe { nw_path_monitor_create() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create a path monitor specific to an interface type, that will allow the enumeration
    /// of any interface that matches the type on the system.
    ///
    ///
    /// Parameter `required_interface_type`: An interface type that will filter any results that the path monitor returns.
    ///
    ///
    /// Returns: Returns an allocated nw_path_monitor_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure. Fails due to invalid parameters.
    #[doc(alias = "nw_path_monitor_create_with_type")]
    #[inline]
    pub fn with_type(required_interface_type: nw_interface_type_t) -> NWRetained<NWPathMonitor> {
        extern "C-unwind" {
            fn nw_path_monitor_create_with_type(
                required_interface_type: nw_interface_type_t,
            ) -> Option<NonNull<NWPathMonitor>>;
        }
        let ret = unsafe { nw_path_monitor_create_with_type(required_interface_type) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Create a path monitor that enumerates all interfaces that support
    /// Ethernet channel.
    ///
    ///
    /// Returns: Returns an allocated nw_path_monitor_t object on success.
    /// Callers are responsible for deallocating using nw_release(obj) or [obj release].
    /// These objects support ARC.
    /// Returns NULL on failure.
    #[doc(alias = "nw_path_monitor_create_for_ethernet_channel")]
    #[inline]
    pub fn new_for_ethernet_channel() -> NWRetained<NWPathMonitor> {
        extern "C-unwind" {
            fn nw_path_monitor_create_for_ethernet_channel() -> Option<NonNull<NWPathMonitor>>;
        }
        let ret = unsafe { nw_path_monitor_create_for_ethernet_channel() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Prohibit this path monitor from using the provided network interface type.
    /// Call before calling nw_path_monitor_start.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `interface_type`: The interface type to prohibit for the path monitor.
    #[doc(alias = "nw_path_monitor_prohibit_interface_type")]
    #[inline]
    pub fn prohibit_interface_type(&self, interface_type: nw_interface_type_t) {
        extern "C-unwind" {
            fn nw_path_monitor_prohibit_interface_type(
                monitor: &NWPathMonitor,
                interface_type: nw_interface_type_t,
            );
        }
        unsafe { nw_path_monitor_prohibit_interface_type(self, interface_type) }
    }
}

/// A block handler to be called when a path monitor is cancelled. This
/// is used to allow clients to release any objects they have retained in
/// association with the path monitor.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_cancel_handler_t?language=objc)
pub type nw_path_monitor_cancel_handler_t = *mut block2::DynBlock<dyn Fn()>;

impl NWPathMonitor {
    /// Set a handler to be called on the queue provided to nw_path_monitor_set_queue
    /// once cancellation has completed. Once the cancel handler has been called, the
    /// update handler will not fire again.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `cancel_handler`: The block to call upon cancellation. Pass NULL to remove the cancel handler.
    ///
    /// # Safety
    ///
    /// `cancel_handler` must be a valid pointer.
    #[doc(alias = "nw_path_monitor_set_cancel_handler")]
    #[inline]
    pub unsafe fn set_cancel_handler(&self, cancel_handler: nw_path_monitor_cancel_handler_t) {
        extern "C-unwind" {
            fn nw_path_monitor_set_cancel_handler(
                monitor: &NWPathMonitor,
                cancel_handler: nw_path_monitor_cancel_handler_t,
            );
        }
        unsafe { nw_path_monitor_set_cancel_handler(self, cancel_handler) }
    }
}

/// A block handler to be called whenever a path monitor has a new snapshot.
/// This will be called one or more times after calling nw_path_monitor_start.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_path_monitor_update_handler_t?language=objc)
pub type nw_path_monitor_update_handler_t = *mut block2::DynBlock<dyn Fn(NonNull<NWPath>)>;

impl NWPathMonitor {
    /// Sets the client update handler. This block will be called with the
    /// current path when start is called and any time the path changes.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `update_handler`: The block to call when the path changes.
    ///
    /// # Safety
    ///
    /// `update_handler` must be a valid pointer.
    #[doc(alias = "nw_path_monitor_set_update_handler")]
    #[inline]
    pub unsafe fn set_update_handler(&self, update_handler: nw_path_monitor_update_handler_t) {
        extern "C-unwind" {
            fn nw_path_monitor_set_update_handler(
                monitor: &NWPathMonitor,
                update_handler: nw_path_monitor_update_handler_t,
            );
        }
        unsafe { nw_path_monitor_set_update_handler(self, update_handler) }
    }

    /// Sets the client update queue. All blocks will be scheduled on
    /// this queue. Call before calling nw_path_monitor_start.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    ///
    ///
    /// Parameter `queue`: The dispatch queue on which to call the update and cancel handlers.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "nw_path_monitor_set_queue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn nw_path_monitor_set_queue(monitor: &NWPathMonitor, queue: &DispatchQueue);
        }
        unsafe { nw_path_monitor_set_queue(self, queue) }
    }

    /// Starts the path monitor.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    #[doc(alias = "nw_path_monitor_start")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn nw_path_monitor_start(monitor: &NWPathMonitor);
        }
        unsafe { nw_path_monitor_start(self) }
    }

    /// Cancel the path monitor.
    ///
    ///
    /// Parameter `monitor`: The path monitor object.
    #[doc(alias = "nw_path_monitor_cancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn nw_path_monitor_cancel(monitor: &NWPathMonitor);
        }
        unsafe { nw_path_monitor_cancel(self) }
    }
}

impl NWProtocolDefinition {
    /// Access the definition of the default system protocol implementation
    /// of QUIC. This protocol can be used as part of a
    /// connection's protocol stack as a transport protocol.
    ///
    ///
    /// Returns: Returns a retained protocol definition object.
    #[doc(alias = "nw_protocol_copy_quic_definition")]
    #[inline]
    pub fn quic() -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_copy_quic_definition() -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_copy_quic_definition() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolOptions {
    /// Create an instance of QUIC protocol options. This object can be added
    /// to an nw_protocol_stack_t to be used in an nw_connection_t or
    /// an nw_listener_t.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_quic_create_options")]
    #[inline]
    pub fn quic() -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_quic_create_options() -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_quic_create_options() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Checks whether the given protocol options define a QUIC protocol.
    ///
    ///
    /// Returns: Returns true if the protocol options are for QUIC, false otherwise.
    #[doc(alias = "nw_protocol_options_is_quic")]
    #[inline]
    pub fn is_quic(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_options_is_quic(options: &NWProtocolOptions) -> bool;
        }
        unsafe { nw_protocol_options_is_quic(self) }
    }

    /// Adds an Application-Layer Protocol Negotiation (ALPN) value to present in the TLS handshake.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    #[doc(alias = "nw_quic_add_tls_application_protocol")]
    #[inline]
    pub fn quic_add_tls_application(&self, application_protocol: &CStr) {
        extern "C-unwind" {
            fn nw_quic_add_tls_application_protocol(
                options: &NWProtocolOptions,
                application_protocol: NonNull<c_char>,
            );
        }
        unsafe {
            nw_quic_add_tls_application_protocol(
                self,
                NonNull::new(application_protocol.as_ptr().cast_mut()).unwrap(),
            )
        }
    }

    /// Returns whether or not a QUIC stream is unidirectional.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for a QUIC stream.
    ///
    ///
    /// Returns: True if the stream is unidirectional, false otherwise.
    #[doc(alias = "nw_quic_get_stream_is_unidirectional")]
    #[inline]
    pub fn quic_stream_is_unidirectional(&self) -> bool {
        extern "C-unwind" {
            fn nw_quic_get_stream_is_unidirectional(options: &NWProtocolOptions) -> bool;
        }
        unsafe { nw_quic_get_stream_is_unidirectional(self) }
    }

    /// Set whether or not a QUIC stream should be unidirectional.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for a QUIC stream.
    ///
    ///
    /// Parameter `is_unidirectional`: True if the stream is unidirectional, false otherwise.
    #[doc(alias = "nw_quic_set_stream_is_unidirectional")]
    #[inline]
    pub fn quic_set_stream_is_unidirectional(&self, is_unidirectional: bool) {
        extern "C-unwind" {
            fn nw_quic_set_stream_is_unidirectional(
                options: &NWProtocolOptions,
                is_unidirectional: bool,
            );
        }
        unsafe { nw_quic_set_stream_is_unidirectional(self, is_unidirectional) }
    }

    /// Get whether or not the QUIC stream is a QUIC datagram flow.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: is_datagram
    /// True if the QUIC stream is a QUIC datagram flow.
    #[doc(alias = "nw_quic_get_stream_is_datagram")]
    #[inline]
    pub fn quic_stream_is_datagram(&self) -> bool {
        extern "C-unwind" {
            fn nw_quic_get_stream_is_datagram(options: &NWProtocolOptions) -> bool;
        }
        unsafe { nw_quic_get_stream_is_datagram(self) }
    }

    /// Set whether or not the QUIC stream should be a QUIC datagram flow.
    /// Only one QUIC datagram flow can be created per connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `is_datagram`: A boolean to indicate whether or not the QUIC stream should be a QUIC datagram flow.
    #[doc(alias = "nw_quic_set_stream_is_datagram")]
    #[inline]
    pub fn quic_set_stream_is_datagram(&self, is_datagram: bool) {
        extern "C-unwind" {
            fn nw_quic_set_stream_is_datagram(options: &NWProtocolOptions, is_datagram: bool);
        }
        unsafe { nw_quic_set_stream_is_datagram(self, is_datagram) }
    }

    /// Get the initial_max_data transport parameter on a QUIC
    /// connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The initial_max_data that a client
    /// is willing to receive on a connection.
    #[doc(alias = "nw_quic_get_initial_max_data")]
    #[inline]
    pub fn quic_initial_max_data(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_initial_max_data(options: &NWProtocolOptions) -> u64;
        }
        unsafe { nw_quic_get_initial_max_data(self) }
    }

    /// Set the initial_max_data transport parameter on a QUIC
    /// connection. Setting this option requires
    /// initial_max_stream_data_bidirectional_local,
    /// initial_max_stream_data_bidirectional_remote and
    /// initial_max_stream_data_unidirectional also to be set.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_data`: The initial_max_data controls how much data, in bytes, a client
    /// is willing to receive on a connection.
    #[doc(alias = "nw_quic_set_initial_max_data")]
    #[inline]
    pub fn quic_set_initial_max_data(&self, initial_max_data: u64) {
        extern "C-unwind" {
            fn nw_quic_set_initial_max_data(options: &NWProtocolOptions, initial_max_data: u64);
        }
        unsafe { nw_quic_set_initial_max_data(self, initial_max_data) }
    }

    /// Get the maximum length of a QUIC packet (UDP payload)
    /// that the client is willing to receive on a connection, in bytes.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The max_udp_payload_size value, in bytes.
    #[doc(alias = "nw_quic_get_max_udp_payload_size")]
    #[inline]
    pub fn quic_max_udp_payload_size(&self) -> u16 {
        extern "C-unwind" {
            fn nw_quic_get_max_udp_payload_size(options: &NWProtocolOptions) -> u16;
        }
        unsafe { nw_quic_get_max_udp_payload_size(self) }
    }

    /// Define the maximum length of a QUIC packet (UDP payload)
    /// that the client is willing to receive on a connection, in bytes.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `max_udp_payload_size`: The max_udp_payload_size value, in bytes.
    #[doc(alias = "nw_quic_set_max_udp_payload_size")]
    #[inline]
    pub fn quic_set_max_udp_payload_size(&self, max_udp_payload_size: u16) {
        extern "C-unwind" {
            fn nw_quic_set_max_udp_payload_size(
                options: &NWProtocolOptions,
                max_udp_payload_size: u16,
            );
        }
        unsafe { nw_quic_set_max_udp_payload_size(self, max_udp_payload_size) }
    }

    /// Get the idle timeout value for the QUIC connection. If no packets are sent or received
    /// within this timeout, the QUIC connection will be closed.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The idle_timeout value, in milliseconds.
    #[doc(alias = "nw_quic_get_idle_timeout")]
    #[inline]
    pub fn quic_idle_timeout(&self) -> u32 {
        extern "C-unwind" {
            fn nw_quic_get_idle_timeout(options: &NWProtocolOptions) -> u32;
        }
        unsafe { nw_quic_get_idle_timeout(self) }
    }

    /// Define an idle timeout value for the QUIC connection. If no packets are sent or received
    /// within this timeout, the QUIC connection will be closed.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `idle_timeout`: The idle_timeout value, in milliseconds.
    #[doc(alias = "nw_quic_set_idle_timeout")]
    #[inline]
    pub fn quic_set_idle_timeout(&self, idle_timeout: u32) {
        extern "C-unwind" {
            fn nw_quic_set_idle_timeout(options: &NWProtocolOptions, idle_timeout: u32);
        }
        unsafe { nw_quic_set_idle_timeout(self, idle_timeout) }
    }

    /// Get the initial value of maximum bidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The initial value for the maximum concurrent bidirectional streams.
    #[doc(alias = "nw_quic_get_initial_max_streams_bidirectional")]
    #[inline]
    pub fn quic_initial_max_streams_bidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_initial_max_streams_bidirectional(options: &NWProtocolOptions) -> u64;
        }
        unsafe { nw_quic_get_initial_max_streams_bidirectional(self) }
    }

    /// Set the initial value of maximum bidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_streams_bidirectional`: The initial value for the maximum concurrent bidirectional streams.
    #[doc(alias = "nw_quic_set_initial_max_streams_bidirectional")]
    #[inline]
    pub fn quic_set_initial_max_streams_bidirectional(
        &self,
        initial_max_streams_bidirectional: u64,
    ) {
        extern "C-unwind" {
            fn nw_quic_set_initial_max_streams_bidirectional(
                options: &NWProtocolOptions,
                initial_max_streams_bidirectional: u64,
            );
        }
        unsafe {
            nw_quic_set_initial_max_streams_bidirectional(self, initial_max_streams_bidirectional)
        }
    }

    /// Get the initial value of maximum unidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: The initial value for the maximum concurrent unidirectional streams.
    #[doc(alias = "nw_quic_get_initial_max_streams_unidirectional")]
    #[inline]
    pub fn quic_initial_max_streams_unidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_initial_max_streams_unidirectional(options: &NWProtocolOptions) -> u64;
        }
        unsafe { nw_quic_get_initial_max_streams_unidirectional(self) }
    }

    /// Set the initial value of maximum unidirectional streams
    /// that the peer can initiate on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_streams_unidirectional`: The initial value for the maximum concurrent unidirectional streams.
    #[doc(alias = "nw_quic_set_initial_max_streams_unidirectional")]
    #[inline]
    pub fn quic_set_initial_max_streams_unidirectional(
        &self,
        initial_max_streams_unidirectional: u64,
    ) {
        extern "C-unwind" {
            fn nw_quic_set_initial_max_streams_unidirectional(
                options: &NWProtocolOptions,
                initial_max_streams_unidirectional: u64,
            );
        }
        unsafe {
            nw_quic_set_initial_max_streams_unidirectional(self, initial_max_streams_unidirectional)
        }
    }

    /// Get the initial_max_stream_data_bidi_local transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: How much data the client is willing to receive on a locally initiated stream.
    #[doc(alias = "nw_quic_get_initial_max_stream_data_bidirectional_local")]
    #[inline]
    pub fn quic_initial_max_stream_data_bidirectional_local(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_initial_max_stream_data_bidirectional_local(
                options: &NWProtocolOptions,
            ) -> u64;
        }
        unsafe { nw_quic_get_initial_max_stream_data_bidirectional_local(self) }
    }

    /// Set the initial_max_stream_data_bidi_local transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_stream_data_bidirectional_local`: The initial_max_stream_data_bidi_local controls how much data
    /// the client is willing to receive on a locally initiated stream.
    #[doc(alias = "nw_quic_set_initial_max_stream_data_bidirectional_local")]
    #[inline]
    pub fn quic_set_initial_max_stream_data_bidirectional_local(
        &self,
        initial_max_stream_data_bidirectional_local: u64,
    ) {
        extern "C-unwind" {
            fn nw_quic_set_initial_max_stream_data_bidirectional_local(
                options: &NWProtocolOptions,
                initial_max_stream_data_bidirectional_local: u64,
            );
        }
        unsafe {
            nw_quic_set_initial_max_stream_data_bidirectional_local(
                self,
                initial_max_stream_data_bidirectional_local,
            )
        }
    }

    /// Get the initial_max_stream_data_bidi_remote transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: How much data the client is willing to receive on a remotely initiated stream.
    #[doc(alias = "nw_quic_get_initial_max_stream_data_bidirectional_remote")]
    #[inline]
    pub fn quic_initial_max_stream_data_bidirectional_remote(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_initial_max_stream_data_bidirectional_remote(
                options: &NWProtocolOptions,
            ) -> u64;
        }
        unsafe { nw_quic_get_initial_max_stream_data_bidirectional_remote(self) }
    }

    /// Set the initial_max_stream_data_bidi_remote transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_stream_data_bidirectional_remote`: The initial_max_stream_data_bidi_remote controls how much data
    /// the client is willing to receive on a remotely initiated stream.
    #[doc(alias = "nw_quic_set_initial_max_stream_data_bidirectional_remote")]
    #[inline]
    pub fn quic_set_initial_max_stream_data_bidirectional_remote(
        &self,
        initial_max_stream_data_bidirectional_remote: u64,
    ) {
        extern "C-unwind" {
            fn nw_quic_set_initial_max_stream_data_bidirectional_remote(
                options: &NWProtocolOptions,
                initial_max_stream_data_bidirectional_remote: u64,
            );
        }
        unsafe {
            nw_quic_set_initial_max_stream_data_bidirectional_remote(
                self,
                initial_max_stream_data_bidirectional_remote,
            )
        }
    }

    /// Get the initial_max_stream_data_uni transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: How much data the client is willing to receive on a unidirectional stream.
    #[doc(alias = "nw_quic_get_initial_max_stream_data_unidirectional")]
    #[inline]
    pub fn quic_initial_max_stream_data_unidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_initial_max_stream_data_unidirectional(
                options: &NWProtocolOptions,
            ) -> u64;
        }
        unsafe { nw_quic_get_initial_max_stream_data_unidirectional(self) }
    }

    /// Set the initial_max_stream_data_uni transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `initial_max_stream_data_unidirectional`: The initial_max_stream_data_uni controls how much data
    /// the client is willing to receive on a unidirectional stream.
    #[doc(alias = "nw_quic_set_initial_max_stream_data_unidirectional")]
    #[inline]
    pub fn quic_set_initial_max_stream_data_unidirectional(
        &self,
        initial_max_stream_data_unidirectional: u64,
    ) {
        extern "C-unwind" {
            fn nw_quic_set_initial_max_stream_data_unidirectional(
                options: &NWProtocolOptions,
                initial_max_stream_data_unidirectional: u64,
            );
        }
        unsafe {
            nw_quic_set_initial_max_stream_data_unidirectional(
                self,
                initial_max_stream_data_unidirectional,
            )
        }
    }

    /// Get the max_datagram_frame_size transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Returns: If greater than zero, the max_datagram_frame_size value indicates that
    /// DATAGRAM frames are supported, and describes the maximum number
    /// of bytes that a single DATAGRAM frame can contain.
    #[doc(alias = "nw_quic_get_max_datagram_frame_size")]
    #[inline]
    pub fn quic_max_datagram_frame_size(&self) -> u16 {
        extern "C-unwind" {
            fn nw_quic_get_max_datagram_frame_size(options: &NWProtocolOptions) -> u16;
        }
        unsafe { nw_quic_get_max_datagram_frame_size(self) }
    }

    /// Set the max_datagram_frame_size transport parameter
    /// on a QUIC connection.
    ///
    ///
    /// Parameter `options`: An nw_protocol_options_t for QUIC.
    ///
    ///
    /// Parameter `max_datagram_frame_size`: If greater than zero, the max_datagram_frame_size value indicates that
    /// DATAGRAM frames are supported, and describes the maximum number
    /// of bytes that a single DATAGRAM frame can contain.
    #[doc(alias = "nw_quic_set_max_datagram_frame_size")]
    #[inline]
    pub fn quic_set_max_datagram_frame_size(&self, max_datagram_frame_size: u16) {
        extern "C-unwind" {
            fn nw_quic_set_max_datagram_frame_size(
                options: &NWProtocolOptions,
                max_datagram_frame_size: u16,
            );
        }
        unsafe { nw_quic_set_max_datagram_frame_size(self, max_datagram_frame_size) }
    }
}

/// Represents the type of a QUIC stream.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_quic_stream_type_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_quic_stream_type_t(pub c_uint);
impl nw_quic_stream_type_t {
    #[doc(alias = "nw_quic_stream_type_unknown")]
    pub const unknown: Self = Self(0);
    #[doc(alias = "nw_quic_stream_type_bidirectional")]
    pub const bidirectional: Self = Self(1);
    #[doc(alias = "nw_quic_stream_type_unidirectional")]
    pub const unidirectional: Self = Self(2);
    #[doc(alias = "nw_quic_stream_type_datagram")]
    pub const datagram: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_quic_stream_type_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_quic_stream_type_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of QUIC.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system QUIC,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_quic")]
    #[inline]
    pub fn is_quic(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_quic(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_quic(self) }
    }

    /// Get the QUIC stream ID.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Returns: Returns the QUIC stream id.
    #[doc(alias = "nw_quic_get_stream_id")]
    #[inline]
    pub fn quic_stream_id(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_stream_id(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_stream_id(self) }
    }

    /// Describes the type of the QUIC stream.
    ///
    ///
    /// Parameter `stream_metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Returns: Returns the type of the QUIC stream, stored in nw_quic_stream_type_t.
    /// If the type can not be determined, returns nw_quic_stream_type_unknown.
    #[doc(alias = "nw_quic_get_stream_type")]
    #[inline]
    pub fn quic_stream_type(&self) -> u8 {
        extern "C-unwind" {
            fn nw_quic_get_stream_type(stream_metadata: &NWProtocolMetadata) -> u8;
        }
        unsafe { nw_quic_get_stream_type(self) }
    }

    /// Access the Application Error value received from the peer in a stream close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Returns: Returns the Application Error code value received from by the peer,
    /// or UINT64_MAX if no error has been received.
    #[doc(alias = "nw_quic_get_stream_application_error")]
    #[inline]
    pub fn quic_stream_application_error(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_stream_application_error(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_stream_application_error(self) }
    }

    /// Set an Application Error value to send to the peer when the stream
    /// is closed.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for a QUIC stream.
    ///
    ///
    /// Parameter `application_error`: An application-specific error code value.
    #[doc(alias = "nw_quic_set_stream_application_error")]
    #[inline]
    pub fn quic_set_stream_application_error(&self, application_error: u64) {
        extern "C-unwind" {
            fn nw_quic_set_stream_application_error(
                metadata: &NWProtocolMetadata,
                application_error: u64,
            );
        }
        unsafe { nw_quic_set_stream_application_error(self, application_error) }
    }

    /// Get the most recent value of the maximum number of bidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's max number of bidirectional streams.
    #[doc(alias = "nw_quic_get_local_max_streams_bidirectional")]
    #[inline]
    pub fn quic_local_max_streams_bidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_local_max_streams_bidirectional(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_local_max_streams_bidirectional(self) }
    }

    /// Sets the maximum number of bidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `max_streams_bidirectional`: The new number of maximum bidirectional streams.
    #[doc(alias = "nw_quic_set_local_max_streams_bidirectional")]
    #[inline]
    pub fn quic_set_local_max_streams_bidirectional(&self, max_streams_bidirectional: u64) {
        extern "C-unwind" {
            fn nw_quic_set_local_max_streams_bidirectional(
                metadata: &NWProtocolMetadata,
                max_streams_bidirectional: u64,
            );
        }
        unsafe { nw_quic_set_local_max_streams_bidirectional(self, max_streams_bidirectional) }
    }

    /// Get the most recent value of the maximum number of unidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's max number of unidirectional streams.
    #[doc(alias = "nw_quic_get_local_max_streams_unidirectional")]
    #[inline]
    pub fn quic_local_max_streams_unidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_local_max_streams_unidirectional(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_local_max_streams_unidirectional(self) }
    }

    /// Sets the maximum number of unidirectional streams that the peer can create.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `max_streams_unidirectional`: The new number of maximum unidirectional streams.
    #[doc(alias = "nw_quic_set_local_max_streams_unidirectional")]
    #[inline]
    pub fn quic_set_local_max_streams_unidirectional(&self, max_streams_unidirectional: u64) {
        extern "C-unwind" {
            fn nw_quic_set_local_max_streams_unidirectional(
                metadata: &NWProtocolMetadata,
                max_streams_unidirectional: u64,
            );
        }
        unsafe { nw_quic_set_local_max_streams_unidirectional(self, max_streams_unidirectional) }
    }

    /// Get the maximum number of bidirectional streams advertised by peer that an application
    /// is allowed to create.
    ///
    /// Note that while attempts to create streams above this limit will
    /// be blocked until the server increases the limit, these blocked
    /// attempts will cause a STREAMS_BLOCKED frame to be sent to the
    /// server. This informs the server that the client has more streams
    /// it would like to create. As a result, the caller should attempt to
    /// create streams over this limit if it desires more streams.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's advertised max number of bidirectional streams.
    #[doc(alias = "nw_quic_get_remote_max_streams_bidirectional")]
    #[inline]
    pub fn quic_remote_max_streams_bidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_remote_max_streams_bidirectional(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_remote_max_streams_bidirectional(self) }
    }

    /// Get the maximum number of unidirectional streams advertised by peer that an application
    /// is allowed to create.
    ///
    /// Note that while attempts to create streams above this limit will
    /// be blocked until the server increases the limit, these blocked
    /// attempts will cause a STREAMS_BLOCKED frame to be sent to the
    /// server. This informs the server that the client has more streams
    /// it would like to create. As a result, the caller should attempt to
    /// create streams over this limit if it desires more streams.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the most recent value of the peer's advertised max number of unidirectional streams.
    #[doc(alias = "nw_quic_get_remote_max_streams_unidirectional")]
    #[inline]
    pub fn quic_remote_max_streams_unidirectional(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_remote_max_streams_unidirectional(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_remote_max_streams_unidirectional(self) }
    }

    /// Get the usable size of a datagram frame from a QUIC datagram flow.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the usable datagram frame size.
    #[doc(alias = "nw_quic_get_stream_usable_datagram_frame_size")]
    #[inline]
    pub fn quic_stream_usable_datagram_frame_size(&self) -> u16 {
        extern "C-unwind" {
            fn nw_quic_get_stream_usable_datagram_frame_size(metadata: &NWProtocolMetadata) -> u16;
        }
        unsafe { nw_quic_get_stream_usable_datagram_frame_size(self) }
    }

    /// Access the Application Error value received from the peer in a connection close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the Application Error code value received from by the peer,
    /// or UINT64_MAX if no    error has been received.
    #[doc(alias = "nw_quic_get_application_error")]
    #[inline]
    pub fn quic_application_error(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_application_error(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_application_error(self) }
    }

    /// Access the Application Error reason string received from the peer in a connection
    /// close message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the Application Error reason received from by the peer,
    /// or NULL if no error reason has been received.
    #[doc(alias = "nw_quic_get_application_error_reason")]
    #[inline]
    pub fn quic_application_error_reason(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_quic_get_application_error_reason(metadata: &NWProtocolMetadata)
                -> *const c_char;
        }
        unsafe { nw_quic_get_application_error_reason(self) }
    }

    /// Set the Application Error value to send to the peer in a connection close
    /// message.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `application_error`: Sets the Application Error code value.
    ///
    ///
    /// Parameter `reason`: An optional reason string to associate with the error.
    #[doc(alias = "nw_quic_set_application_error")]
    #[inline]
    pub fn quic_set_application_error(&self, application_error: u64, reason: Option<&CStr>) {
        extern "C-unwind" {
            fn nw_quic_set_application_error(
                metadata: &NWProtocolMetadata,
                application_error: u64,
                reason: *const c_char,
            );
        }
        unsafe {
            nw_quic_set_application_error(
                self,
                application_error,
                reason
                    .map(|ptr| ptr.as_ptr())
                    .unwrap_or_else(core::ptr::null),
            )
        }
    }

    /// Retrieves the keep-alive interval set on a QUIC connection.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns value of the keep-alive interval, in seconds,
    /// or 0 if the keep-alive timer is disabled.
    #[doc(alias = "nw_quic_get_keepalive_interval")]
    #[inline]
    pub fn quic_keepalive_interval(&self) -> u16 {
        extern "C-unwind" {
            fn nw_quic_get_keepalive_interval(metadata: &NWProtocolMetadata) -> u16;
        }
        unsafe { nw_quic_get_keepalive_interval(self) }
    }

    /// Changes the keep-alive interval for QUIC.
    ///
    ///
    /// QUIC connections are encrypted and operate over the UDP protocol
    /// which makes it hard for Network Address    Translators and firewalls
    /// to track their state. For this reason, these middleboxes may
    /// use short timeouts for QUIC flows. By sending keep-alive packets
    /// (QUIC PING frames), the endpoint can maintain
    /// state of the flow across the network.
    /// Keep-alives should only be enabled while there is an outstanding
    /// exchange of information with the remote endpoint that has not yet
    /// completed, it is not recommended to enable keep-alive packets on an
    /// idle connection that is not expecting to send or receive data in
    /// the near future.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Parameter `keepalive_interval`: The keep-alive interval for QUIC, in seconds,
    /// or 0 if the keep-alive timer is disabled.
    /// Pass `NW_QUIC_CONNECTION_DEFAULT_KEEPALIVE` to use the default
    /// keep-alive interval.
    #[doc(alias = "nw_quic_set_keepalive_interval")]
    #[inline]
    pub fn quic_set_keepalive_interval(&self, keepalive_interval: u16) {
        extern "C-unwind" {
            fn nw_quic_set_keepalive_interval(
                metadata: &NWProtocolMetadata,
                keepalive_interval: u16,
            );
        }
        unsafe { nw_quic_set_keepalive_interval(self, keepalive_interval) }
    }

    /// Access the idle_timeout value in milliseconds received from the peer
    /// in the transport parameters.
    ///
    ///
    /// Parameter `metadata`: A nw_protocol_metadata_t for QUIC.
    ///
    ///
    /// Returns: Returns the idle_timeout value in milliseconds received from the peer.
    #[doc(alias = "nw_quic_get_remote_idle_timeout")]
    #[inline]
    pub fn quic_remote_idle_timeout(&self) -> u64 {
        extern "C-unwind" {
            fn nw_quic_get_remote_idle_timeout(metadata: &NWProtocolMetadata) -> u64;
        }
        unsafe { nw_quic_get_remote_idle_timeout(self) }
    }
}

impl NWProtocolDefinition {
    /// Access the definition of the default system protocol implementation
    /// of TCP (Transmission Control Protocol). This protocol can be used
    /// as part of a connection's protocol stack as the transport protocol.
    ///
    ///
    /// Returns: Returns a retained protocol definition object.
    #[doc(alias = "nw_protocol_copy_tcp_definition")]
    #[inline]
    pub fn tcp() -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_copy_tcp_definition() -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_copy_tcp_definition() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolOptions {
    /// Create an instance of TCP protocol options. This object can be added
    /// to an nw_protocol_stack_t to be used in an nw_connection_t or
    /// an nw_listener_t.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_tcp_create_options")]
    #[inline]
    pub fn tcp() -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_tcp_create_options() -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_tcp_create_options() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Configure TCP to disable Nagle's algorithm, which will
    /// delay sending packets to coalesce sending.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `no_delay`: A boolean indicating that TCP should disable
    /// Nagle's algorithm.
    #[doc(alias = "nw_tcp_options_set_no_delay")]
    #[inline]
    pub fn tcp_set_no_delay(&self, no_delay: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_no_delay(options: &NWProtocolOptions, no_delay: bool);
        }
        unsafe { nw_tcp_options_set_no_delay(self, no_delay) }
    }

    /// Wait to send TCP data until the connection has finished
    /// writing, or else the TCP send buffer is full.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `no_push`: A boolean indicating that TCP should use no-push mode.
    #[doc(alias = "nw_tcp_options_set_no_push")]
    #[inline]
    pub fn tcp_set_no_push(&self, no_push: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_no_push(options: &NWProtocolOptions, no_push: bool);
        }
        unsafe { nw_tcp_options_set_no_push(self, no_push) }
    }

    /// Disable sending TCP options and extensions.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `no_options`: A boolean indicating that TCP should use no-options mode.
    #[doc(alias = "nw_tcp_options_set_no_options")]
    #[inline]
    pub fn tcp_set_no_options(&self, no_options: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_no_options(options: &NWProtocolOptions, no_options: bool);
        }
        unsafe { nw_tcp_options_set_no_options(self, no_options) }
    }

    /// Enable sending TCP keepalive probes.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `enable_keepalive`: A boolean indicating that TCP should send keepalives.
    #[doc(alias = "nw_tcp_options_set_enable_keepalive")]
    #[inline]
    pub fn tcp_set_enable_keepalive(&self, enable_keepalive: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_enable_keepalive(
                options: &NWProtocolOptions,
                enable_keepalive: bool,
            );
        }
        unsafe { nw_tcp_options_set_enable_keepalive(self, enable_keepalive) }
    }

    /// Configure the number of times TCP keepalive probes
    /// should be sent without reply before terminating
    /// the connection.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `keepalive_count`: The number of keepalive probes to send before terminating
    /// the connection.
    #[doc(alias = "nw_tcp_options_set_keepalive_count")]
    #[inline]
    pub fn tcp_set_keepalive_count(&self, keepalive_count: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_keepalive_count(
                options: &NWProtocolOptions,
                keepalive_count: u32,
            );
        }
        unsafe { nw_tcp_options_set_keepalive_count(self, keepalive_count) }
    }

    /// Configure the amount of time that a connection must be
    /// idle before TCP should start sending keepalive probes.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `keepalive_idle_time`: The number of seconds of idleness to wait before keepalive
    /// probes are sent by TCP.
    #[doc(alias = "nw_tcp_options_set_keepalive_idle_time")]
    #[inline]
    pub fn tcp_set_keepalive_idle_time(&self, keepalive_idle_time: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_keepalive_idle_time(
                options: &NWProtocolOptions,
                keepalive_idle_time: u32,
            );
        }
        unsafe { nw_tcp_options_set_keepalive_idle_time(self, keepalive_idle_time) }
    }

    /// Configure the amount of time between sending TCP keepalive
    /// probes when the peer is not responding.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `keepalive_interval`: The number of seconds of to wait before resending TCP
    /// keepalive probes.
    #[doc(alias = "nw_tcp_options_set_keepalive_interval")]
    #[inline]
    pub fn tcp_set_keepalive_interval(&self, keepalive_interval: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_keepalive_interval(
                options: &NWProtocolOptions,
                keepalive_interval: u32,
            );
        }
        unsafe { nw_tcp_options_set_keepalive_interval(self, keepalive_interval) }
    }

    /// Directly configure the maximum segment size (MSS)
    /// TCP will use.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `maximum_segment_size`: The maximum segment size in bytes.
    #[doc(alias = "nw_tcp_options_set_maximum_segment_size")]
    #[inline]
    pub fn tcp_set_maximum_segment_size(&self, maximum_segment_size: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_maximum_segment_size(
                options: &NWProtocolOptions,
                maximum_segment_size: u32,
            );
        }
        unsafe { nw_tcp_options_set_maximum_segment_size(self, maximum_segment_size) }
    }

    /// Define a timeout value after which TCP connection
    /// establishment will give up.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `connection_timeout`: A timeout for TCP connection establishment, in seconds.
    #[doc(alias = "nw_tcp_options_set_connection_timeout")]
    #[inline]
    pub fn tcp_set_connection_timeout(&self, connection_timeout: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_connection_timeout(
                options: &NWProtocolOptions,
                connection_timeout: u32,
            );
        }
        unsafe { nw_tcp_options_set_connection_timeout(self, connection_timeout) }
    }

    /// Define a timeout value after which TCP connections
    /// in the persist state will terminate. See RFC 6429.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `persist_timeout`: The TCP persist timeout, in seconds.
    #[doc(alias = "nw_tcp_options_set_persist_timeout")]
    #[inline]
    pub fn tcp_set_persist_timeout(&self, persist_timeout: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_persist_timeout(
                options: &NWProtocolOptions,
                persist_timeout: u32,
            );
        }
        unsafe { nw_tcp_options_set_persist_timeout(self, persist_timeout) }
    }

    /// Define a timeout value after which TCP will drop
    /// a connection with unacknowledged retransmissions.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `retransmit_connection_drop_time`: A timeout for TCP retransmission attempts, in seconds.
    #[doc(alias = "nw_tcp_options_set_retransmit_connection_drop_time")]
    #[inline]
    pub fn tcp_set_retransmit_connection_drop_time(&self, retransmit_connection_drop_time: u32) {
        extern "C-unwind" {
            fn nw_tcp_options_set_retransmit_connection_drop_time(
                options: &NWProtocolOptions,
                retransmit_connection_drop_time: u32,
            );
        }
        unsafe {
            nw_tcp_options_set_retransmit_connection_drop_time(
                self,
                retransmit_connection_drop_time,
            )
        }
    }

    /// Cause TCP to drop connections after not receiving
    /// an ACK multiple times after a FIN, currently set at three.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `retransmit_fin_drop`: A boolean to cause TCP to drop its connection after
    /// not receiving an ACK after a FIN.
    #[doc(alias = "nw_tcp_options_set_retransmit_fin_drop")]
    #[inline]
    pub fn tcp_set_retransmit_fin_drop(&self, retransmit_fin_drop: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_retransmit_fin_drop(
                options: &NWProtocolOptions,
                retransmit_fin_drop: bool,
            );
        }
        unsafe { nw_tcp_options_set_retransmit_fin_drop(self, retransmit_fin_drop) }
    }

    /// Configure TCP to disable ACK stretching. ACKs will be sent
    /// for every other data packet.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `disable_ack_stretching`: A boolean to cause TCP to disable ACK stretching.
    #[doc(alias = "nw_tcp_options_set_disable_ack_stretching")]
    #[inline]
    pub fn tcp_set_disable_ack_stretching(&self, disable_ack_stretching: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_disable_ack_stretching(
                options: &NWProtocolOptions,
                disable_ack_stretching: bool,
            );
        }
        unsafe { nw_tcp_options_set_disable_ack_stretching(self, disable_ack_stretching) }
    }

    /// Configure TCP to enable TCP Fast Open (TFO). This may take effect
    /// even when TCP is not the top-level protocol in the protocol stack.
    /// For example, if TLS is running over TCP, the Client Hello message
    /// may be sent as fast open data.
    ///
    /// If TCP is the top-level protocol in the stack (the one the application
    /// directly interacts with), TFO will be disabled unless the application
    /// indicated that it will provide its own fast open data by calling
    /// nw_parameters_set_fast_open_enabled().
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `enable_fast_open`: A boolean to enable TFO.
    #[doc(alias = "nw_tcp_options_set_enable_fast_open")]
    #[inline]
    pub fn tcp_set_enable_fast_open(&self, enable_fast_open: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_enable_fast_open(
                options: &NWProtocolOptions,
                enable_fast_open: bool,
            );
        }
        unsafe { nw_tcp_options_set_enable_fast_open(self, enable_fast_open) }
    }

    /// Configure TCP to disable default Explicit Congestion
    /// Notification (ECN) behavior.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `disable_ecn`: A boolean to disable ECN support in TCP.
    #[doc(alias = "nw_tcp_options_set_disable_ecn")]
    #[inline]
    pub fn tcp_set_disable_ecn(&self, disable_ecn: bool) {
        extern "C-unwind" {
            fn nw_tcp_options_set_disable_ecn(options: &NWProtocolOptions, disable_ecn: bool);
        }
        unsafe { nw_tcp_options_set_disable_ecn(self, disable_ecn) }
    }
}

/// Multipath versions represent the MPTCP standard versions
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_multipath_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_multipath_version_t(pub c_int);
impl nw_multipath_version_t {
    #[doc(alias = "nw_multipath_version_unspecified")]
    pub const unspecified: Self = Self(-1);
    #[doc(alias = "nw_multipath_version_0")]
    pub const version_0: Self = Self(0);
    #[doc(alias = "nw_multipath_version_1")]
    pub const version_1: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_multipath_version_t {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_multipath_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolOptions {
    /// Configure MPTCP to use a specified MPTCP standard version.
    /// This ignores the cached value from MPTCP version discovery.
    ///
    ///
    /// Parameter `options`: A TCP protocol options object.
    ///
    ///
    /// Parameter `multipath_force_version`: The MPTCP version.
    #[doc(alias = "nw_tcp_options_set_multipath_force_version")]
    #[inline]
    pub fn tcp_set_multipath_force_version(&self, multipath_force_version: nw_multipath_version_t) {
        extern "C-unwind" {
            fn nw_tcp_options_set_multipath_force_version(
                options: &NWProtocolOptions,
                multipath_force_version: nw_multipath_version_t,
            );
        }
        unsafe { nw_tcp_options_set_multipath_force_version(self, multipath_force_version) }
    }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of TCP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system TCP,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_tcp")]
    #[inline]
    pub fn is_tcp(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_tcp(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_tcp(self) }
    }

    /// Fetch the number of bytes waiting to be read from the receive buffer.
    ///
    ///
    /// Returns: The number of bytes available in the receive buffer.
    #[doc(alias = "nw_tcp_get_available_receive_buffer")]
    #[inline]
    pub fn tcp_available_receive_buffer(&self) -> u32 {
        extern "C-unwind" {
            fn nw_tcp_get_available_receive_buffer(metadata: &NWProtocolMetadata) -> u32;
        }
        unsafe { nw_tcp_get_available_receive_buffer(self) }
    }

    /// Fetch the number of bytes waiting to be acknowledged in the send buffer.
    ///
    ///
    /// Returns: The number of bytes waiting to be acknowledged.
    #[doc(alias = "nw_tcp_get_available_send_buffer")]
    #[inline]
    pub fn tcp_available_send_buffer(&self) -> u32 {
        extern "C-unwind" {
            fn nw_tcp_get_available_send_buffer(metadata: &NWProtocolMetadata) -> u32;
        }
        unsafe { nw_tcp_get_available_send_buffer(self) }
    }
}

impl NWProtocolDefinition {
    /// Access the definition of the default system protocol implementation
    /// of TLS (Transport Layer Security). This protocol can be used
    /// as part of a connection's protocol stack as an application protocol.
    ///
    ///
    /// Returns: Returns a retained protocol definition object.
    #[doc(alias = "nw_protocol_copy_tls_definition")]
    #[inline]
    pub fn tls() -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_copy_tls_definition() -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_copy_tls_definition() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolOptions {
    /// Create an instance of TLS protocol options. This object can be added
    /// to an nw_protocol_stack_t to be used in an nw_connection_t or
    /// an nw_listener_t.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_tls_create_options")]
    #[inline]
    pub fn tls() -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_tls_create_options() -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_tls_create_options() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of TLS.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system TLS,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_tls")]
    #[inline]
    pub fn is_tls(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_tls(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_tls(self) }
    }
}

impl NWProtocolDefinition {
    /// Access the definition of the default system protocol implementation
    /// of UDP (User Datagram Protocol). This protocol can be used
    /// as part of a connection's protocol stack as the transport protocol.
    ///
    ///
    /// Returns: Returns a retained protocol definition object.
    #[doc(alias = "nw_protocol_copy_udp_definition")]
    #[inline]
    pub fn udp() -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_copy_udp_definition() -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_copy_udp_definition() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolOptions {
    /// Create an instance of UDP protocol options. This object can be added
    /// to an nw_protocol_stack_t to be used in an nw_connection_t or
    /// an nw_listener_t.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_udp_create_options")]
    #[inline]
    pub fn udp() -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_udp_create_options() -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_udp_create_options() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Configure UDP to skip computing checksums when sending.
    /// This will only take effect when running over IPv4.
    ///
    ///
    /// Parameter `options`: A UDP protocol options object.
    ///
    ///
    /// Parameter `prefer_no_checksum`: A boolean that indicates if UDP is allowed to skip computing
    /// its checksum.
    #[doc(alias = "nw_udp_options_set_prefer_no_checksum")]
    #[inline]
    pub fn udp_set_prefer_no_checksum(&self, prefer_no_checksum: bool) {
        extern "C-unwind" {
            fn nw_udp_options_set_prefer_no_checksum(
                options: &NWProtocolOptions,
                prefer_no_checksum: bool,
            );
        }
        unsafe { nw_udp_options_set_prefer_no_checksum(self, prefer_no_checksum) }
    }
}

impl NWProtocolMetadata {
    /// Create an instance of UDP metadata that can be used
    /// to configure per-datagram options when sending data
    /// on a connection.
    ///
    ///
    /// Returns: Returns a retained protocol metadata object.
    #[doc(alias = "nw_udp_create_metadata")]
    #[inline]
    pub fn udp() -> NWRetained<NWProtocolMetadata> {
        extern "C-unwind" {
            fn nw_udp_create_metadata() -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_udp_create_metadata() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of UDP.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system UDP,
    /// false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_udp")]
    #[inline]
    pub fn is_udp(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_udp(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_udp(self) }
    }
}

/// WebSocket opcodes that denote the type of frame sent or received by
/// a WebSocket endpoint. Opcodes define the interpretation of their
/// associated payload data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_opcode_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ws_opcode_t(pub c_int);
impl nw_ws_opcode_t {
    #[doc(alias = "nw_ws_opcode_invalid")]
    pub const invalid: Self = Self(-1);
    /// Protocol WebSocket handles continuation frames internally,
    /// so clients will not see or use continuation frames.
    #[doc(alias = "nw_ws_opcode_cont")]
    pub const cont: Self = Self(0x0);
    #[doc(alias = "nw_ws_opcode_text")]
    pub const text: Self = Self(0x1);
    #[doc(alias = "nw_ws_opcode_binary")]
    pub const binary: Self = Self(0x2);
    #[doc(alias = "nw_ws_opcode_close")]
    pub const close: Self = Self(0x8);
    #[doc(alias = "nw_ws_opcode_ping")]
    pub const ping: Self = Self(0x9);
    #[doc(alias = "nw_ws_opcode_pong")]
    pub const pong: Self = Self(0xA);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_opcode_t {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_opcode_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// WebSocket close codes that describe the reason for closing a WebSocket
/// connection. Endpoints MAY use the following pre-defined status codes
/// when sending a Close frame.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_close_code_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct nw_ws_close_code_t(pub c_uint);
impl nw_ws_close_code_t {
    /// meaning that the purpose for which the connection was established
    /// has been fulfilled.
    #[doc(alias = "nw_ws_close_code_normal_closure")]
    pub const normal_closure: Self = Self(1000);
    /// "going away", such as a server going down or a browser having
    /// navigated away from a page.
    #[doc(alias = "nw_ws_close_code_going_away")]
    pub const going_away: Self = Self(1001);
    /// terminating the connection due to a protocol error.
    #[doc(alias = "nw_ws_close_code_protocol_error")]
    pub const protocol_error: Self = Self(1002);
    /// terminating the connection because it has received a type of data
    /// it cannot accept (e.g., an endpoint that understands only text data
    /// MAY send this if it receives a binary message).
    #[doc(alias = "nw_ws_close_code_unsupported_data")]
    pub const unsupported_data: Self = Self(1003);
    /// be set as a status code in a Close control frame by an endpoint. It
    /// is designated for use in applications expecting a status code to
    /// indicate that no status code was actually present.
    #[doc(alias = "nw_ws_close_code_no_status_received")]
    pub const no_status_received: Self = Self(1005);
    /// be set as a status code in a Close control frame by an endpoint.
    /// It is designated for use in applications expecting a status code to
    /// indicate that the connection was closed abnormally, e.g., without
    /// sending or receiving a Close control frame.
    #[doc(alias = "nw_ws_close_code_abnormal_closure")]
    pub const abnormal_closure: Self = Self(1006);
    /// endpoint is terminating the connection because it has received data
    /// within a message that was not consistent with the type of the
    /// message (e.g., non-UTF-8 [RFC3629] data within a text message).
    #[doc(alias = "nw_ws_close_code_invalid_frame_payload_data")]
    pub const invalid_frame_payload_data: Self = Self(1007);
    /// terminating the connection because it has received a message that
    /// violates its policy. This is a generic status code that can be
    /// returned when there is no other more suitable status code (e.g.,
    /// 1003 or 1009) or if there is a need to hide specific details about
    /// the policy.
    #[doc(alias = "nw_ws_close_code_policy_violation")]
    pub const policy_violation: Self = Self(1008);
    /// terminating the connection because it has received a message that
    /// is too big for it to process.
    #[doc(alias = "nw_ws_close_code_message_too_big")]
    pub const message_too_big: Self = Self(1009);
    /// (client) is terminating the connection because it has expected the
    /// server to negotiate one or more extensions, but the server didn't
    /// return them in the response message of the WebSocket handshake. The
    /// list of extensions that are needed SHOULD appear in the /reason/
    /// part of the Close frame. Note that this status code is not used by
    /// the server, because it can fail the WebSocket handshake instead.
    #[doc(alias = "nw_ws_close_code_mandatory_extension")]
    pub const mandatory_extension: Self = Self(1010);
    /// terminating the connection because it encountered an unexpected
    /// condition that prevented it from fulfilling the request.
    #[doc(alias = "nw_ws_close_code_internal_server_error")]
    pub const internal_server_error: Self = Self(1011);
    /// be set as a status code in a Close control frame by an endpoint. It
    /// is designated for use in applications expecting a status code to
    /// indicate that the connection was closed due to a failure to perform
    /// a TLS handshake (e.g., the server certificate can't be verified).
    #[doc(alias = "nw_ws_close_code_tls_handshake")]
    pub const tls_handshake: Self = Self(1015);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_close_code_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_close_code_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The WebSocket Protocol version.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_version_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ws_version_t(pub c_uint);
impl nw_ws_version_t {
    #[doc(alias = "nw_ws_version_invalid")]
    pub const invalid: Self = Self(0);
    #[doc(alias = "nw_ws_version_13")]
    pub const version_13: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_version_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWProtocolDefinition {
    /// Access the definition of the default system implementation of the
    /// WebSocket protocol. This protocol can be appended to a connection's
    /// protocol stack.
    ///
    ///
    /// Returns: Returns a retained protocol definition object.
    #[doc(alias = "nw_protocol_copy_ws_definition")]
    #[inline]
    pub fn ws() -> NWRetained<NWProtocolDefinition> {
        extern "C-unwind" {
            fn nw_protocol_copy_ws_definition() -> Option<NonNull<NWProtocolDefinition>>;
        }
        let ret = unsafe { nw_protocol_copy_ws_definition() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWProtocolOptions {
    /// Create an instance of WebSocket protocol options. This object can be
    /// added to an nw_protocol_stack_t to be used in an nw_connection_t or
    /// an nw_listener_t.
    ///
    ///
    /// Returns: Returns a retained protocol options object.
    #[doc(alias = "nw_ws_create_options")]
    #[inline]
    pub fn ws(version: nw_ws_version_t) -> NWRetained<NWProtocolOptions> {
        extern "C-unwind" {
            fn nw_ws_create_options(version: nw_ws_version_t)
                -> Option<NonNull<NWProtocolOptions>>;
        }
        let ret = unsafe { nw_ws_create_options(version) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Set additional HTTP headers to be sent by the client during the
    /// WebSocket handshake.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `name`: The HTTP header name.
    ///
    ///
    /// Parameter `value`: The HTTP header value.
    #[doc(alias = "nw_ws_options_add_additional_header")]
    #[inline]
    pub fn ws_add_additional_header(&self, name: &CStr, value: &CStr) {
        extern "C-unwind" {
            fn nw_ws_options_add_additional_header(
                options: &NWProtocolOptions,
                name: NonNull<c_char>,
                value: NonNull<c_char>,
            );
        }
        unsafe {
            nw_ws_options_add_additional_header(
                self,
                NonNull::new(name.as_ptr().cast_mut()).unwrap(),
                NonNull::new(value.as_ptr().cast_mut()).unwrap(),
            )
        }
    }

    /// Add to the list of subprotocols that will be presented to a
    /// WebSocket server during connection establishment.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `subprotocol`: The subprotocol supported by the client.
    #[doc(alias = "nw_ws_options_add_subprotocol")]
    #[inline]
    pub fn ws_add_subprotocol(&self, subprotocol: &CStr) {
        extern "C-unwind" {
            fn nw_ws_options_add_subprotocol(
                options: &NWProtocolOptions,
                subprotocol: NonNull<c_char>,
            );
        }
        unsafe {
            nw_ws_options_add_subprotocol(
                self,
                NonNull::new(subprotocol.as_ptr().cast_mut()).unwrap(),
            )
        }
    }

    /// Set whether the WebSocket connection should automatically reply to all
    /// incoming pings. If set to true, the WebSocket protocol will automatically
    /// reply to incoming pings and will deliver the pings to receive requests
    /// on the connection.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `auto_reply_ping`: Whether the WebSocket connection should automatically reply to all
    /// incoming pings.
    #[doc(alias = "nw_ws_options_set_auto_reply_ping")]
    #[inline]
    pub fn ws_set_auto_reply_ping(&self, auto_reply_ping: bool) {
        extern "C-unwind" {
            fn nw_ws_options_set_auto_reply_ping(
                options: &NWProtocolOptions,
                auto_reply_ping: bool,
            );
        }
        unsafe { nw_ws_options_set_auto_reply_ping(self, auto_reply_ping) }
    }

    /// Set whether the WebSocket protocol should skip the opening handshake
    /// and begin framing data as soon as a connection is established.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `skip_handshake`: Whether the WebSocket connection should skip the opening handshake.
    #[doc(alias = "nw_ws_options_set_skip_handshake")]
    #[inline]
    pub fn ws_set_skip_handshake(&self, skip_handshake: bool) {
        extern "C-unwind" {
            fn nw_ws_options_set_skip_handshake(options: &NWProtocolOptions, skip_handshake: bool);
        }
        unsafe { nw_ws_options_set_skip_handshake(self, skip_handshake) }
    }

    /// Set the maximum allowed message size to be received by the WebSocket
    /// connection. This does not limit the sending message size.
    ///
    ///
    /// Parameter `options`: The WebSocket protocol options object.
    ///
    ///
    /// Parameter `maximum_message_size`: The maximum message size in bytes. A maximum message size of 0 means
    /// there is no receive limit. The default maximum message size is 0.
    #[doc(alias = "nw_ws_options_set_maximum_message_size")]
    #[inline]
    pub fn ws_set_maximum_message_size(&self, maximum_message_size: usize) {
        extern "C-unwind" {
            fn nw_ws_options_set_maximum_message_size(
                options: &NWProtocolOptions,
                maximum_message_size: usize,
            );
        }
        unsafe { nw_ws_options_set_maximum_message_size(self, maximum_message_size) }
    }
}

impl NWProtocolMetadata {
    /// Checks if a protocol metadata object is compatible with the
    /// accessors defined in this file for the default system
    /// implementation of WebSocket.
    ///
    ///
    /// Returns: Returns true if the metadata is for the default system
    /// implementation of WebSocket, false otherwise.
    #[doc(alias = "nw_protocol_metadata_is_ws")]
    #[inline]
    pub fn is_ws(&self) -> bool {
        extern "C-unwind" {
            fn nw_protocol_metadata_is_ws(metadata: &NWProtocolMetadata) -> bool;
        }
        unsafe { nw_protocol_metadata_is_ws(self) }
    }

    /// Creates a protocol metadata object that can be used to define the
    /// content context of messages sent over a WebSocket connection.
    ///
    ///
    /// Parameter `opcode`: Set the opcode on a WebSocket frame. This must be defined on create.
    ///
    ///
    /// Returns: Returns a retained metadata object representing the WebSocket frame.
    #[doc(alias = "nw_ws_create_metadata")]
    #[inline]
    pub fn ws(opcode: nw_ws_opcode_t) -> NWRetained<NWProtocolMetadata> {
        extern "C-unwind" {
            fn nw_ws_create_metadata(opcode: nw_ws_opcode_t)
                -> Option<NonNull<NWProtocolMetadata>>;
        }
        let ret = unsafe { nw_ws_create_metadata(opcode) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Get the opcode on a WebSocket frame.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket frame.
    ///
    ///
    /// Returns: The opcode on the WebSocket frame.
    #[doc(alias = "nw_ws_metadata_get_opcode")]
    #[inline]
    pub fn ws_opcode(&self) -> nw_ws_opcode_t {
        extern "C-unwind" {
            fn nw_ws_metadata_get_opcode(metadata: &NWProtocolMetadata) -> nw_ws_opcode_t;
        }
        unsafe { nw_ws_metadata_get_opcode(self) }
    }

    /// Set the close code on a WebSocket frame. The WebSocket frame's opcode
    /// should be nw_ws_opcode_close.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket frame.
    ///
    ///
    /// Parameter `close_code`: The close code on the WebSocket frame.
    #[doc(alias = "nw_ws_metadata_set_close_code")]
    #[inline]
    pub fn ws_set_close_code(&self, close_code: nw_ws_close_code_t) {
        extern "C-unwind" {
            fn nw_ws_metadata_set_close_code(
                metadata: &NWProtocolMetadata,
                close_code: nw_ws_close_code_t,
            );
        }
        unsafe { nw_ws_metadata_set_close_code(self, close_code) }
    }

    /// Get the close code from a WebSocket frame. If the close code is equal
    /// to nw_ws_close_code_no_status_received, it means that a close code
    /// was not actually present in the WebSocket frame.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket frame.
    ///
    ///
    /// Returns: The close code on the WebSocket frame.
    #[doc(alias = "nw_ws_metadata_get_close_code")]
    #[inline]
    pub fn ws_close_code(&self) -> nw_ws_close_code_t {
        extern "C-unwind" {
            fn nw_ws_metadata_get_close_code(metadata: &NWProtocolMetadata) -> nw_ws_close_code_t;
        }
        unsafe { nw_ws_metadata_get_close_code(self) }
    }
}

/// A block to be invoked when a pong reply is received after sending a ping
/// message, or if the WebSocket connection has closed or failed.
///
///
/// Parameter `error`: An optional error if the WebSocket connection fails or closes before a
/// pong reply is received.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_pong_handler_t?language=objc)
pub type nw_ws_pong_handler_t = *mut block2::DynBlock<dyn Fn(*mut NWError)>;

impl NWProtocolMetadata {
    /// Set a callback that will notify the client when a pong message has been
    /// received for a ping message sent. The metadata object's associated
    /// opcode should be nw_ws_opcode_ping.
    ///
    ///
    /// Parameter `metadata`: The WebSocket metadata object.
    ///
    ///
    /// Parameter `client_queue`: The queue on which the pong handler will be delivered.
    ///
    ///
    /// Parameter `pong_handler`: The handler that gets called when a pong reply is received.
    ///
    /// # Safety
    ///
    /// - `client_queue` possibly has additional threading requirements.
    /// - `pong_handler` must be a valid pointer.
    #[doc(alias = "nw_ws_metadata_set_pong_handler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn ws_set_pong_handler(
        &self,
        client_queue: &DispatchQueue,
        pong_handler: nw_ws_pong_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_ws_metadata_set_pong_handler(
                metadata: &NWProtocolMetadata,
                client_queue: &DispatchQueue,
                pong_handler: nw_ws_pong_handler_t,
            );
        }
        unsafe { nw_ws_metadata_set_pong_handler(self, client_queue, pong_handler) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwwsrequest?language=objc)
#[doc(alias = "nw_ws_request_t")]
#[repr(C)]
pub struct NWWsRequest {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWWsRequest {}
);

/// A block that can be applied to every subprotocol in a client's WebSocket
/// request.
///
///
/// Parameter `subprotocol`: A subprotocol presented by the client.
///
///
/// Returns: A boolean value that indicating if enumeration should continue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_subprotocol_enumerator_t?language=objc)
pub type nw_ws_subprotocol_enumerator_t = *mut block2::DynBlock<dyn Fn(NonNull<c_char>) -> bool>;

impl NWWsRequest {
    /// Enumerates the list of subprotocols on the client's request.
    ///
    ///
    /// Parameter `request`: The client request.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_ws_request_enumerate_subprotocols")]
    #[inline]
    pub unsafe fn enumerate_subprotocols(
        &self,
        enumerator: nw_ws_subprotocol_enumerator_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_ws_request_enumerate_subprotocols(
                request: &NWWsRequest,
                enumerator: nw_ws_subprotocol_enumerator_t,
            ) -> bool;
        }
        unsafe { nw_ws_request_enumerate_subprotocols(self, enumerator) }
    }
}

/// A block that can be applied to every additional header in a client's
/// WebSocket request.
///
///
/// Parameter `name`: The HTTP name.
///
///
/// Parameter `value`: The HTTP value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_additional_header_enumerator_t?language=objc)
pub type nw_ws_additional_header_enumerator_t =
    *mut block2::DynBlock<dyn Fn(NonNull<c_char>, NonNull<c_char>) -> bool>;

impl NWWsRequest {
    /// Enumerates the list of additional headers on the client's request.
    ///
    ///
    /// Parameter `request`: The client request.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_ws_request_enumerate_additional_headers")]
    #[inline]
    pub unsafe fn enumerate_additional_headers(
        &self,
        enumerator: nw_ws_additional_header_enumerator_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_ws_request_enumerate_additional_headers(
                request: &NWWsRequest,
                enumerator: nw_ws_additional_header_enumerator_t,
            ) -> bool;
        }
        unsafe { nw_ws_request_enumerate_additional_headers(self, enumerator) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/network/nwwsresponse?language=objc)
#[doc(alias = "nw_ws_response_t")]
#[repr(C)]
pub struct NWWsResponse {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

nw_object!(
    unsafe impl NWWsResponse {}
);

/// The status of a WebSocket server's response to a client's request to
/// connect.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_response_status_t?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct nw_ws_response_status_t(pub c_uint);
impl nw_ws_response_status_t {
    /// be treated as an unexpected value.
    #[doc(alias = "nw_ws_response_status_invalid")]
    pub const invalid: Self = Self(0);
    /// WebSocket connection will begin framing data.
    #[doc(alias = "nw_ws_response_status_accept")]
    pub const accept: Self = Self(1);
    /// WebSocket connection will be closed.
    #[doc(alias = "nw_ws_response_status_reject")]
    pub const reject: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for nw_ws_response_status_t {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for nw_ws_response_status_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl NWWsResponse {
    /// Create a server response to a WebSocket client's opening handshake.
    ///
    ///
    /// Parameter `status`: The status of the response. If the status is nw_ws_response_status_accept,
    /// the server will accept the handshake and open the WebSocket connection.
    /// If the status is nw_ws_response_status_reject, the server will reject the
    /// handshake and respond with the HTTP error 400 Bad Request.
    ///
    ///
    /// Parameter `selected_subprotocol`: The server's selected protocol from the client's list of proposed
    /// subprotocols. If the status of this response is nw_ws_response_status_reject,
    /// this parameter is ignored. Pass NULL to indicate the server did not find
    /// a suitable subprotocol, but has accepted the handshake anyways.
    /// Passing an empty string is prohibited by the WebSocket protocol.
    ///
    ///
    /// Returns: An instantiated WebSocket server response object.
    #[doc(alias = "nw_ws_response_create")]
    #[inline]
    pub fn new(
        status: nw_ws_response_status_t,
        selected_subprotocol: Option<&CStr>,
    ) -> NWRetained<NWWsResponse> {
        extern "C-unwind" {
            fn nw_ws_response_create(
                status: nw_ws_response_status_t,
                selected_subprotocol: *const c_char,
            ) -> Option<NonNull<NWWsResponse>>;
        }
        let ret = unsafe {
            nw_ws_response_create(
                status,
                selected_subprotocol
                    .map(|ptr| ptr.as_ptr())
                    .unwrap_or_else(core::ptr::null),
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }

    /// Get the status from a WebSocket server's response. If the response is
    /// nil, the return value will be nw_ws_response_status_invalid.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Returns: The status of the server's response.
    #[doc(alias = "nw_ws_response_get_status")]
    #[inline]
    pub fn status(response: Option<&NWWsResponse>) -> nw_ws_response_status_t {
        extern "C-unwind" {
            fn nw_ws_response_get_status(
                response: Option<&NWWsResponse>,
            ) -> nw_ws_response_status_t;
        }
        unsafe { nw_ws_response_get_status(response) }
    }

    /// Get the selected subprotocol from a WebSocket server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Returns: The status of the server's response.
    #[doc(alias = "nw_ws_response_get_selected_subprotocol")]
    #[inline]
    pub fn selected_subprotocol(&self) -> *const c_char {
        extern "C-unwind" {
            fn nw_ws_response_get_selected_subprotocol(response: &NWWsResponse) -> *const c_char;
        }
        unsafe { nw_ws_response_get_selected_subprotocol(self) }
    }

    /// Add additional HTTP headers to be sent back to the WebSocket client in
    /// the server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Parameter `name`: The HTTP name.
    ///
    ///
    /// Parameter `value`: The HTTP value.
    #[doc(alias = "nw_ws_response_add_additional_header")]
    #[inline]
    pub fn add_additional_header(&self, name: &CStr, value: &CStr) {
        extern "C-unwind" {
            fn nw_ws_response_add_additional_header(
                response: &NWWsResponse,
                name: NonNull<c_char>,
                value: NonNull<c_char>,
            );
        }
        unsafe {
            nw_ws_response_add_additional_header(
                self,
                NonNull::new(name.as_ptr().cast_mut()).unwrap(),
                NonNull::new(value.as_ptr().cast_mut()).unwrap(),
            )
        }
    }
}

impl NWProtocolMetadata {
    /// Copy the WebSocket server's response to a client's request to connect.
    /// If this is called on a WebSocket server, the response object will contain
    /// the server's own response to the client.
    ///
    ///
    /// Parameter `metadata`: The metadata object representing the WebSocket connection.
    ///
    ///
    /// Returns: The server response.
    #[doc(alias = "nw_ws_metadata_copy_server_response")]
    #[inline]
    pub fn ws_copy_server_response(&self) -> NWRetained<NWWsResponse> {
        extern "C-unwind" {
            fn nw_ws_metadata_copy_server_response(
                metadata: &NWProtocolMetadata,
            ) -> Option<NonNull<NWWsResponse>>;
        }
        let ret = unsafe { nw_ws_metadata_copy_server_response(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { NWRetained::from_raw(ret) }
    }
}

impl NWWsResponse {
    /// Enumerates the list of additional headers on the server's response.
    ///
    ///
    /// Parameter `response`: The server response.
    ///
    ///
    /// Parameter `enumerator`: The enumerator block.
    ///
    ///
    /// Returns: Whether the enumeration completed.
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    #[doc(alias = "nw_ws_response_enumerate_additional_headers")]
    #[inline]
    pub unsafe fn enumerate_additional_headers(
        &self,
        enumerator: nw_ws_additional_header_enumerator_t,
    ) -> bool {
        extern "C-unwind" {
            fn nw_ws_response_enumerate_additional_headers(
                response: &NWWsResponse,
                enumerator: nw_ws_additional_header_enumerator_t,
            ) -> bool;
        }
        unsafe { nw_ws_response_enumerate_additional_headers(self, enumerator) }
    }
}

/// A block to be invoked when a WebSocket server receives a WebSocket
/// client's request to connect.
///
///
/// Parameter `request`: The client request.
///
///
/// Returns: The server response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/network/nw_ws_client_request_handler_t?language=objc)
pub type nw_ws_client_request_handler_t =
    *mut block2::DynBlock<dyn Fn(NonNull<NWWsRequest>) -> NonNull<NWWsResponse>>;

impl NWProtocolOptions {
    /// Set callback handler to be invoked when a WebSocket server receives a
    /// WebSocket client's request to connect.
    ///
    ///
    /// Parameter `options`: The protocol options object.
    ///
    ///
    /// Parameter `client_queue`: The queue on which the client request handler will be delivered.
    ///
    ///
    /// Parameter `handler`: The callback handler.
    ///
    /// # Safety
    ///
    /// - `client_queue` possibly has additional threading requirements.
    /// - `handler` must be a valid pointer.
    #[doc(alias = "nw_ws_options_set_client_request_handler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn ws_set_client_request_handler(
        &self,
        client_queue: &DispatchQueue,
        handler: nw_ws_client_request_handler_t,
    ) {
        extern "C-unwind" {
            fn nw_ws_options_set_client_request_handler(
                options: &NWProtocolOptions,
                client_queue: &DispatchQueue,
                handler: nw_ws_client_request_handler_t,
            );
        }
        unsafe { nw_ws_options_set_client_request_handler(self, client_queue, handler) }
    }
}
