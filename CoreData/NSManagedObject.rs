//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants that specify the reason the managed object may need to reinitialize its values.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSSnapshotEventType(pub NSUInteger);
bitflags::bitflags! {
    impl NSSnapshotEventType: NSUInteger {
/// Specifies a change due to undo from insertion.
        #[doc(alias = "NSSnapshotEventUndoInsertion")]
        const UndoInsertion = 1<<1;
/// Specifies a change due to undo from deletion.
        #[doc(alias = "NSSnapshotEventUndoDeletion")]
        const UndoDeletion = 1<<2;
/// Specifies a change due to a property-level undo.
        #[doc(alias = "NSSnapshotEventUndoUpdate")]
        const UndoUpdate = 1<<3;
/// Specifies a change due to the managed object context being rolled back.
        #[doc(alias = "NSSnapshotEventRollback")]
        const Rollback = 1<<4;
/// Specifies a change due to the managed object being refreshed.
        #[doc(alias = "NSSnapshotEventRefresh")]
        const Refresh = 1<<5;
/// Specifies a change due to conflict resolution during a save operation.
        #[doc(alias = "NSSnapshotEventMergePolicy")]
        const MergePolicy = 1<<6;
    }
}

unsafe impl Encode for NSSnapshotEventType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSSnapshotEventType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The base class that all Core Data model objects inherit from.
    ///
    /// ## Overview
    ///
    /// A managed object has an associated entity description ([`NSEntityDescription`](https://developer.apple.com/documentation/coredata/nsentitydescription)) that provides metadata about the object, including the name of the entity that the object represents and the names of its attributes and relationships. A managed object also has an associated managed object context that tracks changes to the object graph.
    ///
    /// You can’t use instances of direct subclasses of [`NSObject`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class), or any other class that doesn’t inherit from [`NSManagedObject`](https://developer.apple.com/documentation/coredata/nsmanagedobject), with a managed object context. You may create custom subclasses of [`NSManagedObject`](https://developer.apple.com/documentation/coredata/nsmanagedobject), although this isn’t always necessary. If you don’t need custom logic, you can create a complete object graph with [`NSManagedObject`](https://developer.apple.com/documentation/coredata/nsmanagedobject) instances.
    ///
    /// If you instantiate a managed object directly, you must call the designated initializer [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:)).
    ///
    /// ### Data Storage
    ///
    /// In some respects, an `NSManagedObject` acts like a dictionary—it’s a generic container object that provides efficient storage for the properties defined by its associated `NSEntityDescription` instance. `NSManagedObject` supports a range of common types for attribute values, including string, date, and number (see [`NSAttributeDescription`](https://developer.apple.com/documentation/coredata/nsattributedescription) for full details). Therefore, typically you don’t need to define instance variables in subclasses. Sometimes, however, you want to use types that aren’t supported directly, such as colors and C structures. For example, in a graphics application you might want to define a Rectangle entity that has color and bounds attributes that are an instance of `NSColor` and an `NSRect` struct, respectively. For some types you can use a transformable attribute, for others this may require you to create a subclass of `NSManagedObject`.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    /// The default value for [`automaticallyNotifiesObserversForKey:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/automaticallynotifiesobservers(forkey:)) is `false` for managed properties of a `NSManagedObject`, and `true` for unmanaged properties.
    ///
    ///
    ///
    /// </div>
    /// ### Faulting
    ///
    /// Managed objects typically represent data held in a persistent store. In some situations a managed object may be a _fault_—an object whose property values haven’t yet been loaded from the external data store. When you access persistent property values, the fault “fires” and the data is retrieved from the store automatically. This can be a comparatively expensive process (potentially requiring a round trip to the persistent store), and you may wish to avoid unnecessarily firing a fault. See [Faulting and Uniquing](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/FaultingandUniquing.html#//apple_ref/doc/uid/TP40001075-CH18) for more details on faults.
    ///
    /// You can safely invoke the following methods and properties on a fault without causing it to fire: [`isEqual:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/isequal(_:)), [`hash`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/hash), [`superclass`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/superclass), [`class`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobjectprotocol/1571949-class), [`self`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/self()), [`isProxy`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobjectprotocol/1418528-isproxy), [`isKindOfClass:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/iskind(of:)), [`isMemberOfClass:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/ismember(of:)), [`conformsToProtocol:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/conforms(to:)), [`respondsToSelector:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/responds(to:)), [`description`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/description), [`managedObjectContext`](https://developer.apple.com/documentation/coredata/nsmanagedobject/managedobjectcontext), [`entity`](https://developer.apple.com/documentation/coredata/nsmanagedobject/entity-swift.property), [`objectID`](https://developer.apple.com/documentation/coredata/nsmanagedobject/objectid), [`inserted`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isinserted), [`updated`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isupdated), [`deleted`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isdeleted), [`faultingState`](https://developer.apple.com/documentation/coredata/nsmanagedobject/faultingstate), and [`fault`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isfault). Because `isEqual` and `hash` don’t cause a fault to fire, managed objects can typically be placed in collections without firing a fault. Note, however, that invoking key-value coding methods on the collection object might in turn result in an invocation of `valueForKey:` on a managed object, which would fire the fault.
    ///
    /// Although the `description` property doesn’t cause a fault to fire, if you implement a custom `description` that accesses the object’s persistent properties, this does cause a fault to fire. You are strongly discouraged from overriding `description` in this way.
    ///
    /// ### Subclassing Notes
    ///
    /// In combination with the entity description in the managed object model, `NSManagedObject` provides a rich set of default behaviors including support for arbitrary properties and value validation. If you decide to subclass `NSManagedObject` to implement custom features, make sure you don’t disrupt Core Data’s behavior.
    ///
    /// #### Methods and Properties You Must Not Override
    ///
    /// `NSManagedObject` itself customizes many features of `NSObject` so that managed objects can be properly integrated into the Core Data infrastructure. Core Data relies on the `NSManagedObject` implementation of the following methods and properties, which you therefore absolutely must not override: [`primitiveValueForKey:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/primitivevalue(forkey:)), [`setPrimitiveValue:forKey:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/setprimitivevalue(_:forkey:)), [`isEqual:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/isequal(_:)), [`hash`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/hash), [`superclass`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/superclass), [`class`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobjectprotocol/1571949-class), [`self`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/self()), [`isProxy`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobjectprotocol/1418528-isproxy), [`isKindOfClass:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/iskind(of:)), [`isMemberOfClass:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/ismember(of:)), [`conformsToProtocol:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/conforms(to:)), [`respondsToSelector:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/responds(to:)), [`managedObjectContext`](https://developer.apple.com/documentation/coredata/nsmanagedobject/managedobjectcontext), [`entity`](https://developer.apple.com/documentation/coredata/nsmanagedobject/entity-swift.property), [`objectID`](https://developer.apple.com/documentation/coredata/nsmanagedobject/objectid), [`inserted`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isinserted), [`updated`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isupdated), [`deleted`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isdeleted), and [`fault`](https://developer.apple.com/documentation/coredata/nsmanagedobject/isfault), [`alloc`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobject/1571958-alloc), [`allocWithZone:`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobject/1571945-allocwithzone), [`new`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobject/1571948-new),  [`instancesRespondToSelector:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/instancesrespond(to:)), [`instanceMethodForSelector:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/instancemethod(for:)), [`methodForSelector:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/method(for:)), [`methodSignatureForSelector:`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobject/1571960-methodsignatureforselector), [`instanceMethodSignatureForSelector:`](https://developer.apple.comhttps://developer.apple.com/documentation/objectivec/nsobject/1571959-instancemethodsignatureforselect), or [`isSubclassOfClass:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/issubclass(of:)).
    ///
    /// #### Methods and Properties You Shouldn’t Override
    ///
    /// As with any class, you are strongly discouraged from overriding the key-value observing methods such as [`willChangeValueForKey:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/willchangevalue(forkey:)) and [`didChangeValueForKey:withSetMutation:usingObjects:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/didchangevalue(forkey:withsetmutation:using:)). Avoid overriding `description`—if this method fires a fault during a debugging operation, the results may be unpredictable. Also avoid overriding [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:)), or `dealloc`. Changing values in the [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:)) method won’t be noticed by the context, and if you aren’t careful, those changes may not be saved. Perform most initialization customization in one of the `awake…` methods. If you do override [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:)), make sure you adhere to the requirements set out in the method description. See [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:)).
    ///
    /// Don’t override `dealloc` because [`didTurnIntoFault`](https://developer.apple.com/documentation/coredata/nsmanagedobject/didturnintofault()) is usually a better time to clear values—a managed object may not be reclaimed for some time after it has been turned into a fault. Core Data doesn’t guarantee that `dealloc` will be called in all scenarios (such as when the application quits). Therefore, don’t include required side effects (like saving or changes to the file system, user preferences, and so on) in these methods.
    ///
    /// In summary, for [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:)) and `dealloc`, Core Data reserves exclusive control over the life cycle of the managed object (that is, raw memory management). This is so that the framework can provide features such as uniquing and by consequence, relationship maintenance, as well as much better performance than would be possible otherwise.
    ///
    /// #### Additional Override Considerations
    ///
    /// The following methods are intended to be fine grained and aren’t suitable for large-scale operations. Don’t fetch or save in these methods. In particular, they shouldn’t have side effects on the managed object context.
    ///
    /// - [`initWithEntity:insertIntoManagedObjectContext:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/init(entity:insertinto:))
    ///
    /// - [`didTurnIntoFault`](https://developer.apple.com/documentation/coredata/nsmanagedobject/didturnintofault())
    ///
    /// - [`willTurnIntoFault`](https://developer.apple.com/documentation/coredata/nsmanagedobject/willturnintofault())
    ///
    /// - `dealloc`
    ///
    /// In addition, if you plan to override `awakeFromInsert`, `awakeFromFetch`, and validation methods, first invoke `super.method()`, the superclass’s implementation. Don’t modify relationships in [`awakeFromFetch`](https://developer.apple.com/documentation/coredata/nsmanagedobject/awakefromfetch())—see the method description for details.
    ///
    /// #### Custom Accessor Methods
    ///
    /// Typically, you don’t need to write custom accessor methods for properties that are defined in the entity of a managed object’s corresponding managed object model. If you need to do so, follow the implementation patterns described in Managed Object Accessor Methods in [Core Data Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075).
    ///
    /// Core Data automatically generates accessor methods (and primitive accessor methods) for you. For attributes and to-one relationships, Core Data generates the standard get and set accessor methods; for to-many relationships, Core Data generates the indexed accessor methods as described in [Achieving Basic Key-Value Coding Compliance](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/AccessorConventions.html#//apple_ref/doc/uid/20002174) in [Key-Value Coding Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i). You do however need to declare the accessor methods or use Objective-C properties to suppress compiler warnings. For a full discussion, see Managed Object Accessor Methods in [Core Data Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075).
    ///
    /// #### Custom Instance Variables
    ///
    /// By default, `NSManagedObject` stores its properties in an internal structure as objects, and in general Core Data is more efficient working with storage under its own control rather than by using custom instance variables.
    ///
    /// `NSManagedObject` provides support for a range of common types for attribute values, including string, date, and number (see [`NSAttributeDescription`](https://developer.apple.com/documentation/coredata/nsattributedescription) for full details). If you want to use types that aren’t supported directly, like colors and C structures, you can either use transformable attributes or create a subclass of `NSManagedObject`.
    ///
    /// Sometimes it’s convenient to represent variables as scalars—in drawing applications, for example, where variables represent dimensions and x and y coordinates and are frequently used in calculations. To represent attributes as scalars, you declare instance variables as you do in any other class. You also need to implement suitable accessor methods as described in Managed Object Accessor Methods.
    ///
    /// If you define custom instance variables for example to store derived attributes or other transient properties, clean up these variables in [`didTurnIntoFault`](https://developer.apple.com/documentation/coredata/nsmanagedobject/didturnintofault()) rather than `dealloc`.
    ///
    /// #### Validation Methods
    ///
    /// `NSManagedObject` provides consistent hooks for validating property and inter-property values. You typically shouldn’t override [`validateValue:forKey:error:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/validatevalue(_:forkey:)). Instead implement methods of the form `validate<Key>:error:`, as defined by the NSKeyValueCoding protocol. If you want to validate inter-property values, you can override [`validateForUpdate:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/validateforupdate()) and/or related validation methods.
    ///
    /// Don’t call `validateValue:forKey:error:` within custom property validation methods—if you do, you create an infinite loop when `validateValue:forKey:error:` is invoked at runtime. If you do implement custom validation methods, don’t call them directly. Instead, call `validateValue:forKey:error:` with the appropriate key. This ensures that any constraints defined in the managed object model are applied.
    ///
    /// If you implement custom inter-property validation methods like [`validateForUpdate:`](https://developer.apple.com/documentation/coredata/nsmanagedobject/validateforupdate()), call the superclass’s implementation first. This ensures that individual property validation methods are also invoked. If there are multiple validation failures in one operation, collect them in an array and add the array—using the key `NSDetailedErrorsKey`—to the userInfo dictionary in the `NSError` object you return. For an example, see Managed Object Validation.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSManagedObject;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSManagedObject {}
);

impl NSManagedObject {
    extern_methods!(
        #[unsafe(method(contextShouldIgnoreUnmodeledPropertyChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextShouldIgnoreUnmodeledPropertyChanges() -> bool;

        #[cfg(feature = "NSEntityDescription")]
        #[unsafe(method(entity))]
        #[unsafe(method_family = none)]
        pub unsafe fn entity_class() -> Retained<NSEntityDescription>;

        #[cfg(all(feature = "NSFetchRequest", feature = "NSPersistentStoreRequest"))]
        #[unsafe(method(fetchRequest))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchRequest() -> Retained<NSFetchRequest>;

        #[cfg(all(feature = "NSEntityDescription", feature = "NSManagedObjectContext"))]
        #[unsafe(method(initWithEntity:insertIntoManagedObjectContext:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithEntity_insertIntoManagedObjectContext(
            this: Allocated<Self>,
            entity: &NSEntityDescription,
            context: Option<&NSManagedObjectContext>,
        ) -> Retained<NSManagedObject>;

        #[cfg(feature = "NSManagedObjectContext")]
        #[unsafe(method(initWithContext:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContext(
            this: Allocated<Self>,
            moc: &NSManagedObjectContext,
        ) -> Retained<Self>;

        #[cfg(feature = "NSManagedObjectContext")]
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(managedObjectContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn managedObjectContext(&self) -> Option<Retained<NSManagedObjectContext>>;

        #[cfg(feature = "NSEntityDescription")]
        #[unsafe(method(entity))]
        #[unsafe(method_family = none)]
        pub unsafe fn entity(&self) -> Retained<NSEntityDescription>;

        #[cfg(feature = "NSManagedObjectID")]
        #[unsafe(method(objectID))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectID(&self) -> Retained<NSManagedObjectID>;

        #[unsafe(method(isInserted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isInserted(&self) -> bool;

        #[unsafe(method(isUpdated))]
        #[unsafe(method_family = none)]
        pub unsafe fn isUpdated(&self) -> bool;

        #[unsafe(method(isDeleted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isDeleted(&self) -> bool;

        #[unsafe(method(hasChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasChanges(&self) -> bool;

        #[unsafe(method(hasPersistentChangedValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasPersistentChangedValues(&self) -> bool;

        #[unsafe(method(isFault))]
        #[unsafe(method_family = none)]
        pub unsafe fn isFault(&self) -> bool;

        #[unsafe(method(hasFaultForRelationshipNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasFaultForRelationshipNamed(&self, key: &NSString) -> bool;

        #[cfg(feature = "NSManagedObjectID")]
        #[unsafe(method(objectIDsForRelationshipNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectIDsForRelationshipNamed(
            &self,
            key: &NSString,
        ) -> Retained<NSArray<NSManagedObjectID>>;

        #[unsafe(method(faultingState))]
        #[unsafe(method_family = none)]
        pub unsafe fn faultingState(&self) -> NSUInteger;

        #[unsafe(method(willAccessValueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn willAccessValueForKey(&self, key: Option<&NSString>);

        #[unsafe(method(didAccessValueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didAccessValueForKey(&self, key: Option<&NSString>);

        #[unsafe(method(willChangeValueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn willChangeValueForKey(&self, key: &NSString);

        #[unsafe(method(didChangeValueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didChangeValueForKey(&self, key: &NSString);

        /// # Safety
        ///
        /// `in_objects` generic should be of the correct type.
        #[unsafe(method(willChangeValueForKey:withSetMutation:usingObjects:))]
        #[unsafe(method_family = none)]
        pub unsafe fn willChangeValueForKey_withSetMutation_usingObjects(
            &self,
            in_key: &NSString,
            in_mutation_kind: NSKeyValueSetMutationKind,
            in_objects: &NSSet,
        );

        /// # Safety
        ///
        /// `in_objects` generic should be of the correct type.
        #[unsafe(method(didChangeValueForKey:withSetMutation:usingObjects:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didChangeValueForKey_withSetMutation_usingObjects(
            &self,
            in_key: &NSString,
            in_mutation_kind: NSKeyValueSetMutationKind,
            in_objects: &NSSet,
        );

        #[unsafe(method(awakeFromFetch))]
        #[unsafe(method_family = none)]
        pub unsafe fn awakeFromFetch(&self);

        #[unsafe(method(awakeFromInsert))]
        #[unsafe(method_family = none)]
        pub unsafe fn awakeFromInsert(&self);

        #[unsafe(method(awakeFromSnapshotEvents:))]
        #[unsafe(method_family = none)]
        pub unsafe fn awakeFromSnapshotEvents(&self, flags: NSSnapshotEventType);

        #[unsafe(method(prepareForDeletion))]
        #[unsafe(method_family = none)]
        pub unsafe fn prepareForDeletion(&self);

        #[unsafe(method(willSave))]
        #[unsafe(method_family = none)]
        pub unsafe fn willSave(&self);

        #[unsafe(method(didSave))]
        #[unsafe(method_family = none)]
        pub unsafe fn didSave(&self);

        #[unsafe(method(willTurnIntoFault))]
        #[unsafe(method_family = none)]
        pub unsafe fn willTurnIntoFault(&self);

        #[unsafe(method(didTurnIntoFault))]
        #[unsafe(method_family = none)]
        pub unsafe fn didTurnIntoFault(&self);

        #[unsafe(method(valueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueForKey(&self, key: &NSString) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(setValue:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValue_forKey(&self, value: Option<&AnyObject>, key: &NSString);

        #[unsafe(method(primitiveValueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn primitiveValueForKey(&self, key: &NSString) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(setPrimitiveValue:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimitiveValue_forKey(&self, value: Option<&AnyObject>, key: &NSString);

        #[unsafe(method(committedValuesForKeys:))]
        #[unsafe(method_family = none)]
        pub unsafe fn committedValuesForKeys(
            &self,
            keys: Option<&NSArray<NSString>>,
        ) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[unsafe(method(changedValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn changedValues(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[unsafe(method(changedValuesForCurrentEvent))]
        #[unsafe(method_family = none)]
        pub unsafe fn changedValuesForCurrentEvent(
            &self,
        ) -> Retained<NSDictionary<NSString, AnyObject>>;

        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(validateValue:forKey:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn validateValue_forKey_error(
            &self,
            value: &mut Option<Retained<AnyObject>>,
            key: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(validateForDelete:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn validateForDelete(&self) -> Result<(), Retained<NSError>>;

        #[unsafe(method(validateForInsert:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn validateForInsert(&self) -> Result<(), Retained<NSError>>;

        #[unsafe(method(validateForUpdate:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn validateForUpdate(&self) -> Result<(), Retained<NSError>>;

        /// # Safety
        ///
        /// `in_observation_info` must be a valid pointer or null.
        #[unsafe(method(setObservationInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObservationInfo(&self, in_observation_info: *mut c_void);

        #[unsafe(method(observationInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn observationInfo(&self) -> *mut c_void;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSManagedObject {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
