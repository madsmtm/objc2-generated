//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants that define merge policy types.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSMergePolicyType(pub NSUInteger);
impl NSMergePolicyType {
    /// The default merge policy for all managed object contexts.
    ///
    /// ## Discussion
    ///
    /// If a save fails because of conflicting objects, you can find the IDs of those objects in error’s `userInfo` dictionary. Use the [`NSInsertedObjectsKey`](https://developer.apple.com/documentation/coredata/nsinsertedobjectskey) and [`NSUpdatedObjectsKey`](https://developer.apple.com/documentation/coredata/nsupdatedobjectskey) keys to extract the object IDs.
    ///
    ///
    #[doc(alias = "NSErrorMergePolicyType")]
    pub const ErrorMergePolicyType: Self = Self(0x00);
    /// A property-based merge policy that applies external changes.
    ///
    /// ## Discussion
    ///
    /// A policy that merges conflicts between the persistent store’s version of the object and the current in-memory version by individual property, with external changes trumping in-memory changes.
    ///
    ///
    #[doc(alias = "NSMergeByPropertyStoreTrumpMergePolicyType")]
    pub const MergeByPropertyStoreTrumpMergePolicyType: Self = Self(0x01);
    /// A property-based merge policy that applies in-memory changes.
    ///
    /// ## Discussion
    ///
    /// A policy that merges conflicts between the persistent store’s version of the object and the current in-memory version by individual property, with in-memory changes trumping external changes.
    ///
    ///
    #[doc(alias = "NSMergeByPropertyObjectTrumpMergePolicyType")]
    pub const MergeByPropertyObjectTrumpMergePolicyType: Self = Self(0x02);
    /// A merge policy type that overwrites the entire stored object.
    ///
    /// ## Discussion
    ///
    /// This policy merges conflicts between the persistent store’s version of the object and the current in-memory version by saving the entire in-memory object to the persistent store.
    ///
    ///
    #[doc(alias = "NSOverwriteMergePolicyType")]
    pub const OverwriteMergePolicyType: Self = Self(0x03);
    /// A merge policy that discards unsaved changes.
    ///
    /// ## Discussion
    ///
    /// This policy merges conflicts between the persistent store’s version of the object and the current in-memory version by discarding unsaved changes.
    ///
    ///
    #[doc(alias = "NSRollbackMergePolicyType")]
    pub const RollbackMergePolicyType: Self = Self(0x04);
}

unsafe impl Encode for NSMergePolicyType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSMergePolicyType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An encapsulation of conflicts that occur during an attempt to save changes in a managed object context.
    ///
    /// ## Overview
    ///
    /// A conflict can occur in two situations:
    ///
    /// - Between the managed object context and its in-memory cached state at the persistent store coordinator layer.
    ///
    /// - Between the cached state at the persistent store coordinator layer and the external store (file, database, and so forth). In this case, the merge conflict has a cached snapshot and a persisted snapshot.  The source object is also provided as a convenience, but it is not directly involved in the conflict.
    ///
    /// Snapshot dictionaries include values for all attributes and to-one relationships, but not to-many relationships. Relationship values are `NSManagedObjectID` references. To-many relationships must be pulled from the persistent store as needed.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMergeConflict;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMergeConflict {}
);

impl NSMergeConflict {
    extern_methods!(
        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(sourceObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceObject(&self) -> Retained<NSManagedObject>;

        #[unsafe(method(objectSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectSnapshot(&self) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[unsafe(method(cachedSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn cachedSnapshot(&self) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[unsafe(method(persistedSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn persistedSnapshot(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[unsafe(method(newVersionNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn newVersionNumber(&self) -> NSUInteger;

        #[unsafe(method(oldVersionNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn oldVersionNumber(&self) -> NSUInteger;

        #[cfg(feature = "NSManagedObject")]
        /// # Safety
        ///
        /// - `cachesnap` generic should be of the correct type.
        /// - `persnap` generic should be of the correct type.
        #[unsafe(method(initWithSource:newVersion:oldVersion:cachedSnapshot:persistedSnapshot:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSource_newVersion_oldVersion_cachedSnapshot_persistedSnapshot(
            this: Allocated<Self>,
            src_object: &NSManagedObject,
            newvers: NSUInteger,
            oldvers: NSUInteger,
            cachesnap: Option<&NSDictionary<NSString, AnyObject>>,
            persnap: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMergeConflict {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An encapsulation of conflicts that occur during an attempt to save a managed object.
    ///
    /// ## Overview
    ///
    /// A constraint conflict occurs when your data model is using unique constraints and one or more managed objects are violating that constraint.
    ///
    /// When this error occurs, the error instance can be interrogated to determine which instance of [`NSManagedObject`](https://developer.apple.com/documentation/coredata/nsmanagedobject) is violating the constraint and which property on the [`NSManagedObject`](https://developer.apple.com/documentation/coredata/nsmanagedobject) instance is in violation.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSConstraintConflict;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSConstraintConflict {}
);

impl NSConstraintConflict {
    extern_methods!(
        #[unsafe(method(constraint))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraint(&self) -> Retained<NSArray<NSString>>;

        #[unsafe(method(constraintValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraintValues(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(databaseObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseObject(&self) -> Option<Retained<NSManagedObject>>;

        #[unsafe(method(databaseSnapshot))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseSnapshot(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(conflictingObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn conflictingObjects(&self) -> Retained<NSArray<NSManagedObject>>;

        #[unsafe(method(conflictingSnapshots))]
        #[unsafe(method_family = none)]
        pub unsafe fn conflictingSnapshots(&self) -> Retained<NSArray<NSDictionary>>;

        #[cfg(feature = "NSManagedObject")]
        /// # Safety
        ///
        /// - `database_snapshot` generic should be of the correct type.
        /// - `conflicting_snapshots` generic should be of the correct type.
        #[unsafe(method(initWithConstraint:databaseObject:databaseSnapshot:conflictingObjects:conflictingSnapshots:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithConstraint_databaseObject_databaseSnapshot_conflictingObjects_conflictingSnapshots(
            this: Allocated<Self>,
            contraint: &NSArray<NSString>,
            database_object: Option<&NSManagedObject>,
            database_snapshot: Option<&NSDictionary>,
            conflicting_objects: &NSArray<NSManagedObject>,
            conflicting_snapshots: &NSArray,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSConstraintConflict {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A policy object that you use to resolve conflicts between the persistent store and in-memory versions of managed objects.
    ///
    /// ## Overview
    ///
    /// A conflict is a mismatch between state held at two different layers in the Core Data stack. A conflict can arise when you save a managed object context and you have stale data at another layer. There are two places in which a conflict may occur:
    ///
    /// - Between the managed object context layer and its in-memory cached state at the persistent store coordinator layer.
    ///
    /// - Between the cached state at the persistent store coordinator and the external store (file, database, and so forth).
    ///
    /// Conflicts are represented by instances of [`NSMergeConflict`](https://developer.apple.com/documentation/coredata/nsmergeconflict).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMergePolicy;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMergePolicy {}
);

impl NSMergePolicy {
    extern_methods!(
        #[unsafe(method(errorMergePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn errorMergePolicy() -> Retained<NSMergePolicy>;

        #[unsafe(method(rollbackMergePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn rollbackMergePolicy() -> Retained<NSMergePolicy>;

        #[unsafe(method(overwriteMergePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn overwriteMergePolicy() -> Retained<NSMergePolicy>;

        #[unsafe(method(mergeByPropertyObjectTrumpMergePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn mergeByPropertyObjectTrumpMergePolicy() -> Retained<NSMergePolicy>;

        #[unsafe(method(mergeByPropertyStoreTrumpMergePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn mergeByPropertyStoreTrumpMergePolicy() -> Retained<NSMergePolicy>;

        #[unsafe(method(mergeType))]
        #[unsafe(method_family = none)]
        pub unsafe fn mergeType(&self) -> NSMergePolicyType;

        #[unsafe(method(initWithMergeType:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMergeType(
            this: Allocated<Self>,
            ty: NSMergePolicyType,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `list` generic should be of the correct type.
        #[unsafe(method(resolveConflicts:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn resolveConflicts_error(
            &self,
            list: &NSArray,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(resolveOptimisticLockingVersionConflicts:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn resolveOptimisticLockingVersionConflicts_error(
            &self,
            list: &NSArray<NSMergeConflict>,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(resolveConstraintConflicts:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn resolveConstraintConflicts_error(
            &self,
            list: &NSArray<NSConstraintConflict>,
        ) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMergePolicy {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
