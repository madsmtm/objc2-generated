//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A description of a single property belonging to an entity.
    ///
    /// ## Overview
    ///
    /// A property describes a single value within an object managed by the Core Data Framework. There are different types of property, each represented by a subclass which encapsulates the specific property behavior—see [`NSAttributeDescription`](https://developer.apple.com/documentation/coredata/nsattributedescription), [`NSRelationshipDescription`](https://developer.apple.com/documentation/coredata/nsrelationshipdescription), and [`NSFetchedPropertyDescription`](https://developer.apple.com/documentation/coredata/nsfetchedpropertydescription).
    ///
    /// Note that a property name cannot be the same as any no-parameter method name of `NSObject` or `NSManagedObject`. For example, you cannot give a property the name “description”. There are hundreds of methods on `NSObject` which may conflict with property names—and this list can grow without warning from frameworks or other libraries. You should avoid very general words (like “font”, and “color”) and words or phrases which overlap with Cocoa paradigms (such as “isEditing” and “objectSpecifier”).
    ///
    /// Properties—relationships as well as attributes—may be transient. A managed object context knows about transient properties and tracks changes made to them. Transient properties are ignored by the persistent store, and not just during saves: you cannot fetch using a predicate based on transients (although you can use transient properties to filter in memory yourself).
    ///
    /// ### Editing Property Descriptions
    ///
    /// Property descriptions are editable until they are used by an object graph manager (such as a persistent store coordinator). This allows you to create or modify them dynamically. However, once a description is used (when the managed object model to which it belongs is associated with a persistent store coordinator), it _must not_ (indeed cannot) be changed. This is enforced at runtime: any attempt to mutate a model or any of its sub-objects after the model is associated with a persistent store coordinator causes an exception to be thrown. If you need to modify a model that is in use, create a copy, modify the copy, and then discard the objects with the old model.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSPropertyDescription;
);

extern_conformance!(
    unsafe impl NSCoding for NSPropertyDescription {}
);

extern_conformance!(
    unsafe impl NSCopying for NSPropertyDescription {}
);

unsafe impl CopyingHelper for NSPropertyDescription {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSPropertyDescription {}
);

impl NSPropertyDescription {
    extern_methods!(
        #[cfg(feature = "NSEntityDescription")]
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(entity))]
        #[unsafe(method_family = none)]
        pub unsafe fn entity(&self) -> Retained<NSEntityDescription>;

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: &NSString);

        #[unsafe(method(isOptional))]
        #[unsafe(method_family = none)]
        pub unsafe fn isOptional(&self) -> bool;

        /// Setter for [`isOptional`][Self::isOptional].
        #[unsafe(method(setOptional:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOptional(&self, optional: bool);

        #[unsafe(method(isTransient))]
        #[unsafe(method_family = none)]
        pub unsafe fn isTransient(&self) -> bool;

        /// Setter for [`isTransient`][Self::isTransient].
        #[unsafe(method(setTransient:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTransient(&self, transient: bool);

        #[unsafe(method(validationPredicates))]
        #[unsafe(method_family = none)]
        pub unsafe fn validationPredicates(&self) -> Retained<NSArray<NSPredicate>>;

        #[unsafe(method(validationWarnings))]
        #[unsafe(method_family = none)]
        pub unsafe fn validationWarnings(&self) -> Retained<NSArray>;

        #[unsafe(method(setValidationPredicates:withValidationWarnings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValidationPredicates_withValidationWarnings(
            &self,
            validation_predicates: Option<&NSArray<NSPredicate>>,
            validation_warnings: Option<&NSArray<NSString>>,
        );

        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInfo(&self) -> Option<Retained<NSDictionary>>;

        /// Setter for [`userInfo`][Self::userInfo].
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(setUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&NSDictionary>);

        #[deprecated = "Use NSEntityDescription.indexes instead"]
        #[unsafe(method(isIndexed))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIndexed(&self) -> bool;

        /// Setter for [`isIndexed`][Self::isIndexed].
        #[deprecated = "Use NSEntityDescription.indexes instead"]
        #[unsafe(method(setIndexed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIndexed(&self, indexed: bool);

        #[unsafe(method(versionHash))]
        #[unsafe(method_family = none)]
        pub unsafe fn versionHash(&self) -> Retained<NSData>;

        #[unsafe(method(versionHashModifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn versionHashModifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`versionHashModifier`][Self::versionHashModifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setVersionHashModifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVersionHashModifier(&self, version_hash_modifier: Option<&NSString>);

        #[unsafe(method(isIndexedBySpotlight))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIndexedBySpotlight(&self) -> bool;

        /// Setter for [`isIndexedBySpotlight`][Self::isIndexedBySpotlight].
        #[unsafe(method(setIndexedBySpotlight:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIndexedBySpotlight(&self, indexed_by_spotlight: bool);

        #[deprecated = "Spotlight integration is deprecated. Use CoreSpotlight integration instead."]
        #[unsafe(method(isStoredInExternalRecord))]
        #[unsafe(method_family = none)]
        pub unsafe fn isStoredInExternalRecord(&self) -> bool;

        /// Setter for [`isStoredInExternalRecord`][Self::isStoredInExternalRecord].
        #[deprecated = "Spotlight integration is deprecated. Use CoreSpotlight integration instead."]
        #[unsafe(method(setStoredInExternalRecord:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStoredInExternalRecord(&self, stored_in_external_record: bool);

        #[unsafe(method(renamingIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn renamingIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`renamingIdentifier`][Self::renamingIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRenamingIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRenamingIdentifier(&self, renaming_identifier: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSPropertyDescription {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
