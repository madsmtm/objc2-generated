//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A controller that you use to manage the results of a Core Data fetch request and to display data to the user.
    ///
    /// ## Overview
    ///
    /// While you can use table views can in several ways, fetched results controllers primarily assist you with a primary list view. [`UITableView`](https://developer.apple.com/documentation/uikit/uitableview) expects its data source to provide cells as an array of sections made up of rows. You configure a fetched results controller using a _fetch request_ — an object that specifies what type of entity to fetch and how to sort the results. You can also add criteria for when to include a specific instance of the entity.
    ///
    /// The fetched results controller efficiently analyzes the result of the fetch request and computes all the information about sections in the result set. It also computes all the information for the index based on the result set.
    ///
    /// In addition, fetched results controllers:
    ///
    /// - Optionally monitor changes to objects in the associated managed object context, and report changes in the results set to its delegate (see [The controller’s delegate](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller#the-controllers-delegate)).
    ///
    /// - Optionally cache the results of its computation to enable redisplaying the same data without repeating the work to fetch it. For more information, see [The cache](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller#the-cache).
    ///
    /// A controller thus effectively has three modes of operation, determined by whether it has a delegate and whether you set the cache file name.
    ///
    /// - No tracking: The delegate is `nil`. The controller provides access to the data as it was when it fetched it.
    ///
    /// - Memory-only tracking: the delegate is non-`nil` and the file cache name is `nil`. The controller monitors objects in its result set and updates section and ordering information in response to relevant changes.
    ///
    /// - Full persistent tracking: the delegate and the file cache name are non-`nil`. The controller monitors objects in its result set and updates section and ordering information in response to relevant changes. The controller maintains a persistent cache of the results of its computation.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  A delegate must implement at least one of the change tracking delegate methods to enable change tracking. Providing an empty implementation of [`controllerDidChangeContent:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate/controllerdidchangecontent(_:)) is sufficient.
    ///
    ///
    ///
    /// </div>
    /// ### Using NSFetchedResultsController
    ///
    /// #### Creating the fetched results controller
    ///
    /// You typically create an instance of [`NSFetchedResultsController`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller) as an instance variable of a table view controller. When you initialize the fetch results controller, you provide four parameters:
    ///
    /// - A fetch request. This must contain at least one sort descriptor to order the results.
    ///
    /// - A managed object context. The controller uses this context to execute the fetch request.
    ///
    /// - Optionally, a key path on result objects that returns the section name. The controller uses the key path to split the results into sections (passing `nil` indicates that the controller should generate a single section).
    ///
    /// - Optionally, the name of the cache file the controller should use (passing `nil` prevents caching). Using a cache can avoid the overhead of computing the section and index information.
    ///
    /// After creating an instance, you invoke [`performFetch:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/performfetch()) to actually execute the fetch:
    ///
    /// ```swift
    /// // Get the managed object context from the persistent container.
    /// let context = coreDataStack.persistentContainer.viewContext
    ///
    /// // Create a fetch request and sort descriptor for the entity to display
    /// // in the table view.
    /// let fetchRequest: NSFetchRequest<Item> = Item.fetchRequest()
    /// let sortDescriptor = NSSortDescriptor(key: "name", ascending: true)
    /// fetchRequest.sortDescriptors = [sortDescriptor]
    ///
    /// // Initialize the fetched results controller with the fetch request and
    /// // managed object context.
    /// fetchedResultsController = NSFetchedResultsController(
    ///     fetchRequest: fetchRequest,
    ///     managedObjectContext: context,
    ///     sectionNameKeyPath: nil,
    ///     cacheName: nil)
    ///
    /// // Set the controller's delegate.
    /// fetchedResultsController?.delegate = self
    ///
    /// // Perform a fetch.
    /// do {
    ///     try fetchedResultsController?.performFetch()
    /// } catch {
    ///     // Handle error appropriately. It's useful to use
    ///     // `fatalError(_:file:line:)` during development.
    ///     fatalError("Failed to perform fetch: \(error.localizedDescription)")
    /// }
    /// ```
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  If you use a cache, call [`deleteCacheWithName:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/deletecache(withname:)) before changing any of the fetch request, its predicate, or its sort descriptors. Don’t reuse the same fetched results controller for multiple queries unless you set the [`cacheName`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/cachename) to `nil`.
    ///
    ///
    ///
    /// </div>
    /// #### The controller’s delegate
    ///
    /// If you set a delegate for a fetched results controller, the controller registers to receive change notifications from its managed object context. The controller processes any change in the context that affects the result set or section information and updates the results as necessary. The controller notifies the delegate when result objects change location or when changes occur in sections. For more information, see [`NSFetchedResultsControllerDelegate`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate). You typically use these methods to update the display of the table view.
    ///
    /// #### The cache
    ///
    /// Where possible, a controller uses a cache to avoid the need to repeat work performed in setting up any sections and ordering the contents. The system maintains the cache across launches of your application.
    ///
    /// When you initialize an instance of [`NSFetchedResultsController`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller), you typically specify a cache name. If you don’t specify a cache name, the controller doesn’t cache data. When you create a controller, it looks for an existing cache with the given name:
    ///
    /// - If the controller can’t find an appropriate cache, it calculates the required sections and the order of objects within sections. It then writes this information to disk.
    ///
    /// - If it finds a cache with the same name, the controller tests the cache to determine whether its contents are still valid. The controller compares the current entity name, entity version hash, sort descriptors, and section key-path with those stored in the cache, as well as the modification date of the cached information file and the persistent store file.
    ///
    /// If the cache is consistent with the current information, the controller reuses the previously-computed information.
    ///
    /// If the cache isn’t consistent with the current information, then the controller recomputes the required information and updates the cache.
    ///
    /// Any time the section and ordering information change, the controller updates cache.
    ///
    /// If you create multiple fetched results controllers with different configurations, such as different sort descriptors, give each configuration a different cache name.
    ///
    /// You can purge a cache using [`deleteCacheWithName:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/deletecache(withname:)).
    ///
    /// #### Implementing the table view datasource methods
    ///
    /// You ask the object to provide relevant information in your implementation of the table view data source methods:
    ///
    /// ```swift
    /// // Get the number of sections in the table view from the fetched results
    /// // controller.
    /// override func numberOfSections(in tableView: UITableView) -> Int {
    ///     fetchedResultsController?.sections?.count ?? 0
    /// }
    ///
    /// // Get the number of rows in each section of the table view from the fetched results controller.
    /// override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    ///     guard let sectionInfo = fetchedResultsController?.sections?[section] else {
    ///         return 0
    ///     }
    ///     
    ///     return sectionInfo.numberOfObjects
    /// }
    ///
    /// // Get table view cells for index paths from the fetched results controller.
    /// override func tableView(_ tableView: UITableView,
    ///                         cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    ///     let cell = tableView.dequeueReusableCell(withIdentifier: "ItemCell", for: indexPath)
    ///     let item = fetchedResultsController?.object(at: indexPath)
    ///     cell.textLabel?.text = item?.name
    ///     return cell
    /// }
    ///
    /// // Get the title of the header for the specified table view section from the
    /// // fetched results controller.
    /// override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
    ///     guard let sectionInfo = fetchedResultsController?.sections?[section] else {
    ///         return nil
    ///     }
    ///     
    ///     return sectionInfo.name
    /// }
    ///
    /// // Get the section index titles from the fetched results controller.
    /// override func sectionIndexTitles(for tableView: UITableView) -> [String]? {
    ///     fetchedResultsController?.sectionIndexTitles
    /// }
    ///
    /// // Get the section for the specified index title from the fetched
    /// // results controller.
    /// override func tableView(_ tableView: UITableView,
    ///                         sectionForSectionIndexTitle title: String,
    ///                         at index: Int) -> Int {
    ///     guard let result = fetchedResultsController?.section(forSectionIndexTitle: title,
    ///                                                          at: index) else {
    ///         fatalError("Failed to locate section for \(title) at index \(index)")
    ///     }
    ///     
    ///     return result
    /// }
    /// ```
    ///
    /// #### Responding to changes
    ///
    /// I[`NSFetchedResultsController`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller) responds to changes at the model layer, and informs its delegate when result objects change location or when sections change.
    ///
    /// If you allow a user to reorder table rows, then your implementation of the delegate methods must take this into account; see [`NSFetchedResultsControllerDelegate`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate).
    ///
    /// The controller doesn’t show changes until after its managed object context receives a [`processPendingChanges`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/processpendingchanges()) message. Therefore, if you change the value of a managed object’s attribute so that its location in a fetched results controller’s results set changes, its index as reported by the controller won’t typically change until the end of the current event cycle, when the system calls [`processPendingChanges`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/processpendingchanges()). For example, the following code would log `“same”`:
    ///
    /// ```swift
    /// // Obtain a managed object from the fetched objects.
    /// guard let managedObject = fetchedResultsController?.object(at: IndexPath(index: 0)),
    ///       // Get the object's index path before changing it.
    ///       let beforeIndexPath = fetchedResultsController?.indexPath(forObject: managedObject)
    /// else {
    ///     return
    /// }
    ///
    /// // Change the object.
    /// managedObject.setValue("My Item", forKey: "name")
    ///
    /// // Get the object's index path after changing it.
    /// if let afterIndexPath = fetchedResultsController?.indexPath(forObject: managedObject),
    ///    // Compare the index paths before and after the change.
    ///    beforeIndexPath.compare(afterIndexPath) == .orderedSame {
    ///     print("Same")
    /// }
    /// ```
    ///
    /// #### Modifying the fetch request
    ///
    /// You can’t change the fetch request to modify the results. Do the following if you want to change the fetch request:
    ///
    /// 1. Delete the cache if you’re using one, by calling [`deleteCacheWithName:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/deletecache(withname:)).
    ///
    /// 2. Change the fetch request.
    ///
    /// 3. Call [`performFetch:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/performfetch()).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Don’t use a cache if you’re changing the fetch request.
    ///
    ///
    ///
    /// </div>
    /// #### Handling object invalidation
    ///
    /// When a managed object context notifies the fetched results controller of invalidated _individual_ objects, the controller treats these as deleted objects and sends the proper delegate calls.
    ///
    /// Simultaneous invalidation of _all_ the objects in a managed object context is possible, for example, as a result of calling [`reset`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/reset()), or if you remove a store from the persistent store coordinator. When this happens, [`NSFetchedResultsController`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller) doesn’t invalidate all objects, nor does it send individual notifications for object deletions. Instead, you need to call [`performFetch:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/performfetch()) to reset the state of the controller then reload the data in the table view ([`reloadData`](https://developer.apple.com/documentation/uikit/uitableview/reloaddata())).
    ///
    /// ### Subclassing notes
    ///
    /// You create a subclass of this class if you want to customize the creation of sections and index titles. You override [`sectionIndexTitleForSectionName:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/sectionindextitle(forsectionname:)) if you want the section index title to be something other than the capitalized first letter of the section name. You override [`sectionIndexTitles`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/sectionindextitles) if you want the index titles to be something other than the array created by calling [`sectionIndexTitleForSectionName:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller/sectionindextitle(forsectionname:)) on all the known sections.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSFetchRequest")]
    pub struct NSFetchedResultsController<ResultType: ?Sized = AnyObject>;
);

#[cfg(feature = "NSFetchRequest")]
impl<ResultType: ?Sized + Message + NSFetchRequestResult> NSFetchedResultsController<ResultType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewResultType: ?Sized + Message + NSFetchRequestResult>(
        &self,
    ) -> &NSFetchedResultsController<NewResultType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSFetchRequest")]
extern_conformance!(
    unsafe impl<ResultType: ?Sized + NSFetchRequestResult> NSObjectProtocol
        for NSFetchedResultsController<ResultType>
    {
    }
);

#[cfg(feature = "NSFetchRequest")]
impl<ResultType: Message + NSFetchRequestResult> NSFetchedResultsController<ResultType> {
    extern_methods!(
        #[cfg(all(
            feature = "NSManagedObjectContext",
            feature = "NSPersistentStoreRequest"
        ))]
        #[unsafe(method(initWithFetchRequest:managedObjectContext:sectionNameKeyPath:cacheName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFetchRequest_managedObjectContext_sectionNameKeyPath_cacheName(
            this: Allocated<Self>,
            fetch_request: &NSFetchRequest<ResultType>,
            context: &NSManagedObjectContext,
            section_name_key_path: Option<&NSString>,
            name: Option<&NSString>,
        ) -> Retained<Self>;

        #[unsafe(method(performFetch:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn performFetch(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSPersistentStoreRequest")]
        #[unsafe(method(fetchRequest))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchRequest(&self) -> Retained<NSFetchRequest<ResultType>>;

        #[cfg(feature = "NSManagedObjectContext")]
        #[unsafe(method(managedObjectContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn managedObjectContext(&self) -> Retained<NSManagedObjectContext>;

        #[unsafe(method(sectionNameKeyPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn sectionNameKeyPath(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(cacheName))]
        #[unsafe(method_family = none)]
        pub unsafe fn cacheName(&self) -> Option<Retained<NSString>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSFetchedResultsControllerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSFetchedResultsControllerDelegate>>,
        );

        #[unsafe(method(deleteCacheWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteCacheWithName(name: Option<&NSString>);

        #[unsafe(method(fetchedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchedObjects(&self) -> Option<Retained<NSArray<ResultType>>>;

        #[unsafe(method(objectAtIndexPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndexPath(&self, index_path: &NSIndexPath) -> Retained<ResultType>;

        #[unsafe(method(indexPathForObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexPathForObject(
            &self,
            object: &ResultType,
        ) -> Option<Retained<NSIndexPath>>;

        #[unsafe(method(sectionIndexTitleForSectionName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sectionIndexTitleForSectionName(
            &self,
            section_name: &NSString,
        ) -> Option<Retained<NSString>>;

        #[unsafe(method(sectionIndexTitles))]
        #[unsafe(method_family = none)]
        pub unsafe fn sectionIndexTitles(&self) -> Retained<NSArray<NSString>>;

        #[unsafe(method(sections))]
        #[unsafe(method_family = none)]
        pub unsafe fn sections(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn NSFetchedResultsSectionInfo>>>>;

        #[unsafe(method(sectionForSectionIndexTitle:atIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sectionForSectionIndexTitle_atIndex(
            &self,
            title: &NSString,
            section_index: NSInteger,
        ) -> NSInteger;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSFetchRequest")]
impl<ResultType: Message + NSFetchRequestResult> NSFetchedResultsController<ResultType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A protocol that defines the interface for section objects vended by a fetched results controller.
    pub unsafe trait NSFetchedResultsSectionInfo {
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        unsafe fn name(&self) -> Retained<NSString>;

        #[unsafe(method(indexTitle))]
        #[unsafe(method_family = none)]
        unsafe fn indexTitle(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(numberOfObjects))]
        #[unsafe(method_family = none)]
        unsafe fn numberOfObjects(&self) -> NSUInteger;

        #[unsafe(method(objects))]
        #[unsafe(method_family = none)]
        unsafe fn objects(&self) -> Option<Retained<NSArray>>;
    }
);

/// Constants that specify the possible types of changes that are reported.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSFetchedResultsChangeType(pub NSUInteger);
impl NSFetchedResultsChangeType {
    /// Specifies that an object was inserted.
    #[doc(alias = "NSFetchedResultsChangeInsert")]
    pub const Insert: Self = Self(1);
    /// Specifies that an object was deleted.
    #[doc(alias = "NSFetchedResultsChangeDelete")]
    pub const Delete: Self = Self(2);
    /// Specifies that an object was moved.
    #[doc(alias = "NSFetchedResultsChangeMove")]
    pub const Move: Self = Self(3);
    /// Specifies that an object was changed.
    #[doc(alias = "NSFetchedResultsChangeUpdate")]
    pub const Update: Self = Self(4);
}

unsafe impl Encode for NSFetchedResultsChangeType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFetchedResultsChangeType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A delegate protocol that describes the methods that the associated fetched results controller calls when the fetch results change.
    ///
    /// ## Overview
    ///
    /// Consider whether to update the table view for each change. For a large number of simultaneous modifications simultaneously, such as if your app reads data on a background thread, it may be computationally expensive to animate all the changes. Rather than respond to changes individually (as illustrated in [Typical use](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate#typical-use)), implement [`controllerDidChangeContent:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate/controllerdidchangecontent(_:)) to reload the table view after the system processes all pending changes.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The fetched results controller reports changes to its section before changes to the fetched objects themselves.
    ///
    ///
    ///
    /// </div>
    /// ### Typical use
    ///
    /// When a fetched results controller provides the content to a table view, you can use [`controllerWillChangeContent:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate/controllerwillchangecontent(_:)) and [`controllerDidChangeContent:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate/controllerdidchangecontent(_:)) to bracket updates to the table view, as shown in the following example:
    ///
    /// ```swift
    /// // Find out when the fetched results controller is about to start making changes.
    /// func controllerWillChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
    ///     // Start animating table view changes simultaneously.
    ///     tableView.beginUpdates()
    /// }
    ///
    /// // Find out when the fetched results controller finishes making changes.
    /// func controllerDidChangeContent(_ controller: NSFetchedResultsController<NSFetchRequestResult>) {
    ///     // Stop animating table view changes simultaneously.
    ///     tableView.endUpdates()
    /// }
    ///
    /// // Find out when the fetched results controller adds or removes a section.
    /// func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,
    ///                 didChange sectionInfo: NSFetchedResultsSectionInfo,
    ///                 atSectionIndex sectionIndex: Int,
    ///                 for type: NSFetchedResultsChangeType) {
    ///     switch type {
    ///     case .insert:
    ///         // Insert a new section with fade animation.
    ///         tableView.insertSections(IndexSet(integer: sectionIndex), with: .fade)
    ///     case .delete:
    ///         // Delete a section with fade animation.
    ///         tableView.deleteSections(IndexSet(integer: sectionIndex), with: .fade)
    ///     default:
    ///         break
    ///     }
    /// }
    ///
    /// // Find out when the fetched results controller adds, removes, moves, or
    /// // updates a fetched object.
    /// func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,
    ///                 didChange anObject: Any,
    ///                 at indexPath: IndexPath?,
    ///                 for type: NSFetchedResultsChangeType,
    ///                 newIndexPath: IndexPath?) {
    ///     switch type {
    ///     case .insert:
    ///         guard let newIndexPath else { return }
    ///         // Insert a new row with fade animation when the fetched results
    ///         // controller adds or moves an object to the specified index path.
    ///         tableView.insertRows(at: [newIndexPath], with: .fade)
    ///     case .delete:
    ///         guard let indexPath else { return }
    ///         // Delete the row with animation at the old index path when the fetched
    ///         // results controller deletes or moves the associated object.
    ///         tableView.deleteRows(at: [indexPath], with: .fade)
    ///     case .update:
    ///         guard let indexPath else { return }
    ///         // Update the cell as the specified indexPath.
    ///         if let cell = tableView.cellForRow(at: indexPath) {
    ///             cell.textLabel?.text = fetchedResultsController?.object(at: indexPath).name
    ///         }
    ///     case .move:
    ///         guard let indexPath, let newIndexPath else { return }
    ///         // Move a row from the specified index path to the new index path.
    ///         tableView.moveRow(at: indexPath, to: newIndexPath)
    ///     @unknown default:
    ///         break
    ///     }
    /// }
    /// ```
    ///
    /// ### User-driven updates
    ///
    /// In general, [`NSFetchedResultsControllerDelegate`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate) responds to changes at the model layer. If you allow a user to reorder table rows, then your implementation of the delegate methods needs to take this into account.
    ///
    /// Typically, if you allow the user to reorder table rows, your model object has an attribute that specifies its index. When the user moves a row, you update this attribute accordingly. This, however, has the side effect of causing the fetched results controller to also notice the change, which causes it to inform its delegate of the update (using [`controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontrollerdelegate/controller(_:didchange:at:for:newindexpath:))). If you use the implementation of this method shown in the section above, then the delegate attempts to update the table view. However, the table view is already in the appropriate state because of the user’s action.
    ///
    /// Therefore, if you support user-driven updates, you should check if the user intitiated a move, such as by setting a flag. In the implementation of your delegate methods, bypass the method implementation if the user initiated the move, for example:
    ///
    /// ```objc
    /// func controller(_ controller: NSFetchedResultsController<NSFetchRequestResult>,
    ///                 didChange anObject: Any,
    ///                 at indexPath: IndexPath?,
    ///                 for type: NSFetchedResultsChangeType,
    ///                 newIndexPath: IndexPath?) {
    ///     // If you allow users to reorder table rows, bypass automated handling
    ///     // of the change because the model layer already handles it.
    ///     guard changeIsUserDriven == false else { return }
    ///     
    ///     switch type {
    ///     case .insert:
    ///         guard let newIndexPath else { return }
    ///     // Remaining implementation.
    /// }
    /// ```
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Prior to iOS 4.0, [`NSFetchedResultsController`](https://developer.apple.com/documentation/coredata/nsfetchedresultscontroller) doesn’t support deleting sections as a result of a UI-driven change.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait NSFetchedResultsControllerDelegate: NSObjectProtocol {
        #[cfg(all(feature = "NSFetchRequest", feature = "NSManagedObjectID"))]
        /// # Safety
        ///
        /// `controller` generic should be bound by `NSFetchRequestResult`.
        #[optional]
        #[unsafe(method(controller:didChangeContentWithDifference:))]
        #[unsafe(method_family = none)]
        unsafe fn controller_didChangeContentWithDifference(
            &self,
            controller: &NSFetchedResultsController,
            diff: &NSOrderedCollectionDifference<NSManagedObjectID>,
        );

        #[cfg(feature = "NSFetchRequest")]
        /// # Safety
        ///
        /// - `controller` generic should be bound by `NSFetchRequestResult`.
        /// - `an_object` should be of the correct type.
        #[optional]
        #[unsafe(method(controller:didChangeObject:atIndexPath:forChangeType:newIndexPath:))]
        #[unsafe(method_family = none)]
        unsafe fn controller_didChangeObject_atIndexPath_forChangeType_newIndexPath(
            &self,
            controller: &NSFetchedResultsController,
            an_object: &AnyObject,
            index_path: Option<&NSIndexPath>,
            r#type: NSFetchedResultsChangeType,
            new_index_path: Option<&NSIndexPath>,
        );

        #[cfg(feature = "NSFetchRequest")]
        /// # Safety
        ///
        /// `controller` generic should be bound by `NSFetchRequestResult`.
        #[optional]
        #[unsafe(method(controller:didChangeSection:atIndex:forChangeType:))]
        #[unsafe(method_family = none)]
        unsafe fn controller_didChangeSection_atIndex_forChangeType(
            &self,
            controller: &NSFetchedResultsController,
            section_info: &ProtocolObject<dyn NSFetchedResultsSectionInfo>,
            section_index: NSUInteger,
            r#type: NSFetchedResultsChangeType,
        );

        #[cfg(feature = "NSFetchRequest")]
        /// # Safety
        ///
        /// `controller` generic should be bound by `NSFetchRequestResult`.
        #[optional]
        #[unsafe(method(controllerWillChangeContent:))]
        #[unsafe(method_family = none)]
        unsafe fn controllerWillChangeContent(&self, controller: &NSFetchedResultsController);

        #[cfg(feature = "NSFetchRequest")]
        /// # Safety
        ///
        /// `controller` generic should be bound by `NSFetchRequestResult`.
        #[optional]
        #[unsafe(method(controllerDidChangeContent:))]
        #[unsafe(method_family = none)]
        unsafe fn controllerDidChangeContent(&self, controller: &NSFetchedResultsController);

        #[cfg(feature = "NSFetchRequest")]
        /// # Safety
        ///
        /// `controller` generic should be bound by `NSFetchRequestResult`.
        #[optional]
        #[unsafe(method(controller:sectionIndexTitleForSectionName:))]
        #[unsafe(method_family = none)]
        unsafe fn controller_sectionIndexTitleForSectionName(
            &self,
            controller: &NSFetchedResultsController,
            section_name: &NSString,
        ) -> Option<Retained<NSString>>;
    }
);
