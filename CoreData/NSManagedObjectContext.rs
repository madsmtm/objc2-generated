//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// A notification that posts before a context writes unsaved changes.
    ///
    /// ## Discussion
    ///
    /// This notification’s `object` is the context that’s about to save. Only use the notification to operate on the in-process save operation. For example, to insert additional managed objects. Don’t peform any asynchronous work or block the calling thread. [`NSManagedObjectContext`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext) posts notifications to the same thread that creates it.
    ///
    /// There is no `userInfo` dictionary.
    ///
    ///
    pub static NSManagedObjectContextWillSaveNotification: &'static NSString;
}

extern "C" {
    /// A notification that posts after a context finishes writing unsaved changes.
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Use [`NSManagedObjectContextDidSaveObjectIDsNotification`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontextdidsaveobjectidsnotification) instead of this notification.
    ///
    ///
    ///
    /// </div>
    /// This notification’s `object` is the saved context. Don’t peform any asynchronous work or block the calling thread. [`NSManagedObjectContext`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext) posts notifications to the same thread that creates it.
    ///
    /// The `userInfo` dictionary contains the inserted, updated, and deleted managed objects of the completed save. For the keys to access those objects, see [`NSManagedObjectContext.NotificationKey`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/notificationkey). Don’t capture the dictionary’s contents.
    ///
    /// To safely use the provided managed objects on the current thread, create a new context and use its [`mergeChanges(fromContextDidSave:)`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/mergechanges(fromcontextdidsave:)) method to merge in the notification’s changes.
    ///
    ///
    pub static NSManagedObjectContextDidSaveNotification: &'static NSString;
}

extern "C" {
    /// A notification that posts when there are changes to context’s registered managed objects.
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This notification posts only when there are changes to the context’s registered managed objects. It doesn’t post when a fetch adds managed objects to the context.
    ///
    ///
    ///
    /// </div>
    /// This notification’s `object` property is the changed managed object context. Don’t peform any asynchronous work or block the calling thread. [`NSManagedObjectContext`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext) posts notifications to the same thread that creates it.
    ///
    /// The `userInfo` dictionary contains the inserted, updated, deleted, and invalidated managed objects. For the keys to access those objects, see [`NSManagedObjectContext.NotificationKey`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/notificationkey). Don’t capture the dictionary’s contents.
    ///
    ///
    pub static NSManagedObjectContextObjectsDidChangeNotification: &'static NSString;
}

extern "C" {
    /// A notification that posts after a context finishes writing changes.
    ///
    /// ## Discussion
    ///
    /// This notification’s `object` is the saved context. Don’t peform any asynchronous work or block the calling thread. [`NSManagedObjectContext`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext) posts notifications to the same thread that creates it.
    ///
    /// The `userInfo` dictionary contains the identifiers of the inserted, updated, deleted, and invalidated managed objects. For the keys to access those objects, see [`NSManagedObjectContext.NotificationKey`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/notificationkey). It’s safe to capture the dictionary’s contents.
    ///
    /// Use this notification instead of [`NSManagedObjectContextDidSaveNotification`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontextdidsavenotification) if you intend to process the changed managed object on a different thread. It’s safe to pass instances of [`NSManagedObjectID`](https://developer.apple.com/documentation/coredata/nsmanagedobjectid) across thread boundaries.
    ///
    ///
    pub static NSManagedObjectContextDidSaveObjectIDsNotification: &'static NSString;
}

extern "C" {
    pub static NSManagedObjectContextDidMergeChangesObjectIDsNotification: &'static NSString;
}

extern "C" {
    /// A key for the set of objects that were inserted into the context.
    pub static NSInsertedObjectsKey: &'static NSString;
}

extern "C" {
    /// A key for the set of objects that were updated.
    pub static NSUpdatedObjectsKey: &'static NSString;
}

extern "C" {
    /// A key for the set of objects that were marked for deletion during the previous event.
    pub static NSDeletedObjectsKey: &'static NSString;
}

extern "C" {
    /// A key for the set of objects that were refreshed but were not dirtied in the scope of this context.
    pub static NSRefreshedObjectsKey: &'static NSString;
}

extern "C" {
    /// A key for the set of objects that were invalidated.
    pub static NSInvalidatedObjectsKey: &'static NSString;
}

extern "C" {
    /// Constant used to reference the query generation token.
    pub static NSManagedObjectContextQueryGenerationKey: &'static NSString;
}

extern "C" {
    /// A key that specifies that all objects in the context have been invalidated.
    pub static NSInvalidatedAllObjectsKey: &'static NSString;
}

extern "C" {
    /// A user info key to identify inserted object identifiers in notifications after saving a managed object context.
    pub static NSInsertedObjectIDsKey: &'static NSString;
}

extern "C" {
    /// A user info key to identify updated object identifiers in notifications after saving a managed object context.
    pub static NSUpdatedObjectIDsKey: &'static NSString;
}

extern "C" {
    /// A user info key to identify deleted object identifiers in notifications after saving a managed object context.
    pub static NSDeletedObjectIDsKey: &'static NSString;
}

extern "C" {
    /// A user info key to identify refreshed object identifiers in notifications after saving a managed object context.
    pub static NSRefreshedObjectIDsKey: &'static NSString;
}

extern "C" {
    /// A user info key to identify invalidated object identifiers in notifications after saving a managed object context.
    pub static NSInvalidatedObjectIDsKey: &'static NSString;
}

/// The concurrency types you can use with a managed object context.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSManagedObjectContextConcurrencyType(pub NSUInteger);
impl NSManagedObjectContextConcurrencyType {
    /// Specifies that the context will use the thread confinement pattern.
    #[doc(alias = "NSConfinementConcurrencyType")]
    #[deprecated = "Use another NSManagedObjectContextConcurrencyType"]
    pub const ConfinementConcurrencyType: Self = Self(0x00);
    /// Specifies that the context will be associated with a private dispatch queue.
    #[doc(alias = "NSPrivateQueueConcurrencyType")]
    pub const PrivateQueueConcurrencyType: Self = Self(0x01);
    /// Specifies that the context will be associated with the main queue.
    #[doc(alias = "NSMainQueueConcurrencyType")]
    pub const MainQueueConcurrencyType: Self = Self(0x02);
}

unsafe impl Encode for NSManagedObjectContextConcurrencyType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSManagedObjectContextConcurrencyType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object space to manipulate and track changes to managed objects.
    ///
    /// ## Overview
    ///
    /// A context consists of a group of related model objects that represent an internally consistent view of one or more persistent stores. Changes to managed objects remain in memory in the associated context until Core Data saves that context to one or more persistent stores. A single managed object instance exists in one and only one context, but multiple copies of an object can exist in different contexts. Therefore, an object is unique to a particular context.
    ///
    /// ### Life cycle management
    ///
    /// The context is a powerful object with a central role in the life cycle of managed objects, with responsibilities from life cycle management (including faulting) to validation, inverse relationship handling, and undo/redo. Through a context you can retrieve or “fetch” objects from a persistent store, make changes to those objects, and then either discard the changes or—again through the context—commit them back to the persistent store. The context is responsible for watching for changes in its objects and maintains an undo manager so you can have finer-grained control over undo and redo. You can insert new objects and delete ones you have fetched, and commit these modifications to the persistent store.
    ///
    /// All objects fetched from an external store are registered in a context together with a global identifier (an instance of `NSManagedObjectID`) that’s used to uniquely identify each object to the external store.
    ///
    /// ### Parent store
    ///
    /// Managed object contexts have a parent store from which they retrieve data representing managed objects and through which they commit changes to managed objects.
    ///
    /// Prior to OS X v10.7 and iOS v5.0, the parent store is always a persistent store coordinator. In macOS 10.7 and later and iOS v5.0 and later, the parent store may be another managed object context. Ultimately the root of a context’s ancestry must be a persistent store coordinator. The coordinator provides the managed object model and dispatches requests to the various persistent stores containing the data.
    ///
    /// If a context’s parent store is another managed object context, fetch and save operations are mediated by the parent context instead of a coordinator. This pattern has a number of usage scenarios, including:
    ///
    /// - Performing background operations on a second thread or queue.
    ///
    /// - Managing discardable edits, such as in an inspector window or view.
    ///
    /// As the first scenario implies, a parent context can service requests from children on different threads. You cannot, therefore, use parent contexts created with the thread confinement type (see [Concurrency](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext#concurrency)).
    ///
    /// When you save changes in a context, the changes are only committed “one store up.” If you save a child context, changes are pushed to its parent. Changes are not saved to the persistent store until the root context is saved. (A root managed object context is one whose parent context is `nil`.) In addition, a parent does not pull changes from children before it saves. You must save a child context if you want ultimately to commit the changes.
    ///
    /// ### Notifications
    ///
    /// A context posts notifications at various points—see [`NSManagedObjectContextObjectsDidChange`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/nsmanagedobjectcontextobjectsdidchange) for example. Typically, you should register to receive these notifications only from known contexts:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["NotificationCenter.default.addObserver(self,", "                                       selector: #selector(<#methodToCall#>),", "                                       name: .NSManagedObjectContextDidSave,", "                                       object: <#managedObjectContext#>)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[[NSNotificationCenter defaultCenter] addObserver:self", "                                      selector:@selector(<#Selector name#>)", "                                      name:NSManagedObjectContextDidSaveNotification", "                                      object:<#A managed object context#>];"], metadata: None }] }] })
    /// Several system frameworks use Core Data internally. If you register to receive these notifications from all contexts (by passing `nil` as the object parameter to a method such as [`addObserver:selector:name:object:`](https://developer.apple.com/documentation/foundation/notificationcenter/addobserver(_:selector:name:object:))), then you may receive unexpected notifications that are difficult to handle.
    ///
    /// ### Concurrency
    ///
    /// Core Data uses thread (or serialized queue) confinement to protect managed objects and managed object contexts (see [Core Data Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/index.html#//apple_ref/doc/uid/TP40001075)). A consequence of this is that a context assumes the default owner is the thread or queue that creates it. Don’t, therefore, initialize a context on one thread then pass it to another. Instead, pass a reference to a persistent store coordinator and have the receiving thread or queue create a new context using that. If you use [`NSOperation`](https://developer.apple.com/documentation/foundation/operation), you must create the context in [`main`](https://developer.apple.com/documentation/foundation/operation/main()) (for a serial queue) or [`start`](https://developer.apple.com/documentation/foundation/operation/start()) (for a concurrent queue).
    ///
    /// When you create a context you specify the concurrency type with which you’ll use it. When you create a managed object context, you have two options for its thread (queue) association:
    ///
    /// - Private: The context creates and manages a private queue.
    ///
    /// - Main: The context associates with the main queue and is dependent on the application’s event loop; otherwise, it’s similar to a private context. Use this type for contexts that update view controllers and other user interface elements.
    ///
    /// You use contexts using the queue-based concurrency types in conjunction with [`performBlock:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/perform(_:)) and [`performBlockAndWait:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/performandwait(_:)-ypye). You group “standard” messages to send to the context within a block to pass to one of these methods. There are two exceptions:
    ///
    /// - Setter methods on queue-based managed object contexts are thread-safe. You can invoke these methods directly on any thread.
    ///
    /// - If your code executes on the main thread, you can invoke methods on the main queue style contexts directly instead of using the block based API.
    ///
    /// [`performBlock:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/perform(_:)) and [`performBlockAndWait:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/performandwait(_:)-ypye) ensure the block operations execute on the correct queue for the context. The [`performBlock:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/perform(_:)) method returns immediately and the context executes the block methods on its own thread. With the [`performBlockAndWait:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/performandwait(_:)-ypye) method, the context still executes the block methods on its own thread, but the method doesn’t return until the block completes.
    ///
    /// It’s important to appreciate that blocks execute as a distinct body of work. As soon as your block ends, anyone else can enqueue another block, undo changes, reset the context, and so on. Thus blocks may be quite large, and typically end by invoking [`save:`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/save()).
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["var savedOK = false", "managedObjectContext.performAndWait() {", "", "    // Perform operations with the context.", "", "    do {", "        try managedObjectContext.save()", "        savedOK = true", "    } catch {", "        print(\"Error saving context: \\(error)\")", "    }", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["__block BOOL savedOK = NO;", "[managedObjectContext performBlockAndWait:^{", "", "    // Perform operations with the context.", "", "    NSError *error = nil;", "    if ([managedObjectContext save:&error]) {", "        savedOK = YES;", "    } else {", "        NSLog(@\"Error saving: %@\", error);", "    }", "}];"], metadata: None }] }] })
    /// You can also perform other operations, such as:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let fetchRequest: NSFetchRequest<Entity> = NSFetchRequest(entityName: \"Entity\")", "var count = 0", "", "managedObjectContext.performAndWait() {", "    do {", "        count = try managedObjectContext.count(for: fetchRequest)", "    } catch {", "        print(\"Error counting objects: \\(error)\")", "    }", "}", "", "print(\"The fetch request would return \\(count) objects\")"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSFetchRequest *fetchRequest = [NSFetchRequest fetchRequestWithEntityName:@\"Entity\"];", "__block NSUInteger count = 0;", "", "[managedObjectContext performBlockAndWait:^() {", "    NSError *error;", "    count = [managedObjectContext countForFetchRequest:fetchRequest error:&error];", "    if (count == NSNotFound) {", "        NSLog(@\"Error counting objects: %@\", error);", "    }", "}];", "", "NSLog(@\"The fetch request would return %lu objects\", count);"], metadata: None }] }] })
    /// ### Subclassing notes
    ///
    /// You are strongly discouraged from subclassing `NSManagedObjectContext`. The change tracking and undo management mechanisms are highly optimized and hence intricate and delicate. Interposing your own additional logic that might impact [`processPendingChanges`](https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/processpendingchanges()) can have unforeseen consequences. In situations such as store migration, Core Data will create instances of `NSManagedObjectContext` for its own use. Under these circumstances, you cannot rely on any features of your custom subclass. Any `NSManagedObject` subclass must always be fully compatible with `NSManagedObjectContext` (that is, it cannot rely on features of a subclass of `NSManagedObjectContext`).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSManagedObjectContext;
);

unsafe impl Send for NSManagedObjectContext {}

unsafe impl Sync for NSManagedObjectContext {}

extern_conformance!(
    unsafe impl NSCoding for NSManagedObjectContext {}
);

extern_conformance!(
    unsafe impl NSLocking for NSManagedObjectContext {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSManagedObjectContext {}
);

impl NSManagedObjectContext {
    extern_methods!(
        #[deprecated = "Use -initWithConcurrencyType: instead"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[deprecated = "Use -initWithConcurrencyType: instead"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithConcurrencyType:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithConcurrencyType(
            this: Allocated<Self>,
            ct: NSManagedObjectContextConcurrencyType,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[unsafe(method(performBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performBlock(&self, block: &block2::DynBlock<dyn Fn()>);

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[unsafe(method(performBlockAndWait:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performBlockAndWait(&self, block: &block2::DynBlock<dyn Fn() + '_>);

        #[cfg(feature = "NSPersistentStoreCoordinator")]
        #[unsafe(method(persistentStoreCoordinator))]
        #[unsafe(method_family = none)]
        pub unsafe fn persistentStoreCoordinator(
            &self,
        ) -> Option<Retained<NSPersistentStoreCoordinator>>;

        #[cfg(feature = "NSPersistentStoreCoordinator")]
        /// Setter for [`persistentStoreCoordinator`][Self::persistentStoreCoordinator].
        #[unsafe(method(setPersistentStoreCoordinator:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPersistentStoreCoordinator(
            &self,
            persistent_store_coordinator: Option<&NSPersistentStoreCoordinator>,
        );

        #[unsafe(method(parentContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn parentContext(&self) -> Option<Retained<NSManagedObjectContext>>;

        /// Setter for [`parentContext`][Self::parentContext].
        #[unsafe(method(setParentContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setParentContext(&self, parent_context: Option<&NSManagedObjectContext>);

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(undoManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn undoManager(&self, mtm: MainThreadMarker) -> Option<Retained<NSUndoManager>>;

        /// Setter for [`undoManager`][Self::undoManager].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setUndoManager:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUndoManager(&self, undo_manager: Option<&NSUndoManager>);

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(hasChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasChanges(&self) -> bool;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// - The returned generic should be of the correct type.
        /// - This might not be thread-safe.
        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInfo(&self) -> Retained<NSMutableDictionary>;

        #[unsafe(method(concurrencyType))]
        #[unsafe(method_family = none)]
        pub unsafe fn concurrencyType(&self) -> NSManagedObjectContextConcurrencyType;

        #[cfg(all(feature = "NSManagedObject", feature = "NSManagedObjectID"))]
        #[unsafe(method(objectRegisteredForID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectRegisteredForID(
            &self,
            object_id: &NSManagedObjectID,
        ) -> Option<Retained<NSManagedObject>>;

        #[cfg(all(feature = "NSManagedObject", feature = "NSManagedObjectID"))]
        #[unsafe(method(objectWithID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectWithID(
            &self,
            object_id: &NSManagedObjectID,
        ) -> Retained<NSManagedObject>;

        #[cfg(all(feature = "NSManagedObject", feature = "NSManagedObjectID"))]
        #[unsafe(method(existingObjectWithID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn existingObjectWithID_error(
            &self,
            object_id: &NSManagedObjectID,
        ) -> Result<Retained<NSManagedObject>, Retained<NSError>>;

        #[cfg(all(feature = "NSFetchRequest", feature = "NSPersistentStoreRequest"))]
        /// # Safety
        ///
        /// `request` generic should be bound by `NSFetchRequestResult`.
        #[unsafe(method(executeFetchRequest:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn executeFetchRequest_error(
            &self,
            request: &NSFetchRequest,
        ) -> Result<Retained<NSArray>, Retained<NSError>>;

        #[cfg(all(
            feature = "NSPersistentStoreRequest",
            feature = "NSPersistentStoreResult"
        ))]
        #[unsafe(method(executeRequest:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn executeRequest_error(
            &self,
            request: &NSPersistentStoreRequest,
        ) -> Result<Retained<NSPersistentStoreResult>, Retained<NSError>>;

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(insertObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertObject(&self, object: &NSManagedObject);

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(deleteObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteObject(&self, object: &NSManagedObject);

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(refreshObject:mergeChanges:))]
        #[unsafe(method_family = none)]
        pub unsafe fn refreshObject_mergeChanges(&self, object: &NSManagedObject, flag: bool);

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(detectConflictsForObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn detectConflictsForObject(&self, object: &NSManagedObject);

        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `change` generic should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(observeValueForKeyPath:ofObject:change:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn observeValueForKeyPath_ofObject_change_context(
            &self,
            key_path: Option<&NSString>,
            object: Option<&AnyObject>,
            change: Option<&NSDictionary<NSString, AnyObject>>,
            context: *mut c_void,
        );

        #[unsafe(method(processPendingChanges))]
        #[unsafe(method_family = none)]
        pub unsafe fn processPendingChanges(&self);

        #[cfg(feature = "NSPersistentStore")]
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(assignObject:toPersistentStore:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assignObject_toPersistentStore(
            &self,
            object: &AnyObject,
            store: &NSPersistentStore,
        );

        #[cfg(feature = "NSManagedObject")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(insertedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertedObjects(&self) -> Retained<NSSet<NSManagedObject>>;

        #[cfg(feature = "NSManagedObject")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(updatedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn updatedObjects(&self) -> Retained<NSSet<NSManagedObject>>;

        #[cfg(feature = "NSManagedObject")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(deletedObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn deletedObjects(&self) -> Retained<NSSet<NSManagedObject>>;

        #[cfg(feature = "NSManagedObject")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(registeredObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn registeredObjects(&self) -> Retained<NSSet<NSManagedObject>>;

        #[unsafe(method(undo))]
        #[unsafe(method_family = none)]
        pub unsafe fn undo(&self);

        #[unsafe(method(redo))]
        #[unsafe(method_family = none)]
        pub unsafe fn redo(&self);

        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);

        #[unsafe(method(rollback))]
        #[unsafe(method_family = none)]
        pub unsafe fn rollback(&self);

        #[unsafe(method(save:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn save(&self) -> Result<(), Retained<NSError>>;

        #[unsafe(method(refreshAllObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn refreshAllObjects(&self);

        #[deprecated = "Use a queue style context and -performBlockAndWait: instead"]
        #[unsafe(method(lock))]
        #[unsafe(method_family = none)]
        pub unsafe fn lock(&self);

        #[deprecated = "Use a queue style context and -performBlockAndWait: instead"]
        #[unsafe(method(unlock))]
        #[unsafe(method_family = none)]
        pub unsafe fn unlock(&self);

        #[deprecated = "Use a queue style context and -performBlock: instead"]
        #[unsafe(method(tryLock))]
        #[unsafe(method_family = none)]
        pub unsafe fn tryLock(&self) -> bool;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(propagatesDeletesAtEndOfEvent))]
        #[unsafe(method_family = none)]
        pub unsafe fn propagatesDeletesAtEndOfEvent(&self) -> bool;

        /// Setter for [`propagatesDeletesAtEndOfEvent`][Self::propagatesDeletesAtEndOfEvent].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setPropagatesDeletesAtEndOfEvent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPropagatesDeletesAtEndOfEvent(
            &self,
            propagates_deletes_at_end_of_event: bool,
        );

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(retainsRegisteredObjects))]
        #[unsafe(method_family = none)]
        pub unsafe fn retainsRegisteredObjects(&self) -> bool;

        /// Setter for [`retainsRegisteredObjects`][Self::retainsRegisteredObjects].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setRetainsRegisteredObjects:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRetainsRegisteredObjects(&self, retains_registered_objects: bool);

        #[unsafe(method(shouldDeleteInaccessibleFaults))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldDeleteInaccessibleFaults(&self) -> bool;

        /// Setter for [`shouldDeleteInaccessibleFaults`][Self::shouldDeleteInaccessibleFaults].
        #[unsafe(method(setShouldDeleteInaccessibleFaults:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setShouldDeleteInaccessibleFaults(
            &self,
            should_delete_inaccessible_faults: bool,
        );

        #[cfg(all(
            feature = "NSManagedObject",
            feature = "NSManagedObjectID",
            feature = "NSPropertyDescription"
        ))]
        #[unsafe(method(shouldHandleInaccessibleFault:forObjectID:triggeredByProperty:))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldHandleInaccessibleFault_forObjectID_triggeredByProperty(
            &self,
            fault: &NSManagedObject,
            oid: &NSManagedObjectID,
            property: Option<&NSPropertyDescription>,
        ) -> bool;

        #[unsafe(method(stalenessInterval))]
        #[unsafe(method_family = none)]
        pub unsafe fn stalenessInterval(&self) -> NSTimeInterval;

        /// Setter for [`stalenessInterval`][Self::stalenessInterval].
        #[unsafe(method(setStalenessInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStalenessInterval(&self, staleness_interval: NSTimeInterval);

        #[unsafe(method(mergePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn mergePolicy(&self) -> Retained<AnyObject>;

        /// Setter for [`mergePolicy`][Self::mergePolicy].
        ///
        /// # Safety
        ///
        /// `merge_policy` should be of the correct type.
        #[unsafe(method(setMergePolicy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMergePolicy(&self, merge_policy: &AnyObject);

        #[cfg(feature = "NSManagedObject")]
        #[unsafe(method(obtainPermanentIDsForObjects:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn obtainPermanentIDsForObjects_error(
            &self,
            objects: &NSArray<NSManagedObject>,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(mergeChangesFromContextDidSaveNotification:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mergeChangesFromContextDidSaveNotification(
            &self,
            notification: &NSNotification,
        );

        /// # Safety
        ///
        /// `change_notification_data` generic should be of the correct type.
        #[unsafe(method(mergeChangesFromRemoteContextSave:intoContexts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mergeChangesFromRemoteContextSave_intoContexts(
            change_notification_data: &NSDictionary,
            contexts: &NSArray<NSManagedObjectContext>,
        );

        #[cfg(feature = "NSQueryGenerationToken")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(queryGenerationToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn queryGenerationToken(&self) -> Option<Retained<NSQueryGenerationToken>>;

        #[cfg(feature = "NSQueryGenerationToken")]
        #[unsafe(method(setQueryGenerationFromToken:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setQueryGenerationFromToken_error(
            &self,
            generation: Option<&NSQueryGenerationToken>,
        ) -> Result<(), Retained<NSError>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(automaticallyMergesChangesFromParent))]
        #[unsafe(method_family = none)]
        pub unsafe fn automaticallyMergesChangesFromParent(&self) -> bool;

        /// Setter for [`automaticallyMergesChangesFromParent`][Self::automaticallyMergesChangesFromParent].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setAutomaticallyMergesChangesFromParent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAutomaticallyMergesChangesFromParent(
            &self,
            automatically_merges_changes_from_parent: bool,
        );

        #[unsafe(method(transactionAuthor))]
        #[unsafe(method_family = none)]
        pub unsafe fn transactionAuthor(&self) -> Option<Retained<NSString>>;

        /// Setter for [`transactionAuthor`][Self::transactionAuthor].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTransactionAuthor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTransactionAuthor(&self, transaction_author: Option<&NSString>);
    );
}
