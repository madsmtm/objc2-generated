//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An object that enables you to participate in the migration between two versions of the same model.
    ///
    /// ## Overview
    ///
    /// Use [`NSCustomMigrationStage`](https://developer.apple.com/documentation/coredata/nscustommigrationstage) when you have two versions of a model that Core Data can’t automatically migrate. Custom migration stages enable you to participate in the migration process by assigning handlers that the stage invokes before and after it runs. The handlers provide an opportunity to prepare the persistent store’s data for the upcoming changes before the stage runs, and perform any cleanup tasks afterward.
    ///
    /// For example, to support a migration that changes an optional attribute to be nonoptional, you might assign a handler to the stage’s [`willMigrateHandler`](https://developer.apple.com/documentation/coredata/nscustommigrationstage/willmigratehandler-5wead) property that sets any `nil` instances of that attribute to a default value, thereby ensuring the migration succeeds. To access the store you’re migrating, use the [`container`](https://developer.apple.com/documentation/coredata/nsstagedmigrationmanager/container) property of the migration manager that Core Data provides to every handler.
    ///
    ///
    #[unsafe(super(NSMigrationStage, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSMigrationStage")]
    pub struct NSCustomMigrationStage;
);

#[cfg(feature = "NSMigrationStage")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSCustomMigrationStage {}
);

#[cfg(feature = "NSMigrationStage")]
impl NSCustomMigrationStage {
    extern_methods!(
        #[cfg(feature = "NSManagedObjectModelReference")]
        #[unsafe(method(currentModel))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentModel(&self) -> Retained<NSManagedObjectModelReference>;

        #[cfg(feature = "NSManagedObjectModelReference")]
        #[unsafe(method(nextModel))]
        #[unsafe(method_family = none)]
        pub unsafe fn nextModel(&self) -> Retained<NSManagedObjectModelReference>;

        #[cfg(all(feature = "NSStagedMigrationManager", feature = "block2"))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        /// - The returned block's argument 3 must be a valid pointer or null.
        #[unsafe(method(willMigrateHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn willMigrateHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(
                NonNull<NSStagedMigrationManager>,
                NonNull<NSCustomMigrationStage>,
                *mut *mut NSError,
            ) -> Bool,
        >;

        #[cfg(all(feature = "NSStagedMigrationManager", feature = "block2"))]
        /// Setter for [`willMigrateHandler`][Self::willMigrateHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWillMigrateHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWillMigrateHandler(
            &self,
            will_migrate_handler: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<NSStagedMigrationManager>,
                        NonNull<NSCustomMigrationStage>,
                        *mut *mut NSError,
                    ) -> Bool,
                >,
            >,
        );

        #[cfg(all(feature = "NSStagedMigrationManager", feature = "block2"))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        /// - The returned block's argument 3 must be a valid pointer or null.
        #[unsafe(method(didMigrateHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn didMigrateHandler(
            &self,
        ) -> *mut block2::DynBlock<
            dyn Fn(
                NonNull<NSStagedMigrationManager>,
                NonNull<NSCustomMigrationStage>,
                *mut *mut NSError,
            ) -> Bool,
        >;

        #[cfg(all(feature = "NSStagedMigrationManager", feature = "block2"))]
        /// Setter for [`didMigrateHandler`][Self::didMigrateHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDidMigrateHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDidMigrateHandler(
            &self,
            did_migrate_handler: Option<
                &block2::DynBlock<
                    dyn Fn(
                        NonNull<NSStagedMigrationManager>,
                        NonNull<NSCustomMigrationStage>,
                        *mut *mut NSError,
                    ) -> Bool,
                >,
            >,
        );

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSManagedObjectModelReference")]
        #[unsafe(method(initWithCurrentModelReference:nextModelReference:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCurrentModelReference_nextModelReference(
            this: Allocated<Self>,
            current_model: &NSManagedObjectModelReference,
            next_model: &NSManagedObjectModelReference,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSMigrationStage")]
impl NSCustomMigrationStage {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
