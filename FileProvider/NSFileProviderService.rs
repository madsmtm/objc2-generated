//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/fileprovider/nsfileproviderservicesource?language=objc)
    pub unsafe trait NSFileProviderServiceSource {
        /// The service name that uniquely identifies the service (using reverse domain
        /// name notation for you service name is recommended).
        #[unsafe(method(serviceName))]
        #[unsafe(method_family = none)]
        unsafe fn serviceName(&self) -> Retained<NSFileProviderServiceName>;

        /// Return an endpoint object to allow the client application to connect to the
        /// file provider.
        /// The endpoint is retrieved from an anonymous
        /// `NSXPCListener`that the file
        /// provider creates. The file provider is in charge of accepting incoming
        /// `NSXPCConnection's`via
        /// `-[NSXPCListenerDelegate`listener:shouldAcceptNewConnection:],
        /// and setting up properties on the new connection, like its exported object and
        /// interfaces (that both the file provider and the client application have agreed
        /// on).
        #[unsafe(method(makeListenerEndpointAndReturnError:_))]
        #[unsafe(method_family = none)]
        unsafe fn makeListenerEndpointAndReturnError(
            &self,
        ) -> Result<Retained<NSXPCListenerEndpoint>, Retained<NSError>>;

        /// Indicates whether access to the service is restricted.
        ///
        /// A restricted service can only be accessed by processes that can manage the domain the service is attached to. It is only accessible
        /// through `-[NSFileProviderManager getServiceWithName:itemIdentifier:completionHandler:]`
        #[optional]
        #[unsafe(method(isRestricted))]
        #[unsafe(method_family = none)]
        unsafe fn isRestricted(&self) -> bool;
    }
);

/// NSFileProviderService.
///
/// A file provider can override the method in this category to return service
/// sources that provide custom communication channels to client applications.
/// The service sources must be tied to the item identified by
/// `itemIdentifier.`Client applications can retrieve the list of supported services by calling
/// `-[NSFileManager`getFileProviderServicesForItemAtURL:] for a specific item URL.
#[cfg(feature = "Extension")]
impl NSFileProviderExtension {
    extern_methods!(
        #[cfg(feature = "NSFileProviderItem")]
        #[unsafe(method(supportedServiceSourcesForItemIdentifier:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedServiceSourcesForItemIdentifier_error(
            &self,
            item_identifier: &NSFileProviderItemIdentifier,
        ) -> Result<
            Retained<NSArray<ProtocolObject<dyn NSFileProviderServiceSource>>>,
            Retained<NSError>,
        >;
    );
}

/// NSFileProviderService.
#[cfg(feature = "Extension")]
impl NSFileProviderManager {
    extern_methods!(
        #[cfg(all(feature = "NSFileProviderItem", feature = "block2"))]
        /// Retrieve the service with the specified named for the specified item.
        #[unsafe(method(getServiceWithName:itemIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getServiceWithName_itemIdentifier_completionHandler(
            &self,
            service_name: &NSFileProviderServiceName,
            item_identifier: &NSFileProviderItemIdentifier,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSFileProviderService, *mut NSError)>,
        );
    );
}
