//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-ui-kit")]
use objc2_ui_kit::*;
#[cfg(feature = "objc2-user-notifications")]
use objc2_user_notifications::*;

use crate::*;

/// The type of notification interface to display.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKUserNotificationInterfaceType(pub NSInteger);
impl WKUserNotificationInterfaceType {
    /// A constant indicating that the system should display the corresponding static interface instead. When you return this value, the system takes responsibility for displaying the notification’s content.
    #[doc(alias = "WKUserNotificationInterfaceTypeDefault")]
    pub const Default: Self = Self(0);
    /// A constant indicating that the system should display your dynamic notification interface.
    #[doc(alias = "WKUserNotificationInterfaceTypeCustom")]
    pub const Custom: Self = Self(1);
}

unsafe impl Encode for WKUserNotificationInterfaceType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKUserNotificationInterfaceType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Template images that you can use for menus.
///
/// ## Overview
///
/// Use these constants with the [`addMenuItemWithItemIcon:title:action:`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/addmenuitem(with:title:action:)-6pb4t) method to configure actions for your interface controller’s menu.
///
///
// NS_ENUM
#[deprecated]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKMenuItemIcon(pub NSInteger);
impl WKMenuItemIcon {
    /// The icon indicating an action to accept an event or item.
    #[doc(alias = "WKMenuItemIconAccept")]
    #[deprecated]
    pub const Accept: Self = Self(0);
    /// The icon indicating an action for adding an item.
    #[doc(alias = "WKMenuItemIconAdd")]
    #[deprecated]
    pub const Add: Self = Self(1);
    /// The icon indicating an action to block or prevent something from happening.
    #[doc(alias = "WKMenuItemIconBlock")]
    #[deprecated]
    pub const Block: Self = Self(2);
    /// The icon indicating an action to decline or cancel an event.
    #[doc(alias = "WKMenuItemIconDecline")]
    #[deprecated]
    pub const Decline: Self = Self(3);
    /// The icon indicating an action to retrieve more information.
    #[doc(alias = "WKMenuItemIconInfo")]
    #[deprecated]
    pub const Info: Self = Self(4);
    /// The icon indicating an answer of maybe for an action.
    #[doc(alias = "WKMenuItemIconMaybe")]
    #[deprecated]
    pub const Maybe: Self = Self(5);
    /// The icon indicating that more actions or options are available.
    #[doc(alias = "WKMenuItemIconMore")]
    #[deprecated]
    pub const More: Self = Self(6);
    /// The icon indicating an action to mute the sound.
    #[doc(alias = "WKMenuItemIconMute")]
    #[deprecated]
    pub const Mute: Self = Self(7);
    /// The icon indicating an action to pause playback.
    #[doc(alias = "WKMenuItemIconPause")]
    #[deprecated]
    pub const Pause: Self = Self(8);
    /// The icon indicating an action to play some content.
    #[doc(alias = "WKMenuItemIconPlay")]
    #[deprecated]
    pub const Play: Self = Self(9);
    /// The icon indicating that played content should repeat in a loop.
    #[doc(alias = "WKMenuItemIconRepeat")]
    #[deprecated]
    pub const Repeat: Self = Self(10);
    /// The icon indicating an action to resume playing some content.
    #[doc(alias = "WKMenuItemIconResume")]
    #[deprecated]
    pub const Resume: Self = Self(11);
    /// The icon indicating an action to share content.
    #[doc(alias = "WKMenuItemIconShare")]
    #[deprecated]
    pub const Share: Self = Self(12);
    /// The icon indicating an action to shuffle content.
    #[doc(alias = "WKMenuItemIconShuffle")]
    #[deprecated]
    pub const Shuffle: Self = Self(13);
    /// The icon indicating audio output.
    #[doc(alias = "WKMenuItemIconSpeaker")]
    #[deprecated]
    pub const Speaker: Self = Self(14);
    /// The icon indicating an action to delete some content.
    #[doc(alias = "WKMenuItemIconTrash")]
    #[deprecated]
    pub const Trash: Self = Self(15);
}

unsafe impl Encode for WKMenuItemIcon {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKMenuItemIcon {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The input modes supported by the text input controller.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKTextInputMode(pub NSInteger);
impl WKTextInputMode {
    /// Text from dictation and suggestions only. Do not allow emoji of any kind.
    #[doc(alias = "WKTextInputModePlain")]
    pub const Plain: Self = Self(0);
    /// Text from dictation and suggestions plus non animated emoji.
    #[doc(alias = "WKTextInputModeAllowEmoji")]
    pub const AllowEmoji: Self = Self(1);
    /// Text from dictation and suggestions plus both animated and non animated emoji.
    #[doc(alias = "WKTextInputModeAllowAnimatedEmoji")]
    #[deprecated = "Animated Emojis are no longer supported. Use WKTextInputModeAllowEmoji instead"]
    pub const AllowAnimatedEmoji: Self = Self(2);
}

unsafe impl Encode for WKTextInputMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKTextInputMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants indicating the styles for standard system alerts.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKAlertControllerStyle(pub NSInteger);
impl WKAlertControllerStyle {
    /// An alert sheet with stacked buttons. The alert sheet includes a default Cancel button at the bottom of the sheet. You can add other buttons, which are placed above the Cancel button.
    #[doc(alias = "WKAlertControllerStyleAlert")]
    pub const Alert: Self = Self(0);
    /// An alert sheet with side-by-side buttons.
    #[doc(alias = "WKAlertControllerStyleSideBySideButtonsAlert")]
    pub const SideBySideButtonsAlert: Self = Self(1);
    /// An action sheet style. Action sheets are modal sheets that can be dismissed using the Cancel button in the top-left corner of the sheet. You can also add one or two custom buttons to perform related tasks.
    #[doc(alias = "WKAlertControllerStyleActionSheet")]
    pub const ActionSheet: Self = Self(2);
}

unsafe impl Encode for WKAlertControllerStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKAlertControllerStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Scrolling orientations for page-based interfaces.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKPageOrientation(pub NSInteger);
impl WKPageOrientation {
    /// A horizontal page-based scrolling orientation.
    #[doc(alias = "WKPageOrientationHorizontal")]
    pub const Horizontal: Self = Self(0);
    /// A vertical page-based scrolling orientation.
    #[doc(alias = "WKPageOrientationVertical")]
    pub const Vertical: Self = Self(1);
}

unsafe impl Encode for WKPageOrientation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKPageOrientation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Onscreen scroll positions.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKInterfaceScrollPosition(pub NSInteger);
impl WKInterfaceScrollPosition {
    /// The top of the screen.
    #[doc(alias = "WKInterfaceScrollPositionTop")]
    pub const Top: Self = Self(0);
    /// The vertical center of the screen.
    #[doc(alias = "WKInterfaceScrollPositionCenteredVertically")]
    pub const CenteredVertically: Self = Self(1);
    /// The bottom of the screen.
    #[doc(alias = "WKInterfaceScrollPositionBottom")]
    pub const Bottom: Self = Self(2);
}

unsafe impl Encode for WKInterfaceScrollPosition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKInterfaceScrollPosition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants indicating the appearance of video content.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKVideoGravity(pub NSInteger);
impl WKVideoGravity {
    /// Content is resized to fit the bounds rectangle, preserving the original aspect ratio of the content. Content that does not completely fill the bounds rectangle is centered in the partial axis.
    #[doc(alias = "WKVideoGravityResizeAspect")]
    pub const ResizeAspect: Self = Self(0);
    /// Content is resized to fill the bounds rectangle completely while preserving the original aspect ratio of the content. This option results in cropping of the edges of the video in the axis it exceeds.
    #[doc(alias = "WKVideoGravityResizeAspectFill")]
    pub const ResizeAspectFill: Self = Self(1);
    /// Content is resized to fit the entire bounds rectangle. This option does not preserve the original aspect ratio of the content.
    #[doc(alias = "WKVideoGravityResize")]
    pub const Resize: Self = Self(2);
}

unsafe impl Encode for WKVideoGravity {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKVideoGravity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants indicating the quality of audio recordings.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKAudioRecorderPreset(pub NSInteger);
impl WKAudioRecorderPreset {
    /// Audio quality suitable for basic speech recording. This preset records audio with an 8 kHz sampling rate using either the LPCM 128 kbps or AAC 24 kbps format.
    #[doc(alias = "WKAudioRecorderPresetNarrowBandSpeech")]
    pub const NarrowBandSpeech: Self = Self(0);
    /// Audio quality suitable for higher fidelity speech recording. This preset records audio with a 16 kHz sampling rate using either the LPCM 256 kbps or AAC 32 kbps format.
    #[doc(alias = "WKAudioRecorderPresetWideBandSpeech")]
    pub const WideBandSpeech: Self = Self(1);
    /// A high-quality audio recording. This preset records audio with a 44.1 kHz sampling rate using either the LPCM 705.6 kbps or AAC 96 kbps format.
    #[doc(alias = "WKAudioRecorderPresetHighQualityAudio")]
    pub const HighQualityAudio: Self = Self(2);
}

unsafe impl Encode for WKAudioRecorderPreset {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKAudioRecorderPreset {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The option to play a media file automatically when it is displayed. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value indicating whether the media file should begin playing automatically when the interface is displayed. Playback is also contingent upon the file being available and ready to play on Apple Watch. If you do not specify this option, the user must initiate playback.
    pub static WKMediaPlayerControllerOptionsAutoplayKey: &'static NSString;
}

extern "C" {
    /// The number of seconds into the media file at which to begin playback. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an [`NSTimeInterval`](https://developer.apple.com/documentation/foundation/timeinterval) value. Playback begins at the specified number of seconds past the original start point of the media file. If you do not specify this option, playback begins at the beginning of the media file.
    pub static WKMediaPlayerControllerOptionsStartTimeKey: &'static NSString;
}

extern "C" {
    /// The behavior for resizing the video to fit the available space. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an appropriate constant of the [`WKVideoGravity`](https://developer.apple.com/documentation/watchkit/wkvideogravity) type.
    pub static WKMediaPlayerControllerOptionsVideoGravityKey: &'static NSString;
}

extern "C" {
    /// The behavior for playing the media in a loop. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value. Set the value to [`true`](https://developer.apple.com/documentation/swift/true) to play the media file in a loop. If this key is not present, the media file plays one time and then ends.
    pub static WKMediaPlayerControllerOptionsLoopsKey: &'static NSString;
}

extern "C" {
    /// The title to display on the button that the user taps to accept a recording. The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object. If you do not specify this option, the button title is set to “Save”.
    pub static WKAudioRecorderControllerOptionsActionTitleKey: &'static NSString;
}

extern "C" {
    /// The behavior for showing the action button. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object with a Boolean value. When the value is [`true`](https://developer.apple.com/documentation/swift/true), the recording interface always shows the action button. When the value is [`false`](https://developer.apple.com/documentation/swift/false), the sheet shows the button only after the user has recorded some audio. The default value for this option is YES.
    pub static WKAudioRecorderControllerOptionsAlwaysShowActionTitleKey: &'static NSString;
}

extern "C" {
    /// The automatic recording behavior of the action sheet. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object with a Boolean value. When the value is [`true`](https://developer.apple.com/documentation/swift/true), the recording interface starts recording as soon as it is presented. When the value is [`false`](https://developer.apple.com/documentation/swift/false), the user must start recording manually. The default value for this option is [`true`](https://developer.apple.com/documentation/swift/true).
    pub static WKAudioRecorderControllerOptionsAutorecordKey: &'static NSString;
}

extern "C" {
    /// The maximum length of recorded audio clips. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object with an [`NSTimeInterval`](https://developer.apple.com/documentation/foundation/timeinterval) value containing the maximum duration in seconds. If you do not specify this option, there is no maximum recording time.
    pub static WKAudioRecorderControllerOptionsMaximumDurationKey: &'static NSString;
}

extern_class!(
    /// A class that provides the infrastructure for managing the interface in a watchOS app.
    ///
    /// ## Overview
    ///
    /// An interface controller serves the same purpose as a [`UIViewController`](https://developer.apple.com/documentation/uikit/uiviewcontroller) object in a UIKit app, except that it doesn’t manage any actual views. It runs in your WatchKit extension and remotely manages the behavior associated with an interface controller in your Watch app’s storyboard file. You subclass [`WKInterfaceController`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller) and use its methods to configure the elements of your storyboard scene and to respond to interactions with those elements.
    ///
    /// Your interface controller code runs locally on the user’s Apple Watch but is separate from the interface that it manages. When you change the value of an interface object in your code, the system forwards the needed information to your Watch app, which makes the corresponding changes onscreen.
    ///
    /// ### Initialize your interface controllers
    ///
    /// When the user interacts with your app content, the system launches your extension and creates the appropriate interface controller objects automatically. Apps use different interface controllers to manage their notification and app interfaces; WatchKit uses the information in your app’s main storyboard file to determine which interface controller to load. Notification scenes are configured specially so that the system can identify them. For your app, WatchKit loads your app’s main interface controller initially, but you may change the initial interface controller at launch time.
    ///
    /// When creating an interface controller, WatchKit instantiates the class and calls its [`init`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/init()) method. You can use this method to initialize variables and load data; however, don’t use it to configure your user interface. The controller’s user interface elements may not be properly initialized when this method runs.
    ///
    /// Next, the system calls the [`awakeWithContext:`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/awake(withcontext:)) method. If WatchKit passes a valid object to the [`awakeWithContext:`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/awake(withcontext:)) method, use the information in that object to customize the initialization process. Also, the controller’s user interface elements are guaranteed to be available at this point. This means that you can safely use this method to configure your user interface.
    ///
    /// The [`willActivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willactivate()) method lets you know when your interface is about to become active. Use the [`willActivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willactivate()) method to perform any last minute tasks, such as checking for updates to your content; however, don’t use it for your primary initialization.
    ///
    /// The [`willActivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willactivate()) method may be called at times when your interface isn’t yet onscreen. For example, WatchKit may call the method in advance so that you have time to update your content. WatchKit calls the [`didAppear`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/didappear()) method to let you know when your interface becomes visible. Similarly, WatchKit calls the [`willDisappear`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willdisappear()) and [`didDeactivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/diddeactivate()) methods when your interface moves offscreen again.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  An interface controller can make changes to its interface only in the [`awakeWithContext:`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/awake(withcontext:)) method, in the [`willActivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willactivate()) method, and while the interface is active. Once the system calls the [`didDeactivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/diddeactivate()) method, it ignores any attempts to change the value of the controller’s interface objects until the system calls the interface controller’s [`willActivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willactivate()) method again.
    ///
    ///
    ///
    /// </div>
    /// In iOS Simulator, WatchKit calls the [`didDeactivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/diddeactivate()) method for the current interface controller when you lock the simulator by selecting Hardware > Lock. When you subsequently unlock the simulator, WatchKit calls that interface controller’s [`willActivate`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/willactivate()) method again. You can use this capability to debug your activation and deactivation code.
    ///
    /// ### Interface Builder configuration options
    ///
    /// Xcode lets you configure information about your interface controller in your storyboard file. The following table lists the attributes you can configure in your storyboard and their meaning.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Attribute" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Text { text: "Identifier" }] }], [Paragraph { inline_content: [Text { text: "The name of the interface controller. Use this name to specify which interface controller to push or present." }] }]], [[Paragraph { inline_content: [Text { text: "Title" }] }], [Paragraph { inline_content: [Text { text: "The title string assigned to the interface controller. You can set this value programmatically using the " }, Reference { identifier: "doc://com.apple.watchkit/documentation/WatchKit/WKInterfaceController/setTitle(_:)", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " method." }] }]], [[Paragraph { inline_content: [Text { text: "Is Initial Controller" }] }], [Paragraph { inline_content: [Text { text: "A Boolean indicating whether the object is the app’s root interface controller. Only one interface controller at a time may have this option enabled. This option doesn’t apply to glance or notification interface controllers." }] }]], [[Paragraph { inline_content: [Text { text: "Activity Indicator On Load" }] }], [Paragraph { inline_content: [Text { text: "A Boolean value that indicates whether the interface controller’s contents are hidden until the " }, Reference { identifier: "doc://com.apple.watchkit/documentation/WatchKit/WKInterfaceController/willActivate()", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " method returns. When you enable this option, the system displays a progress indicator until the " }, Reference { identifier: "doc://com.apple.watchkit/documentation/WatchKit/WKInterfaceController/willActivate()", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " method returns. You might disable this option if your interface contains mostly static information that can be displayed right away." }] }]], [[Paragraph { inline_content: [Text { text: "Always Bounce" }] }], [Paragraph { inline_content: [Text { text: "A Boolean value that turns off scrolling and allows built-in controls and containers to fill content to the screen edges, regardless of the content-safe area." }] }]], [[Paragraph { inline_content: [Text { text: "Full Screen" }] }], [Paragraph { inline_content: [Text { text: "A Boolean value that determines whether SpriteKit or SceneKit content can use the full screen. The system hides the status bar but displays the time in the upper-right corner with a gradient behind it, making the time clearly visible against the scene." }] }]], [[Paragraph { inline_content: [Text { text: "Fixed to screen edges" }] }], [Paragraph { inline_content: [Text { text: "A Boolean value that indicates whether the contents ignore the safe area and minimum layout margins. When you enable this option, the system turns off scrolling, and allows built-in controls and containers to fill content to the screen edges." }] }]], [[Paragraph { inline_content: [Text { text: "Background" }] }], [Paragraph { inline_content: [Text { text: "The background image displayed behind the scene’s content. The image specified in your storyboard scrolls with your interface controller’s content." }] }]], [[Paragraph { inline_content: [Text { text: "Mode" }] }], [Paragraph { inline_content: [Text { text: "The content mode for the background image. This mode defines how the background image scales or fills the screen and behaves in the same way as the constants for the " }, Reference { identifier: "doc://com.apple.documentation/documentation/UIKit/UIView/ContentMode-swift.enum", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " type." }] }]], [[Paragraph { inline_content: [Text { text: "Animate" }] }], [Paragraph { inline_content: [Text { text: "A Boolean value indicating whether an animated background image starts running its animation automatically after being loaded. Set this option to " }, CodeVoice { code: "Yes" }, Text { text: " if you want the animation to start automatically; set it to " }, CodeVoice { code: "No" }, Text { text: " if you prefer to start the animation programmatically." }] }]], [[Paragraph { inline_content: [Text { text: "Color" }] }], [Paragraph { inline_content: [Text { text: "The background color to be displayed behind the scene’s content." }] }]], [[Paragraph { inline_content: [Text { text: "Insets" }] }], [Paragraph { inline_content: [Text { text: "The amount of space (in points) to insert between the edges of the interface controller and its content. Select Custom to specify different values for the top, bottom, left, and right edges." }] }]], [[Paragraph { inline_content: [Text { text: "Spacing" }] }], [Paragraph { inline_content: [Text { text: "Additional spacing (in points) to include between items in the interface controller." }] }]]], alignments: None, metadata: None })
    /// ### Subclassing notes
    ///
    /// Subclass `WKInterfaceController` when you have a storyboard scene that requires configuration at runtime or that handles user interactions. Typically, you define a custom subclass for each unique storyboard scene that your app manages. In your subclass, define outlets for any interface objects you need to configure and define action methods for responding to interactions with the elements of your storyboard scene.
    ///
    /// Most custom interface controllers you use in your app require a custom interface controller subclass. Even glances need an interface controller to update the glance contents. The only storyboard scene that can’t use a custom interface controller is the scene associated with a static notification interface. When implementing an interface controller for your dynamic notification interface, subclass [`WKUserNotificationInterfaceController`](https://developer.apple.com/documentation/watchkit/wkusernotificationinterfacecontroller) instead.
    ///
    /// Override any methods of the class needed to configure your interface and get it ready to display. Most interface controllers override the [`init`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/init()) and [`awakeWithContext:`](https://developer.apple.com/documentation/watchkit/wkinterfacecontroller/awake(withcontext:)) methods. Override any other methods that make sense based on your needs.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WKInterfaceController;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for WKInterfaceController {}
);

impl WKInterfaceController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `context` should be of the correct type.
        #[unsafe(method(awakeWithContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn awakeWithContext(&self, context: Option<&AnyObject>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentFrame))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentFrame(&self) -> CGRect;

        #[cfg(feature = "WKCrownSequencer")]
        #[unsafe(method(crownSequencer))]
        #[unsafe(method_family = none)]
        pub unsafe fn crownSequencer(&self) -> Retained<WKCrownSequencer>;

        #[cfg(feature = "objc2-ui-kit")]
        #[unsafe(method(contentSafeAreaInsets))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentSafeAreaInsets(&self) -> UIEdgeInsets;

        #[cfg(feature = "objc2-ui-kit")]
        #[unsafe(method(systemMinimumLayoutMargins))]
        #[unsafe(method_family = none)]
        pub unsafe fn systemMinimumLayoutMargins(&self) -> NSDirectionalEdgeInsets;

        #[unsafe(method(isTableScrollingHapticFeedbackEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isTableScrollingHapticFeedbackEnabled(&self) -> bool;

        /// Setter for [`isTableScrollingHapticFeedbackEnabled`][Self::isTableScrollingHapticFeedbackEnabled].
        #[unsafe(method(setTableScrollingHapticFeedbackEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTableScrollingHapticFeedbackEnabled(
            &self,
            table_scrolling_haptic_feedback_enabled: bool,
        );

        #[unsafe(method(willActivate))]
        #[unsafe(method_family = none)]
        pub unsafe fn willActivate(&self);

        #[unsafe(method(didDeactivate))]
        #[unsafe(method_family = none)]
        pub unsafe fn didDeactivate(&self);

        #[unsafe(method(didAppear))]
        #[unsafe(method_family = none)]
        pub unsafe fn didAppear(&self);

        #[unsafe(method(willDisappear))]
        #[unsafe(method_family = none)]
        pub unsafe fn willDisappear(&self);

        #[cfg(all(feature = "WKInterfaceObject", feature = "WKInterfacePicker"))]
        #[unsafe(method(pickerDidFocus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pickerDidFocus(&self, picker: &WKInterfacePicker);

        #[cfg(all(feature = "WKInterfaceObject", feature = "WKInterfacePicker"))]
        #[unsafe(method(pickerDidResignFocus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pickerDidResignFocus(&self, picker: &WKInterfacePicker);

        #[cfg(all(feature = "WKInterfaceObject", feature = "WKInterfacePicker"))]
        #[unsafe(method(pickerDidSettle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pickerDidSettle(&self, picker: &WKInterfacePicker);

        #[cfg(all(feature = "WKInterfaceObject", feature = "WKInterfaceTable"))]
        #[unsafe(method(table:didSelectRowAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn table_didSelectRowAtIndex(
            &self,
            table: &WKInterfaceTable,
            row_index: NSInteger,
        );

        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTitle(&self, title: Option<&NSString>);

        /// # Safety
        ///
        /// `context` should be of the correct type.
        #[unsafe(method(pushControllerWithName:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pushControllerWithName_context(
            &self,
            name: &NSString,
            context: Option<&AnyObject>,
        );

        #[unsafe(method(popController))]
        #[unsafe(method_family = none)]
        pub unsafe fn popController(&self);

        #[unsafe(method(popToRootController))]
        #[unsafe(method_family = none)]
        pub unsafe fn popToRootController(&self);

        #[cfg(feature = "WKInterfaceObject")]
        #[unsafe(method(scrollToObject:atScrollPosition:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scrollToObject_atScrollPosition_animated(
            &self,
            object: &WKInterfaceObject,
            scroll_position: WKInterfaceScrollPosition,
            animated: bool,
        );

        #[unsafe(method(interfaceDidScrollToTop))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceDidScrollToTop(&self);

        #[unsafe(method(interfaceOffsetDidScrollToTop))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceOffsetDidScrollToTop(&self);

        #[unsafe(method(interfaceOffsetDidScrollToBottom))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceOffsetDidScrollToBottom(&self);

        /// # Safety
        ///
        /// `contexts` generic should be of the correct type.
        #[unsafe(method(reloadRootPageControllersWithNames:contexts:orientation:pageIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadRootPageControllersWithNames_contexts_orientation_pageIndex(
            names: &NSArray<NSString>,
            contexts: Option<&NSArray>,
            orientation: WKPageOrientation,
            page_index: NSInteger,
            mtm: MainThreadMarker,
        );

        #[unsafe(method(becomeCurrentPage))]
        #[unsafe(method_family = none)]
        pub unsafe fn becomeCurrentPage(&self);

        /// # Safety
        ///
        /// `context` should be of the correct type.
        #[unsafe(method(presentControllerWithName:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentControllerWithName_context(
            &self,
            name: &NSString,
            context: Option<&AnyObject>,
        );

        /// # Safety
        ///
        /// `contexts` generic should be of the correct type.
        #[unsafe(method(presentControllerWithNames:contexts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentControllerWithNames_contexts(
            &self,
            names: &NSArray<NSString>,
            contexts: Option<&NSArray>,
        );

        #[unsafe(method(dismissController))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissController(&self);

        #[cfg(feature = "block2")]
        #[unsafe(method(presentTextInputControllerWithSuggestions:allowedInputMode:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentTextInputControllerWithSuggestions_allowedInputMode_completion(
            &self,
            suggestions: Option<&NSArray<NSString>>,
            input_mode: WKTextInputMode,
            completion: &block2::DynBlock<dyn Fn(*mut NSArray)>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `suggestions_handler` block's return must be a valid pointer or null.
        #[unsafe(method(presentTextInputControllerWithSuggestionsForLanguage:allowedInputMode:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentTextInputControllerWithSuggestionsForLanguage_allowedInputMode_completion(
            &self,
            suggestions_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<NSString>) -> *mut NSArray>,
            >,
            input_mode: WKTextInputMode,
            completion: &block2::DynBlock<dyn Fn(*mut NSArray)>,
        );

        #[unsafe(method(dismissTextInputController))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissTextInputController(&self);

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(presentMediaPlayerControllerWithURL:options:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentMediaPlayerControllerWithURL_options_completion(
            &self,
            url: &NSURL,
            options: Option<&NSDictionary>,
            completion: &block2::DynBlock<dyn Fn(Bool, NSTimeInterval, *mut NSError)>,
        );

        #[unsafe(method(dismissMediaPlayerController))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissMediaPlayerController(&self);

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(presentAudioRecorderControllerWithOutputURL:preset:options:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentAudioRecorderControllerWithOutputURL_preset_options_completion(
            &self,
            url: &NSURL,
            preset: WKAudioRecorderPreset,
            options: Option<&NSDictionary>,
            completion: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>,
        );

        #[unsafe(method(dismissAudioRecorderController))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissAudioRecorderController(&self);

        #[unsafe(method(contextForSegueWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextForSegueWithIdentifier(
            &self,
            segue_identifier: &NSString,
        ) -> Option<Retained<AnyObject>>;

        #[unsafe(method(contextsForSegueWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextsForSegueWithIdentifier(
            &self,
            segue_identifier: &NSString,
        ) -> Option<Retained<NSArray>>;

        #[cfg(all(feature = "WKInterfaceObject", feature = "WKInterfaceTable"))]
        #[unsafe(method(contextForSegueWithIdentifier:inTable:rowIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextForSegueWithIdentifier_inTable_rowIndex(
            &self,
            segue_identifier: &NSString,
            table: &WKInterfaceTable,
            row_index: NSInteger,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(all(feature = "WKInterfaceObject", feature = "WKInterfaceTable"))]
        #[unsafe(method(contextsForSegueWithIdentifier:inTable:rowIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextsForSegueWithIdentifier_inTable_rowIndex(
            &self,
            segue_identifier: &NSString,
            table: &WKInterfaceTable,
            row_index: NSInteger,
        ) -> Option<Retained<NSArray>>;

        #[cfg(feature = "block2")]
        #[unsafe(method(animateWithDuration:animations:))]
        #[unsafe(method_family = none)]
        pub unsafe fn animateWithDuration_animations(
            &self,
            duration: NSTimeInterval,
            animations: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "WKAlertAction")]
        #[unsafe(method(presentAlertControllerWithTitle:message:preferredStyle:actions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentAlertControllerWithTitle_message_preferredStyle_actions(
            &self,
            title: Option<&NSString>,
            message: Option<&NSString>,
            preferred_style: WKAlertControllerStyle,
            actions: &NSArray<WKAlertAction>,
        );

        #[unsafe(method(dismissAddPassesController))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissAddPassesController(&self);

        #[unsafe(method(updateUserActivity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateUserActivity(&self, user_activity: &NSUserActivity);

        #[unsafe(method(invalidateUserActivity))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateUserActivity(&self);

        #[deprecated = "Glances are no longer supported"]
        #[unsafe(method(beginGlanceUpdates))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginGlanceUpdates(&self);

        #[deprecated = "Glances are no longer supported"]
        #[unsafe(method(endGlanceUpdates))]
        #[unsafe(method_family = none)]
        pub unsafe fn endGlanceUpdates(&self);

        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[deprecated = "use updateUserActivity:"]
        #[unsafe(method(updateUserActivity:userInfo:webpageURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateUserActivity_userInfo_webpageURL(
            &self,
            r#type: &NSString,
            user_info: Option<&NSDictionary>,
            webpage_url: Option<&NSURL>,
        );

        /// # Safety
        ///
        /// `contexts` generic should be of the correct type.
        #[deprecated = "use reloadRootPageControllersWithNames:contexts:orientation:pageIndex:"]
        #[unsafe(method(reloadRootControllersWithNames:contexts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadRootControllersWithNames_contexts(
            names: &NSArray<NSString>,
            contexts: Option<&NSArray>,
            mtm: MainThreadMarker,
        );

        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[deprecated = "use WKExtensionDelegate's handleUserActivity:"]
        #[unsafe(method(handleUserActivity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleUserActivity(&self, user_info: Option<&NSDictionary>);

        #[cfg(feature = "objc2-ui-kit")]
        /// # Safety
        ///
        /// `action` must be a valid selector.
        #[deprecated]
        #[unsafe(method(addMenuItemWithImage:title:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addMenuItemWithImage_title_action(
            &self,
            image: &UIImage,
            title: &NSString,
            action: Sel,
        );

        /// # Safety
        ///
        /// `action` must be a valid selector.
        #[deprecated]
        #[unsafe(method(addMenuItemWithImageNamed:title:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addMenuItemWithImageNamed_title_action(
            &self,
            image_name: &NSString,
            title: &NSString,
            action: Sel,
        );

        /// # Safety
        ///
        /// `action` must be a valid selector.
        #[deprecated]
        #[unsafe(method(addMenuItemWithItemIcon:title:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addMenuItemWithItemIcon_title_action(
            &self,
            item_icon: WKMenuItemIcon,
            title: &NSString,
            action: Sel,
        );

        #[deprecated]
        #[unsafe(method(clearAllMenuItems))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearAllMenuItems(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl WKInterfaceController {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// An interface controller object that manages a dynamic user interface for a local or remote notification.
    ///
    /// ## Overview
    ///
    /// Apps that support notifications can define one or more subclasses of [`WKUserNotificationInterfaceController`](https://developer.apple.com/documentation/watchkit/wkusernotificationinterfacecontroller) and use them to implement their dynamic notification interfaces. For example, you might use a dynamic interface to display custom data from the notification payload or add related graphics.
    ///
    /// To create the custom notification interface, add a notification interface controller to your storyboard. Interface Builder provides a static interface and you can add a dynamic interface as needed. Set the class of the dynamic interface controller to the name of your [`WKUserNotificationInterfaceController`](https://developer.apple.com/documentation/watchkit/wkusernotificationinterfacecontroller) subclass.
    ///
    /// Apps can include multiple notification interfaces in their storyboard file, and associate each interface with a different category. Categories define the purpose of an incoming notification and are custom to your app. In Interface Builder, specify the category information for each of your notification interfaces using the notification category object attached to the static notification interface controller. When sending notifications to a user, add the appropriate category string to the remote notification payload or set the string in the [`categoryIdentifier`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/categoryidentifier) property of a local notification.
    ///
    /// After initializing your interface controller, WatchKit calls the [`didReceiveNotification:`](https://developer.apple.com/documentation/watchkit/wkusernotificationinterfacecontroller/didreceive(_:)) method to provide you with the payload data from the notification. Your implementations of those methods should update any interface objects and call the provided completion handler as quickly as possible. If you don’t call the completion handler in a timely manner, WatchKit displays your static notification interface instead.
    ///
    /// ### Actionable Notifications
    ///
    /// For each category your app supports, you can also register actions for that category. When a category has registered actions, WatchKit adds a button for each action to the corresponding static or dynamic notification interface. Because the system automatically adds the buttons, don’t manually add your own to your custom notification interface. For more information about registering actions, see [Declaring your actionable notification types](https://developer.apple.com/documentation/usernotifications/declaring-your-actionable-notification-types).
    ///
    /// When the user taps an action button, the system launches your app and calls your notification delegate’s [`userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:`](https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate/usernotificationcenter(_:didreceive:withcompletionhandler:)) method. The response parameter’s [`actionIdentifier`](https://developer.apple.com/documentation/usernotifications/unnotificationresponse/actionidentifier) property contains the identifier for the selected action. Implement your delegate’s [`userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:`](https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate/usernotificationcenter(_:didreceive:withcompletionhandler:)) method to check this identifier, and then perform the corresponding task. For more information, see [Handling notifications and notification-related actions](https://developer.apple.com/documentation/usernotifications/handling-notifications-and-notification-related-actions).
    ///
    /// The following rules define where the system handles the action:
    ///
    /// - The system always handles foreground actions on the device where the user selected the action. For example, if you send a remote notification to the user’s iPhone and the system automatically forwards it to their Apple Watch, tapping the action runs it on the watch.
    ///
    /// - The system always handles background actions on the device that was the notification’s target. For example, if you send a notification to the user’s iPhone and the system automatically forwards it to their Apple Watch, tapping the action runs it in the background on their iPhone.
    ///
    /// ### Interface Builder Configuration Options
    ///
    /// Xcode lets you configure information about your notification interface controller in your storyboard file. A notification interface controller supports almost all of the attributes associated with its parent class plus those in the following table.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Attribute" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Text { text: "Has Dynamic Interface" }] }], [Paragraph { inline_content: [Text { text: "A checkbox indicating whether the app supports a dynamic interface for notifications of this type. WatchKit displays dynamic interfaces whenever possible, but WatchKit may fall back to using your static interface because of power restrictions or when your WatchKit extension doesn’t respond in a timely manner. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Apple Watch always displays the static interface in Notification Center." }] }]]], alignments: None, metadata: None })
    /// The notification category object associated with your notification interface controllers also contains configurable attributes. The following table lists the attributes of the notification category object and their meaning.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Attribute" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Text { text: "Name" }] }], [Paragraph { inline_content: [Text { text: "The name of the category that this interface supports. For local notifications, this value corresponds to the string in the " }, Reference { identifier: "doc://com.apple.documentation/documentation/UserNotifications/UNNotificationContent/categoryIdentifier", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property of the " }, Reference { identifier: "doc://com.apple.documentation/documentation/UserNotifications/UNNotificationContent", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " object. For remote notifications, it’s the string in the " }, CodeVoice { code: "category" }, Text { text: " key in the payload. When a notification arrives, WatchKit uses the category string in the notification to decide which of your interface controllers to display." }] }]], [[Paragraph { inline_content: [Text { text: "Sash Color" }] }], [Paragraph { inline_content: [Text { text: "The color to apply to the sash at the top of the long-look notification interface." }] }]], [[Paragraph { inline_content: [Text { text: "Wants Sash Blur" }] }], [Paragraph { inline_content: [Text { text: "A checkbox indicating whether the sash includes a blur effect over the background." }] }]], [[Paragraph { inline_content: [Text { text: "Title Color" }] }], [Paragraph { inline_content: [Text { text: "The color to apply to the text displayed in the sash." }] }]], [[Paragraph { inline_content: [Text { text: "Description" }] }], [Paragraph { inline_content: [Text { text: "The format string to display when multiple notifications of the same type arrive simultaneously. If you specify a custom string, you can use the " }, CodeVoice { code: "%d" }, Text { text: " variable to reflect the number of notifications. If you don’t specify a custom string, WatchKit uses the string " }, CodeVoice { code: "%d Notifications" }, Text { text: " to reflect the number of notifications that arrived." }] }]], [[Paragraph { inline_content: [Text { text: "Has Dynamic Interface" }] }], [Paragraph { inline_content: [Text { text: "A checkbox indicating whether the app supports dynamic interfaces for notifications of this type. WatchKit displays dynamic interfaces whenever possible, but it may fall back to using your static interface because of power restrictions or when your WatchKit extension doesn’t respond in a timely manner. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Apple Watch always displays the static interface in Notification Center." }] }]]], alignments: None, metadata: None })
    ///
    #[unsafe(super(WKInterfaceController, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WKUserNotificationInterfaceController;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for WKUserNotificationInterfaceController {}
);

impl WKUserNotificationInterfaceController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-user-notifications")]
        #[unsafe(method(notificationActions))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationActions(&self) -> Retained<NSArray<UNNotificationAction>>;

        #[cfg(feature = "objc2-user-notifications")]
        /// Setter for [`notificationActions`][Self::notificationActions].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setNotificationActions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNotificationActions(
            &self,
            notification_actions: &NSArray<UNNotificationAction>,
        );

        #[cfg(feature = "objc2-user-notifications")]
        #[unsafe(method(didReceiveNotification:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didReceiveNotification(&self, notification: &UNNotification);

        #[cfg(feature = "objc2-user-notifications")]
        #[unsafe(method(suggestionsForResponseToActionWithIdentifier:forNotification:inputLanguage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn suggestionsForResponseToActionWithIdentifier_forNotification_inputLanguage(
            &self,
            identifier: &NSString,
            notification: &UNNotification,
            input_language: &NSString,
        ) -> Retained<NSArray<NSString>>;

        #[unsafe(method(performNotificationDefaultAction))]
        #[unsafe(method_family = none)]
        pub unsafe fn performNotificationDefaultAction(&self);

        #[unsafe(method(performDismissAction))]
        #[unsafe(method_family = none)]
        pub unsafe fn performDismissAction(&self);

        #[deprecated = "use performDismissAction"]
        #[unsafe(method(dismissController))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissController(&self);

        #[cfg(all(feature = "block2", feature = "objc2-user-notifications"))]
        #[deprecated = "use didReceiveNotification:"]
        #[unsafe(method(didReceiveNotification:withCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn didReceiveNotification_withCompletion(
            &self,
            notification: &UNNotification,
            completion_handler: &block2::DynBlock<dyn Fn(WKUserNotificationInterfaceType)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl WKUserNotificationInterfaceController {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
