//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Defines the potential states the session can be in
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct WKExtendedRuntimeSessionState(pub NSInteger);
impl WKExtendedRuntimeSessionState {
    /// Start has never been called on the session.
    #[doc(alias = "WKExtendedRuntimeSessionStateNotStarted")]
    pub const NotStarted: Self = Self(0);
    /// The session has been successfully scheduled to start at a future date, as specified by date passed to startAtDate.
    #[doc(alias = "WKExtendedRuntimeSessionStateScheduled")]
    pub const Scheduled: Self = Self(1);
    /// The session is actively running.
    #[doc(alias = "WKExtendedRuntimeSessionStateRunning")]
    pub const Running: Self = Self(2);
    /// The session is not running. Either the session ended, or hit an error. See WKExtendedRuntimeSessionInvalidationReason for a list of reasons why the session could be invalid.
    #[doc(alias = "WKExtendedRuntimeSessionStateInvalid")]
    pub const Invalid: Self = Self(3);
}

unsafe impl Encode for WKExtendedRuntimeSessionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Defines the reasons for which a session may become invalid.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessioninvalidationreason?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct WKExtendedRuntimeSessionInvalidationReason(pub NSInteger);
impl WKExtendedRuntimeSessionInvalidationReason {
    /// The session ended normally, likely through a direct call to invalidate.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonNone")]
    pub const None: Self = Self(0);
    /// A session for this application has already been started, and is currently running, another session can not be started.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonSessionInProgress")]
    pub const SessionInProgress: Self = Self(1);
    /// The session hit its time limit, as noted by its expiration date.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonExpired")]
    pub const Expired: Self = Self(2);
    /// The application has lost frontmost status, so the session ended.
    /// Examples of actions by the user which cause the session to lose frontmost status include:
    /// User pressing digital crown, tapping on a notification to go to another application,
    /// switching applications through the dock, or any other apps entering the foreground.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonResignedFrontmost")]
    pub const ResignedFrontmost: Self = Self(3);
    /// Apple Watch is in a state that doesn't currently allow this session type to run.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonSuppressedBySystem")]
    pub const SuppressedBySystem: Self = Self(4);
    /// The session did not end normally, and there is an error returned with more information.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonError")]
    pub const Error: Self = Self(-1);
}

unsafe impl Encode for WKExtendedRuntimeSessionInvalidationReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionInvalidationReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionerrordomain?language=objc)
    pub static WKExtendedRuntimeSessionErrorDomain: &'static NSString;
}

/// [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionerrorcode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct WKExtendedRuntimeSessionErrorCode(pub NSInteger);
impl WKExtendedRuntimeSessionErrorCode {
    #[doc(alias = "WKExtendedRuntimeSessionErrorUnknown")]
    pub const Unknown: Self = Self(1);
    #[doc(alias = "WKExtendedRuntimeSessionErrorScheduledTooFarInAdvance")]
    pub const ScheduledTooFarInAdvance: Self = Self(2);
    #[doc(alias = "WKExtendedRuntimeSessionErrorMustBeActiveToStartOrSchedule")]
    pub const MustBeActiveToStartOrSchedule: Self = Self(3);
    #[doc(alias = "WKExtendedRuntimeSessionErrorNotYetStarted")]
    pub const NotYetStarted: Self = Self(4);
    #[doc(alias = "WKExtendedRuntimeSessionErrorExceededResourceLimits")]
    pub const ExceededResourceLimits: Self = Self(5);
    #[doc(alias = "WKExtendedRuntimeSessionErrorBARDisabled")]
    pub const BARDisabled: Self = Self(6);
    #[doc(alias = "WKExtendedRuntimeSessionErrorNotApprovedToStartSession")]
    pub const NotApprovedToStartSession: Self = Self(7);
    #[doc(alias = "WKExtendedRuntimeSessionErrorNotApprovedToSchedule")]
    pub const NotApprovedToSchedule: Self = Self(8);
    #[doc(alias = "WKExtendedRuntimeSessionErrorMustBeActiveToPrompt")]
    pub const MustBeActiveToPrompt: Self = Self(9);
    #[doc(alias = "WKExtendedRuntimeSessionErrorUnsupportedSessionType")]
    pub const UnsupportedSessionType: Self = Self(10);
}

unsafe impl Encode for WKExtendedRuntimeSessionErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionautolaunchauthorizationstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus(pub NSInteger);
impl WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus {
    #[doc(alias = "WKExtendedRuntimeSessionAutoLaunchAuthorizationStatusUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "WKExtendedRuntimeSessionAutoLaunchAuthorizationStatusInactive")]
    pub const Inactive: Self = Self(1);
    #[doc(alias = "WKExtendedRuntimeSessionAutoLaunchAuthorizationStatusActive")]
    pub const Active: Self = Self(2);
}

unsafe impl Encode for WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WKExtendedRuntimeSession;
);

unsafe impl NSObjectProtocol for WKExtendedRuntimeSession {}

extern_methods!(
    unsafe impl WKExtendedRuntimeSession {
        /// This method will create a session, with the capabilities granted for the appropriate session type specified in the "Background Modes" capability in Xcode.
        #[method_id(@__method_family Other session)]
        pub unsafe fn session() -> Retained<WKExtendedRuntimeSession>;

        #[cfg(feature = "block2")]
        /// Request auto-launch authorization for the current app. This may trigger prompt to the user asking if they
        /// want to make the current app the app to launch automatically when system conditions are met for the app's
        /// supported session type. This prompt will only be shown to the user once per application.
        /// The completion handler will be called with an error if the application's session type does not support auto-launch,
        /// or if the app is not foreground and has not yet triggered a prompt.
        #[method(requestAutoLaunchAuthorizationStatusWithCompletion:)]
        pub unsafe fn requestAutoLaunchAuthorizationStatusWithCompletion(
            completion: &block2::Block<
                dyn Fn(WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus, *mut NSError),
            >,
        );

        /// Setting a delegate on the session provides you with updates on when the session begins,
        /// ends, or, encounters an error. Be sure to set a delegate before calling start, to receive the sessionDidStart callback.
        #[method_id(@__method_family Other delegate)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn WKExtendedRuntimeSessionDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn WKExtendedRuntimeSessionDelegate>>,
        );

        /// The current state of the session.
        #[method(state)]
        pub unsafe fn state(&self) -> WKExtendedRuntimeSessionState;

        /// The date at which the session will no longer receive runtime.
        /// Use this date to figure out how much time there is left to run before the end of the session.
        /// If the session has not yet started, this value will be nil. If the session successfully starts,
        /// this date will then be valid, even after the session gets invalidated.
        #[method_id(@__method_family Other expirationDate)]
        pub unsafe fn expirationDate(&self) -> Option<Retained<NSDate>>;

        /// Starts the session.
        #[method(start)]
        pub unsafe fn start(&self);

        /// Parameter `date`: A date in the future when the session should start running.
        ///
        /// Use this method to schedule the session to run at future date. Calling this API must be done while the application is in the foreground, but the session will start at the appropriate date regardless of application state. This method can only be used for the alarm background mode.
        #[method(startAtDate:)]
        pub unsafe fn startAtDate(&self, date: &NSDate);

        /// This method will end a session early before its expiration date.
        /// If this method is called on a session scheduled through startAtDate, the session will no longer be scheduled to run.
        /// Once invalidate is called on a session, it can no longer run.
        #[method(invalidate)]
        pub unsafe fn invalidate(&self);

        #[cfg(all(feature = "WKInterfaceDevice", feature = "block2"))]
        /// Parameter `type`: Haptic type to play
        ///
        /// Parameter `repeatHandler`: an optional block that returns a valid time interval for when to play the next haptic. This value must be > 0.0 and
        /// <
        /// = 60.0. This block also optionally allows the app to change the haptic type that is played by modifying outHapticType. If repeatHandler is NULL, a system default value is used for the repeat interval.
        ///
        /// Use this method to start playing a repeating haptic to alert the user. If the app is not active, this will result in a system alert UI. The haptic will repeat at the interval specified by the block in the repeatHandler parameter or at a default interval if repeatHandler is not specified. The haptic will continue playing until one of the following happens:
        /// 1) the user taps the stop button in the system alarm alert, ending the session
        /// 2) the session is invalidated by the app while the app is in an active UI state
        ///
        /// This method can only be called on a WKExtendedRuntimeSession that was scheduled with startAtDate: and currently has a state of WKExtendedRuntimeSessionStateRunning. If it is called outside that time, it will be ignored.
        #[method(notifyUserWithHaptic:repeatHandler:)]
        pub unsafe fn notifyUserWithHaptic_repeatHandler(
            &self,
            r#type: WKHapticType,
            repeat_handler: Option<&block2::Block<dyn Fn(NonNull<WKHapticType>) -> NSTimeInterval>>,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl WKExtendedRuntimeSession {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate?language=objc)
    pub unsafe trait WKExtendedRuntimeSessionDelegate: NSObjectProtocol {
        /// Parameter `extendedRuntimeSession`: The session which has been invalidated
        ///
        /// Parameter `reason`: The termination reason explaining why the session has been invalidated.
        ///
        /// Parameter `error`: If reason is WKExtendedRuntimeSessionInvalidationReasonError, this object will represent that error.
        ///
        /// This is called if a session fails to start, or when it ends once it has started. See WKExtendedRuntimeSeesionInvalidationReason for the
        /// reasons this may be called.
        #[method(extendedRuntimeSession:didInvalidateWithReason:error:)]
        unsafe fn extendedRuntimeSession_didInvalidateWithReason_error(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
            reason: WKExtendedRuntimeSessionInvalidationReason,
            error: Option<&NSError>,
        );

        /// Parameter `extendedRuntimeSession`: The session which started
        ///
        /// Called when the session has started successfully.
        #[method(extendedRuntimeSessionDidStart:)]
        unsafe fn extendedRuntimeSessionDidStart(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
        );

        /// Parameter `extendedRuntimeSession`: The session which is about to expire.
        ///
        /// Delegate method provided to application to signify the session will expire soon.
        /// All tasks must be completed before the expiration date.
        #[method(extendedRuntimeSessionWillExpire:)]
        unsafe fn extendedRuntimeSessionWillExpire(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
        );
    }
);
