//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The activation states for an extended runtime session.
/// Defines the potential states the session can be in
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKExtendedRuntimeSessionState(pub NSInteger);
impl WKExtendedRuntimeSessionState {
    /// The app has not yet started or scheduled the session.
    ///
    /// ## Discussion
    ///
    /// When you instantiate a new session, it stays in the [`WKExtendedRuntimeSessionStateNotStarted`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionstate/notstarted) state until you call the session’s [`start`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start()) or [`startAtDate:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start(at:)) method.
    ///
    ///
    /// Start has never been called on the session.
    #[doc(alias = "WKExtendedRuntimeSessionStateNotStarted")]
    pub const NotStarted: Self = Self(0);
    /// The app has scheduled the session to run at a future date.
    ///
    /// ## Discussion
    ///
    /// The session transitions to the [`WKExtendedRuntimeSessionStateScheduled`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionstate/scheduled) state when you call the [`startAtDate:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start(at:)) method. It remains in this state until the start date arrives. Then it transitions to the running state.
    ///
    ///
    /// The session has been successfully scheduled to start at a future date, as specified by date passed to startAtDate.
    #[doc(alias = "WKExtendedRuntimeSessionStateScheduled")]
    pub const Scheduled: Self = Self(1);
    /// The session is actively running.
    /// The session is actively running.
    #[doc(alias = "WKExtendedRuntimeSessionStateRunning")]
    pub const Running: Self = Self(2);
    /// Either the session has encountered an error, or it has stopped running.
    ///
    /// ## Discussion
    ///
    /// The system passes a [`WKExtendedRuntimeSessionInvalidationReason`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessioninvalidationreason) value to the session delegate’s [`extendedRuntimeSession:didInvalidateWithReason:error:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate/extendedruntimesession(_:didinvalidatewith:error:)) method. Use this value to determine why the session became invalid.
    ///
    ///
    /// The session is not running. Either the session ended, or hit an error. See WKExtendedRuntimeSessionInvalidationReason for a list of reasons why the session could be invalid.
    #[doc(alias = "WKExtendedRuntimeSessionStateInvalid")]
    pub const Invalid: Self = Self(3);
}

unsafe impl Encode for WKExtendedRuntimeSessionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The reasons why a session can become invalid.
///
/// ## Overview
///
/// Sessions become invalid when they encounter an error, or when they stop running.
///
///
/// Defines the reasons for which a session may become invalid.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKExtendedRuntimeSessionInvalidationReason(pub NSInteger);
impl WKExtendedRuntimeSessionInvalidationReason {
    /// The session ended normally.
    ///
    /// ## Discussion
    ///
    /// The system uses this reason when you stop a session by calling its [`invalidate`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/invalidate()) method.
    ///
    ///
    /// The session ended normally, likely through a direct call to invalidate.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonNone")]
    pub const None: Self = Self(0);
    /// This app already has a running session.
    ///
    /// ## Discussion
    ///
    /// Each app can only run one extended runtime session at a time.
    ///
    ///
    /// A session for this application has already been started, and is currently running, another session can not be started.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonSessionInProgress")]
    pub const SessionInProgress: Self = Self(1);
    /// The session used all of its allocated time.
    ///
    /// ## Discussion
    ///
    /// Sessions can only run for a limited amount of time. Each session type has a different time limit. For more information, see the session’s [`expirationDate`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/expirationdate) property.
    ///
    ///
    /// The session hit its time limit, as noted by its expiration date.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonExpired")]
    pub const Expired: Self = Self(2);
    /// The app lost its frontmost status.
    ///
    /// ## Discussion
    ///
    /// If the session type doesn’t grant background execution time, the session stops as soon as the app loses its frontmost app status. Users can dismiss the frontmost app by pressing the Digital Crown, tapping a notification, or launching another app. For more information, see `Understand Frontmost App State`.
    ///
    ///
    /// The application has lost frontmost status, so the session ended.
    /// Examples of actions by the user which cause the session to lose frontmost status include:
    /// User pressing digital crown, tapping on a notification to go to another application,
    /// switching applications through the dock, or any other apps entering the foreground.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonResignedFrontmost")]
    pub const ResignedFrontmost: Self = Self(3);
    /// The system is in a state that doesn’t allow sessions of this type.
    /// Apple Watch is in a state that doesn't currently allow this session type to run.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonSuppressedBySystem")]
    pub const SuppressedBySystem: Self = Self(4);
    /// An error prevented the session from running.
    ///
    /// ## Discussion
    ///
    /// When the system passes this value to your extension delegate’s [`extendedRuntimeSession:didInvalidateWithReason:error:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate/extendedruntimesession(_:didinvalidatewith:error:)) method, check the `error` parameter for additional information about the error.
    ///
    ///
    /// The session did not end normally, and there is an error returned with more information.
    #[doc(alias = "WKExtendedRuntimeSessionInvalidationReasonError")]
    pub const Error: Self = Self(-1);
}

unsafe impl Encode for WKExtendedRuntimeSessionInvalidationReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionInvalidationReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain for errors reported by extended runtime sessions.
    ///
    /// ## Discussion
    ///
    /// The session passes these errors to the session delegate’s [`extendedRuntimeSession:didInvalidateWithReason:error:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate/extendedruntimesession(_:didinvalidatewith:error:)) method.
    ///
    ///
    pub static WKExtendedRuntimeSessionErrorDomain: &'static NSString;
}

/// The error codes reported by extended runtime sessions.
///
/// ## Overview
///
/// The session passes these errors to the sesson delegate’s [`extendedRuntimeSession:didInvalidateWithReason:error:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate/extendedruntimesession(_:didinvalidatewith:error:)) method.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct WKExtendedRuntimeSessionErrorCode(pub NSInteger);
impl WKExtendedRuntimeSessionErrorCode {
    /// An unknown error occurred.
    #[doc(alias = "WKExtendedRuntimeSessionErrorUnknown")]
    pub const Unknown: Self = Self(1);
    /// The app attempted to schedule a session too far in the future.
    ///
    /// ## Discussion
    ///
    /// You can’t schedule alarm sessions more than 36 hours in advance. Other session types do not support scheduling.
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorScheduledTooFarInAdvance")]
    pub const ScheduledTooFarInAdvance: Self = Self(2);
    /// The watchOS app attempted to start or schedule a session while not in an active state.
    ///
    /// ## Discussion
    ///
    /// You can only start or schedule sessions when the watchOS app is running in the foreground. Specifically, the WatchKit extension’s [`applicationState`](https://developer.apple.com/documentation/watchkit/wkextension/applicationstate) must equal [`WKApplicationStateActive`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/active).
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorMustBeActiveToStartOrSchedule")]
    pub const MustBeActiveToStartOrSchedule: Self = Self(3);
    /// The app invalidated the session before it started.
    ///
    /// ## Discussion
    ///
    /// The app called the [`invalidate`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/invalidate()) method on a session before calling its [`start`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start()) method.
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorNotYetStarted")]
    pub const NotYetStarted: Self = Self(4);
    /// The session exceeded its resource limits.
    ///
    /// ## Discussion
    ///
    /// During an extended runtime session, the system limits your app’s amortized CPU usage over time. If your app exceeds the limits during a 60-second window, the system cancels the session. Monitoring usage-per-minute allows your app to experience brief spikes of CPU usage, as long as the average remains low.
    ///
    /// When the system cancels your session, it calls your delegate’s [`extendedRuntimeSession:didInvalidateWithReason:error:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate/extendedruntimesession(_:didinvalidatewith:error:)) method and passes a [`WKExtendedRuntimeSessionInvalidationReasonError`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessioninvalidationreason/error) reason with a [`WKExtendedRuntimeSessionErrorExceededResourceLimits`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionerrorcode/exceededresourcelimits) error.
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorExceededResourceLimits")]
    pub const ExceededResourceLimits: Self = Self(5);
    /// The user has disabled background app refresh.
    ///
    /// ## Discussion
    ///
    /// If the user has disabled Background App Refresh for this app, any attempt to schedule a session by calling the [`startAtDate:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start(at:)) method fails. The system calls your delegate’s [`extendedRuntimeSession:didInvalidateWithReason:error:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessiondelegate/extendedruntimesession(_:didinvalidatewith:error:)) method and passes a [`WKExtendedRuntimeSessionInvalidationReasonError`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessioninvalidationreason/error) reason with a [`WKExtendedRuntimeSessionErrorBARDisabled`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesessionerrorcode/bardisabled) error.
    ///
    /// Users can turn off Background App Refresh by selecting General > Background App Refresh in the Watch App.
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorBARDisabled")]
    pub const BARDisabled: Self = Self(6);
    /// The app attempted to start a session, but doesn’t have a valid session type.
    ///
    /// ## Discussion
    ///
    /// To use extended runtime sessions, your app must enable the Background Mode capability and select a session type.
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorNotApprovedToStartSession")]
    pub const NotApprovedToStartSession: Self = Self(7);
    /// The app attempted to schedule a session, but the session type does not support scheduling.
    ///
    /// ## Discussion
    ///
    /// You can schedule alarm sessions by calling the session’s [`startAtDate:`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start(at:)) method. For all other session types, use the [`start`](https://developer.apple.com/documentation/watchkit/wkextendedruntimesession/start()) method instead.
    ///
    ///
    #[doc(alias = "WKExtendedRuntimeSessionErrorNotApprovedToSchedule")]
    pub const NotApprovedToSchedule: Self = Self(8);
    #[doc(alias = "WKExtendedRuntimeSessionErrorMustBeActiveToPrompt")]
    pub const MustBeActiveToPrompt: Self = Self(9);
    #[doc(alias = "WKExtendedRuntimeSessionErrorUnsupportedSessionType")]
    pub const UnsupportedSessionType: Self = Self(10);
}

unsafe impl Encode for WKExtendedRuntimeSessionErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus(pub NSInteger);
impl WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus {
    #[doc(alias = "WKExtendedRuntimeSessionAutoLaunchAuthorizationStatusUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "WKExtendedRuntimeSessionAutoLaunchAuthorizationStatusInactive")]
    pub const Inactive: Self = Self(1);
    #[doc(alias = "WKExtendedRuntimeSessionAutoLaunchAuthorizationStatusActive")]
    pub const Active: Self = Self(2);
}

unsafe impl Encode for WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A session that continues to run your app after the user has stopped interacting.
    ///
    /// ## Overview
    ///
    /// With extended runtime sessions, your app continues to run after the user stops interacting with it. The app can continue to communicate with Bluetooth devices, process data, or play sounds or haptics, even after the watch’s screen turns off.
    ///
    /// Each app can support a single type of extended runtime session: self care, mindfulness, physical therapy, or smart alarm. Select the session by enabling the appropriate Background Modes capability.
    ///
    /// For more information, see [Using extended runtime sessions](https://developer.apple.com/documentation/watchkit/using-extended-runtime-sessions).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WKExtendedRuntimeSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for WKExtendedRuntimeSession {}
);

impl WKExtendedRuntimeSession {
    extern_methods!(
        /// This method will create a session, with the capabilities granted for the appropriate session type specified in the "Background Modes" capability in Xcode.
        #[unsafe(method(session))]
        #[unsafe(method_family = none)]
        pub unsafe fn session() -> Retained<WKExtendedRuntimeSession>;

        #[cfg(feature = "block2")]
        /// Request auto-launch authorization for the current app. This may trigger prompt to the user asking if they
        /// want to make the current app the app to launch automatically when system conditions are met for the app's
        /// supported session type. This prompt will only be shown to the user once per application.
        /// The completion handler will be called with an error if the application's session type does not support auto-launch,
        /// or if the app is not foreground and has not yet triggered a prompt.
        #[unsafe(method(requestAutoLaunchAuthorizationStatusWithCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAutoLaunchAuthorizationStatusWithCompletion(
            completion: &block2::DynBlock<
                dyn Fn(WKExtendedRuntimeSessionAutoLaunchAuthorizationStatus, *mut NSError),
            >,
        );

        /// Setting a delegate on the session provides you with updates on when the session begins,
        /// ends, or, encounters an error. Be sure to set a delegate before calling start, to receive the sessionDidStart callback.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn WKExtendedRuntimeSessionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn WKExtendedRuntimeSessionDelegate>>,
        );

        /// The current state of the session.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> WKExtendedRuntimeSessionState;

        /// The date at which the session will no longer receive runtime.
        /// Use this date to figure out how much time there is left to run before the end of the session.
        /// If the session has not yet started, this value will be nil. If the session successfully starts,
        /// this date will then be valid, even after the session gets invalidated.
        #[unsafe(method(expirationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn expirationDate(&self) -> Option<Retained<NSDate>>;

        /// Starts the session.
        #[unsafe(method(start))]
        #[unsafe(method_family = none)]
        pub unsafe fn start(&self);

        /// Parameter `date`: A date in the future when the session should start running.
        ///
        /// Use this method to schedule the session to run at future date. Calling this API must be done while the application is in the foreground, but the session will start at the appropriate date regardless of application state. This method can only be used for the alarm background mode.
        #[unsafe(method(startAtDate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startAtDate(&self, date: &NSDate);

        /// This method will end a session early before its expiration date.
        /// If this method is called on a session scheduled through startAtDate, the session will no longer be scheduled to run.
        /// Once invalidate is called on a session, it can no longer run.
        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidate(&self);

        #[cfg(all(feature = "WKInterfaceDevice", feature = "block2"))]
        /// Parameter `type`: Haptic type to play
        ///
        /// Parameter `repeatHandler`: an optional block that returns a valid time interval for when to play the next haptic. This value must be > 0.0 and
        /// <
        /// = 60.0. This block also optionally allows the app to change the haptic type that is played by modifying outHapticType. If repeatHandler is NULL, a system default value is used for the repeat interval.
        ///
        /// Use this method to start playing a repeating haptic to alert the user. If the app is not active, this will result in a system alert UI. The haptic will repeat at the interval specified by the block in the repeatHandler parameter or at a default interval if repeatHandler is not specified. The haptic will continue playing until one of the following happens:
        /// 1) the user taps the stop button in the system alarm alert, ending the session
        /// 2) the session is invalidated by the app while the app is in an active UI state
        ///
        /// This method can only be called on a WKExtendedRuntimeSession that was scheduled with startAtDate: and currently has a state of WKExtendedRuntimeSessionStateRunning. If it is called outside that time, it will be ignored.
        #[unsafe(method(notifyUserWithHaptic:repeatHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notifyUserWithHaptic_repeatHandler(
            &self,
            r#type: WKHapticType,
            repeat_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<WKHapticType>) -> NSTimeInterval>,
            >,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl WKExtendedRuntimeSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A set of optional methods for monitoring an extended runtime session.
    ///
    /// ## Overview
    ///
    /// Implement these methods to track the changes to your session’s state.
    ///
    ///
    pub unsafe trait WKExtendedRuntimeSessionDelegate: NSObjectProtocol {
        /// Parameter `extendedRuntimeSession`: The session which has been invalidated
        ///
        /// Parameter `reason`: The termination reason explaining why the session has been invalidated.
        ///
        /// Parameter `error`: If reason is WKExtendedRuntimeSessionInvalidationReasonError, this object will represent that error.
        ///
        /// This is called if a session fails to start, or when it ends once it has started. See WKExtendedRuntimeSeesionInvalidationReason for the
        /// reasons this may be called.
        #[unsafe(method(extendedRuntimeSession:didInvalidateWithReason:error:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedRuntimeSession_didInvalidateWithReason_error(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
            reason: WKExtendedRuntimeSessionInvalidationReason,
            error: Option<&NSError>,
        );

        /// Parameter `extendedRuntimeSession`: The session which started
        ///
        /// Called when the session has started successfully.
        #[unsafe(method(extendedRuntimeSessionDidStart:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedRuntimeSessionDidStart(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
        );

        /// Parameter `extendedRuntimeSession`: The session which is about to expire.
        ///
        /// Delegate method provided to application to signify the session will expire soon.
        /// All tasks must be completed before the expiration date.
        #[unsafe(method(extendedRuntimeSessionWillExpire:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedRuntimeSessionWillExpire(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
        );
    }
);
