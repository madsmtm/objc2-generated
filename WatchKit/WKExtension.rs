//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-cloud-kit")]
use objc2_cloud_kit::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-health-kit")]
use objc2_health_kit::*;
#[cfg(feature = "objc2-intents")]
use objc2_intents::*;
#[cfg(feature = "objc2-ui-kit")]
use objc2_ui_kit::*;

use crate::*;

/// The running states of the Watch app.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKApplicationState(pub NSInteger);
impl WKApplicationState {
    /// The Watch app is running in the foreground and currently receiving events.
    #[doc(alias = "WKApplicationStateActive")]
    pub const Active: Self = Self(0);
    /// The Watch app is running in the foreground, but is not yet responding to actions from controls or gestures.
    ///
    /// ## Discussion
    ///
    /// Typically, apps transition quickly through the [`WKApplicationStateInactive`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/inactive) state when becoming active or going to the background. A newly launched watchOS app starts in the [`WKApplicationStateInactive`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/inactive) state and then quickly transitions to the [`WKApplicationStateActive`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/active) state.
    ///
    /// An active app also transition to this state when the user dismisses the app or stops interacting with it. The app remains in the [`WKApplicationStateInactive`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/inactive) state as long as it is the frontmost app (see `Understand Frontmost App State`). Then the system transitions the app to the [`WKApplicationStateBackground`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/background) state before suspending it.
    ///
    /// In some situations, the app may run for extended periods in the inactive state. For example, this occurs when the app is running in the dock, or when it is the frontmost app.
    ///
    /// When the user scrolls to the app in the dock, the system initially displays the app’s most recent snapshot. Then the app transitions to the foreground, but remains in the [`WKApplicationStateInactive`](https://developer.apple.com/documentation/watchkit/wkapplicationstate/inactive) state. The system displays a running preview of the app in the dock, but the app doesn’t respond to actions or gestures.
    ///
    ///
    #[doc(alias = "WKApplicationStateInactive")]
    pub const Inactive: Self = Self(1);
    /// The Watch app is running in the background.
    ///
    /// ## Discussion
    ///
    /// The system can wake suspended apps in the background. It can also launch apps that are not running in the background to perform background tasks.
    ///
    ///
    #[doc(alias = "WKApplicationStateBackground")]
    pub const Background: Self = Self(2);
}

unsafe impl Encode for WKApplicationState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WKApplicationState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The result of an attempt to download the content associated with a remote notification.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WKBackgroundFetchResult(pub NSUInteger);
impl WKBackgroundFetchResult {
    /// The download attempt succeeded.
    #[doc(alias = "WKBackgroundFetchResultNewData")]
    pub const NewData: Self = Self(0);
    /// The notification has no associated content.
    #[doc(alias = "WKBackgroundFetchResultNoData")]
    pub const NoData: Self = Self(1);
    /// The download attempt failed.
    #[doc(alias = "WKBackgroundFetchResultFailed")]
    pub const Failed: Self = Self(2);
}

unsafe impl Encode for WKBackgroundFetchResult {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for WKBackgroundFetchResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The centralized point of control and coordination for extension-based apps running in watchOS.
    ///
    /// ## Overview
    ///
    /// In Xcode 13 and earlier the system divides a watchOS app into two sections:
    ///
    /// - WatchKit app: An app bundle that contains your app icon. For storyboard-based apps, it also includes your storyboard and any assets used by the storyboard.
    ///
    /// - WatchKit extension: An extension that contains your watchOS app’s code.
    ///
    /// In Xcode 14 and later, you can produce watchOS apps with a single watchOS app target for code, assets, extensions, and localizations. These single-target watchOS apps can run on watchOS 7 and later
    ///
    /// Apps with separate WatchKit app and extensions have a single extension object. While the system creates and manages this object, you can access it to perform app-level tasks such as opening URLs and getting the root interface controller of your app.
    ///
    /// As relevant events occur within your WatchKit app, the extension object notifies its delegate of those events. Your delegate object can implement the methods it needs to provide an appropriate response to life cycle events, handle notifications, or handle Handoff–related behaviors. For more information about the methods of the delegate, see [`WKExtensionDelegate`](https://developer.apple.com/documentation/watchkit/wkextensiondelegate).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WKExtension;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for WKExtension {}
);

impl WKExtension {
    extern_methods!(
        #[unsafe(method(sharedExtension))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedExtension(mtm: MainThreadMarker) -> Retained<WKExtension>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(&self) -> Retained<Self>;

        #[unsafe(method(openSystemURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openSystemURL(&self, url: &NSURL);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn WKExtensionDelegate>>>;

        #[cfg(feature = "WKInterfaceController")]
        #[unsafe(method(rootInterfaceController))]
        #[unsafe(method_family = none)]
        pub unsafe fn rootInterfaceController(&self) -> Option<Retained<WKInterfaceController>>;

        #[cfg(feature = "WKInterfaceController")]
        #[unsafe(method(visibleInterfaceController))]
        #[unsafe(method_family = none)]
        pub unsafe fn visibleInterfaceController(&self) -> Option<Retained<WKInterfaceController>>;

        #[unsafe(method(applicationState))]
        #[unsafe(method_family = none)]
        pub unsafe fn applicationState(&self) -> WKApplicationState;

        #[unsafe(method(isApplicationRunningInDock))]
        #[unsafe(method_family = none)]
        pub unsafe fn isApplicationRunningInDock(&self) -> bool;

        #[unsafe(method(isAutorotating))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAutorotating(&self) -> bool;

        /// Setter for [`isAutorotating`][Self::isAutorotating].
        #[unsafe(method(setAutorotating:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAutorotating(&self, autorotating: bool);

        #[unsafe(method(isAutorotated))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAutorotated(&self) -> bool;

        #[deprecated = "No longer supported"]
        #[unsafe(method(isFrontmostTimeoutExtended))]
        #[unsafe(method_family = none)]
        pub unsafe fn isFrontmostTimeoutExtended(&self) -> bool;

        /// Setter for [`isFrontmostTimeoutExtended`][Self::isFrontmostTimeoutExtended].
        #[deprecated = "No longer supported"]
        #[unsafe(method(setFrontmostTimeoutExtended:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFrontmostTimeoutExtended(&self, frontmost_timeout_extended: bool);

        #[deprecated]
        #[unsafe(method(enableWaterLock))]
        #[unsafe(method_family = none)]
        pub unsafe fn enableWaterLock(&self);

        #[unsafe(method(registerForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForRemoteNotifications(&self);

        #[unsafe(method(unregisterForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn unregisterForRemoteNotifications(&self);

        #[unsafe(method(isRegisteredForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRegisteredForRemoteNotifications(&self) -> bool;

        #[cfg(feature = "objc2-ui-kit")]
        #[unsafe(method(globalTintColor))]
        #[unsafe(method_family = none)]
        pub unsafe fn globalTintColor(&self) -> Retained<UIColor>;
    );
}

/// Methods declared on superclass `NSObject`.
impl WKExtension {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new_class(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern "C" {
    /// A message indicating that the launch process finished and the extension is ready to run.
    ///
    /// ## Discussion
    ///
    /// When creating an app that uses the SwiftUI [`App`](https://developer.apple.com/documentation/swiftui/app) protocol to manage your life cycle, use the [`onChange(of:perform:)`](https://developer.apple.com/documentation/swiftui/view/onchange(of:perform:)) modifier and the [`scenePhase`](https://developer.apple.com/documentation/swiftui/environmentvalues/scenephase) environment value to monitor life cycle changes when possible. For more information, see [Building a watchOS app](https://developer.apple.com/documentation/watchos-apps/building_a_watchos_app).
    ///
    ///
    pub static WKApplicationDidFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// A message indicating that the watchOS app is visible and processing events.
    ///
    /// ## Discussion
    ///
    /// When creating an app that uses the SwiftUI [`App`](https://developer.apple.com/documentation/swiftui/app) protocol to manage your life cycle, use the [`onChange(of:perform:)`](https://developer.apple.com/documentation/swiftui/view/onchange(of:perform:)) modifier and the [`scenePhase`](https://developer.apple.com/documentation/swiftui/environmentvalues/scenephase) environment value to monitor life cycle changes when possible. For more information, see [Building a watchOS app](https://developer.apple.com/documentation/watchos-apps/building_a_watchos_app).
    ///
    ///
    pub static WKApplicationDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// A message indicating that the system is about to deactivate the watchOS app.
    ///
    /// ## Discussion
    ///
    /// When creating an app that uses the SwiftUI [`App`](https://developer.apple.com/documentation/swiftui/app) protocol to manage your life cycle, use the [`onChange(of:perform:)`](https://developer.apple.com/documentation/swiftui/view/onchange(of:perform:)) modifier and the [`scenePhase`](https://developer.apple.com/documentation/swiftui/environmentvalues/scenephase) environment value to monitor life cycle changes when possible. For more information, see [Building a watchOS app](https://developer.apple.com/documentation/watchos-apps/building_a_watchos_app).
    ///
    ///
    pub static WKApplicationWillResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// A message indicating that the watchOS app is about to transition from the background to the foreground.
    ///
    /// ## Discussion
    ///
    /// When creating an app that uses the SwiftUI [`App`](https://developer.apple.com/documentation/swiftui/app) protocol to manage your life cycle, use the [`onChange(of:perform:)`](https://developer.apple.com/documentation/swiftui/view/onchange(of:perform:)) modifier and the [`scenePhase`](https://developer.apple.com/documentation/swiftui/environmentvalues/scenephase) environment value to monitor life cycle changes when possible. For more information, see [Building a watchOS app](https://developer.apple.com/documentation/watchos-apps/building_a_watchos_app).
    ///
    ///
    pub static WKApplicationWillEnterForegroundNotification: &'static NSNotificationName;
}

extern "C" {
    /// A message indicating that the watchOS app transitioned from the foreground to the background.
    ///
    /// ## Discussion
    ///
    /// When creating an app that uses the SwiftUI [`App`](https://developer.apple.com/documentation/swiftui/app) protocol to manage your life cycle, use the [`onChange(of:perform:)`](https://developer.apple.com/documentation/swiftui/view/onchange(of:perform:)) modifier and the [`scenePhase`](https://developer.apple.com/documentation/swiftui/environmentvalues/scenephase) environment value to monitor life cycle changes when possible. For more information, see [Building a watchOS app](https://developer.apple.com/documentation/watchos-apps/building_a_watchos_app).
    ///
    ///
    pub static WKApplicationDidEnterBackgroundNotification: &'static NSNotificationName;
}

extern_protocol!(
    /// A collection of methods that manages the app-level behavior of a WatchKit extension.
    ///
    /// ## Overview
    ///
    /// Implement the delegate’s methods to respond to your app’s life-cycle events, such as the activation and deactivation of your app. You can also implement delegate methods to respond to background tasks, Siri intents, workout sessions, or Handoff activity from another devices.
    ///
    /// WatchKit creates your delegate object automatically by instantiating the class assigned to the [`WKExtensionDelegateClassName`](https://developer.apple.com/documentation/bundleresources/information-property-list/wkextensiondelegateclassname) key in your WatchKit extension’s `Info.plist` file. By default, this class is named ExtensionDelegate. The system then assigns the delegate object to the [`delegate`](https://developer.apple.com/documentation/watchkit/wkextension/delegate) property of the shared [`WKExtension`](https://developer.apple.com/documentation/watchkit/wkextension) object.
    ///
    ///
    pub unsafe trait WKExtensionDelegate: NSObjectProtocol + MainThreadOnly {
        #[optional]
        #[unsafe(method(applicationDidFinishLaunching))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidFinishLaunching(&self);

        #[optional]
        #[unsafe(method(applicationDidBecomeActive))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidBecomeActive(&self);

        #[optional]
        #[unsafe(method(applicationWillResignActive))]
        #[unsafe(method_family = none)]
        unsafe fn applicationWillResignActive(&self);

        #[optional]
        #[unsafe(method(applicationWillEnterForeground))]
        #[unsafe(method_family = none)]
        unsafe fn applicationWillEnterForeground(&self);

        #[optional]
        #[unsafe(method(applicationDidEnterBackground))]
        #[unsafe(method_family = none)]
        unsafe fn applicationDidEnterBackground(&self);

        #[cfg(feature = "objc2-health-kit")]
        #[optional]
        #[unsafe(method(handleWorkoutConfiguration:))]
        #[unsafe(method_family = none)]
        unsafe fn handleWorkoutConfiguration(&self, workout_configuration: &HKWorkoutConfiguration);

        #[optional]
        #[unsafe(method(handleActiveWorkoutRecovery))]
        #[unsafe(method_family = none)]
        unsafe fn handleActiveWorkoutRecovery(&self);

        #[cfg(feature = "WKExtendedRuntimeSession")]
        #[optional]
        #[unsafe(method(handleExtendedRuntimeSession:))]
        #[unsafe(method_family = none)]
        unsafe fn handleExtendedRuntimeSession(
            &self,
            extended_runtime_session: &WKExtendedRuntimeSession,
        );

        #[optional]
        #[unsafe(method(handleRemoteNowPlayingActivity))]
        #[unsafe(method_family = none)]
        unsafe fn handleRemoteNowPlayingActivity(&self);

        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[optional]
        #[unsafe(method(handleUserActivity:))]
        #[unsafe(method_family = none)]
        unsafe fn handleUserActivity(&self, user_info: Option<&NSDictionary>);

        #[optional]
        #[unsafe(method(handleActivity:))]
        #[unsafe(method_family = none)]
        unsafe fn handleActivity(&self, user_activity: &NSUserActivity);

        #[cfg(all(feature = "block2", feature = "objc2-intents"))]
        #[optional]
        #[unsafe(method(handleIntent:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn handleIntent_completionHandler(
            &self,
            intent: &INIntent,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<INIntentResponse>)>,
        );

        #[cfg(feature = "WKBackgroundTask")]
        #[optional]
        #[unsafe(method(handleBackgroundTasks:))]
        #[unsafe(method_family = none)]
        unsafe fn handleBackgroundTasks(&self, background_tasks: &NSSet<WKRefreshBackgroundTask>);

        #[optional]
        #[unsafe(method(deviceOrientationDidChange))]
        #[unsafe(method_family = none)]
        unsafe fn deviceOrientationDidChange(&self);

        #[optional]
        #[unsafe(method(didRegisterForRemoteNotificationsWithDeviceToken:))]
        #[unsafe(method_family = none)]
        unsafe fn didRegisterForRemoteNotificationsWithDeviceToken(&self, device_token: &NSData);

        #[optional]
        #[unsafe(method(didFailToRegisterForRemoteNotificationsWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn didFailToRegisterForRemoteNotificationsWithError(&self, error: &NSError);

        #[cfg(feature = "block2")]
        /// This delegate method offers an opportunity for applications with the "remote-notification" background mode to fetch appropriate new data in response to an incoming remote notification. You should call the fetchCompletionHandler as soon as you're finished performing that operation, so the system can accurately estimate its power and data cost.
        ///
        /// This method will be invoked even if the application was launched or resumed because of the remote background notification.!
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[optional]
        #[unsafe(method(didReceiveRemoteNotification:fetchCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn didReceiveRemoteNotification_fetchCompletionHandler(
            &self,
            user_info: &NSDictionary,
            completion_handler: &block2::DynBlock<dyn Fn(WKBackgroundFetchResult)>,
        );

        #[cfg(feature = "objc2-cloud-kit")]
        #[optional]
        #[unsafe(method(userDidAcceptCloudKitShareWithMetadata:))]
        #[unsafe(method_family = none)]
        unsafe fn userDidAcceptCloudKitShareWithMetadata(
            &self,
            cloud_kit_share_metadata: &CKShareMetadata,
        );

        /// # Safety
        ///
        /// `remote_notification` generic should be of the correct type.
        #[deprecated = "use UNUserNotificationCenterDelegate"]
        #[optional]
        #[unsafe(method(handleActionWithIdentifier:forRemoteNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn handleActionWithIdentifier_forRemoteNotification(
            &self,
            identifier: Option<&NSString>,
            remote_notification: &NSDictionary,
        );

        #[cfg(feature = "objc2-ui-kit")]
        #[deprecated = "use UNUserNotificationCenterDelegate"]
        #[optional]
        #[unsafe(method(handleActionWithIdentifier:forLocalNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn handleActionWithIdentifier_forLocalNotification(
            &self,
            identifier: Option<&NSString>,
            local_notification: &UILocalNotification,
        );

        /// # Safety
        ///
        /// - `remote_notification` generic should be of the correct type.
        /// - `response_info` generic should be of the correct type.
        #[deprecated = "use UNUserNotificationCenterDelegate"]
        #[optional]
        #[unsafe(method(handleActionWithIdentifier:forRemoteNotification:withResponseInfo:))]
        #[unsafe(method_family = none)]
        unsafe fn handleActionWithIdentifier_forRemoteNotification_withResponseInfo(
            &self,
            identifier: Option<&NSString>,
            remote_notification: &NSDictionary,
            response_info: &NSDictionary,
        );

        #[cfg(feature = "objc2-ui-kit")]
        /// # Safety
        ///
        /// `response_info` generic should be of the correct type.
        #[deprecated = "use UNUserNotificationCenterDelegate"]
        #[optional]
        #[unsafe(method(handleActionWithIdentifier:forLocalNotification:withResponseInfo:))]
        #[unsafe(method_family = none)]
        unsafe fn handleActionWithIdentifier_forLocalNotification_withResponseInfo(
            &self,
            identifier: Option<&NSString>,
            local_notification: &UILocalNotification,
            response_info: &NSDictionary,
        );

        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[deprecated = "use UNUserNotificationCenterDelegate"]
        #[optional]
        #[unsafe(method(didReceiveRemoteNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn didReceiveRemoteNotification(&self, user_info: &NSDictionary);

        #[cfg(feature = "objc2-ui-kit")]
        #[deprecated = "use UNUserNotificationCenterDelegate"]
        #[optional]
        #[unsafe(method(didReceiveLocalNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn didReceiveLocalNotification(&self, notification: &UILocalNotification);
    }
);
