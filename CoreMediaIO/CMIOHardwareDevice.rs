//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use objc2::__framework_prelude::*;

use crate::*;

/// CMIODevice is the base class for all objects that represent a CMIO device.
///
/// CMIODevice is a subclass of CMIOObject. CMIODevices normally contain CMIOStreams and CMIOControls.
#[cfg(feature = "CMIOHardwareObject")]
pub type CMIODeviceID = CMIOObjectID;

/// A CMIODevicePropertyID is an integer that identifies a specific piece of information about the object.
#[cfg(feature = "CMIOHardwareObject")]
pub type CMIODevicePropertyID = CMIOObjectPropertySelector;

/// This structure describes the list of streams and the number of channels in each stream.
/// Field: mNumberStreams
/// The number of streams being described.
/// Field: mNumberChannels
/// An array of UInt32's whose length is specified by mNumberStreams. Each element of the array corresponds to a stream and indicates the number of channels it has.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMIODeviceStreamConfiguration {
    pub mNumberStreams: u32,
    pub mNumberChannels: *mut u32,
}

unsafe impl Encode for CMIODeviceStreamConfiguration {
    const ENCODING: Encoding = Encoding::Struct(
        "CMIODeviceStreamConfiguration",
        &[<u32>::ENCODING, <*mut u32>::ENCODING],
    );
}

unsafe impl RefEncode for CMIODeviceStreamConfiguration {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This structure allows an AVC command to be sent to a device. This is not intended to be a general purpose command interfaces, rather only for those devices which can
/// support the "AV/C Digital Interface Command Set General Specification Version 4.1" (1394 Trade Association Document 2001012). Devices indicate whether or not they can
/// process AVC commands via the kCMIODevicePropertyCanProcessAVCCommand property.
/// Field: mCommand
/// The buffer containing the AVC command bytes.
/// Field: mCommandLength
/// The size (in bytes) of the mCommand buffer.
/// Field: mResponse
/// The buffer for returning the response bytes.
/// Field: mResponseLength
/// The size (in bytes) of the mResponse buffer.
/// Field: mResponseUsed
/// The size (in bytes) of the actual number response bytes returned.
#[repr(C, packed(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMIODeviceAVCCommand {
    pub mCommand: *mut u8,
    pub mCommandLength: u32,
    pub mResponse: *mut u8,
    pub mResponseLength: u32,
    pub mResponseUsed: u32,
}

unsafe impl Encode for CMIODeviceAVCCommand {
    const ENCODING: Encoding = Encoding::Struct(
        "CMIODeviceAVCCommand",
        &[
            <*mut u8>::ENCODING,
            <u32>::ENCODING,
            <*mut u8>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for CMIODeviceAVCCommand {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This structure allows an RS422 command to be sent to a device. This is not intended to be a general purpose command interface, rather only for those devices which can
/// support the RS422 protocol. Devices indicate whether or not they can process RS422 commands via the kCMIODevicePropertyCanProcessRS422Command property.
/// Field: mCommand
/// The buffer containing the RS422 command bytes.
/// Field: mCommandLength
/// The size (in bytes) of the mCommand buffer.
/// Field: mResponse
/// The buffer for returning the response bytes.
/// Field: mResponseLength
/// The size (in bytes) of the mResponse buffer.
/// Field: mResponseUsed
/// The size (in bytes) of the actual number response bytes returned.
#[repr(C, packed(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMIODeviceRS422Command {
    pub mCommand: *mut u8,
    pub mCommandLength: u32,
    pub mResponse: *mut u8,
    pub mResponseLength: u32,
    pub mResponseUsed: u32,
}

unsafe impl Encode for CMIODeviceRS422Command {
    const ENCODING: Encoding = Encoding::Struct(
        "CMIODeviceRS422Command",
        &[
            <*mut u8>::ENCODING,
            <u32>::ENCODING,
            <*mut u8>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for CMIODeviceRS422Command {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Clients register a CMIODeviceGetSMPTETimeProc to specify a routine for the a device to call when it needs SMPTE timecode information. Some devices require
/// external means known only to their client to provide SMPTE timecode information (for example, devices conforming to the HDV-1 standard do not provide SMPTE timecode
/// information in the HDV datastream); the HDV device driver may call a provided SMPTE timecode callback when it needs the data.
///
/// The SMPTE time callback is invoked by the device when it needs SMPTE timecode information. The callback should be very low latency, as it may be called on a real-time
/// thread; as such, it may need to rely on a private thread to obtain the values it returns. It is understood that the callback may be obtaining its values in a manner
/// asynchronous to when the device requires it, and as such, there will be jitter in the values; sometimes a value will be repeated, sometimes a value skipped, depending
/// upon the cadence of the threads involved.
///
/// Parameter `refCon`: A pointer to client data established when the proc was registered via setting the kCMIODevicePropertySMPTETimeCallback property.
///
/// Parameter `frameNumber`: The current frame count.
///
/// Parameter `isDropFrame`: True when the frame count is drop frame based (two frames of time code are dropped every minute, on the minute, except every tenth minute), false otherwise.
///
/// Parameter `tolerance`: The maximum amount of jitter expected in the frame count. Differences observed outside of this value are an indication of dropped data.
///
/// Returns: An OSStatus indicating success or failure.
pub type CMIODeviceGetSMPTETimeProc =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut u64, *mut Boolean, *mut u32) -> OSStatus>;

/// This structure allows a client to specify a CMIODeviceGetSMPTETimeProc and its associated private data via the kCMIODevicePropertySMPTETimeCallback property.
/// Field: mGetSMPTETimeProc
/// The CMIODeviceGetSMPTETimeProc to invoke when SMPTE timecode information is needed.
/// Field: mRefCon
/// Client supplied private provided when the kCMIODevicePropertySMPTETimeCallback property was set.
#[repr(C, packed(4))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMIODeviceSMPTETimeCallback {
    pub mGetSMPTETimeProc: CMIODeviceGetSMPTETimeProc,
    pub mRefCon: *mut c_void,
}

unsafe impl Encode for CMIODeviceSMPTETimeCallback {
    const ENCODING: Encoding = Encoding::Struct(
        "CMIODeviceSMPTETimeCallback",
        &[
            <CMIODeviceGetSMPTETimeProc>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for CMIODeviceSMPTETimeCallback {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kCMIODevicePropertyScopeInput: c_uint = 0x696e7074;
pub const kCMIODevicePropertyScopeOutput: c_uint = 0x6f757470;
pub const kCMIODevicePropertyScopePlayThrough: c_uint = 0x70747275;
pub const kCMIODeviceClassID: c_uint = 0x61646576;
#[cfg(feature = "CMIOHardwareObject")]
pub const kCMIODeviceUnknown: c_uint = kCMIOObjectUnknown;

pub const kCMIOAVCDeviceType_Unknown: c_uint = 0x756e6b6e;
pub const kCMIOAVCDeviceType_DV_NTSC: c_uint = 0x64766320;
pub const kCMIOAVCDeviceType_DV_PAL: c_uint = 0x64766370;
pub const kCMIOAVCDeviceType_DVCPro_NTSC: c_uint = 0x6476706e;
pub const kCMIOAVCDeviceType_DVCPro_PAL: c_uint = 0x64767070;
pub const kCMIOAVCDeviceType_DVCPro50_NTSC: c_uint = 0x6476356e;
pub const kCMIOAVCDeviceType_DVCPro50_PAL: c_uint = 0x64763570;
pub const kCMIOAVCDeviceType_DVCPro100_NTSC: c_uint = 0x6476316e;
pub const kCMIOAVCDeviceType_DVCPro100_PAL: c_uint = 0x64763170;
pub const kCMIOAVCDeviceType_DVCPro100_720p: c_uint = 0x64766870;
pub const kCMIOAVCDeviceType_DVCProHD_1080i50: c_uint = 0x64766835;
pub const kCMIOAVCDeviceType_DVCProHD_1080i60: c_uint = 0x64766836;
pub const kCMIOAVCDeviceType_MPEG2: c_uint = 0x6d706732;

pub const kCMIODeviceAVCSignalModeSD525_60: c_uint = 0x00;
pub const kCMIODeviceAVCSignalModeSDL525_60: c_uint = 0x04;
pub const kCMIODeviceAVCSignalModeHD1125_60: c_uint = 0x08;
pub const kCMIODeviceAVCSignalModeSD625_50: c_uint = 0x80;
pub const kCMIODeviceAVCSignalModeSDL625_50: c_uint = 0x84;
pub const kCMIODeviceAVCSignalModeHD1250_50: c_uint = 0x88;
pub const kCMIODeviceAVCSignalModeMPEG25Mbps_60: c_uint = 0x10;
pub const kCMIODeviceAVCSignalModeHDV1_60: c_uint = 0x10;
pub const kCMIODeviceAVCSignalModeMPEG12Mbps_60: c_uint = 0x14;
pub const kCMIODeviceAVCSignalModeMPEG6Mbps_60: c_uint = 0x18;
pub const kCMIODeviceAVCSignalModeMPEG25Mbps_50: c_uint = 0x90;
pub const kCMIODeviceAVCSignalModeHDV1_50: c_uint = 0x90;
pub const kCMIODeviceAVCSignalModeMPEG12Mbps_50: c_uint = 0x94;
pub const kCMIODeviceAVCSignalModeMPEG6Mbps_50: c_uint = 0x98;
pub const kCMIODeviceAVCSignalModeDVHS: c_uint = 0x01;
pub const kCMIODeviceAVCSignalModeVHSNTSC: c_uint = 0x05;
pub const kCMIODeviceAVCSignalModeVHSMPAL: c_uint = 0x25;
pub const kCMIODeviceAVCSignalModeVHSPAL: c_uint = 0xa5;
pub const kCMIODeviceAVCSignalModeVHSNPAL: c_uint = 0xb5;
pub const kCMIODeviceAVCSignalModeVHSSECAM: c_uint = 0xc5;
pub const kCMIODeviceAVCSignalModeVHSMESECAM: c_uint = 0xd5;
pub const kCMIODeviceAVCSignalModeSVHS525_60: c_uint = 0x0d;
pub const kCMIODeviceAVCSignalModeSVHS625_50: c_uint = 0xed;
pub const kCMIODeviceAVCSignalMode8mmNTSC: c_uint = 0x06;
pub const kCMIODeviceAVCSignalMode8mmPAL: c_uint = 0x86;
pub const kCMIODeviceAVCSignalModeHi8NTSC: c_uint = 0x0e;
pub const kCMIODeviceAVCSignalModeHi8PAL: c_uint = 0x8e;
pub const kCMIODeviceAVCSignalModeMicroMV12Mbps_60: c_uint = 0x24;
pub const kCMIODeviceAVCSignalModeMicroMV6Mbps_60: c_uint = 0x28;
pub const kCMIODeviceAVCSignalModeMicroMV12Mbps_50: c_uint = 0xA4;
pub const kCMIODeviceAVCSignalModeMicroMV6Mbps_50: c_uint = 0xA8;
pub const kCMIODeviceAVCSignalModeAudio: c_uint = 0x20;
pub const kCMIODeviceAVCSignalModeHDV2_60: c_uint = 0x1A;
pub const kCMIODeviceAVCSignalModeHDV2_50: c_uint = 0x9A;
pub const kCMIODeviceAVCSignalModeDVCPro25_625_50: c_uint = 0xF8;
pub const kCMIODeviceAVCSignalModeDVCPro25_525_60: c_uint = 0x78;
pub const kCMIODeviceAVCSignalModeDVCPro50_625_50: c_uint = 0xF4;
pub const kCMIODeviceAVCSignalModeDVCPro50_525_60: c_uint = 0x74;
pub const kCMIODeviceAVCSignalModeDVCPro100_50: c_uint = 0xF0;
pub const kCMIODeviceAVCSignalModeDVCPro100_60: c_uint = 0x70;

pub const kCMIODevicePropertyPlugIn: c_uint = 0x706c7567;
pub const kCMIODevicePropertyDeviceUID: c_uint = 0x75696420;
pub const kCMIODevicePropertyModelUID: c_uint = 0x6d756964;
pub const kCMIODevicePropertyTransportType: c_uint = 0x7472616e;
pub const kCMIODevicePropertyDeviceIsAlive: c_uint = 0x6c69766e;
pub const kCMIODevicePropertyDeviceHasChanged: c_uint = 0x64696666;
pub const kCMIODevicePropertyDeviceIsRunning: c_uint = 0x676f696e;
pub const kCMIODevicePropertyDeviceIsRunningSomewhere: c_uint = 0x676f6e65;
pub const kCMIODevicePropertyDeviceCanBeDefaultDevice: c_uint = 0x64666c74;
pub const kCMIODevicePropertyHogMode: c_uint = 0x6f696e6b;
pub const kCMIODevicePropertyLatency: c_uint = 0x6c746e63;
pub const kCMIODevicePropertyStreams: c_uint = 0x73746d23;
pub const kCMIODevicePropertyStreamConfiguration: c_uint = 0x736c6179;
pub const kCMIODevicePropertyDeviceControl: c_uint = 0x706d6e68;
#[deprecated]
pub const kCMIODevicePropertyDeviceMaster: c_uint = kCMIODevicePropertyDeviceControl;
pub const kCMIODevicePropertyExcludeNonDALAccess: c_uint = 0x69786e61;
pub const kCMIODevicePropertyClientSyncDiscontinuity: c_uint = 0x706d6373;
pub const kCMIODevicePropertySMPTETimeCallback: c_uint = 0x706d7363;
pub const kCMIODevicePropertyCanProcessAVCCommand: c_uint = 0x706d6163;
pub const kCMIODevicePropertyAVCDeviceType: c_uint = 0x706d6174;
pub const kCMIODevicePropertyAVCDeviceSignalMode: c_uint = 0x706d736d;
pub const kCMIODevicePropertyCanProcessRS422Command: c_uint = 0x72343232;
pub const kCMIODevicePropertyLinkedCoreAudioDeviceUID: c_uint = 0x706c7564;
pub const kCMIODevicePropertyVideoDigitizerComponents: c_uint = 0x76646967;
pub const kCMIODevicePropertySuspendedByUser: c_uint = 0x73627975;
pub const kCMIODevicePropertyLinkedAndSyncedCoreAudioDeviceUID: c_uint = 0x706c7364;
pub const kCMIODevicePropertyIIDCInitialUnitSpace: c_uint = 0x69756e73;
pub const kCMIODevicePropertyIIDCCSRData: c_uint = 0x63737264;
pub const kCMIODevicePropertyCanSwitchFrameRatesWithoutFrameDrops: c_uint = 0x66726e64;
pub const kCMIODevicePropertyLocation: c_uint = 0x646c6f63;
pub const kCMIODevicePropertyDeviceHasStreamingError: c_uint = 0x73657272;

pub const kCMIODevicePropertyLocationUnknown: c_uint = 0;
pub const kCMIODevicePropertyLocationBuiltInDisplay: c_uint = 1;
pub const kCMIODevicePropertyLocationExternalDisplay: c_uint = 2;
pub const kCMIODevicePropertyLocationExternalDevice: c_uint = 3;
pub const kCMIODevicePropertyLocationExternalWirelessDevice: c_uint = 4;

extern "C-unwind" {
    /// Starts the indicated CMIOStream of the specified CMIODevice.
    ///
    /// Parameter `deviceID`: The CMIODevice that owns the CMIOStream.
    ///
    /// Parameter `streamID`: The CMIOStream to start.
    ///
    /// Returns: An OSStatus indicating success or failure.
    #[cfg(all(feature = "CMIOHardwareObject", feature = "CMIOHardwareStream"))]
    pub fn CMIODeviceStartStream(device_id: CMIODeviceID, stream_id: CMIOStreamID) -> OSStatus;
}

extern "C-unwind" {
    /// Stops the indicated CMIOStream.
    ///
    /// Parameter `deviceID`: The CMIODevice that owns the CMIOStream.
    ///
    /// Parameter `streamID`: The CMIOStream to stop.
    ///
    /// Returns: An OSStatus indicating success or failure.
    #[cfg(all(feature = "CMIOHardwareObject", feature = "CMIOHardwareStream"))]
    pub fn CMIODeviceStopStream(device_id: CMIODeviceID, stream_id: CMIOStreamID) -> OSStatus;
}

extern "C-unwind" {
    /// Allows an AVC command to be sent to a device for processing. This is not intended to be a general purpose command interface, rather only for those devices which can
    /// support the "AV/C Digital Interface Command Set General Specification Version 4.1" (1394 Trade Association Document 2001012). Devices indicate whether or not they can
    /// process AVC commands via the kCMIODevicePropertyCanProcessAVCCommand property.
    ///
    /// Parameter `deviceID`: The CMIODevice for which the command is intended.
    ///
    /// Parameter `ioAVCCommand`: The CMIODeviceAVCCommand to send to the device.
    ///
    /// Returns: An OSStatus indicating success or failure of the command processing.
    ///
    /// # Safety
    ///
    /// `io_avc_command` must be a valid pointer.
    #[cfg(feature = "CMIOHardwareObject")]
    pub fn CMIODeviceProcessAVCCommand(
        device_id: CMIODeviceID,
        io_avc_command: *mut CMIODeviceAVCCommand,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Allows an RS422 command to be sent to a device for processing. This is not intended to be a general purpose command interface, rather only for those devices which can
    /// support the RS422 protocol. Devices indicate whether or not they can process RS422 commands via the kCMIODevicePropertyCanProcessRS422Command property.
    ///
    /// Parameter `deviceID`: The CMIODevice for which the command is intended.
    ///
    /// Parameter `ioRS422Command`: The CMIODeviceRS422Command to send to the device.
    ///
    /// Returns: An OSStatus indicating success or failure of the command processing.
    ///
    /// # Safety
    ///
    /// `io_rs422_command` must be a valid pointer.
    #[cfg(feature = "CMIOHardwareObject")]
    pub fn CMIODeviceProcessRS422Command(
        device_id: CMIODeviceID,
        io_rs422_command: *mut CMIODeviceRS422Command,
    ) -> OSStatus;
}
