//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;

use crate::*;

/// A frame.
///
/// ## Overview
///
/// A frame contains multiple lines of text. The frame object is the output resulting from the text-framing process performed by a [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter) object.
///
/// You can draw the entire text frame directly into the current graphic context. The frame object contains an array of line objects that can be retrieved for individual rendering or to get glyph information.
///
///
#[doc(alias = "CTFrameRef")]
#[repr(C)]
pub struct CTFrame {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CTFrame {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CTFrame"> for CTFrame {}
);

unsafe impl ConcreteType for CTFrame {
    /// Returns the type identifier for the CTFrame opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CTFrame opaque type.
    ///
    ///
    /// Returns the CFType of the frame object
    #[doc(alias = "CTFrameGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CTFrameGetTypeID() -> CFTypeID;
        }
        unsafe { CTFrameGetTypeID() }
    }
}

/// Constants that specify frame progression types.
///
/// ## Overview
///
/// The lines of text within a frame may stack for either horizontal or vertical text. Values are enumerated for each stacking type supported by [`CTFrameProgression`](https://developer.apple.com/documentation/coretext/ctframeprogression). Frames with a progression type that specifies vertical text rotate lines 90 degrees counterclockwise during drawing.
///
///
/// These constants specify frame progression types.
///
///
/// The lines of text within a frame may be stacked for either
/// horizontal or vertical text. Values are enumerated for each
/// stacking type supported by CTFrame. Frames created with a
/// progression type specifying vertical text will rotate lines
/// 90 degrees counterclockwise when drawing.
///
///
/// Lines are stacked top to bottom for horizontal text.
///
///
/// Lines are stacked right to left for vertical text.
///
///
/// Lines are stacked left to right for vertical text.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CTFrameProgression(pub u32);
impl CTFrameProgression {
    /// Lines stack top to bottom for horizontal text.
    #[doc(alias = "kCTFrameProgressionTopToBottom")]
    pub const TopToBottom: Self = Self(0);
    /// Lines stack right to left for vertical text.
    #[doc(alias = "kCTFrameProgressionRightToLeft")]
    pub const RightToLeft: Self = Self(1);
    /// Lines stack left to right for vertical text.
    #[doc(alias = "kCTFrameProgressionLeftToRight")]
    pub const LeftToRight: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTFrameProgression {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTFrameProgression {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// Specifies progression for a frame.
    ///
    /// ## Discussion
    ///
    /// A [`CFNumberRef`](https://developer.apple.com/documentation/corefoundation/cfnumber) object containing a [`CTFrameProgression`](https://developer.apple.com/documentation/coretext/ctframeprogression) constant. The default is `kCTFrameProgressionTopToBottom`.
    ///
    /// This value determines the line-stacking behavior for a frame and does not affect the appearance of the glyphs within that frame.
    ///
    ///
    /// Specifies progression for a frame.
    ///
    ///
    /// Value must be a CFNumberRef containing a CTFrameProgression.
    /// Default is kCTFrameProgressionTopToBottom. This value determines
    /// the line stacking behavior for a frame and does not affect the
    /// appearance of the glyphs within that frame.
    ///
    ///
    /// See also: CTFramesetterCreateFrame
    pub static kCTFrameProgressionAttributeName: &'static CFString;
}

/// These constants specify the fill rule used by a frame
///
/// ## Overview
///
/// When a path intersects with itself, the client should specify which rule to use for deciding the area of the path.
///
///
/// These constants specify fill rule used by the frame.
///
///
/// When a path intersects with itself, the client should specify which rule to use for deciding the
/// area of the path.
///
///
/// Text is filled in the area that would be painted if the path were given to CGContextEOFillPath.
///
///
/// Text is fill in the area that would be painted if the path were given to CGContextFillPath.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CTFramePathFillRule(pub u32);
impl CTFramePathFillRule {
    /// Paints the area using the even-odd fill rule.
    ///
    /// ## Discussion
    ///
    /// Text is filled in the area that would be painted if the path were given to [`CGContextEOFillPath`](https://developer.apple.comhttps://developer.apple.com/documentation/coregraphics/1454865-cgcontexteofillpath).
    ///
    ///
    #[doc(alias = "kCTFramePathFillEvenOdd")]
    pub const EvenOdd: Self = Self(0);
    /// Paints the area using the nonzero winding number rule.
    ///
    /// ## Discussion
    ///
    /// Text is filled in the area that would be painted if the path were given to [`CGContextFillPath`](https://developer.apple.comhttps://developer.apple.com/documentation/coregraphics/1456306-cgcontextfillpath).
    ///
    ///
    #[doc(alias = "kCTFramePathFillWindingNumber")]
    pub const WindingNumber: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTFramePathFillRule {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTFramePathFillRule {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The key used to specify the fill rule for a frame.
    ///
    /// ## Discussion
    ///
    /// The value must be a [`CFNumberRef`](https://developer.apple.com/documentation/corefoundation/cfnumber) object containing a [`CTFramePathFillRule`](https://developer.apple.com/documentation/coretext/ctframepathfillrule) constant. The default value is [`kCTFramePathFillEvenOdd`](https://developer.apple.com/documentation/coretext/ctframepathfillrule/evenodd).
    ///
    ///
    /// Specifies fill rule for a frame if this attribute is used at top level of frameAttributes dictionary, or specify
    /// fill rule for a clipping path if used in a dictionary contained in an array specified by kCTFrameClippingPathsAttributeName.
    ///
    ///
    /// Value must be a CFNumberRef containing kCTFramePathFillEvenOdd or kCTFramePathFillWindingNumber.
    /// Default is kCTFramePathFillEvenOdd.
    ///
    ///
    /// See also: CTFramesetterCreateFrame
    pub static kCTFramePathFillRuleAttributeName: &'static CFString;
}

extern "C" {
    /// The key used to specify the frame width.
    ///
    /// ## Discussion
    ///
    /// The value must be a [`CFNumberRef`](https://developer.apple.com/documentation/corefoundation/cfnumber) object containing a value specifying the frame width. The default width value is zero.
    ///
    ///
    /// Specifies frame width if this attribute is used at top level of frameAttributes dictionary, or specify
    /// clipping path width if used in a dictionary contained in an array specified by kCTFrameClippingPathsAttributeName.
    ///
    ///
    /// Value must be a CFNumberRef specifying frame width.
    /// Default is zero.
    ///
    ///
    /// See also: CTFramesetterCreateFrame
    pub static kCTFramePathWidthAttributeName: &'static CFString;
}

extern "C" {
    /// Specifies array of paths to clip frame.
    ///
    /// ## Discussion
    ///
    /// The value must be a `CFArrayRef` containing `CFDictionaryRef`s. Each dictionary should have a `kCTFramePathClippingPathAttributeName` key-value pair, and can have a `kCTFramePathFillRuleAttributeName` key-value pair and `kCTFramePathFillRuleAttributeName` key-value pair as optional parameters.
    ///
    ///
    /// Specifies array of paths to clip frame.
    ///
    ///
    /// Value must be a CFArrayRef containing CFDictionaryRefs or CGPathRef.  (CGPathRef is allowed on 10.8 or later.)
    /// Each dictionary should have a kCTFramePathClippingPathAttributeName key-value pair, and can have a kCTFramePathFillRuleAttributeName key-value pair
    /// and kCTFramePathFillRuleAttributeName key-value pair as optional parameters.  In case of CGPathRef, default fill rule (kCTFramePathFillEvenOdd) and width (0.0) are used.
    ///
    ///
    /// See also: CTFramesetterCreateFrame
    pub static kCTFrameClippingPathsAttributeName: &'static CFString;
}

extern "C" {
    /// Specifies clipping path.
    ///
    /// ## Discussion
    ///
    /// Specifies clipping path.  This attribute is valid only in a dictionary contained in an array specified by `kCTFrameClippingPathsAttributeName`.
    ///
    /// The value must be a `CGPathRef` specifying a clipping path. See [`kCTFrameClippingPathsAttributeName`](https://developer.apple.com/documentation/coretext/kctframeclippingpathsattributename).
    ///
    ///
    /// Specifies clipping path.  This attribute is valid in a dictionary contained in an array specified by kCTFrameClippingPathsAttributeName.
    /// On 10.8 or later, This attribute is also valid in frameAttributes dictionary passed to CTFramesetterCreateFrame.
    ///
    ///
    /// Value must be a CGPathRef specifying a clipping path.
    ///
    ///
    /// See also: kCTFrameClippingPathsAttributeName
    pub static kCTFramePathClippingPathAttributeName: &'static CFString;
}

impl CTFrame {
    /// Returns the range of characters originally requested to fill the frame.
    ///
    /// Parameters:
    /// - frame: The frame whose character range is returned.
    ///
    ///
    /// ## Return Value
    ///
    /// A `CFRange` structure containing the backing store range of characters that were originally requested to fill the frame, or, if the function call is not successful, an empty range.
    ///
    ///
    /// Returns the range of characters that were originally requested
    /// to fill the frame.
    ///
    ///
    /// Parameter `frame`: The frame that you want to get the character range from.
    ///
    ///
    /// Returns: This function will return a CFRange containing the backing
    /// store range of characters that were originally requested
    /// to fill the frame. If the function call is not successful,
    /// then an empty range will be returned.
    #[doc(alias = "CTFrameGetStringRange")]
    #[inline]
    pub fn string_range(&self) -> CFRange {
        extern "C-unwind" {
            fn CTFrameGetStringRange(frame: &CTFrame) -> CFRange;
        }
        unsafe { CTFrameGetStringRange(self) }
    }

    /// Returns the range of characters that actually fit in the frame.
    ///
    /// Parameters:
    /// - frame: The frame whose visible character range is returned.
    ///
    ///
    /// ## Return Value
    ///
    /// A `CFRange` structure containing the backing store range of characters that fit into the frame, or if the function call is not successful or no characters fit in the frame, an empty range.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function can be used to cascade frames, because it returns the range of characters that can be seen in the frame. The next frame would start where this frame ends.
    ///
    ///
    /// Returns the range of characters that actually fit in the
    /// frame.
    ///
    ///
    /// This can be used to chain frames, as it returns the range of
    /// characters that can be seen in the frame. The next frame would
    /// start where this frame ends.
    ///
    ///
    /// Parameter `frame`: The frame that you want to get the visible character range
    /// from.
    ///
    ///
    /// Returns: This function will return a CFRange containing the backing
    /// store range of characters that fit into the frame. If the
    /// function call is not successful, or if no characters fit
    /// in the frame, then an empty range will be returned.
    #[doc(alias = "CTFrameGetVisibleStringRange")]
    #[inline]
    pub fn visible_string_range(&self) -> CFRange {
        extern "C-unwind" {
            fn CTFrameGetVisibleStringRange(frame: &CTFrame) -> CFRange;
        }
        unsafe { CTFrameGetVisibleStringRange(self) }
    }

    /// Returns the path used to create the frame.
    ///
    /// Parameters:
    /// - frame: The frame whose path is returned.
    ///
    /// Returns the path used to create the frame.
    ///
    ///
    /// Parameter `frame`: The frame that you want to obtain the path from.
    #[doc(alias = "CTFrameGetPath")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub fn path(&self) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CTFrameGetPath(frame: &CTFrame) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CTFrameGetPath(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Returns the frame attributes used to create the frame.
    ///
    /// Parameters:
    /// - frame: The frame whose attributes are returned.
    ///
    ///
    /// ## Return Value
    ///
    /// A reference to a CFDictionary object containing the frame attributes that were used to create the frame, or, if the frame was created without any frame attributes, `NULL`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can create a frame with an attributes dictionary to control various aspects of the framing process. These attributes are different from the ones used to create an attributed string.
    ///
    ///
    /// Returns the frame attributes used to create the frame.
    ///
    ///
    /// It is possible to create a frame with an attributes dictionary
    /// in order to control various aspects of the framing process.
    /// These attributes are different from the ones that are used to
    /// create an attributed string.
    ///
    ///
    /// Parameter `frame`: The frame that you want to obtain the frame attributes from.
    ///
    ///
    /// Returns: This function will return a CFDictionary containing the
    /// frame attributes that were used to create the frame. If the
    /// frame was created without any frame attributes, this function
    /// will return NULL.
    #[doc(alias = "CTFrameGetFrameAttributes")]
    #[inline]
    pub fn frame_attributes(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CTFrameGetFrameAttributes(frame: &CTFrame) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CTFrameGetFrameAttributes(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns an array of lines stored in the frame.
    ///
    /// Parameters:
    /// - frame: The frame whose line array is returned.
    ///
    ///
    /// ## Return Value
    ///
    /// A CFArray object containing the CTLine objects that make up the frame, or, if there are no lines in the frame, an array with no elements.
    ///
    ///
    /// Returns an array of lines that make up the frame.
    ///
    ///
    /// This function will return an array of CTLine objects that are
    /// stored in the frame. These line objects can be accessed and
    /// manipulated in any way that normal line objects can be. It is
    /// possible that an empty frame exists. That is, a frame in which
    /// no lines exist. In this case, the returned array will have 0
    /// entries.
    ///
    ///
    /// Parameter `frame`: The frame that you want to obtain the line array from.
    ///
    ///
    /// Returns: This function will return a CFArray object containing the
    /// CTLine objects that make up the frame.
    #[doc(alias = "CTFrameGetLines")]
    #[inline]
    pub fn lines(&self) -> CFRetained<CFArray> {
        extern "C-unwind" {
            fn CTFrameGetLines(frame: &CTFrame) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CTFrameGetLines(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Copies a range of line origins for a frame.
    ///
    /// Parameters:
    /// - frame: The frame whose line origin array is copied.
    ///
    /// - range: The range of line origins you wish to copy. If the length of the range is 0, then the copy operation continues from the start index of the range to the last line origin.
    ///
    /// - origins: The buffer to which the origins are copied. The buffer must have at least as many elements as specified by range’s length. Each [`CGPoint`](https://developer.apple.com/documentation/corefoundation/cgpoint) in this array is the origin of the corresponding line in the array of lines returned by [`CTFrameGetLines`](https://developer.apple.com/documentation/coretext/ctframegetlines(_:)) relative to the origin of the path’s bounding box, which can be obtained from `CGPathGetPathBoundingBox`.
    ///
    ///
    /// ## Discussion
    ///
    /// This function copies a range of [`CGPoint`](https://developer.apple.com/documentation/corefoundation/cgpoint) structures into the `origins` buffer. The maximum number of line origins this function will copy into the `origins` buffer is the count of the array of lines (the length of the `range` parameter).
    ///
    /// ### Special Considerations
    ///
    /// In versions of macOS prior to 10.7 and versions of iOS prior to 4.2, this function may function unpredictably if the frame is not rectangular.
    ///
    ///
    /// Copies a range of line origins for a frame.
    ///
    ///
    /// This function will copy a range of CGPoint structures. Each
    /// CGPoint is the origin of the corresponding line in the array of
    /// lines returned by CTFrameGetLines, relative to the origin of the
    /// frame's path. The maximum number of line origins returned by
    /// this function is the count of the array of lines.
    ///
    ///
    /// Parameter `frame`: The frame that you want to obtain the line origin array from.
    ///
    ///
    /// Parameter `range`: The range of line origins you wish to copy. If the length of the
    /// range is set to 0, then the copy operation will continue from
    /// the range's start index to the last line origin.
    ///
    ///
    /// Parameter `origins`: The buffer to which the origins will be copied. The buffer must
    /// have at least as many elements as specified by range's length.
    /// When using the origins to calculate measurements for a frame's
    /// contents, remember that line origins do not always correspond to
    /// line metrics; paragraph style settings can affect line origins,
    /// for one. The overall typographic bounds of a frame may generally
    /// be calculated as the difference between the top of the frame and
    /// the descent of the last line. This will obviously exclude any
    /// spacing following the last line, but such spacing has no effect
    /// on framesetting in the first place.
    ///
    /// # Safety
    ///
    /// `origins` must be a valid pointer.
    #[doc(alias = "CTFrameGetLineOrigins")]
    #[inline]
    pub unsafe fn line_origins(&self, range: CFRange, origins: NonNull<CGPoint>) {
        extern "C-unwind" {
            fn CTFrameGetLineOrigins(frame: &CTFrame, range: CFRange, origins: NonNull<CGPoint>);
        }
        unsafe { CTFrameGetLineOrigins(self, range, origins) }
    }

    /// Draws an entire frame into a context.
    ///
    /// Parameters:
    /// - frame: The frame to draw.
    ///
    /// - context: The context in which to draw the frame.
    ///
    ///
    /// ## Discussion
    ///
    /// If both the frame and the context are valid, the frame is drawn in the context. This call can leave the context in any state and does not flush it after the draw operation.
    ///
    ///
    /// Draws an entire frame to a context.
    ///
    ///
    /// This function will draw an entire frame to the context. Note
    /// that this call may leave the context in any state and does not
    /// flush it after the draw operation.
    ///
    ///
    /// Parameter `frame`: The frame that you want to draw.
    ///
    ///
    /// Parameter `context`: The context to draw the frame to.
    ///
    ///
    /// If both the frame and the context are valid, the frame will be
    /// drawn in the context.
    #[doc(alias = "CTFrameDraw")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub fn draw(&self, context: &CGContext) {
        extern "C-unwind" {
            fn CTFrameDraw(frame: &CTFrame, context: &CGContext);
        }
        unsafe { CTFrameDraw(self, context) }
    }
}

#[deprecated = "renamed to `CTFrame::string_range`"]
#[inline]
pub extern "C-unwind" fn CTFrameGetStringRange(frame: &CTFrame) -> CFRange {
    extern "C-unwind" {
        fn CTFrameGetStringRange(frame: &CTFrame) -> CFRange;
    }
    unsafe { CTFrameGetStringRange(frame) }
}

#[deprecated = "renamed to `CTFrame::visible_string_range`"]
#[inline]
pub extern "C-unwind" fn CTFrameGetVisibleStringRange(frame: &CTFrame) -> CFRange {
    extern "C-unwind" {
        fn CTFrameGetVisibleStringRange(frame: &CTFrame) -> CFRange;
    }
    unsafe { CTFrameGetVisibleStringRange(frame) }
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CTFrame::path`"]
#[inline]
pub extern "C-unwind" fn CTFrameGetPath(frame: &CTFrame) -> CFRetained<CGPath> {
    extern "C-unwind" {
        fn CTFrameGetPath(frame: &CTFrame) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CTFrameGetPath(frame) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[deprecated = "renamed to `CTFrame::frame_attributes`"]
#[inline]
pub extern "C-unwind" fn CTFrameGetFrameAttributes(
    frame: &CTFrame,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CTFrameGetFrameAttributes(frame: &CTFrame) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CTFrameGetFrameAttributes(frame) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CTFrame::lines`"]
#[inline]
pub extern "C-unwind" fn CTFrameGetLines(frame: &CTFrame) -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CTFrameGetLines(frame: &CTFrame) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CTFrameGetLines(frame) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CTFrame::line_origins`"]
    pub fn CTFrameGetLineOrigins(frame: &CTFrame, range: CFRange, origins: NonNull<CGPoint>);
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CTFrame::draw`"]
#[inline]
pub extern "C-unwind" fn CTFrameDraw(frame: &CTFrame, context: &CGContext) {
    extern "C-unwind" {
        fn CTFrameDraw(frame: &CTFrame, context: &CGContext);
    }
    unsafe { CTFrameDraw(frame, context) }
}
