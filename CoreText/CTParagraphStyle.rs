//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// Paragraph or ruler attributes in an attributed string.
///
/// ## Overview
///
/// A paragraph style object represents a complex attribute value in an attributed string, storing a number of subattributes that affect paragraph layout for the characters of the string. Among these subattributes are alignment, tab stops, writing direction, line-breaking mode, and indentation settings.
///
///
#[doc(alias = "CTParagraphStyleRef")]
#[repr(C)]
pub struct CTParagraphStyle {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CTParagraphStyle {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CTParagraphStyle"> for CTParagraphStyle {}
);

unsafe impl ConcreteType for CTParagraphStyle {
    /// Returns the Core Foundation type identifier of the paragraph style object.
    /// Returns the CFType of the paragraph style object
    #[doc(alias = "CTParagraphStyleGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CTParagraphStyleGetTypeID() -> CFTypeID;
        }
        unsafe { CTParagraphStyleGetTypeID() }
    }
}

/// Constants that specify text alignment.
/// These constants specify text alignment.
///
///
/// Text is visually left-aligned.
///
///
/// Text is visually right-aligned.
///
///
/// Text is visually center-aligned.
///
///
/// Text is fully justified. The last line in a paragraph is
/// naturally aligned.
///
///
/// Use the natural alignment of the text's script.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CTTextAlignment(pub u8);
impl CTTextAlignment {
    /// Text is visually left-aligned.
    #[doc(alias = "kCTTextAlignmentLeft")]
    pub const Left: Self = Self(0);
    /// Text is visually right-aligned.
    #[doc(alias = "kCTTextAlignmentRight")]
    pub const Right: Self = Self(1);
    /// Text is visually center-aligned.
    #[doc(alias = "kCTTextAlignmentCenter")]
    pub const Center: Self = Self(2);
    /// Text is fully justified.
    ///
    /// ## Discussion
    ///
    /// The last line in a paragraph is naturally aligned.
    ///
    ///
    #[doc(alias = "kCTTextAlignmentJustified")]
    pub const Justified: Self = Self(3);
    /// Text uses the natural alignment of the text’s script.
    #[doc(alias = "kCTTextAlignmentNatural")]
    pub const Natural: Self = Self(4);
    /// Text is visually left-aligned.
    #[deprecated = "Deprecated"]
    pub const kCTLeftTextAlignment: Self = Self(CTTextAlignment::Left.0);
    /// Text is visually right-aligned.
    #[deprecated = "Deprecated"]
    pub const kCTRightTextAlignment: Self = Self(CTTextAlignment::Right.0);
    /// Text is visually center-aligned.
    #[deprecated = "Deprecated"]
    pub const kCTCenterTextAlignment: Self = Self(CTTextAlignment::Center.0);
    /// Text is fully justified.
    ///
    /// ## Discussion
    ///
    /// The last line in a paragraph is naturally aligned.
    ///
    ///
    #[deprecated = "Deprecated"]
    pub const kCTJustifiedTextAlignment: Self = Self(CTTextAlignment::Justified.0);
    /// Text uses the natural alignment of the text’s script.
    #[deprecated = "Deprecated"]
    pub const kCTNaturalTextAlignment: Self = Self(CTTextAlignment::Natural.0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTTextAlignment {
    const ENCODING: Encoding = u8::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTTextAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// These constants specify what happens when a line is too long for its frame.
/// These constants specify what happens when a line is too long for
/// its frame.
///
///
/// Wrapping occurs at word boundaries, unless the word itself doesn't
/// fit on a single line.
///
///
/// Wrapping occurs before the first character that doesn't fit.
///
///
/// Lines are simply not drawn past the edge of the frame.
///
///
/// Each line is displayed so that the end fits in the frame and the
/// missing text is indicated by some kind of ellipsis glyph.
///
///
/// Each line is displayed so that the beginning fits in the
/// container and the missing text is indicated by some kind of
/// ellipsis glyph.
///
///
/// Each line is displayed so that the beginning and end fit in the
/// container and the missing text is indicated by some kind of
/// ellipsis glyph in the middle.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CTLineBreakMode(pub u8);
impl CTLineBreakMode {
    ///
    /// ## Discussion
    ///
    /// Wrapping occurs at word boundaries unless the word itself doesn’t fit on a single line.
    ///
    ///
    #[doc(alias = "kCTLineBreakByWordWrapping")]
    pub const ByWordWrapping: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// Wrapping occurs before the first character that doesn’t fit.
    ///
    ///
    #[doc(alias = "kCTLineBreakByCharWrapping")]
    pub const ByCharWrapping: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// Lines are simply not drawn past the edge of the frame.
    ///
    ///
    #[doc(alias = "kCTLineBreakByClipping")]
    pub const ByClipping: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// Each line is displayed so that the end fits in the frame and the missing text is indicated by an ellipsis glyph.
    ///
    ///
    #[doc(alias = "kCTLineBreakByTruncatingHead")]
    pub const ByTruncatingHead: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// Each line is displayed so that the beginning fits in the container and the missing text is indicated by an ellipsis glyph.
    ///
    ///
    #[doc(alias = "kCTLineBreakByTruncatingTail")]
    pub const ByTruncatingTail: Self = Self(4);
    ///
    /// ## Discussion
    ///
    /// Each line is displayed so that the beginning and end fit in the container and the missing text is indicated by an ellipsis glyph in the middle.
    ///
    ///
    #[doc(alias = "kCTLineBreakByTruncatingMiddle")]
    pub const ByTruncatingMiddle: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTLineBreakMode {
    const ENCODING: Encoding = u8::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTLineBreakMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// These constants specify the writing direction.
/// These constants specify the writing direction
///
///
/// The writing direction is algorithmically determined
/// using the Unicode Bidirectional Algorithm rules P2 and P3.
///
///
/// The writing direction is left to right.
///
///
/// The writing direction is right to left.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CTWritingDirection(pub i8);
impl CTWritingDirection {
    ///
    /// ## Discussion
    ///
    /// The writing direction is algorithmically determined using the Unicode Bidirectional Algorithm rules P2 and P3.
    ///
    ///
    #[doc(alias = "kCTWritingDirectionNatural")]
    pub const Natural: Self = Self(-1);
    ///
    /// ## Discussion
    ///
    /// The writing direction is left to right.
    ///
    ///
    #[doc(alias = "kCTWritingDirectionLeftToRight")]
    pub const LeftToRight: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// The writing direction is right to left.
    ///
    ///
    #[doc(alias = "kCTWritingDirectionRightToLeft")]
    pub const RightToLeft: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTWritingDirection {
    const ENCODING: Encoding = i8::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTWritingDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants used to query and modify a paragraph style object.
///
/// ## Overview
///
/// Each specifier has a type and a default value associated with it. The type must always be observed when setting or fetching the value from the `CTParagraphStyle` object. In addition, some specifiers affect the behavior of both the framesetter and the typesetter, and others affect the behavior of only the framesetter, as noted in the constant descriptions.
///
///
/// These constants are used to query and modify the CTParagraphStyle
/// object.
///
///
/// Each specifier has a type and a default value associated with it.
/// The type must always be observed when setting or fetching the
/// value from the CTParagraphStyle object. In addition, some
/// specifiers affect the behavior of both the framesetter and
/// the typesetter, and others only affect the behavior of the
/// framesetter; this is also noted below.
///
///
/// The text alignment. Natural text alignment is realized as
/// left or right alignment, depending on the line sweep direction
/// of the first script contained in the paragraph.
///
/// Type: CTTextAlignment
/// Default: kCTTextAlignmentNatural
/// Application: CTFramesetter
///
///
/// The distance in points from the leading margin of a frame to
/// the beginning of the paragraph's first line. This value is always
/// nonnegative.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The distance in points from the leading margin of a text
/// container to the beginning of lines other than the first.
/// This value is always nonnegative.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The distance in points from the margin of a frame to the end of
/// lines. If positive, this value is the distance from the leading
/// margin (for example, the left margin in left-to-right text).
/// If 0 or negative, it's the distance from the trailing margin.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The CTTextTab objects, sorted by location, that define the tab
/// stops for the paragraph style.
///
/// Type: CFArray of CTTextTabRef
/// Default: 12 left-aligned tabs, spaced by 28.0 points
/// Application: CTFramesetter, CTTypesetter
///
///
/// The document-wide default tab interval. Tabs after the last
/// specified by kCTParagraphStyleSpecifierTabStops are placed at
/// integer multiples of this distance (if positive).
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter, CTTypesetter
///
///
/// The mode that should be used to break lines when laying out
/// the paragraph's text.
///
/// Type: CTLineBreakMode
/// Default: kCTLineBreakByWordWrapping
/// Application: CTFramesetter
///
///
/// The line height multiple. The natural line height of the
/// receiver is multiplied by this factor (if positive) before
/// being constrained by minimum and maximum line height.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The maximum height that any line in the frame will occupy,
/// regardless of the font size or size of any attached graphic.
/// Glyphs and graphics exceeding this height will overlap
/// neighboring lines. A maximum height of 0 implies
/// no line height limit. This value is always nonnegative.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The minimum height that any line in the frame will occupy,
/// regardless of the font size or size of any attached graphic.
/// This value is always nonnegative.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// Deprecated.
/// Use kCTParagraphStyleSpecifierMaximumLineSpacing, kCTParagraphStyleSpecifierMinimumLineSpacing,
/// and kCTParagraphStyleSpecifierLineSpacingAdjustment to control
/// space between lines.
///
///
/// The space added at the end of the paragraph to separate it from
/// the following paragraph. This value is always nonnegative and is
/// determined by adding the previous paragraph's
/// kCTParagraphStyleSpecifierParagraphSpacing setting and the
/// current paragraph's kCTParagraphStyleSpecifierParagraphSpacingBefore
/// setting.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The distance between the paragraph's top and the beginning of
/// its text content.
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The base writing direction of the lines.
///
/// Type: CTWritingDirection
/// Default: kCTWritingDirectionNatural
/// Application: CTFramesetter, CTTypesetter
///
///
/// The maximum space in points between lines within the paragraph
/// (commonly known as leading).
///
/// Type: CGFloat
/// Default: some large number.
/// Application: CTFramesetter
///
///
/// The minimum space in points between lines within the paragraph
/// (commonly known as leading).
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The space in points added between lines within the paragraph
/// (commonly known as leading).
///
/// Type: CGFloat
/// Default: 0.0
/// Application: CTFramesetter
///
///
/// The options controlling the alignment of the line edges with
/// the leading and trailing margins.
///
/// Type: CTLineBoundsOptions
/// Default: 0 (no options)
/// Application: CTTypesetter
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CTParagraphStyleSpecifier(pub u32);
impl CTParagraphStyleSpecifier {
    /// The text alignment.
    ///
    /// ## Discussion
    ///
    /// Natural text alignment is realized as left or right alignment, depending on the line sweep direction of the first script contained in the paragraph. Type: [`CTTextAlignment`](https://developer.apple.com/documentation/coretext/cttextalignment). Default value: [`kCTNaturalTextAlignment`](https://developer.apple.com/documentation/coretext/cttextalignment/kctnaturaltextalignment). Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierAlignment")]
    pub const Alignment: Self = Self(0);
    /// The distance, in points, from the leading margin of a frame to the beginning of the paragraph’s first line.
    ///
    /// ## Discussion
    ///
    /// This value is always nonnegative. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierFirstLineHeadIndent")]
    pub const FirstLineHeadIndent: Self = Self(1);
    /// The distance, in points, from the leading margin of a text container to the beginning of lines other than the first.
    ///
    /// ## Discussion
    ///
    /// This value is always nonnegative. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierHeadIndent")]
    pub const HeadIndent: Self = Self(2);
    /// The distance, in points, from the margin of a frame to the end of lines.
    ///
    /// ## Discussion
    ///
    /// If positive, this value is the distance from the leading margin (for example, the left margin in left-to-right text). If `0` or negative, it’s the distance from the trailing margin. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierTailIndent")]
    pub const TailIndent: Self = Self(3);
    /// The text tab objects, sorted by location, that define the tab stops for the paragraph style.
    ///
    /// ## Discussion
    ///
    /// Type: An array of [`CTTextTabRef`](https://developer.apple.com/documentation/coretext/cttexttab) objects. Default value: 12 left-aligned tabs, spaced by `28.0` points. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter) and [`CTTypesetterRef`](https://developer.apple.com/documentation/coretext/cttypesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierTabStops")]
    pub const TabStops: Self = Self(4);
    /// The document-wide default tab interval.
    ///
    /// ## Discussion
    ///
    /// Tabs after the last specified by `kCTParagraphStyleSpecifierTabStops` are placed at integer multiples of this distance (if positive). Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter) and [`CTTypesetterRef`](https://developer.apple.com/documentation/coretext/cttypesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierDefaultTabInterval")]
    pub const DefaultTabInterval: Self = Self(5);
    /// The mode that should be used to break lines when laying out the paragraph’s text.
    ///
    /// ## Discussion
    ///
    /// Type: [`CTLineBreakMode`](https://developer.apple.com/documentation/coretext/ctlinebreakmode). Default value: [`kCTLineBreakByWordWrapping`](https://developer.apple.com/documentation/coretext/ctlinebreakmode/bywordwrapping). Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierLineBreakMode")]
    pub const LineBreakMode: Self = Self(6);
    /// The line height multiple.
    ///
    /// ## Discussion
    ///
    /// The natural line height of the receiver is multiplied by this factor (if positive) before being constrained by minimum and maximum line height. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierLineHeightMultiple")]
    pub const LineHeightMultiple: Self = Self(7);
    /// The maximum height that any line in the frame will occupy, regardless of the font size or size of any attached graphic.
    ///
    /// ## Discussion
    ///
    /// Glyphs and graphics exceeding this height overlap neighboring lines. A maximum height of `0` implies no line height limit. This value is always nonnegative. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierMaximumLineHeight")]
    pub const MaximumLineHeight: Self = Self(8);
    /// The minimum height that any line in the frame will occupy, regardless of the font size or size of any attached graphic.
    ///
    /// ## Discussion
    ///
    /// This value is always nonnegative. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierMinimumLineHeight")]
    pub const MinimumLineHeight: Self = Self(9);
    /// The space in points added between lines within the paragraph (commonly known as leading).
    ///
    /// ## Discussion
    ///
    /// Instead, use [`kCTParagraphStyleSpecifierMaximumLineSpacing`](https://developer.apple.com/documentation/coretext/ctparagraphstylespecifier/maximumlinespacing), [`kCTParagraphStyleSpecifierMinimumLineSpacing`](https://developer.apple.com/documentation/coretext/ctparagraphstylespecifier/minimumlinespacing), and [`kCTParagraphStyleSpecifierLineSpacingAdjustment`](https://developer.apple.com/documentation/coretext/ctparagraphstylespecifier/linespacingadjustment) to control space between lines. This value is always nonnegative. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierLineSpacing")]
    #[deprecated = "See documentation for replacements"]
    pub const LineSpacing: Self = Self(10);
    /// The space added at the end of the paragraph to separate it from the following paragraph.
    ///
    /// ## Discussion
    ///
    /// This value is always nonnegative and is determined by adding the previous paragraph’s [`kCTParagraphStyleSpecifierParagraphSpacing`](https://developer.apple.com/documentation/coretext/ctparagraphstylespecifier/paragraphspacing) setting and the current paragraph’s [`kCTParagraphStyleSpecifierParagraphSpacingBefore`](https://developer.apple.com/documentation/coretext/ctparagraphstylespecifier/paragraphspacingbefore) setting. Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierParagraphSpacing")]
    pub const ParagraphSpacing: Self = Self(11);
    /// The distance between the paragraph’s top and the beginning of its text content.
    ///
    /// ## Discussion
    ///
    /// Type: [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierParagraphSpacingBefore")]
    pub const ParagraphSpacingBefore: Self = Self(12);
    /// The base writing direction of the lines.
    ///
    /// ## Discussion
    ///
    /// Type: [`CTWritingDirection`](https://developer.apple.com/documentation/coretext/ctwritingdirection). Default value: [`kCTWritingDirectionNatural`](https://developer.apple.com/documentation/coretext/ctwritingdirection/natural). Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter) and [`CTTypesetterRef`](https://developer.apple.com/documentation/coretext/cttypesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierBaseWritingDirection")]
    pub const BaseWritingDirection: Self = Self(13);
    /// The maximum space in points between lines within the paragraph (commonly known as leading).
    ///
    /// ## Discussion
    ///
    /// This value is always nonnegative. Type: [CGFloat](https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#//apple_ref/doc/uid/TP40008080-TRANSLATED_CHAPTER_965-TRANSLATED_DEST_121). Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierMaximumLineSpacing")]
    pub const MaximumLineSpacing: Self = Self(14);
    /// The minimum space in points between lines within the paragraph (commonly known as leading).
    ///
    /// ## Discussion
    ///
    /// This value is always nonnegative. Type: [CGFloat](https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#//apple_ref/doc/uid/TP40008080-TRANSLATED_CHAPTER_965-TRANSLATED_DEST_121). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierMinimumLineSpacing")]
    pub const MinimumLineSpacing: Self = Self(15);
    /// The space in points added between lines within the paragraph (commonly known as leading).
    ///
    /// ## Discussion
    ///
    /// Type: [CGFloat](https://developer.apple.com/library/archive/releasenotes/Foundation/RN-FoundationOlderNotes/index.html#//apple_ref/doc/uid/TP40008080-TRANSLATED_CHAPTER_965-TRANSLATED_DEST_121). Default value: `0.0`. Affects: [`CTFramesetterRef`](https://developer.apple.com/documentation/coretext/ctframesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierLineSpacingAdjustment")]
    pub const LineSpacingAdjustment: Self = Self(16);
    /// Options that control the alignment of the line edges with the leading and trailing margins.
    ///
    /// ## Discussion
    ///
    /// Type: [`CTLineBoundsOptions`](https://developer.apple.com/documentation/coretext/ctlineboundsoptions). Default value `0` (that is, no options). Affects: [`CTTypesetterRef`](https://developer.apple.com/documentation/coretext/cttypesetter).
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierLineBoundsOptions")]
    pub const LineBoundsOptions: Self = Self(17);
    /// The number of style specifiers.
    ///
    /// ## Discussion
    ///
    /// The purpose is to simplify the validation of style specifiers.
    ///
    ///
    #[doc(alias = "kCTParagraphStyleSpecifierCount")]
    pub const Count: Self = Self(18);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTParagraphStyleSpecifier {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTParagraphStyleSpecifier {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This structure is used to alter the paragraph style.
/// This structure is used to alter the paragraph style.
///
/// Field: spec
/// The specifier of the setting.
///
/// Field: valueSize
/// The size of the value pointed to by the "value" field. This
/// must match the size of the value required by the
/// CTParagraphStyleSpecifier set in the "spec" field.
///
/// Field: value
/// A reference to the value of the setting specified by the
/// "spec" field. The value must be in the proper range for the
/// spec value. The value must also be at least valueSize.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CTParagraphStyleSetting {
    pub spec: CTParagraphStyleSpecifier,
    pub valueSize: usize,
    pub value: NonNull<c_void>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CTParagraphStyleSetting {
    const ENCODING: Encoding = Encoding::Struct(
        "CTParagraphStyleSetting",
        &[
            <CTParagraphStyleSpecifier>::ENCODING,
            <usize>::ENCODING,
            <NonNull<c_void>>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CTParagraphStyleSetting {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CTParagraphStyle {
    /// Creates an immutable paragraph style.
    ///
    /// Parameters:
    /// - settings: The settings with which to preload the paragraph style. If you want to specify the default set of settings, set this parameter to `NULL`.
    ///
    /// - settingCount: The number of settings that you have specified in the `settings` parameter. This must be greater than or equal to `0`.
    ///
    ///
    /// ## Return Value
    ///
    /// A valid reference to an immutable CTParagraphStyle object, If the paragraph style creation was successful; otherwise, `NULL`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Using this function is the easiest and most efficient way to create a paragraph style. Paragraph styles should be kept immutable for totally lock-free operation. If an invalid paragraph style setting specifier is passed into the `settings` parameter, nothing bad will happen, but you will be unable to query for this value. The reason is to allow backward compatibility with style setting specifiers that may be introduced in future versions.
    ///
    ///
    /// Creates an immutable paragraph style.
    ///
    ///
    /// Using this function is the easiest and most efficient way to
    /// create a paragraph style. Paragraph styles should be kept
    /// immutable for totally lock-free operation.
    ///
    /// If an invalid paragraph style setting specifier is passed into
    /// the "settings" parameter, nothing bad will happen but just don't
    /// expect to be able to query for this value. This is to allow
    /// backwards compatibility with style setting specifiers that may
    /// be introduced in future versions.
    ///
    ///
    /// Parameter `settings`: The settings that you wish to pre-load the paragraph style
    /// with. If you wish to specify the default set of settings,
    /// then this parameter may be set to NULL.
    ///
    ///
    /// Parameter `settingCount`: The number of settings that you have specified in the
    /// "settings" parameter. This must be greater than or equal
    /// to zero.
    ///
    ///
    /// Returns: If the paragraph style creation was successful, this function
    /// will return a valid reference to an immutable CTParagraphStyle
    /// object. Otherwise, this function will return NULL.
    ///
    /// # Safety
    ///
    /// `settings` must be a valid pointer or null.
    #[doc(alias = "CTParagraphStyleCreate")]
    #[inline]
    pub unsafe fn new(
        settings: *const CTParagraphStyleSetting,
        setting_count: usize,
    ) -> CFRetained<CTParagraphStyle> {
        extern "C-unwind" {
            fn CTParagraphStyleCreate(
                settings: *const CTParagraphStyleSetting,
                setting_count: usize,
            ) -> Option<NonNull<CTParagraphStyle>>;
        }
        let ret = unsafe { CTParagraphStyleCreate(settings, setting_count) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates an immutable copy of a paragraph style.
    ///
    /// Parameters:
    /// - paragraphStyle: The style to copy. This parameter may not be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// A valid reference to an immutable CTParagraphStyle object that is a copy of the one passed into `paragraphStyle`, If the `paragraphStyle` reference is valid; otherwise `NULL`, if any error occurred, including being supplied with an invalid reference.
    ///
    ///
    /// Creates an immutable copy of a paragraph style.
    ///
    ///
    /// Parameter `paragraphStyle`: The style that you wish to copy.
    ///
    ///
    /// Returns: If the "paragraphStyle" reference is valid, then this
    /// function will return valid reference to an immutable
    /// CTParagraphStyle object that is a copy of the one passed into
    /// "paragraphStyle".
    #[doc(alias = "CTParagraphStyleCreateCopy")]
    #[inline]
    pub fn copy(&self) -> CFRetained<CTParagraphStyle> {
        extern "C-unwind" {
            fn CTParagraphStyleCreateCopy(
                paragraph_style: &CTParagraphStyle,
            ) -> Option<NonNull<CTParagraphStyle>>;
        }
        let ret = unsafe { CTParagraphStyleCreateCopy(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Obtains the current value for a single setting specifier.
    ///
    /// Parameters:
    /// - paragraphStyle: The paragraph style from which to get the value. This parameter may not be `NULL`.
    ///
    /// - spec: The setting specifier for which to get the value.
    ///
    /// - valueBufferSize: The size of the buffer pointed to by the `valueBuffer` parameter. This value must be at least as large as the size the required by the [`CTParagraphStyleSpecifier`](https://developer.apple.com/documentation/coretext/ctparagraphstylespecifier) value set in the `spec` parameter.
    ///
    /// - valueBuffer: On output, the requested setting value. The buffer’s size needs to be at least as large as the value passed into `valueBufferSize`. This parameter is required and may not be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// `True` if `valueBuffer` was successfully filled; otherwise, `False`, indicating that one or more of the parameters are not valid.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns the current value of the specifier whether or not the user actually set it. If the user did not set the specifier, this function returns the default value. If an invalid paragraph style setting specifier is passed into the `spec` parameter, nothing bad happens, and the buffer value is simply zeroed out. The reason is to allow backward compatibility with style setting specifiers that may be introduced in future versions.
    ///
    ///
    /// Obtains the current value for a single setting specifier.
    ///
    ///
    /// This function will return the current value of the specifier
    /// whether or not the user had actually set it. If the user has
    /// not set it, this function will return the default value.
    ///
    /// If an invalid paragraph style setting specifier is passed into
    /// the "spec" parameter, nothing bad will happen and the buffer
    /// value will simply be zeroed out. This is to allow backwards
    /// compatibility with style setting specifier that may be introduced
    /// in future versions.
    ///
    ///
    /// Parameter `paragraphStyle`: The paragraph style that you wish to get the value from.
    ///
    ///
    /// Parameter `spec`: The setting specifier that you want to get the value for.
    ///
    ///
    /// Parameter `valueBufferSize`: The size of the buffer pointed to by the "valueBuffer" parameter.
    /// This value must be at least as large as the size the required by
    /// the CTParagraphSpecifier value set in the "spec" parameter.
    ///
    ///
    /// Parameter `valueBuffer`: The buffer where the requested setting value will be written
    /// upon successful completion. The buffer's size needs to be at least
    /// as large as the value passed into "valueBufferSize".
    ///
    ///
    /// Returns: This function will return "true" if the valueBuffer had been
    /// successfully filled. Otherwise, this function will return false,
    /// indicating that one or more of the parameters is not valid.
    ///
    /// # Safety
    ///
    /// `value_buffer` must be a valid pointer.
    #[doc(alias = "CTParagraphStyleGetValueForSpecifier")]
    #[inline]
    pub unsafe fn value_for_specifier(
        &self,
        spec: CTParagraphStyleSpecifier,
        value_buffer_size: usize,
        value_buffer: NonNull<c_void>,
    ) -> bool {
        extern "C-unwind" {
            fn CTParagraphStyleGetValueForSpecifier(
                paragraph_style: &CTParagraphStyle,
                spec: CTParagraphStyleSpecifier,
                value_buffer_size: usize,
                value_buffer: NonNull<c_void>,
            ) -> bool;
        }
        unsafe { CTParagraphStyleGetValueForSpecifier(self, spec, value_buffer_size, value_buffer) }
    }
}

#[deprecated = "renamed to `CTParagraphStyle::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CTParagraphStyleCreate(
    settings: *const CTParagraphStyleSetting,
    setting_count: usize,
) -> CFRetained<CTParagraphStyle> {
    extern "C-unwind" {
        fn CTParagraphStyleCreate(
            settings: *const CTParagraphStyleSetting,
            setting_count: usize,
        ) -> Option<NonNull<CTParagraphStyle>>;
    }
    let ret = unsafe { CTParagraphStyleCreate(settings, setting_count) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CTParagraphStyle::copy`"]
#[inline]
pub extern "C-unwind" fn CTParagraphStyleCreateCopy(
    paragraph_style: &CTParagraphStyle,
) -> CFRetained<CTParagraphStyle> {
    extern "C-unwind" {
        fn CTParagraphStyleCreateCopy(
            paragraph_style: &CTParagraphStyle,
        ) -> Option<NonNull<CTParagraphStyle>>;
    }
    let ret = unsafe { CTParagraphStyleCreateCopy(paragraph_style) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CTParagraphStyle::value_for_specifier`"]
    pub fn CTParagraphStyleGetValueForSpecifier(
        paragraph_style: &CTParagraphStyle,
        spec: CTParagraphStyleSpecifier,
        value_buffer_size: usize,
        value_buffer: NonNull<c_void>,
    ) -> bool;
}
