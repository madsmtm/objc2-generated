//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A document that contains PDF (Portable Document Format) drawing information.
///
/// ## Overview
///
/// PDF provides an efficient format for cross-platform exchange of documents with rich content. PDF files can contain multiple pages of images and text. A PDF document object contains all the information relating to a PDF document, including its catalog and contents.
///
/// Note that PDF documents may be encrypted, and that some operations may be restricted until a valid password is supplied—see the functions listed in [Working with an Encrypted PDF Document](https://developer.apple.com/documentation/coregraphics/cgpdfdocument#working-with-an-encrypted-pdf-document).  Core Graphics also supports decrypting encrypted documents.
///
/// Core Graphics can both display and generate files that are compliant with the PDF standard.
///
///
#[doc(alias = "CGPDFDocumentRef")]
#[repr(C)]
pub struct CGPDFDocument {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGPDFDocument {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGPDFDocument"> for CGPDFDocument {}
);

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGPDFAccessPermissions(pub u32);
bitflags::bitflags! {
    impl CGPDFAccessPermissions: u32 {
        #[doc(alias = "kCGPDFAllowsLowQualityPrinting")]
        const AllowsLowQualityPrinting = 1<<0;
        #[doc(alias = "kCGPDFAllowsHighQualityPrinting")]
        const AllowsHighQualityPrinting = 1<<1;
        #[doc(alias = "kCGPDFAllowsDocumentChanges")]
        const AllowsDocumentChanges = 1<<2;
        #[doc(alias = "kCGPDFAllowsDocumentAssembly")]
        const AllowsDocumentAssembly = 1<<3;
        #[doc(alias = "kCGPDFAllowsContentCopying")]
        const AllowsContentCopying = 1<<4;
        #[doc(alias = "kCGPDFAllowsContentAccessibility")]
        const AllowsContentAccessibility = 1<<5;
        #[doc(alias = "kCGPDFAllowsCommenting")]
        const AllowsCommenting = 1<<6;
        #[doc(alias = "kCGPDFAllowsFormFieldEntry")]
        const AllowsFormFieldEntry = 1<<7;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPDFAccessPermissions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPDFAccessPermissions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    pub static kCGPDFOutlineTitle: &'static CFString;
}

extern "C" {
    pub static kCGPDFOutlineChildren: &'static CFString;
}

extern "C" {
    pub static kCGPDFOutlineDestination: &'static CFString;
}

extern "C" {
    pub static kCGPDFOutlineDestinationRect: &'static CFString;
}

impl CGPDFDocument {
    /// Creates a Core Graphics PDF document using a data provider.
    ///
    /// Parameters:
    /// - provider: A data provider that supplies the PDF document data.
    ///
    ///
    /// ## Return Value
    ///
    /// A new Core Graphics PDF document, or `NULL` if a document can not be created. In Objective-C, you’re responsible for releasing the object using [`CGPDFDocumentRelease`](https://developer.apple.com/documentation/coregraphics/cgpdfdocumentrelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Distributing individual pages of a PDF document to separate threads is not supported. If you want to use threads, consider creating a separate document for each thread and operating on a block of pages per thread.
    ///
    ///
    #[doc(alias = "CGPDFDocumentCreateWithProvider")]
    #[cfg(feature = "CGDataProvider")]
    #[inline]
    pub fn with_provider(provider: Option<&CGDataProvider>) -> Option<CFRetained<CGPDFDocument>> {
        extern "C-unwind" {
            fn CGPDFDocumentCreateWithProvider(
                provider: Option<&CGDataProvider>,
            ) -> Option<NonNull<CGPDFDocument>>;
        }
        let ret = unsafe { CGPDFDocumentCreateWithProvider(provider) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a Core Graphics PDF document using data specified by a URL.
    ///
    /// Parameters:
    /// - url: The URL address at which the PDF document data is located.
    ///
    ///
    /// ## Return Value
    ///
    /// A new Core Graphics PDF document, or `NULL` if a document could not be created. In Objective-C, you’re responsible for releasing the object using [`CGPDFDocumentRelease`](https://developer.apple.com/documentation/coregraphics/cgpdfdocumentrelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Distributing individual pages of a PDF document to separate threads is not supported. If you want to use threads, consider creating a separate document for each thread and operating on a block of pages per thread.
    ///
    ///
    #[doc(alias = "CGPDFDocumentCreateWithURL")]
    #[inline]
    pub fn with_url(url: Option<&CFURL>) -> Option<CFRetained<CGPDFDocument>> {
        extern "C-unwind" {
            fn CGPDFDocumentCreateWithURL(url: Option<&CFURL>) -> Option<NonNull<CGPDFDocument>>;
        }
        let ret = unsafe { CGPDFDocumentCreateWithURL(url) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the major and minor version numbers of a Core Graphics PDF document.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    /// - majorVersion: On return, contains the major version number of the document.
    ///
    /// - minorVersion: On return, contains the minor version number of the document.
    ///
    ///
    /// ## Discussion
    ///
    /// On return, the values of the `majorVersion` and `minorVersion` parameters are set to the major and minor version numbers of the document respectively.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `major_version` must be a valid pointer.
    /// - `minor_version` must be a valid pointer.
    #[doc(alias = "CGPDFDocumentGetVersion")]
    #[inline]
    pub unsafe fn version(
        document: Option<&CGPDFDocument>,
        major_version: NonNull<c_int>,
        minor_version: NonNull<c_int>,
    ) {
        extern "C-unwind" {
            fn CGPDFDocumentGetVersion(
                document: Option<&CGPDFDocument>,
                major_version: NonNull<c_int>,
                minor_version: NonNull<c_int>,
            );
        }
        unsafe { CGPDFDocumentGetVersion(document, major_version, minor_version) }
    }

    /// Returns whether the specified PDF file is encrypted.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean that, if [`true`](https://developer.apple.com/documentation/swift/true), indicates that the document is encrypted. If the value is [`false`](https://developer.apple.com/documentation/swift/false), the document is not encrypted.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the document is encrypted, a password must be supplied before certain operations are enabled. For more information, see [`CGPDFDocumentUnlockWithPassword`](https://developer.apple.com/documentation/coregraphics/cgpdfdocument/unlockwithpassword(_:)).
    ///
    ///
    #[doc(alias = "CGPDFDocumentIsEncrypted")]
    #[inline]
    pub fn is_encrypted(document: Option<&CGPDFDocument>) -> bool {
        extern "C-unwind" {
            fn CGPDFDocumentIsEncrypted(document: Option<&CGPDFDocument>) -> bool;
        }
        unsafe { CGPDFDocumentIsEncrypted(document) }
    }

    /// Unlocks an encrypted PDF document when a valid password is supplied.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    /// - password: A pointer to a string that contains the password.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean that, if [`true`](https://developer.apple.com/documentation/swift/true), indicates that the document has been successfully unlocked. If the value is [`false`](https://developer.apple.com/documentation/swift/false), the document has not been unlocked.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Given an encrypted PDF document and a password, this function does the following:
    ///
    /// - Sets the lock state of the document, based on the validity of the password.
    ///
    /// - Returns [`true`](https://developer.apple.com/documentation/swift/true) if the document is unlocked.
    ///
    /// - Returns [`false`](https://developer.apple.com/documentation/swift/false) if the document cannot be unlocked with the specified password.
    ///
    /// Unlocking a PDF document makes it possible to decrypt the document and perform other privileged operations. Different passwords enable different operations.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `password` must be a valid pointer.
    #[doc(alias = "CGPDFDocumentUnlockWithPassword")]
    #[inline]
    pub unsafe fn unlock_with_password(
        document: Option<&CGPDFDocument>,
        password: NonNull<c_char>,
    ) -> bool {
        extern "C-unwind" {
            fn CGPDFDocumentUnlockWithPassword(
                document: Option<&CGPDFDocument>,
                password: NonNull<c_char>,
            ) -> bool;
        }
        unsafe { CGPDFDocumentUnlockWithPassword(document, password) }
    }

    /// Returns whether the specified PDF document is currently unlocked.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean that, if [`true`](https://developer.apple.com/documentation/swift/true), indicates that the document is not locked. If the value is [`false`](https://developer.apple.com/documentation/swift/false), the document is locked.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// There are two possible reasons why a PDF document is unlocked:
    ///
    /// - The document is not encrypted.
    ///
    /// - The document is encrypted, and a valid password was previously specified using [`CGPDFDocumentUnlockWithPassword`](https://developer.apple.com/documentation/coregraphics/cgpdfdocument/unlockwithpassword(_:)).
    ///
    ///
    #[doc(alias = "CGPDFDocumentIsUnlocked")]
    #[inline]
    pub fn is_unlocked(document: Option<&CGPDFDocument>) -> bool {
        extern "C-unwind" {
            fn CGPDFDocumentIsUnlocked(document: Option<&CGPDFDocument>) -> bool;
        }
        unsafe { CGPDFDocumentIsUnlocked(document) }
    }

    /// Returns whether a PDF document allows printing.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean that, if [`true`](https://developer.apple.com/documentation/swift/true), indicates that the document allows printing. If the value is [`false`](https://developer.apple.com/documentation/swift/false), the document does not allow printing.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the document is encrypted and the current password doesn’t grant permission to perform printing, this returns [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    #[doc(alias = "CGPDFDocumentAllowsPrinting")]
    #[inline]
    pub fn allows_printing(document: Option<&CGPDFDocument>) -> bool {
        extern "C-unwind" {
            fn CGPDFDocumentAllowsPrinting(document: Option<&CGPDFDocument>) -> bool;
        }
        unsafe { CGPDFDocumentAllowsPrinting(document) }
    }

    /// Returns whether the specified PDF document allows copying.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean that, if [`true`](https://developer.apple.com/documentation/swift/true), indicates that the document allows copying. If the value is [`false`](https://developer.apple.com/documentation/swift/false), the document does not allow copying.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the document is encrypted and the current password doesn’t grant permission to perform copying, this returns [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    #[doc(alias = "CGPDFDocumentAllowsCopying")]
    #[inline]
    pub fn allows_copying(document: Option<&CGPDFDocument>) -> bool {
        extern "C-unwind" {
            fn CGPDFDocumentAllowsCopying(document: Option<&CGPDFDocument>) -> bool;
        }
        unsafe { CGPDFDocumentAllowsCopying(document) }
    }

    /// Returns the number of pages in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The total number of pages in the PDF document.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetNumberOfPages")]
    #[inline]
    pub fn number_of_pages(document: Option<&CGPDFDocument>) -> usize {
        extern "C-unwind" {
            fn CGPDFDocumentGetNumberOfPages(document: Option<&CGPDFDocument>) -> usize;
        }
        unsafe { CGPDFDocumentGetNumberOfPages(document) }
    }

    /// Returns a page from a Core Graphics PDF document.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    /// - pageNumber: The number of the page requested.
    ///
    ///
    /// ## Return Value
    ///
    /// Return the PDF page corresponding to the specified page number, or `NULL` if no such page exists in the document. Pages are numbered starting at 1.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetPage")]
    #[cfg(feature = "CGPDFPage")]
    #[inline]
    pub fn page(
        document: Option<&CGPDFDocument>,
        page_number: usize,
    ) -> Option<CFRetained<CGPDFPage>> {
        extern "C-unwind" {
            fn CGPDFDocumentGetPage(
                document: Option<&CGPDFDocument>,
                page_number: usize,
            ) -> Option<NonNull<CGPDFPage>>;
        }
        let ret = unsafe { CGPDFDocumentGetPage(document, page_number) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the document catalog of a Core Graphics PDF document.
    ///
    /// Parameters:
    /// - document: A PDF document.
    ///
    ///
    /// ## Return Value
    ///
    /// The document catalog of the specified document.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The entries in a PDF document catalog recursively describe the contents of the PDF document. You can access the contents of a PDF document catalog by calling the function [`CGPDFDocumentGetCatalog`](https://developer.apple.com/documentation/coregraphics/cgpdfdocument/catalog). For information on accessing PDF metadata, see [Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066).
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetCatalog")]
    #[cfg(feature = "CGPDFDictionary")]
    #[inline]
    pub fn catalog(document: Option<&CGPDFDocument>) -> CGPDFDictionaryRef {
        extern "C-unwind" {
            fn CGPDFDocumentGetCatalog(document: Option<&CGPDFDocument>) -> CGPDFDictionaryRef;
        }
        unsafe { CGPDFDocumentGetCatalog(document) }
    }

    /// Gets the information dictionary for a PDF document.
    ///
    /// Parameters:
    /// - document: The document whose dictionary you want to obtain.
    ///
    ///
    /// ## Return Value
    ///
    /// The information dictionary for the document.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetInfo")]
    #[cfg(feature = "CGPDFDictionary")]
    #[inline]
    pub fn info(document: Option<&CGPDFDocument>) -> CGPDFDictionaryRef {
        extern "C-unwind" {
            fn CGPDFDocumentGetInfo(document: Option<&CGPDFDocument>) -> CGPDFDictionaryRef;
        }
        unsafe { CGPDFDocumentGetInfo(document) }
    }

    /// Gets the file identifier for a PDF document.
    ///
    /// Parameters:
    /// - document: The document whose file identifier you want to obtain.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the file identifier for the document.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A PDF file identifier is defined in the PDF specification as an array of two strings, the first of which is a permanent identifier that doesn’t change even when the file is updated. The second string changes each time the file is updated. For more information, see _PDF Reference: Version 1.3 (Second Edition)_, Adobe Systems Incorporated.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetID")]
    #[cfg(feature = "CGPDFArray")]
    #[inline]
    pub fn id(document: Option<&CGPDFDocument>) -> CGPDFArrayRef {
        extern "C-unwind" {
            fn CGPDFDocumentGetID(document: Option<&CGPDFDocument>) -> CGPDFArrayRef;
        }
        unsafe { CGPDFDocumentGetID(document) }
    }
}

unsafe impl ConcreteType for CGPDFDocument {
    /// Returns the type identifier for Core Graphics PDF documents.
    ///
    /// ## Return Value
    ///
    /// The identifier for the type [`CGPDFDocumentRef`](https://developer.apple.com/documentation/coregraphics/cgpdfdocument).
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGPDFDocumentGetTypeID() -> CFTypeID;
        }
        unsafe { CGPDFDocumentGetTypeID() }
    }
}

impl CGPDFDocument {
    #[doc(alias = "CGPDFDocumentGetOutline")]
    #[inline]
    pub fn outline(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGPDFDocumentGetOutline(document: &CGPDFDocument) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CGPDFDocumentGetOutline(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CGPDFDocumentGetAccessPermissions")]
    #[inline]
    pub fn access_permissions(&self) -> CGPDFAccessPermissions {
        extern "C-unwind" {
            fn CGPDFDocumentGetAccessPermissions(
                document: &CGPDFDocument,
            ) -> CGPDFAccessPermissions;
        }
        unsafe { CGPDFDocumentGetAccessPermissions(self) }
    }

    /// Returns the media box of a page in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    /// - page: An integer that specifies the number of the page to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A rectangle that represents the media box for the specified page, expressed in default PDF user space units (points).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The replacement function for this one is [`getBoxRect(_:)`](https://developer.apple.com/documentation/coregraphics/cgpdfpage/getboxrect(_:)), which gets the rectangle associated with a type of box (art, media, crop, bleed trim) that represents a content region or page dimensions of a PDF page. For more information see [`CGPDFPage`](https://developer.apple.com/documentation/coregraphics/cgpdfpage).
    ///
    /// The media box defines the location and size of the physical medium on which the page is intended to be displayed or printed. For example, if the page size is 8.5 by 11 inches, this function returns the coordinate pairs `(0,0)` and (`612,792)`.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetMediaBox")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn media_box(document: Option<&CGPDFDocument>, page: c_int) -> CGRect {
        extern "C-unwind" {
            fn CGPDFDocumentGetMediaBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
        }
        unsafe { CGPDFDocumentGetMediaBox(document, page) }
    }

    /// Returns the crop box of a page in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    /// - page: An integer that specifies the number of the page to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A rectangle that represents the crop box for the specified page, expressed in default PDF user space units (points).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The replacement function for this one is [`getBoxRect(_:)`](https://developer.apple.com/documentation/coregraphics/cgpdfpage/getboxrect(_:)), which gets the rectangle associated with a type of box (art, media, crop, bleed trim) that represents a content region or page dimensions of a PDF page. For more information see [`CGPDFPage`](https://developer.apple.com/documentation/coregraphics/cgpdfpage).
    ///
    /// The crop box defines the region to which the contents of the page are to be clipped (or cropped) when displayed or printed. Unlike the other boxes, the crop box has no defined meaning in terms of physical page geometry or intended use—it merely suggests where the page should be clipped.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetCropBox")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn crop_box(document: Option<&CGPDFDocument>, page: c_int) -> CGRect {
        extern "C-unwind" {
            fn CGPDFDocumentGetCropBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
        }
        unsafe { CGPDFDocumentGetCropBox(document, page) }
    }

    /// Returns the bleed box of a page in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    /// - page: An integer that specifies the number of the page to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A rectangle that represents the bleed box for the specified page, expressed in default PDF user space units (points).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The replacement function for this one is [`getBoxRect(_:)`](https://developer.apple.com/documentation/coregraphics/cgpdfpage/getboxrect(_:)), which gets the rectangle associated with a type of box (art, media, crop, bleed trim) that represents a content region or page dimensions of a PDF page. For more information see [`CGPDFPage`](https://developer.apple.com/documentation/coregraphics/cgpdfpage).
    ///
    /// The bleed box defines the bounds to which the contents of the page should be clipped when output in a production environment. The default value is the page’s crop box.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetBleedBox")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn bleed_box(document: Option<&CGPDFDocument>, page: c_int) -> CGRect {
        extern "C-unwind" {
            fn CGPDFDocumentGetBleedBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
        }
        unsafe { CGPDFDocumentGetBleedBox(document, page) }
    }

    /// Returns the trim box of a page in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    /// - page: A value specifying the number of the page to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns a rectangle that represents the trim box for the specified page, expressed in default PDF user space units (points).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The replacement function for this one is [`getBoxRect(_:)`](https://developer.apple.com/documentation/coregraphics/cgpdfpage/getboxrect(_:)), which gets the rectangle associated with a type of box (art, media, crop, bleed trim) that represents a content region or page dimensions of a PDF page. For more information see [`CGPDFPage`](https://developer.apple.com/documentation/coregraphics/cgpdfpage).
    ///
    /// The trim box defines the intended dimensions of the finished page after trimming. It may be smaller than the media box, to allow for production-related content such as printing instructions, cut marks, or color bars. The default value is the page’s crop box.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetTrimBox")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn trim_box(document: Option<&CGPDFDocument>, page: c_int) -> CGRect {
        extern "C-unwind" {
            fn CGPDFDocumentGetTrimBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
        }
        unsafe { CGPDFDocumentGetTrimBox(document, page) }
    }

    /// Returns the art box of a page in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    /// - page: An integer that specifies the number of the page to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A rectangle that represents the art box for the specified page, expressed in default PDF user space units (points).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The replacement function for this one is [`getBoxRect(_:)`](https://developer.apple.com/documentation/coregraphics/cgpdfpage/getboxrect(_:)), which gets the rectangle associated with a type of box (art, media, crop, bleed trim) that represents a content region or page dimensions of a PDF page. For more information see [`CGPDFPage`](https://developer.apple.com/documentation/coregraphics/cgpdfpage).
    ///
    /// The art box defines the extent of the page’s meaningful content (including potential white space) as intended by the document creator. The default value is the page’s crop box.
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetArtBox")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn art_box(document: Option<&CGPDFDocument>, page: c_int) -> CGRect {
        extern "C-unwind" {
            fn CGPDFDocumentGetArtBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
        }
        unsafe { CGPDFDocumentGetArtBox(document, page) }
    }

    /// Returns the rotation angle of a page in a PDF document.
    ///
    /// Parameters:
    /// - document: The PDF document to examine.
    ///
    /// - page: An integer that specifies the number of the page to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The rotation angle of the page, expressed in degrees. If the specified page does not exist, returns `0`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The replacement function for this one is [`rotationAngle`](https://developer.apple.com/documentation/coregraphics/cgpdfpage/rotationangle). For more information see [`CGPDFPage`](https://developer.apple.com/documentation/coregraphics/cgpdfpage).
    ///
    ///
    #[doc(alias = "CGPDFDocumentGetRotationAngle")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn rotation_angle(document: Option<&CGPDFDocument>, page: c_int) -> c_int {
        extern "C-unwind" {
            fn CGPDFDocumentGetRotationAngle(
                document: Option<&CGPDFDocument>,
                page: c_int,
            ) -> c_int;
        }
        unsafe { CGPDFDocumentGetRotationAngle(document, page) }
    }
}

#[cfg(feature = "CGDataProvider")]
#[deprecated = "renamed to `CGPDFDocument::with_provider`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentCreateWithProvider(
    provider: Option<&CGDataProvider>,
) -> Option<CFRetained<CGPDFDocument>> {
    extern "C-unwind" {
        fn CGPDFDocumentCreateWithProvider(
            provider: Option<&CGDataProvider>,
        ) -> Option<NonNull<CGPDFDocument>>;
    }
    let ret = unsafe { CGPDFDocumentCreateWithProvider(provider) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPDFDocument::with_url`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentCreateWithURL(
    url: Option<&CFURL>,
) -> Option<CFRetained<CGPDFDocument>> {
    extern "C-unwind" {
        fn CGPDFDocumentCreateWithURL(url: Option<&CFURL>) -> Option<NonNull<CGPDFDocument>>;
    }
    let ret = unsafe { CGPDFDocumentCreateWithURL(url) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGPDFDocument::version`"]
    pub fn CGPDFDocumentGetVersion(
        document: Option<&CGPDFDocument>,
        major_version: NonNull<c_int>,
        minor_version: NonNull<c_int>,
    );
}

#[deprecated = "renamed to `CGPDFDocument::is_encrypted`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentIsEncrypted(document: Option<&CGPDFDocument>) -> bool {
    extern "C-unwind" {
        fn CGPDFDocumentIsEncrypted(document: Option<&CGPDFDocument>) -> bool;
    }
    unsafe { CGPDFDocumentIsEncrypted(document) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGPDFDocument::unlock_with_password`"]
    pub fn CGPDFDocumentUnlockWithPassword(
        document: Option<&CGPDFDocument>,
        password: NonNull<c_char>,
    ) -> bool;
}

#[deprecated = "renamed to `CGPDFDocument::is_unlocked`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentIsUnlocked(document: Option<&CGPDFDocument>) -> bool {
    extern "C-unwind" {
        fn CGPDFDocumentIsUnlocked(document: Option<&CGPDFDocument>) -> bool;
    }
    unsafe { CGPDFDocumentIsUnlocked(document) }
}

#[deprecated = "renamed to `CGPDFDocument::allows_printing`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentAllowsPrinting(document: Option<&CGPDFDocument>) -> bool {
    extern "C-unwind" {
        fn CGPDFDocumentAllowsPrinting(document: Option<&CGPDFDocument>) -> bool;
    }
    unsafe { CGPDFDocumentAllowsPrinting(document) }
}

#[deprecated = "renamed to `CGPDFDocument::allows_copying`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentAllowsCopying(document: Option<&CGPDFDocument>) -> bool {
    extern "C-unwind" {
        fn CGPDFDocumentAllowsCopying(document: Option<&CGPDFDocument>) -> bool;
    }
    unsafe { CGPDFDocumentAllowsCopying(document) }
}

#[deprecated = "renamed to `CGPDFDocument::number_of_pages`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetNumberOfPages(document: Option<&CGPDFDocument>) -> usize {
    extern "C-unwind" {
        fn CGPDFDocumentGetNumberOfPages(document: Option<&CGPDFDocument>) -> usize;
    }
    unsafe { CGPDFDocumentGetNumberOfPages(document) }
}

#[cfg(feature = "CGPDFPage")]
#[deprecated = "renamed to `CGPDFDocument::page`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetPage(
    document: Option<&CGPDFDocument>,
    page_number: usize,
) -> Option<CFRetained<CGPDFPage>> {
    extern "C-unwind" {
        fn CGPDFDocumentGetPage(
            document: Option<&CGPDFDocument>,
            page_number: usize,
        ) -> Option<NonNull<CGPDFPage>>;
    }
    let ret = unsafe { CGPDFDocumentGetPage(document, page_number) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "CGPDFDictionary")]
#[deprecated = "renamed to `CGPDFDocument::catalog`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetCatalog(
    document: Option<&CGPDFDocument>,
) -> CGPDFDictionaryRef {
    extern "C-unwind" {
        fn CGPDFDocumentGetCatalog(document: Option<&CGPDFDocument>) -> CGPDFDictionaryRef;
    }
    unsafe { CGPDFDocumentGetCatalog(document) }
}

#[cfg(feature = "CGPDFDictionary")]
#[deprecated = "renamed to `CGPDFDocument::info`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetInfo(
    document: Option<&CGPDFDocument>,
) -> CGPDFDictionaryRef {
    extern "C-unwind" {
        fn CGPDFDocumentGetInfo(document: Option<&CGPDFDocument>) -> CGPDFDictionaryRef;
    }
    unsafe { CGPDFDocumentGetInfo(document) }
}

#[cfg(feature = "CGPDFArray")]
#[deprecated = "renamed to `CGPDFDocument::id`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetID(document: Option<&CGPDFDocument>) -> CGPDFArrayRef {
    extern "C-unwind" {
        fn CGPDFDocumentGetID(document: Option<&CGPDFDocument>) -> CGPDFArrayRef;
    }
    unsafe { CGPDFDocumentGetID(document) }
}

#[deprecated = "renamed to `CGPDFDocument::outline`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetOutline(
    document: &CGPDFDocument,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGPDFDocumentGetOutline(document: &CGPDFDocument) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGPDFDocumentGetOutline(document) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CGPDFDocument::access_permissions`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetAccessPermissions(
    document: &CGPDFDocument,
) -> CGPDFAccessPermissions {
    extern "C-unwind" {
        fn CGPDFDocumentGetAccessPermissions(document: &CGPDFDocument) -> CGPDFAccessPermissions;
    }
    unsafe { CGPDFDocumentGetAccessPermissions(document) }
}

#[deprecated = "renamed to `CGPDFDocument::media_box`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetMediaBox(
    document: Option<&CGPDFDocument>,
    page: c_int,
) -> CGRect {
    extern "C-unwind" {
        fn CGPDFDocumentGetMediaBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
    }
    unsafe { CGPDFDocumentGetMediaBox(document, page) }
}

#[deprecated = "renamed to `CGPDFDocument::crop_box`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetCropBox(
    document: Option<&CGPDFDocument>,
    page: c_int,
) -> CGRect {
    extern "C-unwind" {
        fn CGPDFDocumentGetCropBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
    }
    unsafe { CGPDFDocumentGetCropBox(document, page) }
}

#[deprecated = "renamed to `CGPDFDocument::bleed_box`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetBleedBox(
    document: Option<&CGPDFDocument>,
    page: c_int,
) -> CGRect {
    extern "C-unwind" {
        fn CGPDFDocumentGetBleedBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
    }
    unsafe { CGPDFDocumentGetBleedBox(document, page) }
}

#[deprecated = "renamed to `CGPDFDocument::trim_box`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetTrimBox(
    document: Option<&CGPDFDocument>,
    page: c_int,
) -> CGRect {
    extern "C-unwind" {
        fn CGPDFDocumentGetTrimBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
    }
    unsafe { CGPDFDocumentGetTrimBox(document, page) }
}

#[deprecated = "renamed to `CGPDFDocument::art_box`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetArtBox(
    document: Option<&CGPDFDocument>,
    page: c_int,
) -> CGRect {
    extern "C-unwind" {
        fn CGPDFDocumentGetArtBox(document: Option<&CGPDFDocument>, page: c_int) -> CGRect;
    }
    unsafe { CGPDFDocumentGetArtBox(document, page) }
}

#[deprecated = "renamed to `CGPDFDocument::rotation_angle`"]
#[inline]
pub extern "C-unwind" fn CGPDFDocumentGetRotationAngle(
    document: Option<&CGPDFDocument>,
    page: c_int,
) -> c_int {
    extern "C-unwind" {
        fn CGPDFDocumentGetRotationAngle(document: Option<&CGPDFDocument>, page: c_int) -> c_int;
    }
    unsafe { CGPDFDocumentGetRotationAngle(document, page) }
}
