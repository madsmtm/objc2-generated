//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A set of components that define a color, with a color space specifying how to interpret them.
///
/// ## Overview
///
/// `CGColor` is the fundamental data type used internally by Core Graphics to represent colors. `CGColor` objects, and the functions that operate on them, provide a fast and convenient way of managing and setting colors directly, especially colors that are reused (such as black for text).
///
/// A color object contains a set of components (such as red, green, and blue) that uniquely define a color, and a color space that specifies how those components should be interpreted.
///
/// Color objects provide a fast and convenient way to manage and set colors, especially colors that are used repeatedly. Drawing operations use color objects for setting fill and stroke colors, managing alpha, and setting color with a pattern.
///
/// [`CGColorRef`](https://developer.apple.com/documentation/coregraphics/cgcolor) is derived from [`CFTypeRef`](https://developer.apple.com/documentation/corefoundation/cftyperef) and inherits the properties that all Core Foundation types have in common.
///
///
#[doc(alias = "CGColorRef")]
#[repr(C)]
pub struct CGColor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGColor {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGColor"> for CGColor {}
);

impl CGColor {
    /// Creates a color using a list of intensity values (including alpha) and an associated color space.
    ///
    /// Parameters:
    /// - space: A color space for the new color. Core Graphics retains this object; upon return, you may safely release it.
    ///
    /// - components: An array of intensity values describing the color. The array should contain _n_+1 values that correspond to the _n_ color components in the specified color space, followed by the alpha component. Each component value should be in the range appropriate for the color space. Values outside this range will be clamped to the nearest correct value.
    ///
    ///
    /// ## Return Value
    ///
    /// A new color. In Objective-C, you’re responsible for releasing this object using [`CGColorRelease`](https://developer.apple.com/documentation/coregraphics/cgcolorrelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `components` must be a valid pointer or null.
    #[doc(alias = "CGColorCreate")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn new(
        space: Option<&CGColorSpace>,
        components: *const CGFloat,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreate(
                space: Option<&CGColorSpace>,
                components: *const CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreate(space, components) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a color in the Generic gray color space.
    ///
    /// Parameters:
    /// - gray: A grayscale value (`0.0` - `1.0`).
    ///
    /// - alpha: An alpha value (`0.0` - `1.0`).
    ///
    ///
    /// ## Return Value
    ///
    /// A color object.
    ///
    ///
    #[doc(alias = "CGColorCreateGenericGray")]
    #[inline]
    pub fn new_generic_gray(gray: CGFloat, alpha: CGFloat) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericGray(gray: CGFloat, alpha: CGFloat) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericGray(gray, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a color in the Generic RGB color space.
    ///
    /// Parameters:
    /// - red: A red component value (`0.0` - `1.0`).
    ///
    /// - green: A green component value (`0.0` - `1.0`).
    ///
    /// - blue: A blue component value (`0.0` - `1.0`).
    ///
    /// - alpha: An alpha value (`0.0` - `1.0`).
    ///
    ///
    /// ## Return Value
    ///
    /// A color object.
    ///
    ///
    #[doc(alias = "CGColorCreateGenericRGB")]
    #[inline]
    pub fn new_generic_rgb(
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericRGB(
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericRGB(red, green, blue, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a color in the Generic CMYK color space.
    ///
    /// Parameters:
    /// - cyan: A cyan value (`0.0` - `1.0`).
    ///
    /// - magenta: A magenta value (`0.0` - `1.0`).
    ///
    /// - yellow: A yellow value (`0.0` - `1.0`).
    ///
    /// - black: A black value (`0.0` - `1.0`).
    ///
    /// - alpha: An alpha value `(0.0 - 1.0)`.
    ///
    ///
    /// ## Return Value
    ///
    /// A color object.
    ///
    ///
    #[doc(alias = "CGColorCreateGenericCMYK")]
    #[inline]
    pub fn new_generic_cmyk(
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    ) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericCMYK(
                cyan: CGFloat,
                magenta: CGFloat,
                yellow: CGFloat,
                black: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericCMYK(cyan, magenta, yellow, black, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a color in the Generic gray color space with a gamma ramp of 2.2.
    ///
    /// Parameters:
    /// - gray: A grayscale value (0.0 - 1.0).
    ///
    /// - alpha: An alpha value (0.0 - 1.0).
    ///
    #[doc(alias = "CGColorCreateGenericGrayGamma2_2")]
    #[inline]
    pub fn new_generic_gray_gamma2_2(gray: CGFloat, alpha: CGFloat) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericGrayGamma2_2(
                gray: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericGrayGamma2_2(gray, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a color in the sRGB color space.
    ///
    /// Parameters:
    /// - red: A red component value `(0.0 - 1.0)`.
    ///
    /// - green: A green component value `(0.0 - 1.0)`.
    ///
    /// - blue: A blue component value `(0.0 - 1.0)`.
    ///
    /// - alpha: An alpha value `(0.0 - 1.0)`.
    ///
    ///
    /// ## Return Value
    ///
    /// A color object.
    ///
    ///
    #[doc(alias = "CGColorCreateSRGB")]
    #[inline]
    pub fn new_srgb(
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateSRGB(
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateSRGB(red, green, blue, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorCreateWithContentHeadroom")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn with_content_headroom(
        headroom: c_float,
        space: Option<&CGColorSpace>,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateWithContentHeadroom(
                headroom: c_float,
                space: Option<&CGColorSpace>,
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret =
            unsafe { CGColorCreateWithContentHeadroom(headroom, space, red, green, blue, alpha) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorGetContentHeadroom")]
    #[inline]
    pub fn content_headroom(color: Option<&CGColor>) -> c_float {
        extern "C-unwind" {
            fn CGColorGetContentHeadroom(color: Option<&CGColor>) -> c_float;
        }
        unsafe { CGColorGetContentHeadroom(color) }
    }

    /// Returns a color object that represents a constant color.
    ///
    /// Parameters:
    /// - colorName: A color name. You can pass any of constants in [Getting System Colors](https://developer.apple.com/documentation/coregraphics/cgcolor#getting-system-colors).
    ///
    ///
    /// ## Return Value
    ///
    /// A color object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As this function is not a “Copy” or “Create” function, it does not necessarily return a new reference each time it’s called. As a consequence, you should not release the returned value. However, colors returned from this function can be retained and released in a properly nested fashion, just as any other Core Foundation type can.
    ///
    ///
    #[doc(alias = "CGColorGetConstantColor")]
    #[inline]
    pub fn constant_color(color_name: Option<&CFString>) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorGetConstantColor(color_name: Option<&CFString>) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorGetConstantColor(color_name) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Creates a color using a list of intensity values (including alpha), a pattern color space, and a pattern.
    ///
    /// Parameters:
    /// - space: A pattern color space for the new color. Core Graphics retains the color space you pass in. On return, you may safely release it.
    ///
    /// - pattern: A pattern for the new color object. Core Graphics retains the pattern you pass in. On return, you may safely release it.
    ///
    /// - components: An array of intensity values describing the color. The array should contain `n + 1` values that correspond to the `n` color components in the specified color space, followed by the alpha component. Each component value should be in the range appropriate for the color space. Values outside this range will be clamped to the nearest correct value.
    ///
    ///
    /// ## Return Value
    ///
    /// A new color. In Objective-C, you’re responsible for releasing this object using [`CGColorRelease`](https://developer.apple.com/documentation/coregraphics/cgcolorrelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `components` must be a valid pointer or null.
    #[doc(alias = "CGColorCreateWithPattern")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGPattern"))]
    #[inline]
    pub unsafe fn with_pattern(
        space: Option<&CGColorSpace>,
        pattern: Option<&CGPattern>,
        components: *const CGFloat,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateWithPattern(
                space: Option<&CGColorSpace>,
                pattern: Option<&CGPattern>,
                components: *const CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateWithPattern(space, pattern, components) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a copy of an existing color.
    ///
    /// Parameters:
    /// - color: A color.
    ///
    ///
    /// ## Return Value
    ///
    /// A copy of the specified color. In Objective-C, you’re responsible for releasing this object using [`CGColorRelease`](https://developer.apple.com/documentation/coregraphics/cgcolorrelease).
    ///
    ///
    #[doc(alias = "CGColorCreateCopy")]
    #[inline]
    pub fn new_copy(color: Option<&CGColor>) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateCopy(color: Option<&CGColor>) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateCopy(color) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a copy of an existing color, substituting a new alpha value.
    ///
    /// Parameters:
    /// - color: The color to copy.
    ///
    /// - alpha: A value that specifies the desired opacity of the copy. Values outside the range `[0,1]` are clamped to `0` or `1`.
    ///
    ///
    /// ## Return Value
    ///
    /// A copy of the specified color, using the specified alpha value. In Objective-C, you’re responsible for releasing this object using [`CGColorRelease`](https://developer.apple.com/documentation/coregraphics/cgcolorrelease).
    ///
    ///
    #[doc(alias = "CGColorCreateCopyWithAlpha")]
    #[inline]
    pub fn new_copy_with_alpha(
        color: Option<&CGColor>,
        alpha: CGFloat,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateCopyWithAlpha(
                color: Option<&CGColor>,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateCopyWithAlpha(color, alpha) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new color in a different color space that matches the provided color.
    ///
    /// ### Parameters
    ///
    /// - CGColorSpaceRef: The destination color space.
    ///
    /// - to: The destination color space.
    ///
    /// - intent: The mechanism to use to match the color when the color is outside the gamut of the new color space.
    ///
    /// - color: The color to convert.
    ///
    /// - options: A dictionary of options used to convert the color. Currently, you should pass `NULL`.
    ///
    /// ### Returns
    ///
    /// A new color in the destination color space that matches (or closely approximates) the source color.
    ///
    /// ## Discussion
    ///
    /// To create the new color, this method creates a `CFColorConverterRef` using the options you specified and applies it to the source color.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGColorCreateCopyByMatchingToColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn new_copy_by_matching_to_color_space(
        param1: Option<&CGColorSpace>,
        intent: CGColorRenderingIntent,
        color: Option<&CGColor>,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateCopyByMatchingToColorSpace(
                param1: Option<&CGColorSpace>,
                intent: CGColorRenderingIntent,
                color: Option<&CGColor>,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret =
            unsafe { CGColorCreateCopyByMatchingToColorSpace(param1, intent, color, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Indicates whether two colors are equal.
    ///
    /// Parameters:
    /// - color1: The first color to compare.
    ///
    /// - color2: The second color to compare.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean value that, if [`true`](https://developer.apple.com/documentation/swift/true), indicates that the specified colors are equal. If the colors are not equal, the value is [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Two colors are equal if they share the same color space and numerically equal color components.
    ///
    ///
    #[doc(alias = "CGColorEqualToColor")]
    #[inline]
    pub fn equal_to_color(color1: Option<&CGColor>, color2: Option<&CGColor>) -> bool {
        extern "C-unwind" {
            fn CGColorEqualToColor(color1: Option<&CGColor>, color2: Option<&CGColor>) -> bool;
        }
        unsafe { CGColorEqualToColor(color1, color2) }
    }

    /// Returns the number of color components (including alpha) associated with a color.
    ///
    /// Parameters:
    /// - color: A color.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of color components (including alpha) associated with the specified color. This number is one more than the number of components of the color space for the color.
    ///
    ///
    #[doc(alias = "CGColorGetNumberOfComponents")]
    #[inline]
    pub fn number_of_components(color: Option<&CGColor>) -> usize {
        extern "C-unwind" {
            fn CGColorGetNumberOfComponents(color: Option<&CGColor>) -> usize;
        }
        unsafe { CGColorGetNumberOfComponents(color) }
    }

    /// Returns the values of the color components (including alpha) associated with a color.
    ///
    /// Parameters:
    /// - color: A color.
    ///
    ///
    /// ## Return Value
    ///
    /// An array of intensity values for the color components (including alpha) associated with the specified color. The size of the array is one more than the number of components of the color space for the color.
    ///
    ///
    #[doc(alias = "CGColorGetComponents")]
    #[inline]
    pub fn components(color: Option<&CGColor>) -> *const CGFloat {
        extern "C-unwind" {
            fn CGColorGetComponents(color: Option<&CGColor>) -> *const CGFloat;
        }
        unsafe { CGColorGetComponents(color) }
    }

    /// Returns the value of the alpha component associated with a color.
    ///
    /// Parameters:
    /// - color: A color.
    ///
    ///
    /// ## Return Value
    ///
    /// An alpha intensity value in the range `[0,1]`. The value represents the opacity of the color.
    ///
    ///
    #[doc(alias = "CGColorGetAlpha")]
    #[inline]
    pub fn alpha(color: Option<&CGColor>) -> CGFloat {
        extern "C-unwind" {
            fn CGColorGetAlpha(color: Option<&CGColor>) -> CGFloat;
        }
        unsafe { CGColorGetAlpha(color) }
    }

    /// Returns the color space associated with a color.
    ///
    /// Parameters:
    /// - color: A color.
    ///
    ///
    /// ## Return Value
    ///
    /// The color space for the specified color. You are responsible for retaining and releasing it as needed.
    ///
    ///
    #[doc(alias = "CGColorGetColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn color_space(color: Option<&CGColor>) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorGetColorSpace(color: Option<&CGColor>) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorGetColorSpace(color) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the pattern associated with a color in a pattern color space.
    ///
    /// Parameters:
    /// - color: A color.
    ///
    ///
    /// ## Return Value
    ///
    /// The pattern for the specified color. You are responsible for retaining and releasing the pattern as needed.
    ///
    ///
    #[doc(alias = "CGColorGetPattern")]
    #[cfg(feature = "CGPattern")]
    #[inline]
    pub fn pattern(color: Option<&CGColor>) -> Option<CFRetained<CGPattern>> {
        extern "C-unwind" {
            fn CGColorGetPattern(color: Option<&CGColor>) -> Option<NonNull<CGPattern>>;
        }
        let ret = unsafe { CGColorGetPattern(color) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

unsafe impl ConcreteType for CGColor {
    /// Returns the Core Foundation type identifier for a color data type.
    ///
    /// ## Return Value
    ///
    /// The Core Foundation type identifier for [`CGColorRef`](https://developer.apple.com/documentation/coregraphics/cgcolor).
    ///
    ///
    #[doc(alias = "CGColorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGColorGetTypeID() -> CFTypeID;
        }
        unsafe { CGColorGetTypeID() }
    }
}

extern "C" {
    /// The white color in the Generic gray color space.
    /// * Names of colors for use with `CGColorGetConstantColor'. **
    pub static kCGColorWhite: &'static CFString;
}

extern "C" {
    /// The black color in the Generic gray color space.
    pub static kCGColorBlack: &'static CFString;
}

extern "C" {
    /// The clear color in the Generic gray color space.
    pub static kCGColorClear: &'static CFString;
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGColor::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CGColorCreate(
    space: Option<&CGColorSpace>,
    components: *const CGFloat,
) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorCreate(
            space: Option<&CGColorSpace>,
            components: *const CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreate(space, components) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGColor::new_generic_gray`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateGenericGray(
    gray: CGFloat,
    alpha: CGFloat,
) -> CFRetained<CGColor> {
    extern "C-unwind" {
        fn CGColorCreateGenericGray(gray: CGFloat, alpha: CGFloat) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateGenericGray(gray, alpha) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGColor::new_generic_rgb`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateGenericRGB(
    red: CGFloat,
    green: CGFloat,
    blue: CGFloat,
    alpha: CGFloat,
) -> CFRetained<CGColor> {
    extern "C-unwind" {
        fn CGColorCreateGenericRGB(
            red: CGFloat,
            green: CGFloat,
            blue: CGFloat,
            alpha: CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateGenericRGB(red, green, blue, alpha) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGColor::new_generic_cmyk`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateGenericCMYK(
    cyan: CGFloat,
    magenta: CGFloat,
    yellow: CGFloat,
    black: CGFloat,
    alpha: CGFloat,
) -> CFRetained<CGColor> {
    extern "C-unwind" {
        fn CGColorCreateGenericCMYK(
            cyan: CGFloat,
            magenta: CGFloat,
            yellow: CGFloat,
            black: CGFloat,
            alpha: CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateGenericCMYK(cyan, magenta, yellow, black, alpha) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGColor::new_generic_gray_gamma2_2`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateGenericGrayGamma2_2(
    gray: CGFloat,
    alpha: CGFloat,
) -> CFRetained<CGColor> {
    extern "C-unwind" {
        fn CGColorCreateGenericGrayGamma2_2(
            gray: CGFloat,
            alpha: CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateGenericGrayGamma2_2(gray, alpha) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGColor::new_srgb`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateSRGB(
    red: CGFloat,
    green: CGFloat,
    blue: CGFloat,
    alpha: CGFloat,
) -> CFRetained<CGColor> {
    extern "C-unwind" {
        fn CGColorCreateSRGB(
            red: CGFloat,
            green: CGFloat,
            blue: CGFloat,
            alpha: CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateSRGB(red, green, blue, alpha) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGColor::with_content_headroom`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateWithContentHeadroom(
    headroom: c_float,
    space: Option<&CGColorSpace>,
    red: CGFloat,
    green: CGFloat,
    blue: CGFloat,
    alpha: CGFloat,
) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorCreateWithContentHeadroom(
            headroom: c_float,
            space: Option<&CGColorSpace>,
            red: CGFloat,
            green: CGFloat,
            blue: CGFloat,
            alpha: CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateWithContentHeadroom(headroom, space, red, green, blue, alpha) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGColor::content_headroom`"]
#[inline]
pub extern "C-unwind" fn CGColorGetContentHeadroom(color: Option<&CGColor>) -> c_float {
    extern "C-unwind" {
        fn CGColorGetContentHeadroom(color: Option<&CGColor>) -> c_float;
    }
    unsafe { CGColorGetContentHeadroom(color) }
}

#[deprecated = "renamed to `CGColor::constant_color`"]
#[inline]
pub extern "C-unwind" fn CGColorGetConstantColor(
    color_name: Option<&CFString>,
) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorGetConstantColor(color_name: Option<&CFString>) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorGetConstantColor(color_name) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CGColorSpace", feature = "CGPattern"))]
#[deprecated = "renamed to `CGColor::with_pattern`"]
#[inline]
pub unsafe extern "C-unwind" fn CGColorCreateWithPattern(
    space: Option<&CGColorSpace>,
    pattern: Option<&CGPattern>,
    components: *const CGFloat,
) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorCreateWithPattern(
            space: Option<&CGColorSpace>,
            pattern: Option<&CGPattern>,
            components: *const CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateWithPattern(space, pattern, components) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGColor::new_copy`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateCopy(color: Option<&CGColor>) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorCreateCopy(color: Option<&CGColor>) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateCopy(color) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGColor::new_copy_with_alpha`"]
#[inline]
pub extern "C-unwind" fn CGColorCreateCopyWithAlpha(
    color: Option<&CGColor>,
    alpha: CGFloat,
) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorCreateCopyWithAlpha(
            color: Option<&CGColor>,
            alpha: CGFloat,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateCopyWithAlpha(color, alpha) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGColor::new_copy_by_matching_to_color_space`"]
#[inline]
pub unsafe extern "C-unwind" fn CGColorCreateCopyByMatchingToColorSpace(
    param1: Option<&CGColorSpace>,
    intent: CGColorRenderingIntent,
    color: Option<&CGColor>,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGColor>> {
    extern "C-unwind" {
        fn CGColorCreateCopyByMatchingToColorSpace(
            param1: Option<&CGColorSpace>,
            intent: CGColorRenderingIntent,
            color: Option<&CGColor>,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGColor>>;
    }
    let ret = unsafe { CGColorCreateCopyByMatchingToColorSpace(param1, intent, color, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGColor::equal_to_color`"]
#[inline]
pub extern "C-unwind" fn CGColorEqualToColor(
    color1: Option<&CGColor>,
    color2: Option<&CGColor>,
) -> bool {
    extern "C-unwind" {
        fn CGColorEqualToColor(color1: Option<&CGColor>, color2: Option<&CGColor>) -> bool;
    }
    unsafe { CGColorEqualToColor(color1, color2) }
}

#[deprecated = "renamed to `CGColor::number_of_components`"]
#[inline]
pub extern "C-unwind" fn CGColorGetNumberOfComponents(color: Option<&CGColor>) -> usize {
    extern "C-unwind" {
        fn CGColorGetNumberOfComponents(color: Option<&CGColor>) -> usize;
    }
    unsafe { CGColorGetNumberOfComponents(color) }
}

#[deprecated = "renamed to `CGColor::components`"]
#[inline]
pub extern "C-unwind" fn CGColorGetComponents(color: Option<&CGColor>) -> *const CGFloat {
    extern "C-unwind" {
        fn CGColorGetComponents(color: Option<&CGColor>) -> *const CGFloat;
    }
    unsafe { CGColorGetComponents(color) }
}

#[deprecated = "renamed to `CGColor::alpha`"]
#[inline]
pub extern "C-unwind" fn CGColorGetAlpha(color: Option<&CGColor>) -> CGFloat {
    extern "C-unwind" {
        fn CGColorGetAlpha(color: Option<&CGColor>) -> CGFloat;
    }
    unsafe { CGColorGetAlpha(color) }
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGColor::color_space`"]
#[inline]
pub extern "C-unwind" fn CGColorGetColorSpace(
    color: Option<&CGColor>,
) -> Option<CFRetained<CGColorSpace>> {
    extern "C-unwind" {
        fn CGColorGetColorSpace(color: Option<&CGColor>) -> Option<NonNull<CGColorSpace>>;
    }
    let ret = unsafe { CGColorGetColorSpace(color) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "CGPattern")]
#[deprecated = "renamed to `CGColor::pattern`"]
#[inline]
pub extern "C-unwind" fn CGColorGetPattern(
    color: Option<&CGColor>,
) -> Option<CFRetained<CGPattern>> {
    extern "C-unwind" {
        fn CGColorGetPattern(color: Option<&CGColor>) -> Option<NonNull<CGPattern>>;
    }
    let ret = unsafe { CGColorGetPattern(color) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}
