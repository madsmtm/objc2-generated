//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcolor?language=objc)
#[doc(alias = "CGColorRef")]
#[repr(C)]
pub struct CGColor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGColor {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGColor"> for CGColor {}
);

impl CGColor {
    /// # Safety
    ///
    /// `components` must be a valid pointer.
    #[doc(alias = "CGColorCreate")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn new(
        space: &CGColorSpace,
        components: NonNull<CGFloat>,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreate(
                space: &CGColorSpace,
                components: NonNull<CGFloat>,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreate(space, components) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorCreateGenericGray")]
    #[inline]
    pub fn new_generic_gray(gray: CGFloat, alpha: CGFloat) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericGray(gray: CGFloat, alpha: CGFloat) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericGray(gray, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorCreateGenericRGB")]
    #[inline]
    pub fn new_generic_rgb(
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericRGB(
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericRGB(red, green, blue, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorCreateGenericCMYK")]
    #[inline]
    pub fn new_generic_cmyk(
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    ) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericCMYK(
                cyan: CGFloat,
                magenta: CGFloat,
                yellow: CGFloat,
                black: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericCMYK(cyan, magenta, yellow, black, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorCreateGenericGrayGamma2_2")]
    #[inline]
    pub fn new_generic_gray_gamma2_2(gray: CGFloat, alpha: CGFloat) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateGenericGrayGamma2_2(
                gray: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateGenericGrayGamma2_2(gray, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorCreateSRGB")]
    #[inline]
    pub fn new_srgb(
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) -> CFRetained<CGColor> {
        extern "C-unwind" {
            fn CGColorCreateSRGB(
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateSRGB(red, green, blue, alpha) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorCreateWithContentHeadroom")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn with_content_headroom(
        headroom: c_float,
        space: &CGColorSpace,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateWithContentHeadroom(
                headroom: c_float,
                space: &CGColorSpace,
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret =
            unsafe { CGColorCreateWithContentHeadroom(headroom, space, red, green, blue, alpha) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorGetContentHeadroom")]
    #[inline]
    pub fn content_headroom(&self) -> c_float {
        extern "C-unwind" {
            fn CGColorGetContentHeadroom(color: &CGColor) -> c_float;
        }
        unsafe { CGColorGetContentHeadroom(self) }
    }

    #[doc(alias = "CGColorGetConstantColor")]
    #[inline]
    pub fn constant_color(color_name: &CFString) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorGetConstantColor(color_name: &CFString) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorGetConstantColor(color_name) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// # Safety
    ///
    /// `components` must be a valid pointer.
    #[doc(alias = "CGColorCreateWithPattern")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGPattern"))]
    #[inline]
    pub unsafe fn with_pattern(
        space: &CGColorSpace,
        pattern: &CGPattern,
        components: NonNull<CGFloat>,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateWithPattern(
                space: &CGColorSpace,
                pattern: &CGPattern,
                components: NonNull<CGFloat>,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateWithPattern(space, pattern, components) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorCreateCopy")]
    #[inline]
    pub fn copy(&self) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateCopy(color: &CGColor) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateCopy(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorCreateCopyWithAlpha")]
    #[inline]
    pub fn copy_with_alpha(&self, alpha: CGFloat) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateCopyWithAlpha(
                color: &CGColor,
                alpha: CGFloat,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret = unsafe { CGColorCreateCopyWithAlpha(self, alpha) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGColorCreateCopyByMatchingToColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn new_copy_by_matching_to_color_space(
        param1: &CGColorSpace,
        intent: CGColorRenderingIntent,
        color: &CGColor,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGColor>> {
        extern "C-unwind" {
            fn CGColorCreateCopyByMatchingToColorSpace(
                param1: &CGColorSpace,
                intent: CGColorRenderingIntent,
                color: &CGColor,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGColor>>;
        }
        let ret =
            unsafe { CGColorCreateCopyByMatchingToColorSpace(param1, intent, color, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorEqualToColor")]
    #[inline]
    pub fn equal_to_color(&self, color2: &CGColor) -> bool {
        extern "C-unwind" {
            fn CGColorEqualToColor(color1: &CGColor, color2: &CGColor) -> bool;
        }
        unsafe { CGColorEqualToColor(self, color2) }
    }

    #[doc(alias = "CGColorGetNumberOfComponents")]
    #[inline]
    pub fn number_of_components(&self) -> usize {
        extern "C-unwind" {
            fn CGColorGetNumberOfComponents(color: &CGColor) -> usize;
        }
        unsafe { CGColorGetNumberOfComponents(self) }
    }

    #[doc(alias = "CGColorGetComponents")]
    #[inline]
    pub fn components(&self) -> *const CGFloat {
        extern "C-unwind" {
            fn CGColorGetComponents(color: &CGColor) -> *const CGFloat;
        }
        unsafe { CGColorGetComponents(self) }
    }

    #[doc(alias = "CGColorGetAlpha")]
    #[inline]
    pub fn alpha(&self) -> CGFloat {
        extern "C-unwind" {
            fn CGColorGetAlpha(color: &CGColor) -> CGFloat;
        }
        unsafe { CGColorGetAlpha(self) }
    }

    #[doc(alias = "CGColorGetColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn color_space(&self) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorGetColorSpace(color: &CGColor) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorGetColorSpace(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CGColorGetPattern")]
    #[cfg(feature = "CGPattern")]
    #[inline]
    pub fn pattern(&self) -> Option<CFRetained<CGPattern>> {
        extern "C-unwind" {
            fn CGColorGetPattern(color: &CGColor) -> Option<NonNull<CGPattern>>;
        }
        let ret = unsafe { CGColorGetPattern(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

unsafe impl ConcreteType for CGColor {
    #[doc(alias = "CGColorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGColorGetTypeID() -> CFTypeID;
        }
        unsafe { CGColorGetTypeID() }
    }
}

extern "C" {
    /// * Names of colors for use with `CGColorGetConstantColor'. **
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorwhite?language=objc)
    pub static kCGColorWhite: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorblack?language=objc)
    pub static kCGColorBlack: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorclear?language=objc)
    pub static kCGColorClear: &'static CFString;
}
