//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A bitmap image or image mask.
///
/// ## Overview
///
/// A bitmap image is a rectangular array of pixels, each of which represents a single sample or data point from a source image.
///
///
#[doc(alias = "CGImageRef")]
#[repr(C)]
pub struct CGImage {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGImage {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGImage"> for CGImage {}
);

/// Storage options for alpha component data.
///
/// ## Overview
///
/// A [`CGImageAlphaInfo`](https://developer.apple.com/documentation/coregraphics/cgimagealphainfo) constant specifies (1) whether a bitmap contains an alpha channel, (2) where the alpha bits are located in the image data, and (3) whether the alpha value is premultiplied. You can obtain a [`CGImageAlphaInfo`](https://developer.apple.com/documentation/coregraphics/cgimagealphainfo) constant for an image by calling the [`CGImageGetAlphaInfo`](https://developer.apple.com/documentation/coregraphics/cgimage/alphainfo) function. (You provide a [`CGBitmapInfo`](https://developer.apple.com/documentation/coregraphics/cgbitmapinfo) constant to the function [`CGImageCreate`](https://developer.apple.com/documentation/coregraphics/cgimage/init(width:height:bitspercomponent:bitsperpixel:bytesperrow:space:bitmapinfo:provider:decode:shouldinterpolate:intent:)), part of which is a [`CGImageAlphaInfo`](https://developer.apple.com/documentation/coregraphics/cgimagealphainfo) constant.)
///
/// Alpha blending is accomplished by combining the color components of the source image with the color components of the destination image using the linear interpolation formula, where “source” is one color component of one pixel of the new paint and “destination” is one color component of the background image.
///
/// Core Graphics supports premultiplied alpha only for images. You should not premultiply any other color values specified in Core Graphics.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGImageAlphaInfo(pub u32);
impl CGImageAlphaInfo {
    /// There is no alpha channel.
    #[doc(alias = "kCGImageAlphaNone")]
    pub const None: Self = Self(0);
    /// The alpha component is stored in the least significant bits of each pixel and the color components have already been multiplied by this alpha value. For example, premultiplied RGBA.
    #[doc(alias = "kCGImageAlphaPremultipliedLast")]
    pub const PremultipliedLast: Self = Self(1);
    /// The alpha component is stored in the most significant bits of each pixel and the color components have already been multiplied by this alpha value. For example, premultiplied ARGB.
    #[doc(alias = "kCGImageAlphaPremultipliedFirst")]
    pub const PremultipliedFirst: Self = Self(2);
    /// The alpha component is stored in the least significant bits of each pixel. For example, non-premultiplied RGBA.
    #[doc(alias = "kCGImageAlphaLast")]
    pub const Last: Self = Self(3);
    /// The alpha component is stored in the most significant bits of each pixel. For example, non-premultiplied ARGB.
    #[doc(alias = "kCGImageAlphaFirst")]
    pub const First: Self = Self(4);
    /// There is no alpha channel.
    #[doc(alias = "kCGImageAlphaNoneSkipLast")]
    pub const NoneSkipLast: Self = Self(5);
    /// There is no alpha channel. If the total size of the pixel is greater than the space required for the number of color components in the color space, the most significant bits are ignored.
    #[doc(alias = "kCGImageAlphaNoneSkipFirst")]
    pub const NoneSkipFirst: Self = Self(6);
    /// There is no color data, only an alpha channel.
    #[doc(alias = "kCGImageAlphaOnly")]
    pub const Only: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageAlphaInfo {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageAlphaInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGImageComponentInfo(pub u32);
impl CGImageComponentInfo {
    #[doc(alias = "kCGImageComponentInteger")]
    pub const Integer: Self = Self(0 << 8);
    #[doc(alias = "kCGImageComponentFloat")]
    pub const Float: Self = Self(1 << 8);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageComponentInfo {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageComponentInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGImageByteOrderInfo(pub u32);
impl CGImageByteOrderInfo {
    #[doc(alias = "kCGImageByteOrderMask")]
    #[deprecated]
    pub const OrderMask: Self = Self(0x7000);
    #[doc(alias = "kCGImageByteOrderDefault")]
    pub const OrderDefault: Self = Self(0 << 12);
    #[doc(alias = "kCGImageByteOrder16Little")]
    pub const Order16Little: Self = Self(1 << 12);
    #[doc(alias = "kCGImageByteOrder32Little")]
    pub const Order32Little: Self = Self(2 << 12);
    #[doc(alias = "kCGImageByteOrder16Big")]
    pub const Order16Big: Self = Self(3 << 12);
    #[doc(alias = "kCGImageByteOrder32Big")]
    pub const Order32Big: Self = Self(4 << 12);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageByteOrderInfo {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageByteOrderInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGImagePixelFormatInfo(pub u32);
impl CGImagePixelFormatInfo {
    #[doc(alias = "kCGImagePixelFormatMask")]
    #[deprecated]
    pub const Mask: Self = Self(0xF0000);
    #[doc(alias = "kCGImagePixelFormatPacked")]
    pub const Packed: Self = Self(0 << 16);
    #[doc(alias = "kCGImagePixelFormatRGB555")]
    pub const RGB555: Self = Self(1 << 16);
    #[doc(alias = "kCGImagePixelFormatRGB565")]
    pub const RGB565: Self = Self(2 << 16);
    #[doc(alias = "kCGImagePixelFormatRGB101010")]
    pub const RGB101010: Self = Self(3 << 16);
    #[doc(alias = "kCGImagePixelFormatRGBCIF10")]
    pub const RGBCIF10: Self = Self(4 << 16);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImagePixelFormatInfo {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImagePixelFormatInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Component information for a bitmap image.
///
/// ## Overview
///
/// Applications that store pixel data in memory using ARGB format must take care in how they read data. If the code is not written correctly, it’s possible to misread the data which leads to colors or alpha that appear wrong. The byte order constants specify the byte ordering of pixel formats. To specify byte ordering, use a bitwise OR operator to combine the appropriate constant with the `bitmapInfo` parameter.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGBitmapInfo(pub u32);
bitflags::bitflags! {
    impl CGBitmapInfo: u32 {
        #[doc(alias = "kCGBitmapAlphaInfoMask")]
        const AlphaInfoMask = 0x1F;
        #[doc(alias = "kCGBitmapComponentInfoMask")]
        const ComponentInfoMask = 0xF00;
        #[doc(alias = "kCGBitmapByteOrderInfoMask")]
        const ByteOrderInfoMask = 0x7000;
        #[doc(alias = "kCGBitmapPixelFormatInfoMask")]
        const PixelFormatInfoMask = 0xF0000;
        #[doc(alias = "kCGBitmapFloatInfoMask")]
#[deprecated]
        const FloatInfoMask = CGBitmapInfo::ComponentInfoMask.0;
        #[doc(alias = "kCGBitmapByteOrderMask")]
#[deprecated]
        const ByteOrderMask = CGBitmapInfo::ByteOrderInfoMask.0;
/// The components of a bitmap are floating-point values.
        #[doc(alias = "kCGBitmapFloatComponents")]
#[deprecated]
        const FloatComponents = CGImageComponentInfo::Float.0;
/// The default byte order.
        #[doc(alias = "kCGBitmapByteOrderDefault")]
#[deprecated]
        const ByteOrderDefault = CGImageByteOrderInfo::OrderDefault.0;
/// 16-bit, little endian format.
        #[doc(alias = "kCGBitmapByteOrder16Little")]
#[deprecated]
        const ByteOrder16Little = CGImageByteOrderInfo::Order16Little.0;
/// 32-bit, little endian format.
        #[doc(alias = "kCGBitmapByteOrder32Little")]
#[deprecated]
        const ByteOrder32Little = CGImageByteOrderInfo::Order32Little.0;
/// 16-bit, big endian format.
        #[doc(alias = "kCGBitmapByteOrder16Big")]
#[deprecated]
        const ByteOrder16Big = CGImageByteOrderInfo::Order16Big.0;
/// 32-bit, big endian format.
        #[doc(alias = "kCGBitmapByteOrder32Big")]
#[deprecated]
        const ByteOrder32Big = CGImageByteOrderInfo::Order32Big.0;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGBitmapInfo {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGBitmapInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGBitmapInfo {
    // TODO: pub fn CGBitmapInfoMake(alpha: CGImageAlphaInfo,component: CGImageComponentInfo,byte_order: CGImageByteOrderInfo,pixel_format: CGImagePixelFormatInfo,) -> CGBitmapInfo;
}

unsafe impl ConcreteType for CGImage {
    /// Returns the type identifier for CGImage objects.
    ///
    /// ## Return Value
    ///
    /// The identifier for the type [`CGImageRef`](https://developer.apple.com/documentation/coregraphics/cgimage).
    ///
    ///
    #[doc(alias = "CGImageGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGImageGetTypeID() -> CFTypeID;
        }
        unsafe { CGImageGetTypeID() }
    }
}

impl CGImage {
    /// Creates a bitmap image from data supplied by a data provider.
    ///
    /// Parameters:
    /// - width: The width, in pixels, of the required image.
    ///
    /// - height: The height, in pixels, of the required image
    ///
    /// - bitsPerComponent: The number of bits for each component in a source pixel. For example, if the source image uses the RGBA-32 format, you would specify 8 bits per component.
    ///
    /// - bitsPerPixel: The total number of bits in a source pixel. This value must be at least `bitsPerComponent` times the number of components per pixel.
    ///
    /// - bytesPerRow: The number of bytes of memory for each horizontal row of the bitmap.
    ///
    /// - space: The color space for the image. The color space is retained; on return, you may safely release it.
    ///
    /// - bitmapInfo: A constant that specifies whether the bitmap should contain an alpha channel and its relative location in a pixel, along with whether the components are floating-point or integer values.
    ///
    /// - provider: The source of data for the bitmap. For information about supported data formats, see the discussion below. The provider is retained; on return, you may safely release it.
    ///
    /// - decode: The decode array for the image. If you do not want to allow remapping of the image’s color values, pass `NULL` for the decode array. For each color component in the image’s color space (including the alpha component), a decode array provides a pair of values denoting the upper and lower limits of a range. For example, the decode array for a source image in the RGB color space would contain six entries total, consisting of one pair each for red, green, and blue. When the image is rendered, Core Graphics uses a linear transform to map the original component value into a relative number within your designated range that is appropriate for the destination color space.
    ///
    /// - shouldInterpolate: A Boolean value that specifies whether interpolation should occur. The interpolation setting specifies whether Core Graphics should apply a pixel-smoothing algorithm to the image. Without interpolation, the image may appear jagged or pixelated when drawn on an output device with higher resolution than the image data.
    ///
    /// - intent: A rendering intent constant that specifies how Core Graphics should handle colors that are not located within the gamut of the destination color space of a graphics context. The rendering intent determines the exact method used to map colors from one color space to another. For descriptions of the defined rendering-intent constants, see [`CGColorRenderingIntent`](https://developer.apple.com/documentation/coregraphics/cgcolorrenderingintent).
    ///
    ///
    /// ## Return Value
    ///
    /// A new bitmap image. In Objective-C, you’re responsible for releasing this object by calling [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The data provider should provide raw data that matches the format specified by the other input parameters. To use encoded data (for example, from a file specified by a URL-based data provider), see [`CGImageCreateWithJPEGDataProvider`](https://developer.apple.com/documentation/coregraphics/cgimage/init(jpegdataprovidersource:decode:shouldinterpolate:intent:)) and [`CGImageCreateWithPNGDataProvider`](https://developer.apple.com/documentation/coregraphics/cgimage/init(pngdataprovidersource:decode:shouldinterpolate:intent:)).
    ///
    /// For information on supported pixel formats, see [Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `decode` must be a valid pointer or null.
    #[doc(alias = "CGImageCreate")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
    #[inline]
    pub unsafe fn new(
        width: usize,
        height: usize,
        bits_per_component: usize,
        bits_per_pixel: usize,
        bytes_per_row: usize,
        space: Option<&CGColorSpace>,
        bitmap_info: CGBitmapInfo,
        provider: Option<&CGDataProvider>,
        decode: *const CGFloat,
        should_interpolate: bool,
        intent: CGColorRenderingIntent,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreate(
                width: usize,
                height: usize,
                bits_per_component: usize,
                bits_per_pixel: usize,
                bytes_per_row: usize,
                space: Option<&CGColorSpace>,
                bitmap_info: CGBitmapInfo,
                provider: Option<&CGDataProvider>,
                decode: *const CGFloat,
                should_interpolate: bool,
                intent: CGColorRenderingIntent,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe {
            CGImageCreate(
                width,
                height,
                bits_per_component,
                bits_per_pixel,
                bytes_per_row,
                space,
                bitmap_info,
                provider,
                decode,
                should_interpolate,
                intent,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a bitmap image mask from data supplied by a data provider.
    ///
    /// Parameters:
    /// - width: The width, in pixels, of the required image mask.
    ///
    /// - height: The height, in pixels, of the required image mask.
    ///
    /// - bitsPerComponent: The number of significant masking bits in a source pixel. For example, if the source image is an 8-bit mask, you specify 8 bits per component. Image masks must be 1, 2, 4, or 8 bits per component.
    ///
    /// - bitsPerPixel: The total number of bits in a source pixel.
    ///
    /// - bytesPerRow: The number of bytes to use for each horizontal row of the image mask.
    ///
    /// - provider: The data source for the image mask.
    ///
    /// - decode: Typically a decode array is unnecessary, and you should pass `NULL`.
    ///
    /// - shouldInterpolate: A Boolean value that specifies whether an edge-smoothing algorithm is applied to the image mask.
    ///
    ///
    /// ## Return Value
    ///
    /// A bitmap image mask. In Objective-C, you’re responsible for releasing this object by calling [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A bitmap image mask is used the same way an artist uses a silkscreen, or a sign painter uses a stencil. The bitmap represents a mask through which a color is transferred. The bitmap itself does not have a color. It gets its color from the fill color currently set in the graphics state.
    ///
    /// When you draw into a context with a bitmap image mask, the mask determines where and how the current fill color is applied to the image rectangle. Each sample value in the mask specifies how much of the current fill color is masked out at a specific location. Effectively, the sample value specifies the opacity of the mask. Larger values represent greater opacity and hence less color applied to the page.
    ///
    /// Image masks must be 1, 2, 4, or 8 bits per component. For a 1-bit mask, a sample value of `1` specifies sections of the mask that are masked out; these sections block the current fill color. A sample value of `0` specifies sections of the mask that are not masked out; these sections show the current fill color of the graphics state when the mask is painted. You can think of the sample values as an inverse alpha. That is, a value of `1` is transparent and `0` is opaque.
    ///
    /// For image masks that are 2, 4, or 8 bits per component, each component is mapped to a range of 0 to 1 by scaling using this formula:
    ///
    /// `1/(2^bits per component – 1)`
    ///
    /// For example, a 4-bit mask has values that range from 0 to 15. These values are scaled by 1/15 so that each component ranges from 0 to 1. Component values that rescale to 0 or 1 behave the same way as they behave for 1-bit image masks. Values that scale to between 0 and 1 act as an inverse alpha. That is, the fill color is painted as if it has an alpha value of (`1 – MaskSampleValue`). For example, if the sample value of an 8-bit mask scales to `0.8`, the current fill color is painted as if it has an alpha value of `0.2`, that is (`1–0.8`).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `decode` must be a valid pointer or null.
    #[doc(alias = "CGImageMaskCreate")]
    #[cfg(feature = "CGDataProvider")]
    #[inline]
    pub unsafe fn mask_create(
        width: usize,
        height: usize,
        bits_per_component: usize,
        bits_per_pixel: usize,
        bytes_per_row: usize,
        provider: Option<&CGDataProvider>,
        decode: *const CGFloat,
        should_interpolate: bool,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageMaskCreate(
                width: usize,
                height: usize,
                bits_per_component: usize,
                bits_per_pixel: usize,
                bytes_per_row: usize,
                provider: Option<&CGDataProvider>,
                decode: *const CGFloat,
                should_interpolate: bool,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe {
            CGImageMaskCreate(
                width,
                height,
                bits_per_component,
                bits_per_pixel,
                bytes_per_row,
                provider,
                decode,
                should_interpolate,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a copy of a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to copy.
    ///
    ///
    /// ## Return Value
    ///
    /// An copy of the image.
    ///
    ///
    #[doc(alias = "CGImageCreateCopy")]
    #[inline]
    pub fn new_copy(image: Option<&CGImage>) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateCopy(image: Option<&CGImage>) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateCopy(image) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a bitmap image using JPEG-encoded data supplied by a data provider.
    ///
    /// Parameters:
    /// - source: A data provider supplying JPEG-encoded data.
    ///
    /// - decode: The decode array for the image. Typically a decode array is unnecessary, and you should pass `NULL`.
    ///
    /// - shouldInterpolate: A Boolean value that specifies whether interpolation should occur. The interpolation setting specifies whether a pixel-smoothing algorithm should be applied to the image.
    ///
    /// - intent: A CGColorRenderingIntent constant that specifies how to handle colors that are not located within the gamut of the destination color space of a graphics context.
    ///
    ///
    /// ## Return Value
    ///
    /// A new CGImage. In Objective-C, you’re responsible for releasing this object by calling [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `decode` must be a valid pointer or null.
    #[doc(alias = "CGImageCreateWithJPEGDataProvider")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
    #[inline]
    pub unsafe fn with_jpeg_data_provider(
        source: Option<&CGDataProvider>,
        decode: *const CGFloat,
        should_interpolate: bool,
        intent: CGColorRenderingIntent,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateWithJPEGDataProvider(
                source: Option<&CGDataProvider>,
                decode: *const CGFloat,
                should_interpolate: bool,
                intent: CGColorRenderingIntent,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe {
            CGImageCreateWithJPEGDataProvider(source, decode, should_interpolate, intent)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a bitmap image using PNG-encoded data supplied by a data provider.
    ///
    /// Parameters:
    /// - source: A data provider supplying PNG-encoded data.
    ///
    /// - decode: The decode array for the image. Typically a decode array is unnecessary, and you should pass `NULL`.
    ///
    /// - shouldInterpolate: A Boolean value that specifies whether interpolation should occur. The interpolation setting specifies whether a pixel-smoothing algorithm should be applied to the image.
    ///
    /// - intent: A CGColorRenderingIntent constant that specifies how to handle colors that are not located within the gamut of the destination color space of a graphics context.
    ///
    ///
    /// ## Return Value
    ///
    /// A new CGImage. In Objective-C, you’re responsible for releasing this object by calling [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `decode` must be a valid pointer or null.
    #[doc(alias = "CGImageCreateWithPNGDataProvider")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
    #[inline]
    pub unsafe fn with_png_data_provider(
        source: Option<&CGDataProvider>,
        decode: *const CGFloat,
        should_interpolate: bool,
        intent: CGColorRenderingIntent,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateWithPNGDataProvider(
                source: Option<&CGDataProvider>,
                decode: *const CGFloat,
                should_interpolate: bool,
                intent: CGColorRenderingIntent,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret =
            unsafe { CGImageCreateWithPNGDataProvider(source, decode, should_interpolate, intent) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a bitmap image using the data contained within a subregion of an existing bitmap image.
    ///
    /// Parameters:
    /// - image: The image from which to extract the subimage.
    ///
    /// - rect: A rectangle specifying the portion of the image to keep.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`CGImageRef`](https://developer.apple.com/documentation/coregraphics/cgimage) object that specifies a subimage of the image. If the `rect` parameter defines an area that is not in the image, returns `NULL`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Cropping removes content around the designated rectangle; it cuts out the desired area of the input image and returns an image of the cropped size.
    ///
    ///
    /// ![Butterfly photo with background cropped out](https://docs-assets.developer.apple.com/published/44e39ae57f70286b7a3ea4d5a6491b8b/media-2951298%402x.png)
    ///
    ///
    /// [`CGImageCreateWithImageInRect`](https://developer.apple.com/documentation/coregraphics/cgimage/cropping(to:)) performs the following tasks to create the subimage:
    ///
    /// - It calls the [`CGRectIntegral`](https://developer.apple.com/documentation/coregraphics/cgrectintegral(_:)) function to adjust the `rect` parameter to integral bounds.
    ///
    /// - It intersects the `rect` with a rectangle whose origin is `(0,0)` and size is equal to the size of the image specified by the `image` parameter.
    ///
    /// - It reads the pixels within the resulting rectangle, treating the first pixel within as the origin of the subimage.
    ///
    /// If `W` and `H` are the width and height of image, respectively, then the point `(0,0)` corresponds to the first pixel of the image data. The point `(W–1, 0)` is the last pixel of the first row of the image data, while `(0, H–1)` is the first pixel of the last row of the image data and `(W–1, H–1)` is the last pixel of the last row of the image data.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Be sure to specify the subrectangle’s coordinates relative to the original image’s full size, even if the [`UIImageView`](https://developer.apple.com/documentation/uikit/uiimageview) shows only a scaled version.
    ///
    ///
    ///
    /// </div>
    /// The resulting image retains a reference to the original image, which means you may release the original image after calling this function.  In Swift, you do not need to release the original image reference explicitly.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["    func cropImage(_ inputImage: UIImage, toRect cropRect: CGRect, viewWidth: CGFloat, viewHeight: CGFloat) -> UIImage? ", "{    ", "    let imageViewScale = max(inputImage.size.width / viewWidth,", "                             inputImage.size.height / viewHeight)", "", "", "    // Scale cropRect to handle images larger than shown-on-screen size", "    let cropZone = CGRect(x:cropRect.origin.x * imageViewScale,", "                          y:cropRect.origin.y * imageViewScale,", "                          width:cropRect.size.width * imageViewScale,", "                          height:cropRect.size.height * imageViewScale)", "", "", "    // Perform cropping in Core Graphics", "    guard let cutImageRef: CGImage = inputImage.cgImage?.cropping(to:cropZone)", "    else {", "        return nil", "    }", "", "", "    // Return image to UIImage", "    let croppedImage: UIImage = UIImage(cgImage: cutImageRef)", "    return croppedImage", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (UIImage*) cropImage:(UIImage*)inputImage", "                toRect:(CGRect)cropRect", "             viewWidth:(CGFloat)viewWidth", "            viewHeight:(CGFloat)viewHeight", "{", "    // viewWidth, viewHeight are dimensions of imageView", "    const CGFloat imageViewScale = MAX(inputImage.size.width/_viewWidth, inputImage.size.height/_viewHeight);", "", "    // Scale cropRect to handle images larger than shown-on-screen size", "    cropRect.origin.x *= imageViewScale;", "    cropRect.origin.y *= imageViewScale;", "    cropRect.size.width *= imageViewScale;", "    cropRect.size.height *= imageViewScale;", "    ", "    // Perform cropping in Core Graphics", "    CGImageRef cutImageRef = CGImageCreateWithImageInRect(inputImage.CGImage, cropRect);", "    ", "    // Convert back to UIImage", "    UIImage* croppedImage = [UIImage imageWithCGImage:cutImageRef];", "    ", "    // Clean up reference pointers", "    CGImageRelease(cutImageRef);", "    ", "    return croppedImage;", "}"], metadata: None }] }] })
    /// If you already use [`CIImage`](https://developer.apple.com/documentation/coreimage/ciimage), or if you are post-processing images as [`CIImage`](https://developer.apple.com/documentation/coreimage/ciimage) data in Core Image, such as chaining together multiple filters to the cropped result, it may be more efficient to crop [`CIImage`](https://developer.apple.com/documentation/coreimage/ciimage) directly in the Core Image framework using the `CICrop` filter; in this case, use the convenience function [`imageByCroppingToRect:`](https://developer.apple.com/documentation/coreimage/ciimage/cropped(to:)).
    ///
    ///
    #[doc(alias = "CGImageCreateWithImageInRect")]
    #[inline]
    pub fn with_image_in_rect(
        image: Option<&CGImage>,
        rect: CGRect,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateWithImageInRect(
                image: Option<&CGImage>,
                rect: CGRect,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateWithImageInRect(image, rect) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a bitmap image from an existing image and an image mask.
    ///
    /// Parameters:
    /// - image: The image to apply the `mask` parameter to. This image must not be an image mask and may not have an image mask or masking color associated with it.
    ///
    /// - mask: A mask. If the mask is an image, it must be in the DeviceGray color space, must not have an alpha component, and may not itself be masked by an image mask or a masking color. If the mask is not the same size as the image specified by the `image` parameter, the mask is scaled to fit the image.
    ///
    ///
    /// ## Return Value
    ///
    /// An image created by masking `image` with `mask`. In Objective-C, you’re responsible for releasing this object by calling [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The resulting image depends on whether the `mask` parameter is an image mask or an image. If the `mask` parameter is an image mask, then the source samples of the image mask act as an inverse alpha value. That is, if the value of a source sample in the image mask is S, then the corresponding region in `image` is blended with the destination using an alpha value of (1-S). For example, if S is 1, then the region is not painted, while if S is 0, the region is fully painted.
    ///
    /// If the `mask` parameter is an image, then it serves as an alpha mask for blending the image onto the destination. The source samples of `mask`’ act as an alpha value. If the value of the source sample in mask is S, then the corresponding region in image is blended with the destination with an alpha of S. For example, if S is 0, then the region is not painted, while if S is 1, the region is fully painted.
    ///
    ///
    #[doc(alias = "CGImageCreateWithMask")]
    #[inline]
    pub fn with_mask(
        image: Option<&CGImage>,
        mask: Option<&CGImage>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateWithMask(
                image: Option<&CGImage>,
                mask: Option<&CGImage>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateWithMask(image, mask) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a bitmap image by masking an existing bitmap image with the provided color values.
    ///
    /// Parameters:
    /// - image: The image to mask. This parameter may not be an image mask, may not already have an image mask or masking color associated with it, and cannot have an alpha component.
    ///
    /// - components: An array of color components that specify a color or range of colors to mask the image with. The array must contain `2N` values `{ min[1], max[1], ... min[N], max[N] }` where `N` is the number of components in color space of `image`. Each value in `components` must be a valid image sample value. If `image` has integer pixel components, then each value must be in the range `[0 .. 2**bitsPerComponent - 1]` (where `bitsPerComponent` is the number of bits/component of `image`). If `image` has floating-point pixel components, then each value may be any floating-point number which is a valid color component.
    ///
    ///
    /// ## Return Value
    ///
    /// An image created by masking `image` with the colors specified in the `components` array. In Objective-C, you’re responsible for releasing this object by calling [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Any image sample with color value `{c[1], ... c[N]}` where `min[i] <= c[i] <= max[i]` for `1 <= i <= N` is masked out (that is, not painted). This means that anything underneath the unpainted samples, such as the current fill color, shows through.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `components` must be a valid pointer or null.
    #[doc(alias = "CGImageCreateWithMaskingColors")]
    #[inline]
    pub unsafe fn with_masking_colors(
        image: Option<&CGImage>,
        components: *const CGFloat,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateWithMaskingColors(
                image: Option<&CGImage>,
                components: *const CGFloat,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateWithMaskingColors(image, components) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a copy of a bitmap image, replacing its colorspace.
    ///
    /// Parameters:
    /// - image: The graphics image to copy.
    ///
    /// - space: The destination color space. The number of components in this color space must be the same as the number in the specified image.
    ///
    ///
    /// ## Return Value
    ///
    /// A new CGImage that is a copy of the image passed as the `image` parameter but with its color space replaced by that specified by the `colorspace` parameter. Returns `NULL` if `image` is an image mask, or if the number of components of `colorspace` is not the same as the number of components of the colorspace of `image`. In Objective-C, you’re responsible for releasing this object using [`CGImageRelease`](https://developer.apple.com/documentation/coregraphics/cgimagerelease).
    ///
    ///
    #[doc(alias = "CGImageCreateCopyWithColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn new_copy_with_color_space(
        image: Option<&CGImage>,
        space: Option<&CGColorSpace>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateCopyWithColorSpace(
                image: Option<&CGImage>,
                space: Option<&CGColorSpace>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateCopyWithColorSpace(image, space) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `decode` must be a valid pointer or null.
    #[doc(alias = "CGImageCreateWithContentHeadroom")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
    #[inline]
    pub unsafe fn with_content_headroom(
        headroom: c_float,
        width: usize,
        height: usize,
        bits_per_component: usize,
        bits_per_pixel: usize,
        bytes_per_row: usize,
        space: Option<&CGColorSpace>,
        bitmap_info: CGBitmapInfo,
        provider: Option<&CGDataProvider>,
        decode: *const CGFloat,
        should_interpolate: bool,
        intent: CGColorRenderingIntent,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateWithContentHeadroom(
                headroom: c_float,
                width: usize,
                height: usize,
                bits_per_component: usize,
                bits_per_pixel: usize,
                bytes_per_row: usize,
                space: Option<&CGColorSpace>,
                bitmap_info: CGBitmapInfo,
                provider: Option<&CGDataProvider>,
                decode: *const CGFloat,
                should_interpolate: bool,
                intent: CGColorRenderingIntent,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe {
            CGImageCreateWithContentHeadroom(
                headroom,
                width,
                height,
                bits_per_component,
                bits_per_pixel,
                bytes_per_row,
                space,
                bitmap_info,
                provider,
                decode,
                should_interpolate,
                intent,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGImageCreateCopyWithContentHeadroom")]
    #[inline]
    pub fn new_copy_with_content_headroom(
        headroom: c_float,
        image: Option<&CGImage>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateCopyWithContentHeadroom(
                headroom: c_float,
                image: Option<&CGImage>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateCopyWithContentHeadroom(headroom, image) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    pub static kCGDefaultHDRImageContentHeadroom: c_float;
}

impl CGImage {
    #[doc(alias = "CGImageGetContentHeadroom")]
    #[inline]
    pub fn content_headroom(image: Option<&CGImage>) -> c_float {
        extern "C-unwind" {
            fn CGImageGetContentHeadroom(image: Option<&CGImage>) -> c_float;
        }
        unsafe { CGImageGetContentHeadroom(image) }
    }

    #[doc(alias = "CGImageCalculateContentHeadroom")]
    #[inline]
    pub fn calculate_content_headroom(image: Option<&CGImage>) -> c_float {
        extern "C-unwind" {
            fn CGImageCalculateContentHeadroom(image: Option<&CGImage>) -> c_float;
        }
        unsafe { CGImageCalculateContentHeadroom(image) }
    }

    #[doc(alias = "CGImageGetContentAverageLightLevel")]
    #[inline]
    pub fn content_average_light_level(image: Option<&CGImage>) -> c_float {
        extern "C-unwind" {
            fn CGImageGetContentAverageLightLevel(image: Option<&CGImage>) -> c_float;
        }
        unsafe { CGImageGetContentAverageLightLevel(image) }
    }

    #[doc(alias = "CGImageCalculateContentAverageLightLevel")]
    #[inline]
    pub fn calculate_content_average_light_level(image: Option<&CGImage>) -> c_float {
        extern "C-unwind" {
            fn CGImageCalculateContentAverageLightLevel(image: Option<&CGImage>) -> c_float;
        }
        unsafe { CGImageCalculateContentAverageLightLevel(image) }
    }

    #[doc(alias = "CGImageCreateCopyWithContentAverageLightLevel")]
    #[inline]
    pub fn new_copy_with_content_average_light_level(
        image: Option<&CGImage>,
        avll: c_float,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateCopyWithContentAverageLightLevel(
                image: Option<&CGImage>,
                avll: c_float,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateCopyWithContentAverageLightLevel(image, avll) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGImageCreateCopyWithCalculatedHDRStats")]
    #[inline]
    pub fn new_copy_with_calculated_hdr_stats(
        image: Option<&CGImage>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageCreateCopyWithCalculatedHDRStats(
                image: Option<&CGImage>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageCreateCopyWithCalculatedHDRStats(image) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns whether a bitmap image is an image mask.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean value that indicates whether the image passed in the `image` parameter is an image mask ([`true`](https://developer.apple.com/documentation/swift/true) indicates that the image is an image mask).
    ///
    ///
    #[doc(alias = "CGImageIsMask")]
    #[inline]
    pub fn is_mask(image: Option<&CGImage>) -> bool {
        extern "C-unwind" {
            fn CGImageIsMask(image: Option<&CGImage>) -> bool;
        }
        unsafe { CGImageIsMask(image) }
    }

    /// Returns the width of a bitmap image, in pixels.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The width, in pixels, of the specified bitmap image (or image mask).
    ///
    ///
    #[doc(alias = "CGImageGetWidth")]
    #[inline]
    pub fn width(image: Option<&CGImage>) -> usize {
        extern "C-unwind" {
            fn CGImageGetWidth(image: Option<&CGImage>) -> usize;
        }
        unsafe { CGImageGetWidth(image) }
    }

    /// Returns the height of a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The height in pixels of the bitmap image (or image mask).
    ///
    ///
    #[doc(alias = "CGImageGetHeight")]
    #[inline]
    pub fn height(image: Option<&CGImage>) -> usize {
        extern "C-unwind" {
            fn CGImageGetHeight(image: Option<&CGImage>) -> usize;
        }
        unsafe { CGImageGetHeight(image) }
    }

    /// Returns the number of bits allocated for a single color component of a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of bits used in memory for each color component of the specified bitmap image (or image mask).
    ///
    ///
    ///
    /// ## Description
    ///
    /// Possible values are 1, 2, 4, or 8. For example, for a 16-bit RGB(A) colorspace, the function would return a value of 4 bits per color component.
    ///
    ///
    #[doc(alias = "CGImageGetBitsPerComponent")]
    #[inline]
    pub fn bits_per_component(image: Option<&CGImage>) -> usize {
        extern "C-unwind" {
            fn CGImageGetBitsPerComponent(image: Option<&CGImage>) -> usize;
        }
        unsafe { CGImageGetBitsPerComponent(image) }
    }

    /// Returns the number of bits allocated for a single pixel in a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of bits used in memory for each pixel of the specified bitmap image (or image mask).
    ///
    ///
    #[doc(alias = "CGImageGetBitsPerPixel")]
    #[inline]
    pub fn bits_per_pixel(image: Option<&CGImage>) -> usize {
        extern "C-unwind" {
            fn CGImageGetBitsPerPixel(image: Option<&CGImage>) -> usize;
        }
        unsafe { CGImageGetBitsPerPixel(image) }
    }

    /// Returns the number of bytes allocated for a single row of a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of bytes used in memory for each row of the specified bitmap image (or image mask).
    ///
    ///
    #[doc(alias = "CGImageGetBytesPerRow")]
    #[inline]
    pub fn bytes_per_row(image: Option<&CGImage>) -> usize {
        extern "C-unwind" {
            fn CGImageGetBytesPerRow(image: Option<&CGImage>) -> usize;
        }
        unsafe { CGImageGetBytesPerRow(image) }
    }

    /// Return the color space for a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The source color space for the specified bitmap image, or `NULL` if the image is an image mask. You are responsible for retaining and releasing the color space as necessary.
    ///
    ///
    #[doc(alias = "CGImageGetColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn color_space(image: Option<&CGImage>) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGImageGetColorSpace(image: Option<&CGImage>) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGImageGetColorSpace(image) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the alpha channel information for a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`CGImageAlphaInfo`](https://developer.apple.com/documentation/coregraphics/cgimagealphainfo) constant.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The returned value specifies (1) whether the bitmap contains an alpha channel, (2) where the alpha bits are located in the image data, and (3) whether the alpha value is premultiplied. For possible values, see [Constants](https://developer.apple.com/documentation/coregraphics/cgimage#constants). The function returns [`kCGImageAlphaNone`](https://developer.apple.com/documentation/coregraphics/cgimagealphainfo/none) if the `image` parameter refers to an image mask.
    ///
    /// The alpha value is what determines the opacity of a pixel when it is drawn.
    ///
    ///
    #[doc(alias = "CGImageGetAlphaInfo")]
    #[inline]
    pub fn alpha_info(image: Option<&CGImage>) -> CGImageAlphaInfo {
        extern "C-unwind" {
            fn CGImageGetAlphaInfo(image: Option<&CGImage>) -> CGImageAlphaInfo;
        }
        unsafe { CGImageGetAlphaInfo(image) }
    }

    /// Returns the data provider for a bitmap image or image mask.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The data provider for the specified image. You are responsible for retaining and releasing the data provider as necessary.
    ///
    ///
    #[doc(alias = "CGImageGetDataProvider")]
    #[cfg(feature = "CGDataProvider")]
    #[inline]
    pub fn data_provider(image: Option<&CGImage>) -> Option<CFRetained<CGDataProvider>> {
        extern "C-unwind" {
            fn CGImageGetDataProvider(image: Option<&CGImage>) -> Option<NonNull<CGDataProvider>>;
        }
        let ret = unsafe { CGImageGetDataProvider(image) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the decode array for a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The decode array for a bitmap image (or image mask). See the discussion for a description of possible return values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For a bitmap image or image mask, for each color component in the source color space, the decode array contains a pair of values denoting the upper and lower limits of a range. When the image is rendered, a linear transform maps the original component value into a relative number, within the designated range, that is appropriate for the destination color space. If remapping of the image’s color values is not allowed, the returned value will be `NULL`.
    ///
    ///
    #[doc(alias = "CGImageGetDecode")]
    #[inline]
    pub fn decode(image: Option<&CGImage>) -> *const CGFloat {
        extern "C-unwind" {
            fn CGImageGetDecode(image: Option<&CGImage>) -> *const CGFloat;
        }
        unsafe { CGImageGetDecode(image) }
    }

    /// Returns the interpolation setting for a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if interpolation is enabled for the specified bitmap image (or image mask), otherwise, returns `false`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The interpolation setting specifies whether an edge-smoothing algorithm is applied to the associated image.
    ///
    ///
    #[doc(alias = "CGImageGetShouldInterpolate")]
    #[inline]
    pub fn should_interpolate(image: Option<&CGImage>) -> bool {
        extern "C-unwind" {
            fn CGImageGetShouldInterpolate(image: Option<&CGImage>) -> bool;
        }
        unsafe { CGImageGetShouldInterpolate(image) }
    }

    /// Returns the rendering intent setting for a bitmap image.
    ///
    /// Parameters:
    /// - image: The image to examine.
    ///
    ///
    /// ## Discussion
    ///
    /// Provides the `CGColorRenderingIntent` constant that specifies how to handle colors that are not located within the gamut of the destination color space of a graphics context in which the image is drawn. If the image is an image mask, this function returns [`kCGRenderingIntentDefault`](https://developer.apple.com/documentation/coregraphics/cgcolorrenderingintent/defaultintent).
    ///
    ///
    #[doc(alias = "CGImageGetRenderingIntent")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn rendering_intent(image: Option<&CGImage>) -> CGColorRenderingIntent {
        extern "C-unwind" {
            fn CGImageGetRenderingIntent(image: Option<&CGImage>) -> CGColorRenderingIntent;
        }
        unsafe { CGImageGetRenderingIntent(image) }
    }

    /// Returns the bitmap information for a bitmap image.
    ///
    /// Parameters:
    /// - image: An image.
    ///
    ///
    /// ## Return Value
    ///
    /// The bitmap information associated with an image.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns a constant that specifies:
    ///
    /// - The type of bitmap data—floating point or integer. You use the constant [`kCGBitmapFloatComponents`](https://developer.apple.com/documentation/coregraphics/cgbitmapinfo/floatcomponents) to extract this information.
    ///
    /// - Whether an alpha channel is in the data, and if so, how the alpha data is stored. You use the constant [`alphaInfoMask`](https://developer.apple.com/documentation/coregraphics/cgbitmapinfo/alphainfomask) to extract the alpha information. Alpha information is specified as one of the constants listed in [`CGImageAlphaInfo`](https://developer.apple.com/documentation/coregraphics/cgimagealphainfo).
    ///
    /// You can extract the alpha information
    ///
    ///
    #[doc(alias = "CGImageGetBitmapInfo")]
    #[inline]
    pub fn bitmap_info(image: Option<&CGImage>) -> CGBitmapInfo {
        extern "C-unwind" {
            fn CGImageGetBitmapInfo(image: Option<&CGImage>) -> CGBitmapInfo;
        }
        unsafe { CGImageGetBitmapInfo(image) }
    }

    #[doc(alias = "CGImageGetByteOrderInfo")]
    #[inline]
    pub fn byte_order_info(image: Option<&CGImage>) -> CGImageByteOrderInfo {
        extern "C-unwind" {
            fn CGImageGetByteOrderInfo(image: Option<&CGImage>) -> CGImageByteOrderInfo;
        }
        unsafe { CGImageGetByteOrderInfo(image) }
    }

    #[doc(alias = "CGImageGetPixelFormatInfo")]
    #[inline]
    pub fn pixel_format_info(image: Option<&CGImage>) -> CGImagePixelFormatInfo {
        extern "C-unwind" {
            fn CGImageGetPixelFormatInfo(image: Option<&CGImage>) -> CGImagePixelFormatInfo;
        }
        unsafe { CGImageGetPixelFormatInfo(image) }
    }

    #[doc(alias = "CGImageShouldToneMap")]
    #[inline]
    pub fn should_tone_map(image: Option<&CGImage>) -> bool {
        extern "C-unwind" {
            fn CGImageShouldToneMap(image: Option<&CGImage>) -> bool;
        }
        unsafe { CGImageShouldToneMap(image) }
    }

    #[doc(alias = "CGImageContainsImageSpecificToneMappingMetadata")]
    #[inline]
    pub fn contains_image_specific_tone_mapping_metadata(image: Option<&CGImage>) -> bool {
        extern "C-unwind" {
            fn CGImageContainsImageSpecificToneMappingMetadata(image: Option<&CGImage>) -> bool;
        }
        unsafe { CGImageContainsImageSpecificToneMappingMetadata(image) }
    }

    /// The Universal Type Identifier for the image.
    #[doc(alias = "CGImageGetUTType")]
    #[inline]
    pub fn ut_type(image: Option<&CGImage>) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageGetUTType(image: Option<&CGImage>) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageGetUTType(image) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

#[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
#[deprecated = "renamed to `CGImage::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageCreate(
    width: usize,
    height: usize,
    bits_per_component: usize,
    bits_per_pixel: usize,
    bytes_per_row: usize,
    space: Option<&CGColorSpace>,
    bitmap_info: CGBitmapInfo,
    provider: Option<&CGDataProvider>,
    decode: *const CGFloat,
    should_interpolate: bool,
    intent: CGColorRenderingIntent,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreate(
            width: usize,
            height: usize,
            bits_per_component: usize,
            bits_per_pixel: usize,
            bytes_per_row: usize,
            space: Option<&CGColorSpace>,
            bitmap_info: CGBitmapInfo,
            provider: Option<&CGDataProvider>,
            decode: *const CGFloat,
            should_interpolate: bool,
            intent: CGColorRenderingIntent,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe {
        CGImageCreate(
            width,
            height,
            bits_per_component,
            bits_per_pixel,
            bytes_per_row,
            space,
            bitmap_info,
            provider,
            decode,
            should_interpolate,
            intent,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGDataProvider")]
#[deprecated = "renamed to `CGImage::mask_create`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMaskCreate(
    width: usize,
    height: usize,
    bits_per_component: usize,
    bits_per_pixel: usize,
    bytes_per_row: usize,
    provider: Option<&CGDataProvider>,
    decode: *const CGFloat,
    should_interpolate: bool,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageMaskCreate(
            width: usize,
            height: usize,
            bits_per_component: usize,
            bits_per_pixel: usize,
            bytes_per_row: usize,
            provider: Option<&CGDataProvider>,
            decode: *const CGFloat,
            should_interpolate: bool,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe {
        CGImageMaskCreate(
            width,
            height,
            bits_per_component,
            bits_per_pixel,
            bytes_per_row,
            provider,
            decode,
            should_interpolate,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::new_copy`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateCopy(image: Option<&CGImage>) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateCopy(image: Option<&CGImage>) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateCopy(image) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
#[deprecated = "renamed to `CGImage::with_jpeg_data_provider`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageCreateWithJPEGDataProvider(
    source: Option<&CGDataProvider>,
    decode: *const CGFloat,
    should_interpolate: bool,
    intent: CGColorRenderingIntent,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateWithJPEGDataProvider(
            source: Option<&CGDataProvider>,
            decode: *const CGFloat,
            should_interpolate: bool,
            intent: CGColorRenderingIntent,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret =
        unsafe { CGImageCreateWithJPEGDataProvider(source, decode, should_interpolate, intent) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
#[deprecated = "renamed to `CGImage::with_png_data_provider`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageCreateWithPNGDataProvider(
    source: Option<&CGDataProvider>,
    decode: *const CGFloat,
    should_interpolate: bool,
    intent: CGColorRenderingIntent,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateWithPNGDataProvider(
            source: Option<&CGDataProvider>,
            decode: *const CGFloat,
            should_interpolate: bool,
            intent: CGColorRenderingIntent,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret =
        unsafe { CGImageCreateWithPNGDataProvider(source, decode, should_interpolate, intent) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::with_image_in_rect`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateWithImageInRect(
    image: Option<&CGImage>,
    rect: CGRect,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateWithImageInRect(
            image: Option<&CGImage>,
            rect: CGRect,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateWithImageInRect(image, rect) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::with_mask`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateWithMask(
    image: Option<&CGImage>,
    mask: Option<&CGImage>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateWithMask(
            image: Option<&CGImage>,
            mask: Option<&CGImage>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateWithMask(image, mask) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::with_masking_colors`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageCreateWithMaskingColors(
    image: Option<&CGImage>,
    components: *const CGFloat,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateWithMaskingColors(
            image: Option<&CGImage>,
            components: *const CGFloat,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateWithMaskingColors(image, components) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGImage::new_copy_with_color_space`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateCopyWithColorSpace(
    image: Option<&CGImage>,
    space: Option<&CGColorSpace>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateCopyWithColorSpace(
            image: Option<&CGImage>,
            space: Option<&CGColorSpace>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateCopyWithColorSpace(image, space) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGColorSpace", feature = "CGDataProvider"))]
#[deprecated = "renamed to `CGImage::with_content_headroom`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageCreateWithContentHeadroom(
    headroom: c_float,
    width: usize,
    height: usize,
    bits_per_component: usize,
    bits_per_pixel: usize,
    bytes_per_row: usize,
    space: Option<&CGColorSpace>,
    bitmap_info: CGBitmapInfo,
    provider: Option<&CGDataProvider>,
    decode: *const CGFloat,
    should_interpolate: bool,
    intent: CGColorRenderingIntent,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateWithContentHeadroom(
            headroom: c_float,
            width: usize,
            height: usize,
            bits_per_component: usize,
            bits_per_pixel: usize,
            bytes_per_row: usize,
            space: Option<&CGColorSpace>,
            bitmap_info: CGBitmapInfo,
            provider: Option<&CGDataProvider>,
            decode: *const CGFloat,
            should_interpolate: bool,
            intent: CGColorRenderingIntent,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe {
        CGImageCreateWithContentHeadroom(
            headroom,
            width,
            height,
            bits_per_component,
            bits_per_pixel,
            bytes_per_row,
            space,
            bitmap_info,
            provider,
            decode,
            should_interpolate,
            intent,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::new_copy_with_content_headroom`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateCopyWithContentHeadroom(
    headroom: c_float,
    image: Option<&CGImage>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateCopyWithContentHeadroom(
            headroom: c_float,
            image: Option<&CGImage>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateCopyWithContentHeadroom(headroom, image) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::content_headroom`"]
#[inline]
pub extern "C-unwind" fn CGImageGetContentHeadroom(image: Option<&CGImage>) -> c_float {
    extern "C-unwind" {
        fn CGImageGetContentHeadroom(image: Option<&CGImage>) -> c_float;
    }
    unsafe { CGImageGetContentHeadroom(image) }
}

#[deprecated = "renamed to `CGImage::calculate_content_headroom`"]
#[inline]
pub extern "C-unwind" fn CGImageCalculateContentHeadroom(image: Option<&CGImage>) -> c_float {
    extern "C-unwind" {
        fn CGImageCalculateContentHeadroom(image: Option<&CGImage>) -> c_float;
    }
    unsafe { CGImageCalculateContentHeadroom(image) }
}

#[deprecated = "renamed to `CGImage::content_average_light_level`"]
#[inline]
pub extern "C-unwind" fn CGImageGetContentAverageLightLevel(image: Option<&CGImage>) -> c_float {
    extern "C-unwind" {
        fn CGImageGetContentAverageLightLevel(image: Option<&CGImage>) -> c_float;
    }
    unsafe { CGImageGetContentAverageLightLevel(image) }
}

#[deprecated = "renamed to `CGImage::calculate_content_average_light_level`"]
#[inline]
pub extern "C-unwind" fn CGImageCalculateContentAverageLightLevel(
    image: Option<&CGImage>,
) -> c_float {
    extern "C-unwind" {
        fn CGImageCalculateContentAverageLightLevel(image: Option<&CGImage>) -> c_float;
    }
    unsafe { CGImageCalculateContentAverageLightLevel(image) }
}

#[deprecated = "renamed to `CGImage::new_copy_with_content_average_light_level`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateCopyWithContentAverageLightLevel(
    image: Option<&CGImage>,
    avll: c_float,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateCopyWithContentAverageLightLevel(
            image: Option<&CGImage>,
            avll: c_float,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateCopyWithContentAverageLightLevel(image, avll) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::new_copy_with_calculated_hdr_stats`"]
#[inline]
pub extern "C-unwind" fn CGImageCreateCopyWithCalculatedHDRStats(
    image: Option<&CGImage>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageCreateCopyWithCalculatedHDRStats(
            image: Option<&CGImage>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageCreateCopyWithCalculatedHDRStats(image) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImage::is_mask`"]
#[inline]
pub extern "C-unwind" fn CGImageIsMask(image: Option<&CGImage>) -> bool {
    extern "C-unwind" {
        fn CGImageIsMask(image: Option<&CGImage>) -> bool;
    }
    unsafe { CGImageIsMask(image) }
}

#[deprecated = "renamed to `CGImage::width`"]
#[inline]
pub extern "C-unwind" fn CGImageGetWidth(image: Option<&CGImage>) -> usize {
    extern "C-unwind" {
        fn CGImageGetWidth(image: Option<&CGImage>) -> usize;
    }
    unsafe { CGImageGetWidth(image) }
}

#[deprecated = "renamed to `CGImage::height`"]
#[inline]
pub extern "C-unwind" fn CGImageGetHeight(image: Option<&CGImage>) -> usize {
    extern "C-unwind" {
        fn CGImageGetHeight(image: Option<&CGImage>) -> usize;
    }
    unsafe { CGImageGetHeight(image) }
}

#[deprecated = "renamed to `CGImage::bits_per_component`"]
#[inline]
pub extern "C-unwind" fn CGImageGetBitsPerComponent(image: Option<&CGImage>) -> usize {
    extern "C-unwind" {
        fn CGImageGetBitsPerComponent(image: Option<&CGImage>) -> usize;
    }
    unsafe { CGImageGetBitsPerComponent(image) }
}

#[deprecated = "renamed to `CGImage::bits_per_pixel`"]
#[inline]
pub extern "C-unwind" fn CGImageGetBitsPerPixel(image: Option<&CGImage>) -> usize {
    extern "C-unwind" {
        fn CGImageGetBitsPerPixel(image: Option<&CGImage>) -> usize;
    }
    unsafe { CGImageGetBitsPerPixel(image) }
}

#[deprecated = "renamed to `CGImage::bytes_per_row`"]
#[inline]
pub extern "C-unwind" fn CGImageGetBytesPerRow(image: Option<&CGImage>) -> usize {
    extern "C-unwind" {
        fn CGImageGetBytesPerRow(image: Option<&CGImage>) -> usize;
    }
    unsafe { CGImageGetBytesPerRow(image) }
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGImage::color_space`"]
#[inline]
pub extern "C-unwind" fn CGImageGetColorSpace(
    image: Option<&CGImage>,
) -> Option<CFRetained<CGColorSpace>> {
    extern "C-unwind" {
        fn CGImageGetColorSpace(image: Option<&CGImage>) -> Option<NonNull<CGColorSpace>>;
    }
    let ret = unsafe { CGImageGetColorSpace(image) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CGImage::alpha_info`"]
#[inline]
pub extern "C-unwind" fn CGImageGetAlphaInfo(image: Option<&CGImage>) -> CGImageAlphaInfo {
    extern "C-unwind" {
        fn CGImageGetAlphaInfo(image: Option<&CGImage>) -> CGImageAlphaInfo;
    }
    unsafe { CGImageGetAlphaInfo(image) }
}

#[cfg(feature = "CGDataProvider")]
#[deprecated = "renamed to `CGImage::data_provider`"]
#[inline]
pub extern "C-unwind" fn CGImageGetDataProvider(
    image: Option<&CGImage>,
) -> Option<CFRetained<CGDataProvider>> {
    extern "C-unwind" {
        fn CGImageGetDataProvider(image: Option<&CGImage>) -> Option<NonNull<CGDataProvider>>;
    }
    let ret = unsafe { CGImageGetDataProvider(image) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CGImage::decode`"]
#[inline]
pub extern "C-unwind" fn CGImageGetDecode(image: Option<&CGImage>) -> *const CGFloat {
    extern "C-unwind" {
        fn CGImageGetDecode(image: Option<&CGImage>) -> *const CGFloat;
    }
    unsafe { CGImageGetDecode(image) }
}

#[deprecated = "renamed to `CGImage::should_interpolate`"]
#[inline]
pub extern "C-unwind" fn CGImageGetShouldInterpolate(image: Option<&CGImage>) -> bool {
    extern "C-unwind" {
        fn CGImageGetShouldInterpolate(image: Option<&CGImage>) -> bool;
    }
    unsafe { CGImageGetShouldInterpolate(image) }
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGImage::rendering_intent`"]
#[inline]
pub extern "C-unwind" fn CGImageGetRenderingIntent(
    image: Option<&CGImage>,
) -> CGColorRenderingIntent {
    extern "C-unwind" {
        fn CGImageGetRenderingIntent(image: Option<&CGImage>) -> CGColorRenderingIntent;
    }
    unsafe { CGImageGetRenderingIntent(image) }
}

#[deprecated = "renamed to `CGImage::bitmap_info`"]
#[inline]
pub extern "C-unwind" fn CGImageGetBitmapInfo(image: Option<&CGImage>) -> CGBitmapInfo {
    extern "C-unwind" {
        fn CGImageGetBitmapInfo(image: Option<&CGImage>) -> CGBitmapInfo;
    }
    unsafe { CGImageGetBitmapInfo(image) }
}

#[deprecated = "renamed to `CGImage::byte_order_info`"]
#[inline]
pub extern "C-unwind" fn CGImageGetByteOrderInfo(image: Option<&CGImage>) -> CGImageByteOrderInfo {
    extern "C-unwind" {
        fn CGImageGetByteOrderInfo(image: Option<&CGImage>) -> CGImageByteOrderInfo;
    }
    unsafe { CGImageGetByteOrderInfo(image) }
}

#[deprecated = "renamed to `CGImage::pixel_format_info`"]
#[inline]
pub extern "C-unwind" fn CGImageGetPixelFormatInfo(
    image: Option<&CGImage>,
) -> CGImagePixelFormatInfo {
    extern "C-unwind" {
        fn CGImageGetPixelFormatInfo(image: Option<&CGImage>) -> CGImagePixelFormatInfo;
    }
    unsafe { CGImageGetPixelFormatInfo(image) }
}

#[deprecated = "renamed to `CGImage::should_tone_map`"]
#[inline]
pub extern "C-unwind" fn CGImageShouldToneMap(image: Option<&CGImage>) -> bool {
    extern "C-unwind" {
        fn CGImageShouldToneMap(image: Option<&CGImage>) -> bool;
    }
    unsafe { CGImageShouldToneMap(image) }
}

#[deprecated = "renamed to `CGImage::contains_image_specific_tone_mapping_metadata`"]
#[inline]
pub extern "C-unwind" fn CGImageContainsImageSpecificToneMappingMetadata(
    image: Option<&CGImage>,
) -> bool {
    extern "C-unwind" {
        fn CGImageContainsImageSpecificToneMappingMetadata(image: Option<&CGImage>) -> bool;
    }
    unsafe { CGImageContainsImageSpecificToneMappingMetadata(image) }
}

#[deprecated = "renamed to `CGImage::ut_type`"]
#[inline]
pub extern "C-unwind" fn CGImageGetUTType(image: Option<&CGImage>) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageGetUTType(image: Option<&CGImage>) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageGetUTType(image) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}
