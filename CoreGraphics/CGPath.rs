//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgmutablepath?language=objc)
#[doc(alias = "CGMutablePathRef")]
#[repr(C)]
pub struct CGMutablePath {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGMutablePath: CGPath {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGPath"> for CGMutablePath {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpath?language=objc)
#[doc(alias = "CGPathRef")]
#[repr(C)]
pub struct CGPath {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGPath {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGPath"> for CGPath {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cglinejoin?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGLineJoin(pub i32);
impl CGLineJoin {
    #[doc(alias = "kCGLineJoinMiter")]
    pub const Miter: Self = Self(0);
    #[doc(alias = "kCGLineJoinRound")]
    pub const Round: Self = Self(1);
    #[doc(alias = "kCGLineJoinBevel")]
    pub const Bevel: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGLineJoin {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGLineJoin {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cglinecap?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGLineCap(pub i32);
impl CGLineCap {
    #[doc(alias = "kCGLineCapButt")]
    pub const Butt: Self = Self(0);
    #[doc(alias = "kCGLineCapRound")]
    pub const Round: Self = Self(1);
    #[doc(alias = "kCGLineCapSquare")]
    pub const Square: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGLineCap {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGLineCap {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CGPath {
    #[doc(alias = "CGPathGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGPathGetTypeID() -> CFTypeID;
        }
        unsafe { CGPathGetTypeID() }
    }
}

impl CGMutablePath {
    #[doc(alias = "CGPathCreateMutable")]
    #[inline]
    pub fn new() -> CFRetained<CGMutablePath> {
        extern "C-unwind" {
            fn CGPathCreateMutable() -> Option<NonNull<CGMutablePath>>;
        }
        let ret = unsafe { CGPathCreateMutable() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

impl CGPath {
    #[doc(alias = "CGPathCreateCopy")]
    #[inline]
    pub fn copy(&self) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopy(path: &CGPath) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopy(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateCopyByTransformingPath")]
    #[inline]
    pub unsafe fn copy_by_transforming_path(
        &self,
        transform: *const CGAffineTransform,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByTransformingPath(
                path: &CGPath,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByTransformingPath(self, transform) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGMutablePath {
    #[doc(alias = "CGPathCreateMutableCopy")]
    #[inline]
    pub fn new_copy(path: &CGPath) -> Option<CFRetained<CGMutablePath>> {
        extern "C-unwind" {
            fn CGPathCreateMutableCopy(path: &CGPath) -> Option<NonNull<CGMutablePath>>;
        }
        let ret = unsafe { CGPathCreateMutableCopy(path) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateMutableCopyByTransformingPath")]
    #[inline]
    pub unsafe fn new_copy_by_transforming_path(
        path: &CGPath,
        transform: *const CGAffineTransform,
    ) -> Option<CFRetained<CGMutablePath>> {
        extern "C-unwind" {
            fn CGPathCreateMutableCopyByTransformingPath(
                path: &CGPath,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGMutablePath>>;
        }
        let ret = unsafe { CGPathCreateMutableCopyByTransformingPath(path, transform) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGPath {
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateWithRect")]
    #[inline]
    pub unsafe fn with_rect(
        rect: CGRect,
        transform: *const CGAffineTransform,
    ) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CGPathCreateWithRect(
                rect: CGRect,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateWithRect(rect, transform) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateWithEllipseInRect")]
    #[inline]
    pub unsafe fn with_ellipse_in_rect(
        rect: CGRect,
        transform: *const CGAffineTransform,
    ) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CGPathCreateWithEllipseInRect(
                rect: CGRect,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateWithEllipseInRect(rect, transform) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateWithRoundedRect")]
    #[inline]
    pub unsafe fn with_rounded_rect(
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
        transform: *const CGAffineTransform,
    ) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CGPathCreateWithRoundedRect(
                rect: CGRect,
                corner_width: CGFloat,
                corner_height: CGFloat,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret =
            unsafe { CGPathCreateWithRoundedRect(rect, corner_width, corner_height, transform) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

impl CGMutablePath {
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRoundedRect")]
    #[inline]
    pub unsafe fn add_rounded_rect(
        &self,
        transform: *const CGAffineTransform,
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddRoundedRect(
                path: &CGMutablePath,
                transform: *const CGAffineTransform,
                rect: CGRect,
                corner_width: CGFloat,
                corner_height: CGFloat,
            );
        }
        unsafe { CGPathAddRoundedRect(self, transform, rect, corner_width, corner_height) }
    }
}

impl CGPath {
    /// # Safety
    ///
    /// - `transform` must be a valid pointer or null.
    /// - `lengths` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateCopyByDashingPath")]
    #[inline]
    pub unsafe fn copy_by_dashing_path(
        &self,
        transform: *const CGAffineTransform,
        phase: CGFloat,
        lengths: *const CGFloat,
        count: usize,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByDashingPath(
                path: &CGPath,
                transform: *const CGAffineTransform,
                phase: CGFloat,
                lengths: *const CGFloat,
                count: usize,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByDashingPath(self, transform, phase, lengths, count) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateCopyByStrokingPath")]
    #[inline]
    pub unsafe fn copy_by_stroking_path(
        &self,
        transform: *const CGAffineTransform,
        line_width: CGFloat,
        line_cap: CGLineCap,
        line_join: CGLineJoin,
        miter_limit: CGFloat,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByStrokingPath(
                path: &CGPath,
                transform: *const CGAffineTransform,
                line_width: CGFloat,
                line_cap: CGLineCap,
                line_join: CGLineJoin,
                miter_limit: CGFloat,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe {
            CGPathCreateCopyByStrokingPath(
                self,
                transform,
                line_width,
                line_cap,
                line_join,
                miter_limit,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathEqualToPath")]
    #[inline]
    pub fn equal_to_path(&self, path2: &CGPath) -> bool {
        extern "C-unwind" {
            fn CGPathEqualToPath(path1: &CGPath, path2: &CGPath) -> bool;
        }
        unsafe { CGPathEqualToPath(self, path2) }
    }
}

impl CGMutablePath {
    /// * Path construction functions. **
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathMoveToPoint")]
    #[inline]
    pub unsafe fn move_to_point(&self, m: *const CGAffineTransform, x: CGFloat, y: CGFloat) {
        extern "C-unwind" {
            fn CGPathMoveToPoint(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathMoveToPoint(self, m, x, y) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddLineToPoint")]
    #[inline]
    pub unsafe fn add_line_to_point(&self, m: *const CGAffineTransform, x: CGFloat, y: CGFloat) {
        extern "C-unwind" {
            fn CGPathAddLineToPoint(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathAddLineToPoint(self, m, x, y) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddQuadCurveToPoint")]
    #[inline]
    pub unsafe fn add_quad_curve_to_point(
        &self,
        m: *const CGAffineTransform,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddQuadCurveToPoint(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                cpx: CGFloat,
                cpy: CGFloat,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathAddQuadCurveToPoint(self, m, cpx, cpy, x, y) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddCurveToPoint")]
    #[inline]
    pub unsafe fn add_curve_to_point(
        &self,
        m: *const CGAffineTransform,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddCurveToPoint(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                cp1x: CGFloat,
                cp1y: CGFloat,
                cp2x: CGFloat,
                cp2y: CGFloat,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathAddCurveToPoint(self, m, cp1x, cp1y, cp2x, cp2y, x, y) }
    }

    #[doc(alias = "CGPathCloseSubpath")]
    #[inline]
    pub fn close_subpath(&self) {
        extern "C-unwind" {
            fn CGPathCloseSubpath(path: &CGMutablePath);
        }
        unsafe { CGPathCloseSubpath(self) }
    }

    /// * Path construction convenience functions. **
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRect")]
    #[inline]
    pub unsafe fn add_rect(&self, m: *const CGAffineTransform, rect: CGRect) {
        extern "C-unwind" {
            fn CGPathAddRect(path: &CGMutablePath, m: *const CGAffineTransform, rect: CGRect);
        }
        unsafe { CGPathAddRect(self, m, rect) }
    }

    /// # Safety
    ///
    /// - `m` must be a valid pointer or null.
    /// - `rects` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRects")]
    #[inline]
    pub unsafe fn add_rects(
        &self,
        m: *const CGAffineTransform,
        rects: *const CGRect,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGPathAddRects(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                rects: *const CGRect,
                count: usize,
            );
        }
        unsafe { CGPathAddRects(self, m, rects, count) }
    }

    /// # Safety
    ///
    /// - `m` must be a valid pointer or null.
    /// - `points` must be a valid pointer or null.
    #[doc(alias = "CGPathAddLines")]
    #[inline]
    pub unsafe fn add_lines(
        &self,
        m: *const CGAffineTransform,
        points: *const CGPoint,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGPathAddLines(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                points: *const CGPoint,
                count: usize,
            );
        }
        unsafe { CGPathAddLines(self, m, points, count) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddEllipseInRect")]
    #[inline]
    pub unsafe fn add_ellipse_in_rect(&self, m: *const CGAffineTransform, rect: CGRect) {
        extern "C-unwind" {
            fn CGPathAddEllipseInRect(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                rect: CGRect,
            );
        }
        unsafe { CGPathAddEllipseInRect(self, m, rect) }
    }

    /// # Safety
    ///
    /// `matrix` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRelativeArc")]
    #[inline]
    pub unsafe fn add_relative_arc(
        &self,
        matrix: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        delta: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddRelativeArc(
                path: &CGMutablePath,
                matrix: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
                radius: CGFloat,
                start_angle: CGFloat,
                delta: CGFloat,
            );
        }
        unsafe { CGPathAddRelativeArc(self, matrix, x, y, radius, start_angle, delta) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddArc")]
    #[inline]
    pub unsafe fn add_arc(
        &self,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: bool,
    ) {
        extern "C-unwind" {
            fn CGPathAddArc(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
                radius: CGFloat,
                start_angle: CGFloat,
                end_angle: CGFloat,
                clockwise: bool,
            );
        }
        unsafe { CGPathAddArc(self, m, x, y, radius, start_angle, end_angle, clockwise) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddArcToPoint")]
    #[inline]
    pub unsafe fn add_arc_to_point(
        &self,
        m: *const CGAffineTransform,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddArcToPoint(
                path: &CGMutablePath,
                m: *const CGAffineTransform,
                x1: CGFloat,
                y1: CGFloat,
                x2: CGFloat,
                y2: CGFloat,
                radius: CGFloat,
            );
        }
        unsafe { CGPathAddArcToPoint(self, m, x1, y1, x2, y2, radius) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddPath")]
    #[inline]
    pub unsafe fn add_path(&self, m: *const CGAffineTransform, path2: &CGPath) {
        extern "C-unwind" {
            fn CGPathAddPath(path1: &CGMutablePath, m: *const CGAffineTransform, path2: &CGPath);
        }
        unsafe { CGPathAddPath(self, m, path2) }
    }
}

impl CGPath {
    /// * Path information functions. **
    #[doc(alias = "CGPathIsEmpty")]
    #[inline]
    pub fn is_empty(&self) -> bool {
        extern "C-unwind" {
            fn CGPathIsEmpty(path: &CGPath) -> bool;
        }
        unsafe { CGPathIsEmpty(self) }
    }

    /// # Safety
    ///
    /// `rect` must be a valid pointer or null.
    #[doc(alias = "CGPathIsRect")]
    #[inline]
    pub unsafe fn is_rect(&self, rect: *mut CGRect) -> bool {
        extern "C-unwind" {
            fn CGPathIsRect(path: &CGPath, rect: *mut CGRect) -> bool;
        }
        unsafe { CGPathIsRect(self, rect) }
    }

    #[doc(alias = "CGPathGetCurrentPoint")]
    #[inline]
    pub fn current_point(&self) -> CGPoint {
        extern "C-unwind" {
            fn CGPathGetCurrentPoint(path: &CGPath) -> CGPoint;
        }
        unsafe { CGPathGetCurrentPoint(self) }
    }

    #[doc(alias = "CGPathGetBoundingBox")]
    #[inline]
    pub fn bounding_box(&self) -> CGRect {
        extern "C-unwind" {
            fn CGPathGetBoundingBox(path: &CGPath) -> CGRect;
        }
        unsafe { CGPathGetBoundingBox(self) }
    }

    #[doc(alias = "CGPathGetPathBoundingBox")]
    #[inline]
    pub fn path_bounding_box(&self) -> CGRect {
        extern "C-unwind" {
            fn CGPathGetPathBoundingBox(path: &CGPath) -> CGRect;
        }
        unsafe { CGPathGetPathBoundingBox(self) }
    }

    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathContainsPoint")]
    #[inline]
    pub unsafe fn contains_point(
        &self,
        m: *const CGAffineTransform,
        point: CGPoint,
        eo_fill: bool,
    ) -> bool {
        extern "C-unwind" {
            fn CGPathContainsPoint(
                path: &CGPath,
                m: *const CGAffineTransform,
                point: CGPoint,
                eo_fill: bool,
            ) -> bool;
        }
        unsafe { CGPathContainsPoint(self, m, point, eo_fill) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathelementtype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGPathElementType(pub i32);
impl CGPathElementType {
    #[doc(alias = "kCGPathElementMoveToPoint")]
    pub const MoveToPoint: Self = Self(0);
    #[doc(alias = "kCGPathElementAddLineToPoint")]
    pub const AddLineToPoint: Self = Self(1);
    #[doc(alias = "kCGPathElementAddQuadCurveToPoint")]
    pub const AddQuadCurveToPoint: Self = Self(2);
    #[doc(alias = "kCGPathElementAddCurveToPoint")]
    pub const AddCurveToPoint: Self = Self(3);
    #[doc(alias = "kCGPathElementCloseSubpath")]
    pub const CloseSubpath: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathElementType {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathElementType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathelement?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CGPathElement {
    pub r#type: CGPathElementType,
    pub points: NonNull<CGPoint>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathElement {
    const ENCODING: Encoding = Encoding::Struct(
        "CGPathElement",
        &[<CGPathElementType>::ENCODING, <NonNull<CGPoint>>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathElement {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathapplierfunction?language=objc)
pub type CGPathApplierFunction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, NonNull<CGPathElement>)>;

impl CGPath {
    /// # Safety
    ///
    /// - `info` must be a valid pointer or null.
    /// - `function` must be implemented correctly.
    #[doc(alias = "CGPathApply")]
    #[inline]
    pub unsafe fn apply(&self, info: *mut c_void, function: CGPathApplierFunction) {
        extern "C-unwind" {
            fn CGPathApply(path: &CGPath, info: *mut c_void, function: CGPathApplierFunction);
        }
        unsafe { CGPathApply(self, info, function) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathapplyblock?language=objc)
#[cfg(feature = "block2")]
pub type CGPathApplyBlock = *mut block2::DynBlock<dyn Fn(NonNull<CGPathElement>)>;

impl CGPath {
    /// # Safety
    ///
    /// `block` must be a valid pointer.
    #[doc(alias = "CGPathApplyWithBlock")]
    #[cfg(feature = "block2")]
    #[inline]
    pub unsafe fn apply_with_block(&self, block: CGPathApplyBlock) {
        extern "C-unwind" {
            fn CGPathApplyWithBlock(path: &CGPath, block: CGPathApplyBlock);
        }
        unsafe { CGPathApplyWithBlock(self, block) }
    }

    #[doc(alias = "CGPathCreateCopyByNormalizing")]
    #[inline]
    pub fn copy_by_normalizing(&self, even_odd_fill_rule: bool) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByNormalizing(
                path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByNormalizing(self, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyByUnioningPath")]
    #[inline]
    pub fn copy_by_unioning_path(
        &self,
        mask_path: &CGPath,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByUnioningPath(
                path: &CGPath,
                mask_path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByUnioningPath(self, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyByIntersectingPath")]
    #[inline]
    pub fn copy_by_intersecting_path(
        &self,
        mask_path: &CGPath,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByIntersectingPath(
                path: &CGPath,
                mask_path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret =
            unsafe { CGPathCreateCopyByIntersectingPath(self, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyBySubtractingPath")]
    #[inline]
    pub fn copy_by_subtracting_path(
        &self,
        mask_path: &CGPath,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyBySubtractingPath(
                path: &CGPath,
                mask_path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyBySubtractingPath(self, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyBySymmetricDifferenceOfPath")]
    #[inline]
    pub fn copy_by_symmetric_difference_of_path(
        &self,
        mask_path: &CGPath,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyBySymmetricDifferenceOfPath(
                path: &CGPath,
                mask_path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe {
            CGPathCreateCopyBySymmetricDifferenceOfPath(self, mask_path, even_odd_fill_rule)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyOfLineBySubtractingPath")]
    #[inline]
    pub fn copy_of_line_by_subtracting_path(
        &self,
        mask_path: &CGPath,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyOfLineBySubtractingPath(
                path: &CGPath,
                mask_path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret =
            unsafe { CGPathCreateCopyOfLineBySubtractingPath(self, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyOfLineByIntersectingPath")]
    #[inline]
    pub fn copy_of_line_by_intersecting_path(
        &self,
        mask_path: &CGPath,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyOfLineByIntersectingPath(
                path: &CGPath,
                mask_path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe {
            CGPathCreateCopyOfLineByIntersectingPath(self, mask_path, even_odd_fill_rule)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateSeparateComponents")]
    #[inline]
    pub fn separate_components(&self, even_odd_fill_rule: bool) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CGPathCreateSeparateComponents(
                path: &CGPath,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CGPathCreateSeparateComponents(self, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyByFlattening")]
    #[inline]
    pub fn copy_by_flattening(&self, flattening_threshold: CGFloat) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByFlattening(
                path: &CGPath,
                flattening_threshold: CGFloat,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByFlattening(self, flattening_threshold) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathIntersectsPath")]
    #[inline]
    pub fn intersects_path(&self, path2: &CGPath, even_odd_fill_rule: bool) -> bool {
        extern "C-unwind" {
            fn CGPathIntersectsPath(
                path1: &CGPath,
                path2: &CGPath,
                even_odd_fill_rule: bool,
            ) -> bool;
        }
        unsafe { CGPathIntersectsPath(self, path2, even_odd_fill_rule) }
    }
}
