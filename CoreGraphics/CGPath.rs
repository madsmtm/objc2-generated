//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A mutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
///
/// ## Overview
///
/// Neither `CGPath` nor [`CGMutablePathRef`](https://developer.apple.com/documentation/coregraphics/cgmutablepath) define functions to draw a path. To draw a Core Graphics path to a graphics context, you add the path to the graphics context by calling [`CGContextAddPath`](https://developer.apple.com/documentation/coregraphics/cgcontext/addpath(_:)) and then call one of the context’s drawing functions—see [`CGContextRef`](https://developer.apple.com/documentation/coregraphics/cgcontext).
///
/// Each figure in the graphics path is constructed with a connected set of lines and Bézier curves, called a _subpath_. A subpath has an ordered set of _path elements_ that represent single steps in the construction of the subpath. (For example, a line segment from one corner of a rectangle to another corner is a path element. Every subpath includes a _starting point_, which is the first point in the subpath. The path also maintains a _current point_, which is the last point in the last subpath.
///
/// To append a new subpath onto a mutable path, your application typically calls [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint) to set the subpath’s starting point and initial current point, followed by a series of “add” calls (such as [`CGPathAddLineToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddlinetopoint)) to add line segments and curves to the subpath. As segments or curves are added to the subpath, the subpath’s current point is updated to point to the end of the last segment or curve to be added. The lines and curves of a subpath are always connected, but they are not required to form a closed set of lines. Your application explicitly closes a subpath by calling [`CGPathCloseSubpath`](https://developer.apple.com/documentation/coregraphics/cgmutablepath/closesubpath()). Closing the subpath adds a line segment that terminates at the subpath’s starting point, and also changes how those lines are rendered—for more information see [Paths](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211) in [Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066).
///
///
#[doc(alias = "CGMutablePathRef")]
#[repr(C)]
pub struct CGMutablePath {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGMutablePath: CGPath {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGPath"> for CGMutablePath {}
);

/// An immutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
///
/// ## Overview
///
/// Neither `CGPath` nor [`CGMutablePathRef`](https://developer.apple.com/documentation/coregraphics/cgmutablepath) define functions to draw a path. To draw a Core Graphics path to a graphics context, you add the path to the graphics context by calling [`CGContextAddPath`](https://developer.apple.com/documentation/coregraphics/cgcontext/addpath(_:)) and then call one of the context’s drawing functions—see [`CGContextRef`](https://developer.apple.com/documentation/coregraphics/cgcontext).
///
/// Each figure in the graphics path is constructed with a connected set of lines and Bézier curves, called a _subpath_. A subpath has an ordered set of _path elements_ that represent single steps in the construction of the subpath. (For example, a line segment from one corner of a rectangle to another corner is a path element. Every subpath includes a _starting point_, which is the first point in the subpath. The path also maintains a _current point_, which is the last point in the last subpath.
///
///
#[doc(alias = "CGPathRef")]
#[repr(C)]
pub struct CGPath {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGPath {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGPath"> for CGPath {}
);

/// Junction types for stroked lines.
///
/// ## Overview
///
/// A line join specifies how [`CGContextStrokePath`](https://developer.apple.com/documentation/coregraphics/cgcontext/strokepath()) draws the junction between connected line segments. To set the line join style in a graphics context, you use the function [`CGContextSetLineJoin`](https://developer.apple.com/documentation/coregraphics/cgcontext/setlinejoin(_:)).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGLineJoin(pub i32);
impl CGLineJoin {
    ///
    /// ## Discussion
    ///
    /// A join with a sharp (angled) corner. Core Graphics draws the outer sides of the lines beyond the endpoint of the path, until they meet. If the length of the miter divided by the line width is greater than the miter limit, a bevel join is used instead. This is the default. To set the miter limit, see [`CGContextSetMiterLimit`](https://developer.apple.com/documentation/coregraphics/cgcontext/setmiterlimit(_:)).
    ///
    ///
    #[doc(alias = "kCGLineJoinMiter")]
    pub const Miter: Self = Self(0);
    /// A join with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
    #[doc(alias = "kCGLineJoinRound")]
    pub const Round: Self = Self(1);
    /// A join with a squared-off end. Core Graphics draws the line to extend beyond the endpoint of the path, for a distance of 1/2 the line’s width.
    #[doc(alias = "kCGLineJoinBevel")]
    pub const Bevel: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGLineJoin {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGLineJoin {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Styles for rendering the endpoint of a stroked line.
///
/// ## Overview
///
/// A line cap specifies the method used by [`CGContextStrokePath`](https://developer.apple.com/documentation/coregraphics/cgcontext/strokepath()) to draw the endpoint of the line. To change the line cap style in a graphics context, you use the function [`CGContextSetLineCap`](https://developer.apple.com/documentation/coregraphics/cgcontext/setlinecap(_:)).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGLineCap(pub i32);
impl CGLineCap {
    /// A line with a squared-off end. Core Graphics draws the line to extend only to the exact endpoint of the path. This is the default.
    #[doc(alias = "kCGLineCapButt")]
    pub const Butt: Self = Self(0);
    /// A line with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
    #[doc(alias = "kCGLineCapRound")]
    pub const Round: Self = Self(1);
    /// A line with a squared-off end. Core Graphics extends the line beyond the endpoint of the path for a distance equal to half the line width.
    #[doc(alias = "kCGLineCapSquare")]
    pub const Square: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGLineCap {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGLineCap {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CGPath {
    /// Returns the Core Foundation type identifier for Core Graphics paths.
    ///
    /// ## Return Value
    ///
    /// The Core Foundation identifier for the opaque type [`CGPathRef`](https://developer.apple.com/documentation/coregraphics/cgpath).
    ///
    ///
    #[doc(alias = "CGPathGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGPathGetTypeID() -> CFTypeID;
        }
        unsafe { CGPathGetTypeID() }
    }
}

impl CGMutablePath {
    /// Creates a mutable graphics path.
    ///
    /// ## Return Value
    ///
    /// A new mutable path. You are responsible for releasing this object.
    ///
    ///
    #[doc(alias = "CGPathCreateMutable")]
    #[inline]
    pub fn new() -> CFRetained<CGMutablePath> {
        extern "C-unwind" {
            fn CGPathCreateMutable() -> Option<NonNull<CGMutablePath>>;
        }
        let ret = unsafe { CGPathCreateMutable() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

impl CGPath {
    /// Creates an immutable copy of a graphics path.
    ///
    /// Parameters:
    /// - path: The path to copy.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable copy of the specified path. You are responsible for releasing this object.
    ///
    ///
    #[doc(alias = "CGPathCreateCopy")]
    #[inline]
    pub fn new_copy(path: Option<&CGPath>) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopy(path: Option<&CGPath>) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopy(path) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an immutable copy of a graphics path transformed by a transformation matrix.
    ///
    /// Parameters:
    /// - path: The path to copy.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable copy of the path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateCopyByTransformingPath")]
    #[inline]
    pub unsafe fn new_copy_by_transforming_path(
        path: Option<&CGPath>,
        transform: *const CGAffineTransform,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByTransformingPath(
                path: Option<&CGPath>,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByTransformingPath(path, transform) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGMutablePath {
    /// Creates a mutable copy of an existing graphics path.
    ///
    /// Parameters:
    /// - path: The path to copy.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, mutable, copy of the specified path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can modify a mutable graphics path by calling the various path geometry functions, such as [`CGPathAddArc`](https://developer.apple.com/documentation/coregraphics/cgpathaddarc), [`CGPathAddLineToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddlinetopoint), and [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint).
    ///
    ///
    #[doc(alias = "CGPathCreateMutableCopy")]
    #[inline]
    pub fn new_copy(path: Option<&CGPath>) -> Option<CFRetained<CGMutablePath>> {
        extern "C-unwind" {
            fn CGPathCreateMutableCopy(path: Option<&CGPath>) -> Option<NonNull<CGMutablePath>>;
        }
        let ret = unsafe { CGPathCreateMutableCopy(path) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a mutable copy of a graphics path transformed by a transformation matrix.
    ///
    /// Parameters:
    /// - path: The path to copy.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, mutable copy of the specified path transformed by the transform parameter. You are responsible for releasing this object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateMutableCopyByTransformingPath")]
    #[inline]
    pub unsafe fn new_copy_by_transforming_path(
        path: Option<&CGPath>,
        transform: *const CGAffineTransform,
    ) -> Option<CFRetained<CGMutablePath>> {
        extern "C-unwind" {
            fn CGPathCreateMutableCopyByTransformingPath(
                path: Option<&CGPath>,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGMutablePath>>;
        }
        let ret = unsafe { CGPathCreateMutableCopyByTransformingPath(path, transform) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGPath {
    /// Create an immutable path of a rectangle.
    ///
    /// Parameters:
    /// - rect: The rectangle to add.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that creates a path of an rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.
    ///
    /// Calling this function is equivalent to using [`CGRectGetMinX`](https://developer.apple.com/documentation/coregraphics/cgrectgetminx(_:)) and related functions to find the corners of the rectangle, then using the [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint), [`CGPathAddLineToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddlinetopoint), and [`CGPathCloseSubpath`](https://developer.apple.com/documentation/coregraphics/cgmutablepath/closesubpath()) functions to draw the rectangle.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateWithRect")]
    #[inline]
    pub unsafe fn with_rect(
        rect: CGRect,
        transform: *const CGAffineTransform,
    ) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CGPathCreateWithRect(
                rect: CGRect,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateWithRect(rect, transform) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Create an immutable path of an ellipse.
    ///
    /// Parameters:
    /// - rect: The rectangle that bounds the ellipse.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the ellipse before it is added to the path.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that creates a path of an ellipse. Using this convenience function is more efficient than creating a mutable path and adding an ellipse to it.
    ///
    /// The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the `rect` parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the `rect` parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.
    ///
    /// The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed Bézier curves that define the ellipse are transformed before they are added to the path.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateWithEllipseInRect")]
    #[inline]
    pub unsafe fn with_ellipse_in_rect(
        rect: CGRect,
        transform: *const CGAffineTransform,
    ) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CGPathCreateWithEllipseInRect(
                rect: CGRect,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateWithEllipseInRect(rect, transform) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Create an immutable path of a rounded rectangle.
    ///
    /// Parameters:
    /// - rect: The rectangle to add.
    ///
    /// - cornerWidth: The width of the rounded corner sections.
    ///
    /// - cornerHeight: The height of the rounded corner sections.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that creates a path of an rounded rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.
    ///
    /// Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the `cornerWidth` and `cornerHeight` parameters. The rounded rectangle forms a complete subpath and is oriented in the clockwise direction.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateWithRoundedRect")]
    #[inline]
    pub unsafe fn with_rounded_rect(
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
        transform: *const CGAffineTransform,
    ) -> CFRetained<CGPath> {
        extern "C-unwind" {
            fn CGPathCreateWithRoundedRect(
                rect: CGRect,
                corner_width: CGFloat,
                corner_height: CGFloat,
                transform: *const CGAffineTransform,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret =
            unsafe { CGPathCreateWithRoundedRect(rect, corner_width, corner_height, transform) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

impl CGMutablePath {
    /// Appends a rounded rectangle to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before adding it to the path.
    ///
    /// - rect: The rectangle to add.
    ///
    /// - cornerWidth: The width of the rounded corner sections.
    ///
    /// - cornerHeight: The height of the rounded corner sections.
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that adds a path of an rounded rectangle.
    ///
    /// Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the `cornerWidth` and `cornerHeight` parameters. The rounded rectangle forms a complete subpath and is oriented in the clockwise direction.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRoundedRect")]
    #[inline]
    pub unsafe fn add_rounded_rect(
        path: Option<&CGMutablePath>,
        transform: *const CGAffineTransform,
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddRoundedRect(
                path: Option<&CGMutablePath>,
                transform: *const CGAffineTransform,
                rect: CGRect,
                corner_width: CGFloat,
                corner_height: CGFloat,
            );
        }
        unsafe { CGPathAddRoundedRect(path, transform, rect, corner_width, corner_height) }
    }
}

impl CGPath {
    /// Creates a dashed copy of another path.
    ///
    /// Parameters:
    /// - path: The path to copy.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
    ///
    /// - phase: A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, passing a value of `3` means the line is drawn with the dash pattern starting at three units from its beginning. Passing a value of `0` draws a line starting with the beginning of a dash pattern.
    ///
    /// - lengths: An array of values that specify the lengths of the painted segments and unpainted segments, respectively, of the dash pattern—or `NULL` for no dash pattern.
    ///
    /// For example, passing an array with the values `[2,3]` sets a dash pattern that alternates between a 2-user-space-unit-long painted segment and a 3-user-space-unit-long unpainted segment. Passing the values `[1,3,4,2]` sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.
    ///
    /// - count: If the `lengths` parameter specifies an array, pass the number of elements in the array. Otherwise, pass `0`.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `transform` must be a valid pointer or null.
    /// - `lengths` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateCopyByDashingPath")]
    #[inline]
    pub unsafe fn new_copy_by_dashing_path(
        path: Option<&CGPath>,
        transform: *const CGAffineTransform,
        phase: CGFloat,
        lengths: *const CGFloat,
        count: usize,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByDashingPath(
                path: Option<&CGPath>,
                transform: *const CGAffineTransform,
                phase: CGFloat,
                lengths: *const CGFloat,
                count: usize,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByDashingPath(path, transform, phase, lengths, count) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a stroked copy of another path.
    ///
    /// Parameters:
    /// - path: The path to copy.
    ///
    /// - transform: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
    ///
    /// - lineWidth: The line width to use, in user space units. The value must be greater than `0`.
    ///
    /// - lineCap: A line cap style constant—[`CGLineCap.butt`](https://developer.apple.com/documentation/coregraphics/cglinecap/butt) (the default), [`CGLineCap.round`](https://developer.apple.com/documentation/coregraphics/cglinecap/round), or [`CGLineCap.square`](https://developer.apple.com/documentation/coregraphics/cglinecap/square).
    ///
    /// - lineJoin: A line join value—[`CGLineJoin.miter`](https://developer.apple.com/documentation/coregraphics/cglinejoin/miter) (the default), [`CGLineJoin.round`](https://developer.apple.com/documentation/coregraphics/cglinejoin/round), or [`CGLineJoin.bevel`](https://developer.apple.com/documentation/coregraphics/cglinejoin/bevel).
    ///
    /// - miterLimit: The miter limit to use.
    ///
    ///
    /// ## Return Value
    ///
    /// A new, immutable path. You are responsible for releasing this object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The new path is created so that filling the new path draws the same pixels as stroking the original path.
    ///
    /// If the line join style is set to `kCGLineJoinMiter`, Core Graphics uses the miter limit to determine whether the lines should be joined with a bevel instead of a miter. Core Graphics divides the length of the miter by the line width. If the result is greater than the miter limit, Core Graphics converts the style to a bevel.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `transform` must be a valid pointer or null.
    #[doc(alias = "CGPathCreateCopyByStrokingPath")]
    #[inline]
    pub unsafe fn new_copy_by_stroking_path(
        path: Option<&CGPath>,
        transform: *const CGAffineTransform,
        line_width: CGFloat,
        line_cap: CGLineCap,
        line_join: CGLineJoin,
        miter_limit: CGFloat,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByStrokingPath(
                path: Option<&CGPath>,
                transform: *const CGAffineTransform,
                line_width: CGFloat,
                line_cap: CGLineCap,
                line_join: CGLineJoin,
                miter_limit: CGFloat,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe {
            CGPathCreateCopyByStrokingPath(
                path,
                transform,
                line_width,
                line_cap,
                line_join,
                miter_limit,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Indicates whether two graphics paths are equivalent.
    ///
    /// Parameters:
    /// - path1: The first path being compared.
    ///
    /// - path2: The second path being compared.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean value that indicates whether or not the two specified paths contain the same sequence of path elements. If the paths are not the same, returns [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    #[doc(alias = "CGPathEqualToPath")]
    #[inline]
    pub fn equal_to_path(path1: Option<&CGPath>, path2: Option<&CGPath>) -> bool {
        extern "C-unwind" {
            fn CGPathEqualToPath(path1: Option<&CGPath>, path2: Option<&CGPath>) -> bool;
        }
        unsafe { CGPathEqualToPath(path1, path2) }
    }
}

impl CGMutablePath {
    /// Starts a new subpath at a specified location in a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the point before changing the path.
    ///
    /// - x: The x-coordinate of the new location.
    ///
    /// - y: The y-coordinate of the new location.
    ///
    ///
    /// ## Discussion
    ///
    /// This function ends the subpath already in progress (if any) and starts a new subpath, initializing the starting point and the current point to the specified location (x,y) after an optional transformation.
    ///
    ///
    /// * Path construction functions. **
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathMoveToPoint")]
    #[inline]
    pub unsafe fn move_to_point(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathMoveToPoint(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathMoveToPoint(path, m, x, y) }
    }

    /// Appends a line segment to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change. The path must not be empty.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the line before it is added to the path.
    ///
    /// - x: The x-coordinate of the end point of the line.
    ///
    /// - y: The y-coordinate of the end point of the line.
    ///
    ///
    /// ## Discussion
    ///
    /// Before returning, this function updates the current point to the specified location `(x,y)`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddLineToPoint")]
    #[inline]
    pub unsafe fn add_line_to_point(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddLineToPoint(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathAddLineToPoint(path, m, x, y) }
    }

    /// Appends a quadratic Bézier curve to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change. The path must not be empty.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the curve before adding it to the path.
    ///
    /// - cpx: The x-coordinate of the control point.
    ///
    /// - cpy: The y-coordinate of the control point.
    ///
    /// - x: The x-coordinate of the end point of the curve.
    ///
    /// - y: The y-coordinate of the end point of the curve.
    ///
    ///
    /// ## Discussion
    ///
    /// Before returning, this function updates the current point to the specified location `(x, y)`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddQuadCurveToPoint")]
    #[inline]
    pub unsafe fn add_quad_curve_to_point(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddQuadCurveToPoint(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                cpx: CGFloat,
                cpy: CGFloat,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathAddQuadCurveToPoint(path, m, cpx, cpy, x, y) }
    }

    /// Appends a cubic Bézier curve to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change. The path must not be empty.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the curve before it is added to the path.
    ///
    /// - cp1x: The x-coordinate of the first control point.
    ///
    /// - cp1y: The y-coordinate of the first control point.
    ///
    /// - cp2x: The x-coordinate of the second control point.
    ///
    /// - cp2y: The y-coordinate of the second control point.
    ///
    /// - x: The x-coordinate of the end point of the curve.
    ///
    /// - y: The y-coordinate of the end point of the curve.
    ///
    ///
    /// ## Discussion
    ///
    /// Appends a cubic Bézier curve from the current point in a path to the specified location using two control points, after an optional transformation. Before returning, this function updates the current point to the specified location `(x,y`).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddCurveToPoint")]
    #[inline]
    pub unsafe fn add_curve_to_point(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddCurveToPoint(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                cp1x: CGFloat,
                cp1y: CGFloat,
                cp2x: CGFloat,
                cp2y: CGFloat,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGPathAddCurveToPoint(path, m, cp1x, cp1y, cp2x, cp2y, x, y) }
    }

    /// Closes and completes a subpath in a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The path to change.
    ///
    ///
    /// ## Discussion
    ///
    /// Appends a line from the current point to the starting point of the current subpath and ends the subpath.
    ///
    /// After closing the subpath, your application can begin a new subpath without first calling [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint). In this case, a new subpath is implicitly created with a starting and current point equal to the previous subpath’s starting point.
    ///
    ///
    #[doc(alias = "CGPathCloseSubpath")]
    #[inline]
    pub fn close_subpath(path: Option<&CGMutablePath>) {
        extern "C-unwind" {
            fn CGPathCloseSubpath(path: Option<&CGMutablePath>);
        }
        unsafe { CGPathCloseSubpath(path) }
    }

    /// Appends a rectangle to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before adding it to the path.
    ///
    /// - rect: The rectangle to add.
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that adds a rectangle to a path. Calling this function is equivalent to using [`CGRectGetMinX(_:)`](https://developer.apple.com/documentation/coregraphics/cgrectgetminx(_:)) and related functions to find the corners of the rectangle, then using the [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint), [`CGPathAddLineToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddlinetopoint), and [`closeSubpath()`](https://developer.apple.com/documentation/coregraphics/cgmutablepath/closesubpath()) functions to add each line segment of the rectangle.
    ///
    ///
    /// * Path construction convenience functions. **
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRect")]
    #[inline]
    pub unsafe fn add_rect(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        rect: CGRect,
    ) {
        extern "C-unwind" {
            fn CGPathAddRect(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                rect: CGRect,
            );
        }
        unsafe { CGPathAddRect(path, m, rect) }
    }

    /// Appends an array of rectangles to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change.
    ///
    /// - m: An affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangles before adding them to the path.
    ///
    /// - rects: The array of new rectangles to add.
    ///
    /// - count: The number of elements in the array.
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that adds an array of rectangles to a path. This function is equivalent to repeatedly calling the [`CGPathAddRect`](https://developer.apple.com/documentation/coregraphics/cgpathaddrect) function to append the sequence of rectangles.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `m` must be a valid pointer or null.
    /// - `rects` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRects")]
    #[inline]
    pub unsafe fn add_rects(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        rects: *const CGRect,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGPathAddRects(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                rects: *const CGRect,
                count: usize,
            );
        }
        unsafe { CGPathAddRects(path, m, rects, count) }
    }

    /// Appends an array of new line segments to a mutable graphics path.
    ///
    /// Parameters:
    /// - path: The mutable path to change.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the lines before adding them to the path.
    ///
    /// - points: An array of points that specifies the line segments to add.
    ///
    /// - count: The number of elements in the array.
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function that adds a sequence of connected line segments to a path. This function is equivalent to calling the [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint) function to move to the starting point of the first line segment, then repeatedly calling the [`CGPathAddLineToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddlinetopoint) to append the sequence of line segments.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `m` must be a valid pointer or null.
    /// - `points` must be a valid pointer or null.
    #[doc(alias = "CGPathAddLines")]
    #[inline]
    pub unsafe fn add_lines(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        points: *const CGPoint,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGPathAddLines(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                points: *const CGPoint,
                count: usize,
            );
        }
        unsafe { CGPathAddLines(path, m, points, count) }
    }

    /// Adds to a path an ellipse that fits inside a rectangle.
    ///
    /// Parameters:
    /// - path: The path to modify.
    ///
    /// - m: An affine transform to apply to the ellipse, or `NULL` if you don’t want to transform the ellipse.
    ///
    /// - rect: A rectangle to enclose the ellipse.
    ///
    ///
    /// ## Discussion
    ///
    /// The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the `rect` parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the `rect` parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.
    ///
    /// The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed Bézier curves that define the ellipse are transformed before they are added to the path.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddEllipseInRect")]
    #[inline]
    pub unsafe fn add_ellipse_in_rect(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        rect: CGRect,
    ) {
        extern "C-unwind" {
            fn CGPathAddEllipseInRect(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                rect: CGRect,
            );
        }
        unsafe { CGPathAddEllipseInRect(path, m, rect) }
    }

    /// Appends an arc to a mutable graphics path, possibly preceded by a straight line segment.
    ///
    /// Parameters:
    /// - path: The mutable graphics path to change.
    ///
    /// - matrix: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the arc before it is added to the path.
    ///
    /// - x: The x-coordinate of the center point of the arc.
    ///
    /// - y: The y-coordinate of the center point of the arc.
    ///
    /// - radius: The radius of the arc.
    ///
    /// - startAngle: The angle (in radians) that determines the starting point of the arc, measured from the x-axis in the current user space.
    ///
    /// - delta: The distance the arc should travel (in radians). A positive value indicates a counter-clockwise arc in the current user space.
    ///
    ///
    /// ## Discussion
    ///
    /// The angle to the second endpoint of the arc is calculated by adding the delta to the start angle.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `matrix` must be a valid pointer or null.
    #[doc(alias = "CGPathAddRelativeArc")]
    #[inline]
    pub unsafe fn add_relative_arc(
        path: Option<&CGMutablePath>,
        matrix: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        delta: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddRelativeArc(
                path: Option<&CGMutablePath>,
                matrix: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
                radius: CGFloat,
                start_angle: CGFloat,
                delta: CGFloat,
            );
        }
        unsafe { CGPathAddRelativeArc(path, matrix, x, y, radius, start_angle, delta) }
    }

    /// Appends an arc to a mutable graphics path, possibly preceded by a straight line segment.
    ///
    /// Parameters:
    /// - path: The mutable graphics path to change.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the arc before it is added to the path.
    ///
    /// - x: The x-coordinate of the center point of the arc.
    ///
    /// - y: The y-coordinate of the center point of the arc.
    ///
    /// - radius: The radius of the arc.
    ///
    /// - startAngle: The angle (in radians) that determines the starting point of the arc, measured from the x-axis in the current user space.
    ///
    /// - endAngle: The angle (in radians) that determines the ending point of the arc, measured from the x-axis in the current user space.
    ///
    /// - clockwise: A Boolean value that specifies whether or not to draw the arc in the clockwise direction, before applying the transformation matrix.
    ///
    ///
    /// ## Discussion
    ///
    /// An arc is a segment of a circle with radius r centered at a point `(x,y)`. When you call this function, you provide the center point, radius, and two angles in radians. Core Graphics uses this information to determine the end points of the arc, and then approximates the new arc using a sequence of cubic Bézier curves. The `clockwise` parameter determines the direction in which the arc is created. The actual direction may change depending on the coordinate system transformation applied to the path.
    ///
    /// A transformation may be applied to the Bézier curves before they are added to the path. If no transform is needed, the second argument should be `NULL`.
    ///
    /// If the specified path already contains a subpath, Core Graphics implicitly adds a line connecting the subpath’s current point to the beginning of the arc. If the path is empty, Core Graphics creates a new subpath with a starting point set to the starting point of the arc.
    ///
    /// The ending point of the arc becomes the new current point of the path.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddArc")]
    #[inline]
    pub unsafe fn add_arc(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: bool,
    ) {
        extern "C-unwind" {
            fn CGPathAddArc(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                x: CGFloat,
                y: CGFloat,
                radius: CGFloat,
                start_angle: CGFloat,
                end_angle: CGFloat,
                clockwise: bool,
            );
        }
        unsafe { CGPathAddArc(path, m, x, y, radius, start_angle, end_angle, clockwise) }
    }

    /// Appends an arc to a mutable graphics path, possibly preceded by a straight line segment.
    ///
    /// Parameters:
    /// - path: The mutable path to change. The path must not be empty.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to the arc before it is added to the path.
    ///
    /// - x1: The x-coordinate of the user space for the end point of the first tangent line. The first tangent line is drawn from the current point to `(x1,y1)`.
    ///
    /// - y1: The y-coordinate of the user space for the end point of the first tangent line. The first tangent line is drawn from the current point to `(x1,y1)`.
    ///
    /// - x2: The x-coordinate of the user space for the end point of the second tangent line. The second tangent line is drawn from `(x1,y1)` to `(x2,y2)`.
    ///
    /// - y2: The y-coordinate of the user space for the end point of the second tangent line. The second tangent line is drawn from `(x1,y1)` to `(x2,y2)`.
    ///
    /// - radius: The radius of the arc, in user space coordinates.
    ///
    ///
    /// ## Discussion
    ///
    /// This function uses a sequence of cubic Bézier curves to create an arc that is tangent to the line from the current point to (x1,y1) and to the line from (x1,y1) to (x2,y2). The start and end points of the arc are located on the first and second tangent lines, respectively. The start and end points of the arc are also the “tangent points” of the lines.
    ///
    /// If the current point and the first tangent point of the arc (the starting point) are not equal, Core Graphics appends a straight line segment from the current point to the first tangent point.
    ///
    /// The ending point of the arc becomes the new current point of the path.
    ///
    /// For another way to draw an arc in a path, see [`CGPathAddArc`](https://developer.apple.com/documentation/coregraphics/cgpathaddarc).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddArcToPoint")]
    #[inline]
    pub unsafe fn add_arc_to_point(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGPathAddArcToPoint(
                path: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                x1: CGFloat,
                y1: CGFloat,
                x2: CGFloat,
                y2: CGFloat,
                radius: CGFloat,
            );
        }
        unsafe { CGPathAddArcToPoint(path, m, x1, y1, x2, y2, radius) }
    }

    /// Appends a path to onto a mutable graphics path.
    ///
    /// Parameters:
    /// - path1: The mutable path to change.
    ///
    /// - m: A pointer to an affine transformation matrix, or `NULL` if no transformation is needed. If specified, Core Graphics applies the transformation to `path2` before it is added to `path1`.
    ///
    /// - path2: The path to add.
    ///
    ///
    /// ## Discussion
    ///
    /// If the source path is non-empty, then its path elements are appended in order onto the mutable path. After the call completes, the start point and current point of the path are those of the last subpath in `path2`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathAddPath")]
    #[inline]
    pub unsafe fn add_path(
        path1: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        path2: Option<&CGPath>,
    ) {
        extern "C-unwind" {
            fn CGPathAddPath(
                path1: Option<&CGMutablePath>,
                m: *const CGAffineTransform,
                path2: Option<&CGPath>,
            );
        }
        unsafe { CGPathAddPath(path1, m, path2) }
    }
}

impl CGPath {
    /// Indicates whether or not a graphics path is empty.
    ///
    /// Parameters:
    /// - path: The path to evaluate.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean value that indicates whether the specified path is empty.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// An empty path contains no elements.
    ///
    ///
    /// * Path information functions. **
    #[doc(alias = "CGPathIsEmpty")]
    #[inline]
    pub fn is_empty(path: Option<&CGPath>) -> bool {
        extern "C-unwind" {
            fn CGPathIsEmpty(path: Option<&CGPath>) -> bool;
        }
        unsafe { CGPathIsEmpty(path) }
    }

    /// Indicates whether or not a graphics path represents a rectangle.
    ///
    /// Parameters:
    /// - path: The path to evaluate.
    ///
    /// - rect: On input, a pointer to an uninitialized rectangle. If the specified path represents a rectangle, on return contains a copy of the rectangle.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean value that indicates whether the specified path represents a rectangle. If the path represents a rectangle, returns [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `rect` must be a valid pointer or null.
    #[doc(alias = "CGPathIsRect")]
    #[inline]
    pub unsafe fn is_rect(path: Option<&CGPath>, rect: *mut CGRect) -> bool {
        extern "C-unwind" {
            fn CGPathIsRect(path: Option<&CGPath>, rect: *mut CGRect) -> bool;
        }
        unsafe { CGPathIsRect(path, rect) }
    }

    /// Returns the current point in a graphics path.
    ///
    /// Parameters:
    /// - path: The path to evaluate.
    ///
    ///
    /// ## Return Value
    ///
    /// The current point in the specified path.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the path is empty—that is, if it has no elements—this function returns [`CGPointZero`](https://developer.apple.com/documentation/coregraphics/cgpointzero) (see [CGGeometry](https://developer.apple.com/documentation/coregraphics/cggeometry)). To determine whether a path is empty, use [`CGPathIsEmpty`](https://developer.apple.com/documentation/coregraphics/cgpath/isempty).
    ///
    ///
    #[doc(alias = "CGPathGetCurrentPoint")]
    #[inline]
    pub fn current_point(path: Option<&CGPath>) -> CGPoint {
        extern "C-unwind" {
            fn CGPathGetCurrentPoint(path: Option<&CGPath>) -> CGPoint;
        }
        unsafe { CGPathGetCurrentPoint(path) }
    }

    /// Returns the bounding box containing all points in a graphics path.
    ///
    /// Parameters:
    /// - path: The graphics path to evaluate.
    ///
    ///
    /// ## Return Value
    ///
    /// A rectangle that represents the bounding box of the specified path.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The bounding box is the smallest rectangle completely enclosing all points in the path, including control points for Bézier and quadratic curves. If the path is empty, this value is [`CGRectNull`](https://developer.apple.com/documentation/coregraphics/cgrectnull).
    ///
    ///
    #[doc(alias = "CGPathGetBoundingBox")]
    #[inline]
    pub fn bounding_box(path: Option<&CGPath>) -> CGRect {
        extern "C-unwind" {
            fn CGPathGetBoundingBox(path: Option<&CGPath>) -> CGRect;
        }
        unsafe { CGPathGetBoundingBox(path) }
    }

    /// Returns the bounding box of a graphics path.
    ///
    /// Parameters:
    /// - path: The graphics path to evaluate.
    ///
    ///
    /// ## Return Value
    ///
    /// A rectangle that represents the path bounding box of the specified path.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The path bounding box is the smallest rectangle completely enclosing all points in the path but not including control points for Bézier and quadratic curves. If the path is empty, this value is [`CGRectNull`](https://developer.apple.com/documentation/coregraphics/cgrectnull).
    ///
    ///
    #[doc(alias = "CGPathGetPathBoundingBox")]
    #[inline]
    pub fn path_bounding_box(path: Option<&CGPath>) -> CGRect {
        extern "C-unwind" {
            fn CGPathGetPathBoundingBox(path: Option<&CGPath>) -> CGRect;
        }
        unsafe { CGPathGetPathBoundingBox(path) }
    }

    /// Checks whether a point is contained in a graphics path.
    ///
    /// Parameters:
    /// - path: The path to evaluate the point against.
    ///
    /// - m: An affine transform. If `m` is not `NULL` then the point is transformed by this affine transform prior to determining whether the path contains the point.
    ///
    /// - point: The point to check.
    ///
    /// - eoFill: A Boolean value that, if [`true`](https://developer.apple.com/documentation/swift/true), specifies to use the even-odd fill rule to evaluate the painted region of the path. If [`false`](https://developer.apple.com/documentation/swift/false), the winding fill rule is used.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns [`true`](https://developer.apple.com/documentation/swift/true) if the point is contained in the path; [`false`](https://developer.apple.com/documentation/swift/false) otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A point is contained in a path if it would be inside the painted region when the path is filled.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `m` must be a valid pointer or null.
    #[doc(alias = "CGPathContainsPoint")]
    #[inline]
    pub unsafe fn contains_point(
        path: Option<&CGPath>,
        m: *const CGAffineTransform,
        point: CGPoint,
        eo_fill: bool,
    ) -> bool {
        extern "C-unwind" {
            fn CGPathContainsPoint(
                path: Option<&CGPath>,
                m: *const CGAffineTransform,
                point: CGPoint,
                eo_fill: bool,
            ) -> bool;
        }
        unsafe { CGPathContainsPoint(path, m, point, eo_fill) }
    }
}

/// The type of element found in a path.
///
/// ## Overview
///
/// For more information about paths, see [`CGPathRef`](https://developer.apple.com/documentation/coregraphics/cgpath).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGPathElementType(pub i32);
impl CGPathElementType {
    /// The path element that starts a new subpath.
    ///
    /// ## Discussion
    ///
    /// The element holds a single point for the destination. See the function [`CGPathMoveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathmovetopoint).
    ///
    ///
    #[doc(alias = "kCGPathElementMoveToPoint")]
    pub const MoveToPoint: Self = Self(0);
    /// The path element that adds a line from the current point to a new point.
    ///
    /// ## Discussion
    ///
    /// The element holds a single point for the destination. See the function [`CGPathAddLineToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddlinetopoint).
    ///
    ///
    #[doc(alias = "kCGPathElementAddLineToPoint")]
    pub const AddLineToPoint: Self = Self(1);
    /// The path element that adds a quadratic curve from the current point to the specified point.
    ///
    /// ## Discussion
    ///
    /// The element holds a control point and a destination point. See the function [`CGPathAddQuadCurveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddquadcurvetopoint).
    ///
    ///
    #[doc(alias = "kCGPathElementAddQuadCurveToPoint")]
    pub const AddQuadCurveToPoint: Self = Self(2);
    /// The path element that adds a cubic curve from the current point to the specified point.
    ///
    /// ## Discussion
    ///
    /// The element holds two control points and a destination point. See the function [`CGPathAddCurveToPoint`](https://developer.apple.com/documentation/coregraphics/cgpathaddcurvetopoint).
    ///
    ///
    #[doc(alias = "kCGPathElementAddCurveToPoint")]
    pub const AddCurveToPoint: Self = Self(3);
    /// The path element that closes and completes a subpath. The element does not contain any points. See the function [`CGPathCloseSubpath`](https://developer.apple.com/documentation/coregraphics/cgmutablepath/closesubpath()).
    #[doc(alias = "kCGPathElementCloseSubpath")]
    pub const CloseSubpath: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathElementType {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathElementType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A data structure that provides information about a path element.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CGPathElement {
    pub r#type: CGPathElementType,
    pub points: NonNull<CGPoint>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathElement {
    const ENCODING: Encoding = Encoding::Struct(
        "CGPathElement",
        &[<CGPathElementType>::ENCODING, <NonNull<CGPoint>>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathElement {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Defines a callback function that can view an element in a graphics path.
///
/// ## Discussion
///
/// See also [`CGPathApply`](https://developer.apple.com/documentation/coregraphics/cgpath/apply(info:function:)).
///
///
pub type CGPathApplierFunction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, NonNull<CGPathElement>)>;

impl CGPath {
    /// For each element in a graphics path, calls a custom applier function.
    ///
    /// Parameters:
    /// - path: The path to which the function will be applied.
    ///
    /// - info: A pointer to the user data that Core Graphics will pass to the function being applied, or `NULL`.
    ///
    /// - function: A pointer to the function to apply. See [`CGPathApplierFunction`](https://developer.apple.com/documentation/coregraphics/cgpathapplierfunction) for more information.
    ///
    ///
    /// ## Discussion
    ///
    /// For each element in the specified path, Core Graphics calls the applier function, which can examine (but not modify) the element.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `info` must be a valid pointer or null.
    /// - `function` must be implemented correctly.
    #[doc(alias = "CGPathApply")]
    #[inline]
    pub unsafe fn apply(path: Option<&CGPath>, info: *mut c_void, function: CGPathApplierFunction) {
        extern "C-unwind" {
            fn CGPathApply(
                path: Option<&CGPath>,
                info: *mut c_void,
                function: CGPathApplierFunction,
            );
        }
        unsafe { CGPathApply(path, info, function) }
    }
}

#[cfg(feature = "block2")]
pub type CGPathApplyBlock = *mut block2::DynBlock<dyn Fn(NonNull<CGPathElement>)>;

impl CGPath {
    /// # Safety
    ///
    /// `block` must be a valid pointer.
    #[doc(alias = "CGPathApplyWithBlock")]
    #[cfg(feature = "block2")]
    #[inline]
    pub unsafe fn apply_with_block(&self, block: CGPathApplyBlock) {
        extern "C-unwind" {
            fn CGPathApplyWithBlock(path: &CGPath, block: CGPathApplyBlock);
        }
        unsafe { CGPathApplyWithBlock(self, block) }
    }

    #[doc(alias = "CGPathCreateCopyByNormalizing")]
    #[inline]
    pub fn new_copy_by_normalizing(
        path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByNormalizing(
                path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByNormalizing(path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyByUnioningPath")]
    #[inline]
    pub fn new_copy_by_unioning_path(
        path: Option<&CGPath>,
        mask_path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByUnioningPath(
                path: Option<&CGPath>,
                mask_path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByUnioningPath(path, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyByIntersectingPath")]
    #[inline]
    pub fn new_copy_by_intersecting_path(
        path: Option<&CGPath>,
        mask_path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByIntersectingPath(
                path: Option<&CGPath>,
                mask_path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret =
            unsafe { CGPathCreateCopyByIntersectingPath(path, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyBySubtractingPath")]
    #[inline]
    pub fn new_copy_by_subtracting_path(
        path: Option<&CGPath>,
        mask_path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyBySubtractingPath(
                path: Option<&CGPath>,
                mask_path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyBySubtractingPath(path, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyBySymmetricDifferenceOfPath")]
    #[inline]
    pub fn new_copy_by_symmetric_difference_of_path(
        path: Option<&CGPath>,
        mask_path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyBySymmetricDifferenceOfPath(
                path: Option<&CGPath>,
                mask_path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe {
            CGPathCreateCopyBySymmetricDifferenceOfPath(path, mask_path, even_odd_fill_rule)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyOfLineBySubtractingPath")]
    #[inline]
    pub fn new_copy_of_line_by_subtracting_path(
        path: Option<&CGPath>,
        mask_path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyOfLineBySubtractingPath(
                path: Option<&CGPath>,
                mask_path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret =
            unsafe { CGPathCreateCopyOfLineBySubtractingPath(path, mask_path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyOfLineByIntersectingPath")]
    #[inline]
    pub fn new_copy_of_line_by_intersecting_path(
        path: Option<&CGPath>,
        mask_path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyOfLineByIntersectingPath(
                path: Option<&CGPath>,
                mask_path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe {
            CGPathCreateCopyOfLineByIntersectingPath(path, mask_path, even_odd_fill_rule)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateSeparateComponents")]
    #[inline]
    pub fn new_separate_components(
        path: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CGPathCreateSeparateComponents(
                path: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CGPathCreateSeparateComponents(path, even_odd_fill_rule) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathCreateCopyByFlattening")]
    #[inline]
    pub fn new_copy_by_flattening(
        path: Option<&CGPath>,
        flattening_threshold: CGFloat,
    ) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGPathCreateCopyByFlattening(
                path: Option<&CGPath>,
                flattening_threshold: CGFloat,
            ) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGPathCreateCopyByFlattening(path, flattening_threshold) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGPathIntersectsPath")]
    #[inline]
    pub fn intersects_path(
        path1: Option<&CGPath>,
        path2: Option<&CGPath>,
        even_odd_fill_rule: bool,
    ) -> bool {
        extern "C-unwind" {
            fn CGPathIntersectsPath(
                path1: Option<&CGPath>,
                path2: Option<&CGPath>,
                even_odd_fill_rule: bool,
            ) -> bool;
        }
        unsafe { CGPathIntersectsPath(path1, path2, even_odd_fill_rule) }
    }
}

#[deprecated = "renamed to `CGMutablePath::new`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateMutable() -> CFRetained<CGMutablePath> {
    extern "C-unwind" {
        fn CGPathCreateMutable() -> Option<NonNull<CGMutablePath>>;
    }
    let ret = unsafe { CGPathCreateMutable() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGPath::new_copy`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopy(path: Option<&CGPath>) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopy(path: Option<&CGPath>) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopy(path) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_transforming_path`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateCopyByTransformingPath(
    path: Option<&CGPath>,
    transform: *const CGAffineTransform,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByTransformingPath(
            path: Option<&CGPath>,
            transform: *const CGAffineTransform,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyByTransformingPath(path, transform) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGMutablePath::new_copy`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateMutableCopy(
    path: Option<&CGPath>,
) -> Option<CFRetained<CGMutablePath>> {
    extern "C-unwind" {
        fn CGPathCreateMutableCopy(path: Option<&CGPath>) -> Option<NonNull<CGMutablePath>>;
    }
    let ret = unsafe { CGPathCreateMutableCopy(path) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGMutablePath::new_copy_by_transforming_path`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateMutableCopyByTransformingPath(
    path: Option<&CGPath>,
    transform: *const CGAffineTransform,
) -> Option<CFRetained<CGMutablePath>> {
    extern "C-unwind" {
        fn CGPathCreateMutableCopyByTransformingPath(
            path: Option<&CGPath>,
            transform: *const CGAffineTransform,
        ) -> Option<NonNull<CGMutablePath>>;
    }
    let ret = unsafe { CGPathCreateMutableCopyByTransformingPath(path, transform) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::with_rect`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateWithRect(
    rect: CGRect,
    transform: *const CGAffineTransform,
) -> CFRetained<CGPath> {
    extern "C-unwind" {
        fn CGPathCreateWithRect(
            rect: CGRect,
            transform: *const CGAffineTransform,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateWithRect(rect, transform) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGPath::with_ellipse_in_rect`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateWithEllipseInRect(
    rect: CGRect,
    transform: *const CGAffineTransform,
) -> CFRetained<CGPath> {
    extern "C-unwind" {
        fn CGPathCreateWithEllipseInRect(
            rect: CGRect,
            transform: *const CGAffineTransform,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateWithEllipseInRect(rect, transform) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGPath::with_rounded_rect`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateWithRoundedRect(
    rect: CGRect,
    corner_width: CGFloat,
    corner_height: CGFloat,
    transform: *const CGAffineTransform,
) -> CFRetained<CGPath> {
    extern "C-unwind" {
        fn CGPathCreateWithRoundedRect(
            rect: CGRect,
            corner_width: CGFloat,
            corner_height: CGFloat,
            transform: *const CGAffineTransform,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateWithRoundedRect(rect, corner_width, corner_height, transform) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_rounded_rect`"]
    pub fn CGPathAddRoundedRect(
        path: Option<&CGMutablePath>,
        transform: *const CGAffineTransform,
        rect: CGRect,
        corner_width: CGFloat,
        corner_height: CGFloat,
    );
}

#[deprecated = "renamed to `CGPath::new_copy_by_dashing_path`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateCopyByDashingPath(
    path: Option<&CGPath>,
    transform: *const CGAffineTransform,
    phase: CGFloat,
    lengths: *const CGFloat,
    count: usize,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByDashingPath(
            path: Option<&CGPath>,
            transform: *const CGAffineTransform,
            phase: CGFloat,
            lengths: *const CGFloat,
            count: usize,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyByDashingPath(path, transform, phase, lengths, count) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_stroking_path`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPathCreateCopyByStrokingPath(
    path: Option<&CGPath>,
    transform: *const CGAffineTransform,
    line_width: CGFloat,
    line_cap: CGLineCap,
    line_join: CGLineJoin,
    miter_limit: CGFloat,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByStrokingPath(
            path: Option<&CGPath>,
            transform: *const CGAffineTransform,
            line_width: CGFloat,
            line_cap: CGLineCap,
            line_join: CGLineJoin,
            miter_limit: CGFloat,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe {
        CGPathCreateCopyByStrokingPath(
            path,
            transform,
            line_width,
            line_cap,
            line_join,
            miter_limit,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::equal_to_path`"]
#[inline]
pub extern "C-unwind" fn CGPathEqualToPath(path1: Option<&CGPath>, path2: Option<&CGPath>) -> bool {
    extern "C-unwind" {
        fn CGPathEqualToPath(path1: Option<&CGPath>, path2: Option<&CGPath>) -> bool;
    }
    unsafe { CGPathEqualToPath(path1, path2) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::move_to_point`"]
    pub fn CGPathMoveToPoint(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_line_to_point`"]
    pub fn CGPathAddLineToPoint(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_quad_curve_to_point`"]
    pub fn CGPathAddQuadCurveToPoint(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        cpx: CGFloat,
        cpy: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_curve_to_point`"]
    pub fn CGPathAddCurveToPoint(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    );
}

#[deprecated = "renamed to `CGMutablePath::close_subpath`"]
#[inline]
pub extern "C-unwind" fn CGPathCloseSubpath(path: Option<&CGMutablePath>) {
    extern "C-unwind" {
        fn CGPathCloseSubpath(path: Option<&CGMutablePath>);
    }
    unsafe { CGPathCloseSubpath(path) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_rect`"]
    pub fn CGPathAddRect(path: Option<&CGMutablePath>, m: *const CGAffineTransform, rect: CGRect);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_rects`"]
    pub fn CGPathAddRects(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        rects: *const CGRect,
        count: usize,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_lines`"]
    pub fn CGPathAddLines(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        points: *const CGPoint,
        count: usize,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_ellipse_in_rect`"]
    pub fn CGPathAddEllipseInRect(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        rect: CGRect,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_relative_arc`"]
    pub fn CGPathAddRelativeArc(
        path: Option<&CGMutablePath>,
        matrix: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        delta: CGFloat,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_arc`"]
    pub fn CGPathAddArc(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: bool,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_arc_to_point`"]
    pub fn CGPathAddArcToPoint(
        path: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutablePath::add_path`"]
    pub fn CGPathAddPath(
        path1: Option<&CGMutablePath>,
        m: *const CGAffineTransform,
        path2: Option<&CGPath>,
    );
}

#[deprecated = "renamed to `CGPath::is_empty`"]
#[inline]
pub extern "C-unwind" fn CGPathIsEmpty(path: Option<&CGPath>) -> bool {
    extern "C-unwind" {
        fn CGPathIsEmpty(path: Option<&CGPath>) -> bool;
    }
    unsafe { CGPathIsEmpty(path) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGPath::is_rect`"]
    pub fn CGPathIsRect(path: Option<&CGPath>, rect: *mut CGRect) -> bool;
}

#[deprecated = "renamed to `CGPath::current_point`"]
#[inline]
pub extern "C-unwind" fn CGPathGetCurrentPoint(path: Option<&CGPath>) -> CGPoint {
    extern "C-unwind" {
        fn CGPathGetCurrentPoint(path: Option<&CGPath>) -> CGPoint;
    }
    unsafe { CGPathGetCurrentPoint(path) }
}

#[deprecated = "renamed to `CGPath::bounding_box`"]
#[inline]
pub extern "C-unwind" fn CGPathGetBoundingBox(path: Option<&CGPath>) -> CGRect {
    extern "C-unwind" {
        fn CGPathGetBoundingBox(path: Option<&CGPath>) -> CGRect;
    }
    unsafe { CGPathGetBoundingBox(path) }
}

#[deprecated = "renamed to `CGPath::path_bounding_box`"]
#[inline]
pub extern "C-unwind" fn CGPathGetPathBoundingBox(path: Option<&CGPath>) -> CGRect {
    extern "C-unwind" {
        fn CGPathGetPathBoundingBox(path: Option<&CGPath>) -> CGRect;
    }
    unsafe { CGPathGetPathBoundingBox(path) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGPath::contains_point`"]
    pub fn CGPathContainsPoint(
        path: Option<&CGPath>,
        m: *const CGAffineTransform,
        point: CGPoint,
        eo_fill: bool,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGPath::apply`"]
    pub fn CGPathApply(path: Option<&CGPath>, info: *mut c_void, function: CGPathApplierFunction);
}

extern "C-unwind" {
    #[cfg(feature = "block2")]
    #[deprecated = "renamed to `CGPath::apply_with_block`"]
    pub fn CGPathApplyWithBlock(path: &CGPath, block: CGPathApplyBlock);
}

#[deprecated = "renamed to `CGPath::new_copy_by_normalizing`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyByNormalizing(
    path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByNormalizing(
            path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyByNormalizing(path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_unioning_path`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyByUnioningPath(
    path: Option<&CGPath>,
    mask_path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByUnioningPath(
            path: Option<&CGPath>,
            mask_path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyByUnioningPath(path, mask_path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_intersecting_path`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyByIntersectingPath(
    path: Option<&CGPath>,
    mask_path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByIntersectingPath(
            path: Option<&CGPath>,
            mask_path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyByIntersectingPath(path, mask_path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_subtracting_path`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyBySubtractingPath(
    path: Option<&CGPath>,
    mask_path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyBySubtractingPath(
            path: Option<&CGPath>,
            mask_path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyBySubtractingPath(path, mask_path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_symmetric_difference_of_path`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyBySymmetricDifferenceOfPath(
    path: Option<&CGPath>,
    mask_path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyBySymmetricDifferenceOfPath(
            path: Option<&CGPath>,
            mask_path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret =
        unsafe { CGPathCreateCopyBySymmetricDifferenceOfPath(path, mask_path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_of_line_by_subtracting_path`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyOfLineBySubtractingPath(
    path: Option<&CGPath>,
    mask_path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyOfLineBySubtractingPath(
            path: Option<&CGPath>,
            mask_path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret =
        unsafe { CGPathCreateCopyOfLineBySubtractingPath(path, mask_path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_of_line_by_intersecting_path`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyOfLineByIntersectingPath(
    path: Option<&CGPath>,
    mask_path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyOfLineByIntersectingPath(
            path: Option<&CGPath>,
            mask_path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret =
        unsafe { CGPathCreateCopyOfLineByIntersectingPath(path, mask_path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_separate_components`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateSeparateComponents(
    path: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CGPathCreateSeparateComponents(
            path: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CGPathCreateSeparateComponents(path, even_odd_fill_rule) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::new_copy_by_flattening`"]
#[inline]
pub extern "C-unwind" fn CGPathCreateCopyByFlattening(
    path: Option<&CGPath>,
    flattening_threshold: CGFloat,
) -> Option<CFRetained<CGPath>> {
    extern "C-unwind" {
        fn CGPathCreateCopyByFlattening(
            path: Option<&CGPath>,
            flattening_threshold: CGFloat,
        ) -> Option<NonNull<CGPath>>;
    }
    let ret = unsafe { CGPathCreateCopyByFlattening(path, flattening_threshold) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGPath::intersects_path`"]
#[inline]
pub extern "C-unwind" fn CGPathIntersectsPath(
    path1: Option<&CGPath>,
    path2: Option<&CGPath>,
    even_odd_fill_rule: bool,
) -> bool {
    extern "C-unwind" {
        fn CGPathIntersectsPath(
            path1: Option<&CGPath>,
            path2: Option<&CGPath>,
            even_odd_fill_rule: bool,
        ) -> bool;
    }
    unsafe { CGPathIntersectsPath(path1, path2, even_odd_fill_rule) }
}
