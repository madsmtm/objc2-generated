//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "CGEventTypes")]
unsafe impl ConcreteType for CGEvent {
    #[doc(alias = "CGEventGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGEventGetTypeID() -> CFTypeID;
        }
        unsafe { CGEventGetTypeID() }
    }
}

#[cfg(feature = "CGEventTypes")]
impl CGEvent {
    #[doc(alias = "CGEventCreate")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new(source: Option<&CGEventSource>) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreate(source: Option<&CGEventSource>) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreate(source) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateData")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_data(
        allocator: Option<&CFAllocator>,
        event: Option<&CGEvent>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CGEventCreateData(
                allocator: Option<&CFAllocator>,
                event: Option<&CGEvent>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CGEventCreateData(allocator, event) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateFromData")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn from_data(
        allocator: Option<&CFAllocator>,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateFromData(
                allocator: Option<&CFAllocator>,
                data: Option<&CFData>,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreateFromData(allocator, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateMouseEvent")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_mouse_event(
        source: Option<&CGEventSource>,
        mouse_type: CGEventType,
        mouse_cursor_position: CGPoint,
        mouse_button: CGMouseButton,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateMouseEvent(
                source: Option<&CGEventSource>,
                mouse_type: CGEventType,
                mouse_cursor_position: CGPoint,
                mouse_button: CGMouseButton,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe {
            CGEventCreateMouseEvent(source, mouse_type, mouse_cursor_position, mouse_button)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateKeyboardEvent")]
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    #[inline]
    pub fn new_keyboard_event(
        source: Option<&CGEventSource>,
        virtual_key: CGKeyCode,
        key_down: bool,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateKeyboardEvent(
                source: Option<&CGEventSource>,
                virtual_key: CGKeyCode,
                key_down: bool,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreateKeyboardEvent(source, virtual_key, key_down) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateScrollWheelEvent2")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_scroll_wheel_event2(
        source: Option<&CGEventSource>,
        units: CGScrollEventUnit,
        wheel_count: u32,
        wheel1: i32,
        wheel2: i32,
        wheel3: i32,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateScrollWheelEvent2(
                source: Option<&CGEventSource>,
                units: CGScrollEventUnit,
                wheel_count: u32,
                wheel1: i32,
                wheel2: i32,
                wheel3: i32,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe {
            CGEventCreateScrollWheelEvent2(source, units, wheel_count, wheel1, wheel2, wheel3)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateCopy")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_copy(event: Option<&CGEvent>) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateCopy(event: Option<&CGEvent>) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreateCopy(event) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateSourceFromEvent")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_source_from_event(event: Option<&CGEvent>) -> Option<CFRetained<CGEventSource>> {
        extern "C-unwind" {
            fn CGEventCreateSourceFromEvent(
                event: Option<&CGEvent>,
            ) -> Option<NonNull<CGEventSource>>;
        }
        let ret = unsafe { CGEventCreateSourceFromEvent(event) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventSetSource")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_source(event: Option<&CGEvent>, source: Option<&CGEventSource>) {
        extern "C-unwind" {
            fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>);
        }
        unsafe { CGEventSetSource(event, source) }
    }

    #[doc(alias = "CGEventGetType")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn r#type(event: Option<&CGEvent>) -> CGEventType {
        extern "C-unwind" {
            fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType;
        }
        unsafe { CGEventGetType(event) }
    }

    #[doc(alias = "CGEventSetType")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_type(event: Option<&CGEvent>, r#type: CGEventType) {
        extern "C-unwind" {
            fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType);
        }
        unsafe { CGEventSetType(event, r#type) }
    }

    #[doc(alias = "CGEventGetTimestamp")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn timestamp(event: Option<&CGEvent>) -> CGEventTimestamp {
        extern "C-unwind" {
            fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp;
        }
        unsafe { CGEventGetTimestamp(event) }
    }

    #[doc(alias = "CGEventSetTimestamp")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_timestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp) {
        extern "C-unwind" {
            fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp);
        }
        unsafe { CGEventSetTimestamp(event, timestamp) }
    }

    #[doc(alias = "CGEventGetLocation")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn location(event: Option<&CGEvent>) -> CGPoint {
        extern "C-unwind" {
            fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint;
        }
        unsafe { CGEventGetLocation(event) }
    }

    #[doc(alias = "CGEventGetUnflippedLocation")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn unflipped_location(event: Option<&CGEvent>) -> CGPoint {
        extern "C-unwind" {
            fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint;
        }
        unsafe { CGEventGetUnflippedLocation(event) }
    }

    #[doc(alias = "CGEventSetLocation")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_location(event: Option<&CGEvent>, location: CGPoint) {
        extern "C-unwind" {
            fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint);
        }
        unsafe { CGEventSetLocation(event, location) }
    }

    #[doc(alias = "CGEventGetFlags")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn flags(event: Option<&CGEvent>) -> CGEventFlags {
        extern "C-unwind" {
            fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags;
        }
        unsafe { CGEventGetFlags(event) }
    }

    #[doc(alias = "CGEventSetFlags")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_flags(event: Option<&CGEvent>, flags: CGEventFlags) {
        extern "C-unwind" {
            fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags);
        }
        unsafe { CGEventSetFlags(event, flags) }
    }

    /// # Safety
    ///
    /// - `actual_string_length` must be a valid pointer or null.
    /// - `unicode_string` must be a valid pointer or null.
    #[doc(alias = "CGEventKeyboardGetUnicodeString")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn keyboard_get_unicode_string(
        event: Option<&CGEvent>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    ) {
        extern "C-unwind" {
            fn CGEventKeyboardGetUnicodeString(
                event: Option<&CGEvent>,
                max_string_length: UniCharCount,
                actual_string_length: *mut UniCharCount,
                unicode_string: *mut UniChar,
            );
        }
        unsafe {
            CGEventKeyboardGetUnicodeString(
                event,
                max_string_length,
                actual_string_length,
                unicode_string,
            )
        }
    }

    /// # Safety
    ///
    /// `unicode_string` must be a valid pointer or null.
    #[doc(alias = "CGEventKeyboardSetUnicodeString")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn keyboard_set_unicode_string(
        event: Option<&CGEvent>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    ) {
        extern "C-unwind" {
            fn CGEventKeyboardSetUnicodeString(
                event: Option<&CGEvent>,
                string_length: UniCharCount,
                unicode_string: *const UniChar,
            );
        }
        unsafe { CGEventKeyboardSetUnicodeString(event, string_length, unicode_string) }
    }

    #[doc(alias = "CGEventGetIntegerValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn integer_value_field(event: Option<&CGEvent>, field: CGEventField) -> i64 {
        extern "C-unwind" {
            fn CGEventGetIntegerValueField(event: Option<&CGEvent>, field: CGEventField) -> i64;
        }
        unsafe { CGEventGetIntegerValueField(event, field) }
    }

    #[doc(alias = "CGEventSetIntegerValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_integer_value_field(event: Option<&CGEvent>, field: CGEventField, value: i64) {
        extern "C-unwind" {
            fn CGEventSetIntegerValueField(
                event: Option<&CGEvent>,
                field: CGEventField,
                value: i64,
            );
        }
        unsafe { CGEventSetIntegerValueField(event, field, value) }
    }

    #[doc(alias = "CGEventGetDoubleValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn double_value_field(event: Option<&CGEvent>, field: CGEventField) -> c_double {
        extern "C-unwind" {
            fn CGEventGetDoubleValueField(event: Option<&CGEvent>, field: CGEventField)
                -> c_double;
        }
        unsafe { CGEventGetDoubleValueField(event, field) }
    }

    #[doc(alias = "CGEventSetDoubleValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_double_value_field(event: Option<&CGEvent>, field: CGEventField, value: c_double) {
        extern "C-unwind" {
            fn CGEventSetDoubleValueField(
                event: Option<&CGEvent>,
                field: CGEventField,
                value: c_double,
            );
        }
        unsafe { CGEventSetDoubleValueField(event, field, value) }
    }

    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[doc(alias = "CGEventTapCreate")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn tap_create(
        tap: CGEventTapLocation,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> Option<CFRetained<CFMachPort>> {
        extern "C-unwind" {
            fn CGEventTapCreate(
                tap: CGEventTapLocation,
                place: CGEventTapPlacement,
                options: CGEventTapOptions,
                events_of_interest: CGEventMask,
                callback: CGEventTapCallBack,
                user_info: *mut c_void,
            ) -> Option<NonNull<CFMachPort>>;
        }
        let ret = unsafe {
            CGEventTapCreate(tap, place, options, events_of_interest, callback, user_info)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `process_serial_number` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[doc(alias = "CGEventTapCreateForPSN")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn tap_create_for_psn(
        process_serial_number: NonNull<c_void>,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> Option<CFRetained<CFMachPort>> {
        extern "C-unwind" {
            fn CGEventTapCreateForPSN(
                process_serial_number: NonNull<c_void>,
                place: CGEventTapPlacement,
                options: CGEventTapOptions,
                events_of_interest: CGEventMask,
                callback: CGEventTapCallBack,
                user_info: *mut c_void,
            ) -> Option<NonNull<CFMachPort>>;
        }
        let ret = unsafe {
            CGEventTapCreateForPSN(
                process_serial_number,
                place,
                options,
                events_of_interest,
                callback,
                user_info,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[doc(alias = "CGEventTapCreateForPid")]
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    #[inline]
    pub unsafe fn tap_create_for_pid(
        pid: libc::pid_t,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> Option<CFRetained<CFMachPort>> {
        extern "C-unwind" {
            fn CGEventTapCreateForPid(
                pid: libc::pid_t,
                place: CGEventTapPlacement,
                options: CGEventTapOptions,
                events_of_interest: CGEventMask,
                callback: CGEventTapCallBack,
                user_info: *mut c_void,
            ) -> Option<NonNull<CFMachPort>>;
        }
        let ret = unsafe {
            CGEventTapCreateForPid(pid, place, options, events_of_interest, callback, user_info)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventTapEnable")]
    #[inline]
    pub fn tap_enable(tap: &CFMachPort, enable: bool) {
        extern "C-unwind" {
            fn CGEventTapEnable(tap: &CFMachPort, enable: bool);
        }
        unsafe { CGEventTapEnable(tap, enable) }
    }

    #[doc(alias = "CGEventTapIsEnabled")]
    #[inline]
    pub fn tap_is_enabled(tap: &CFMachPort) -> bool {
        extern "C-unwind" {
            fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool;
        }
        unsafe { CGEventTapIsEnabled(tap) }
    }

    /// # Safety
    ///
    /// `proxy` must be a valid pointer or null.
    #[doc(alias = "CGEventTapPostEvent")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn tap_post_event(proxy: CGEventTapProxy, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEvent>);
        }
        unsafe { CGEventTapPostEvent(proxy, event) }
    }

    #[doc(alias = "CGEventPost")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn post(tap: CGEventTapLocation, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>);
        }
        unsafe { CGEventPost(tap, event) }
    }

    /// # Safety
    ///
    /// `process_serial_number` must be a valid pointer or null.
    #[doc(alias = "CGEventPostToPSN")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn post_to_psn(process_serial_number: *mut c_void, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEvent>);
        }
        unsafe { CGEventPostToPSN(process_serial_number, event) }
    }

    #[doc(alias = "CGEventPostToPid")]
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    #[inline]
    pub fn post_to_pid(pid: libc::pid_t, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>);
        }
        unsafe { CGEventPostToPid(pid, event) }
    }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `tap_list` must be a valid pointer or null.
    /// - `event_tap_count` must be a valid pointer or null.
    #[cfg(all(feature = "CGError", feature = "CGEventTypes", feature = "libc"))]
    pub fn CGGetEventTapList(
        max_number_of_taps: u32,
        tap_list: *mut CGEventTapInformation,
        event_tap_count: *mut u32,
    ) -> CGError;
}

#[inline]
pub extern "C-unwind" fn CGPreflightListenEventAccess() -> bool {
    extern "C-unwind" {
        fn CGPreflightListenEventAccess() -> bool;
    }
    unsafe { CGPreflightListenEventAccess() }
}

#[inline]
pub extern "C-unwind" fn CGRequestListenEventAccess() -> bool {
    extern "C-unwind" {
        fn CGRequestListenEventAccess() -> bool;
    }
    unsafe { CGRequestListenEventAccess() }
}

#[inline]
pub extern "C-unwind" fn CGPreflightPostEventAccess() -> bool {
    extern "C-unwind" {
        fn CGPreflightPostEventAccess() -> bool;
    }
    unsafe { CGPreflightPostEventAccess() }
}

#[inline]
pub extern "C-unwind" fn CGRequestPostEventAccess() -> bool {
    extern "C-unwind" {
        fn CGRequestPostEventAccess() -> bool;
    }
    unsafe { CGRequestPostEventAccess() }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new`"]
#[inline]
pub extern "C-unwind" fn CGEventCreate(
    source: Option<&CGEventSource>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreate(source: Option<&CGEventSource>) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreate(source) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_data`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateData(
    allocator: Option<&CFAllocator>,
    event: Option<&CGEvent>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CGEventCreateData(
            allocator: Option<&CFAllocator>,
            event: Option<&CGEvent>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CGEventCreateData(allocator, event) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::from_data`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateFromData(
    allocator: Option<&CFAllocator>,
    data: Option<&CFData>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateFromData(
            allocator: Option<&CFAllocator>,
            data: Option<&CFData>,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreateFromData(allocator, data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_mouse_event`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateMouseEvent(
    source: Option<&CGEventSource>,
    mouse_type: CGEventType,
    mouse_cursor_position: CGPoint,
    mouse_button: CGMouseButton,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateMouseEvent(
            source: Option<&CGEventSource>,
            mouse_type: CGEventType,
            mouse_cursor_position: CGPoint,
            mouse_button: CGMouseButton,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret =
        unsafe { CGEventCreateMouseEvent(source, mouse_type, mouse_cursor_position, mouse_button) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
#[deprecated = "renamed to `CGEvent::new_keyboard_event`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateKeyboardEvent(
    source: Option<&CGEventSource>,
    virtual_key: CGKeyCode,
    key_down: bool,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateKeyboardEvent(
            source: Option<&CGEventSource>,
            virtual_key: CGKeyCode,
            key_down: bool,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreateKeyboardEvent(source, virtual_key, key_down) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_scroll_wheel_event2`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateScrollWheelEvent2(
    source: Option<&CGEventSource>,
    units: CGScrollEventUnit,
    wheel_count: u32,
    wheel1: i32,
    wheel2: i32,
    wheel3: i32,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateScrollWheelEvent2(
            source: Option<&CGEventSource>,
            units: CGScrollEventUnit,
            wheel_count: u32,
            wheel1: i32,
            wheel2: i32,
            wheel3: i32,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe {
        CGEventCreateScrollWheelEvent2(source, units, wheel_count, wheel1, wheel2, wheel3)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_copy`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateCopy(event: Option<&CGEvent>) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateCopy(event: Option<&CGEvent>) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreateCopy(event) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_source_from_event`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateSourceFromEvent(
    event: Option<&CGEvent>,
) -> Option<CFRetained<CGEventSource>> {
    extern "C-unwind" {
        fn CGEventCreateSourceFromEvent(event: Option<&CGEvent>) -> Option<NonNull<CGEventSource>>;
    }
    let ret = unsafe { CGEventCreateSourceFromEvent(event) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_source`"]
#[inline]
pub extern "C-unwind" fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>) {
    extern "C-unwind" {
        fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>);
    }
    unsafe { CGEventSetSource(event, source) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::type`"]
#[inline]
pub extern "C-unwind" fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType {
    extern "C-unwind" {
        fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType;
    }
    unsafe { CGEventGetType(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_type`"]
#[inline]
pub extern "C-unwind" fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType) {
    extern "C-unwind" {
        fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType);
    }
    unsafe { CGEventSetType(event, r#type) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::timestamp`"]
#[inline]
pub extern "C-unwind" fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp {
    extern "C-unwind" {
        fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp;
    }
    unsafe { CGEventGetTimestamp(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_timestamp`"]
#[inline]
pub extern "C-unwind" fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp) {
    extern "C-unwind" {
        fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp);
    }
    unsafe { CGEventSetTimestamp(event, timestamp) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::location`"]
#[inline]
pub extern "C-unwind" fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint {
    extern "C-unwind" {
        fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint;
    }
    unsafe { CGEventGetLocation(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::unflipped_location`"]
#[inline]
pub extern "C-unwind" fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint {
    extern "C-unwind" {
        fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint;
    }
    unsafe { CGEventGetUnflippedLocation(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_location`"]
#[inline]
pub extern "C-unwind" fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint) {
    extern "C-unwind" {
        fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint);
    }
    unsafe { CGEventSetLocation(event, location) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::flags`"]
#[inline]
pub extern "C-unwind" fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags {
    extern "C-unwind" {
        fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags;
    }
    unsafe { CGEventGetFlags(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_flags`"]
#[inline]
pub extern "C-unwind" fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags) {
    extern "C-unwind" {
        fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags);
    }
    unsafe { CGEventSetFlags(event, flags) }
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::keyboard_get_unicode_string`"]
    pub fn CGEventKeyboardGetUnicodeString(
        event: Option<&CGEvent>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::keyboard_set_unicode_string`"]
    pub fn CGEventKeyboardSetUnicodeString(
        event: Option<&CGEvent>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    );
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::integer_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventGetIntegerValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
) -> i64 {
    extern "C-unwind" {
        fn CGEventGetIntegerValueField(event: Option<&CGEvent>, field: CGEventField) -> i64;
    }
    unsafe { CGEventGetIntegerValueField(event, field) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_integer_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventSetIntegerValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
    value: i64,
) {
    extern "C-unwind" {
        fn CGEventSetIntegerValueField(event: Option<&CGEvent>, field: CGEventField, value: i64);
    }
    unsafe { CGEventSetIntegerValueField(event, field, value) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::double_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventGetDoubleValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
) -> c_double {
    extern "C-unwind" {
        fn CGEventGetDoubleValueField(event: Option<&CGEvent>, field: CGEventField) -> c_double;
    }
    unsafe { CGEventGetDoubleValueField(event, field) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_double_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventSetDoubleValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
    value: c_double,
) {
    extern "C-unwind" {
        fn CGEventSetDoubleValueField(
            event: Option<&CGEvent>,
            field: CGEventField,
            value: c_double,
        );
    }
    unsafe { CGEventSetDoubleValueField(event, field, value) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::tap_create`"]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreate(
    tap: CGEventTapLocation,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreate(
            tap: CGEventTapLocation,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> Option<NonNull<CFMachPort>>;
    }
    let ret =
        unsafe { CGEventTapCreate(tap, place, options, events_of_interest, callback, user_info) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::tap_create_for_psn`"]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreateForPSN(
    process_serial_number: NonNull<c_void>,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreateForPSN(
            process_serial_number: NonNull<c_void>,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> Option<NonNull<CFMachPort>>;
    }
    let ret = unsafe {
        CGEventTapCreateForPSN(
            process_serial_number,
            place,
            options,
            events_of_interest,
            callback,
            user_info,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGEventTypes", feature = "libc"))]
#[deprecated = "renamed to `CGEvent::tap_create_for_pid`"]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreateForPid(
    pid: libc::pid_t,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreateForPid(
            pid: libc::pid_t,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> Option<NonNull<CFMachPort>>;
    }
    let ret = unsafe {
        CGEventTapCreateForPid(pid, place, options, events_of_interest, callback, user_info)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGEvent::tap_enable`"]
#[inline]
pub extern "C-unwind" fn CGEventTapEnable(tap: &CFMachPort, enable: bool) {
    extern "C-unwind" {
        fn CGEventTapEnable(tap: &CFMachPort, enable: bool);
    }
    unsafe { CGEventTapEnable(tap, enable) }
}

#[deprecated = "renamed to `CGEvent::tap_is_enabled`"]
#[inline]
pub extern "C-unwind" fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool {
    extern "C-unwind" {
        fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool;
    }
    unsafe { CGEventTapIsEnabled(tap) }
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::tap_post_event`"]
    pub fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEvent>);
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::post`"]
#[inline]
pub extern "C-unwind" fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>) {
    extern "C-unwind" {
        fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>);
    }
    unsafe { CGEventPost(tap, event) }
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::post_to_psn`"]
    pub fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEvent>);
}

#[cfg(all(feature = "CGEventTypes", feature = "libc"))]
#[deprecated = "renamed to `CGEvent::post_to_pid`"]
#[inline]
pub extern "C-unwind" fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>) {
    extern "C-unwind" {
        fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>);
    }
    unsafe { CGEventPostToPid(pid, event) }
}
