//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "CGEventTypes")]
unsafe impl ConcreteType for CGEvent {
    /// Returns the type identifier for the opaque type `CGEventRef`.
    ///
    /// ## Return Value
    ///
    /// The Core Foundation type identifier for the opaque type [`CGEventRef`](https://developer.apple.com/documentation/coregraphics/cgevent).
    ///
    ///
    #[doc(alias = "CGEventGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGEventGetTypeID() -> CFTypeID;
        }
        unsafe { CGEventGetTypeID() }
    }
}

#[cfg(feature = "CGEventTypes")]
impl CGEvent {
    /// Returns a new Quartz event.
    ///
    /// Parameters:
    /// - source: The event source, or `NULL` to use a default source.
    ///
    ///
    /// ## Return Value
    ///
    /// A new event to be filled in, or `NULL` if the event could not be created. When you no longer need the event, you should release it using the function `CFRelease`.
    ///
    ///
    #[doc(alias = "CGEventCreate")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new(source: Option<&CGEventSource>) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreate(source: Option<&CGEventSource>) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreate(source) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a flattened data representation of a Quartz event.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the data object. To use the current default allocator, pass `NULL` or `kCFAllocatorDefault`.
    ///
    /// - event: The event to flatten.
    ///
    ///
    /// ## Return Value
    ///
    /// The flattened data representation of the event, or `NULL` if the `event` parameter is invalid. When you no longer need the data object, you should release it using the function `CFRelease`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can use this function to flatten an event for network transport to another system.
    ///
    ///
    #[doc(alias = "CGEventCreateData")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_data(
        allocator: Option<&CFAllocator>,
        event: Option<&CGEvent>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CGEventCreateData(
                allocator: Option<&CFAllocator>,
                event: Option<&CGEvent>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CGEventCreateData(allocator, event) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a Quartz event created from a flattened data representation of the event.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the event object. To use the current default allocator, pass `NULL` or `kCFAllocatorDefault`.
    ///
    /// - data: The flattened data representation of the event to reconstruct.
    ///
    ///
    /// ## Return Value
    ///
    /// An event built from the flattened data representation, or `NULL` if the `eventData` parameter is invalid.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can use this function to reconstruct a Quartz event received by network transport from another system.
    ///
    ///
    #[doc(alias = "CGEventCreateFromData")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn from_data(
        allocator: Option<&CFAllocator>,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateFromData(
                allocator: Option<&CFAllocator>,
                data: Option<&CFData>,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreateFromData(allocator, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a new Quartz mouse event.
    ///
    /// Parameters:
    /// - source: An event source taken from another event, or `NULL`.
    ///
    /// - mouseType: A mouse event type. Pass one of the constants listed in [`CGEventType`](https://developer.apple.com/documentation/coregraphics/cgeventtype).
    ///
    /// - mouseCursorPosition: The position of the mouse cursor in global coordinates.
    ///
    /// - mouseButton: The button that’s changing state. Pass one of the constants listed in [`CGMouseButton`](https://developer.apple.com/documentation/coregraphics/cgmousebutton). This parameter is ignored unless the `mouseType` parameter is `kCGEventOtherMouseDown`, `kCGEventOtherMouseDragged`, or `kCGEventOtherMouseUp`.
    ///
    ///
    /// ## Return Value
    ///
    /// A new mouse event, or `NULL` if the event could not be created. When you no longer need the event, you should release it using the function `CFRelease`.
    ///
    ///
    #[doc(alias = "CGEventCreateMouseEvent")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_mouse_event(
        source: Option<&CGEventSource>,
        mouse_type: CGEventType,
        mouse_cursor_position: CGPoint,
        mouse_button: CGMouseButton,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateMouseEvent(
                source: Option<&CGEventSource>,
                mouse_type: CGEventType,
                mouse_cursor_position: CGPoint,
                mouse_button: CGMouseButton,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe {
            CGEventCreateMouseEvent(source, mouse_type, mouse_cursor_position, mouse_button)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a new Quartz keyboard event.
    ///
    /// Parameters:
    /// - source: An event source taken from another event, or `NULL`.
    ///
    /// - virtualKey: The virtual key code for the event.
    ///
    /// - keyDown: Pass `true` to specify that the key position is down. To specify that the key position is up, pass `false`. This value is used to determine the type of the keyboard event—see [`CGEventType`](https://developer.apple.com/documentation/coregraphics/cgeventtype).
    ///
    ///
    /// ## Return Value
    ///
    /// A new keyboard event, or `NULL` if the event could not be created. When you no longer need the event, you should release it using the function `CFRelease`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// All keystrokes needed to generate a character must be entered, including modifier keys.  For example, to produce a ‘Z’, the SHIFT key must be down, the ‘z’ key must go down, and then the SHIFT and ‘z’ key must be released:
    ///
    /// ```objc
    /// CGEventRef event1, event2, event3, event4;
    /// event1 = CGEventCreateKeyboardEvent (NULL, (CGKeyCode)56, true);
    /// event2 = CGEventCreateKeyboardEvent (NULL, (CGKeyCode)6, true);
    /// event3 = CGEventCreateKeyboardEvent (NULL, (CGKeyCode)6, false);
    /// event4 = CGEventCreateKeyboardEvent (NULL, (CGKeyCode)56, false);
    /// ```
    ///
    ///
    #[doc(alias = "CGEventCreateKeyboardEvent")]
    #[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
    #[inline]
    pub fn new_keyboard_event(
        source: Option<&CGEventSource>,
        virtual_key: CGKeyCode,
        key_down: bool,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateKeyboardEvent(
                source: Option<&CGEventSource>,
                virtual_key: CGKeyCode,
                key_down: bool,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreateKeyboardEvent(source, virtual_key, key_down) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGEventCreateScrollWheelEvent2")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_scroll_wheel_event2(
        source: Option<&CGEventSource>,
        units: CGScrollEventUnit,
        wheel_count: u32,
        wheel1: i32,
        wheel2: i32,
        wheel3: i32,
    ) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateScrollWheelEvent2(
                source: Option<&CGEventSource>,
                units: CGScrollEventUnit,
                wheel_count: u32,
                wheel1: i32,
                wheel2: i32,
                wheel3: i32,
            ) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe {
            CGEventCreateScrollWheelEvent2(source, units, wheel_count, wheel1, wheel2, wheel3)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of an existing Quartz event.
    ///
    /// Parameters:
    /// - event: The event being copied.
    ///
    ///
    /// ## Return Value
    ///
    /// A copy of the specified event. When you no longer need the copy, you should release it using the function `CFRelease`.
    ///
    ///
    #[doc(alias = "CGEventCreateCopy")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_copy(event: Option<&CGEvent>) -> Option<CFRetained<CGEvent>> {
        extern "C-unwind" {
            fn CGEventCreateCopy(event: Option<&CGEvent>) -> Option<NonNull<CGEvent>>;
        }
        let ret = unsafe { CGEventCreateCopy(event) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a Quartz event source created from an existing Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    ///
    /// ## Return Value
    ///
    /// An event source created from the specified event, or `NULL` if the event was generated with a private event source owned by another process. When you no longer need this event source, you should release it using the function `CFRelease`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Event filters may use the event source to generate events that are compatible with an event being filtered.
    ///
    ///
    #[doc(alias = "CGEventCreateSourceFromEvent")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn new_source_from_event(event: Option<&CGEvent>) -> Option<CFRetained<CGEventSource>> {
        extern "C-unwind" {
            fn CGEventCreateSourceFromEvent(
                event: Option<&CGEvent>,
            ) -> Option<NonNull<CGEventSource>>;
        }
        let ret = unsafe { CGEventCreateSourceFromEvent(event) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets the event source of a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - source: The new event source of the specified event.
    ///
    #[doc(alias = "CGEventSetSource")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_source(event: Option<&CGEvent>, source: Option<&CGEventSource>) {
        extern "C-unwind" {
            fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>);
        }
        unsafe { CGEventSetSource(event, source) }
    }

    /// Returns the event type of a Quartz event (left mouse down, for example).
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    ///
    /// ## Return Value
    ///
    /// The current event type of the specified event. The return value is one of the constants listed in [`CGEventType`](https://developer.apple.com/documentation/coregraphics/cgeventtype).
    ///
    ///
    #[doc(alias = "CGEventGetType")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn r#type(event: Option<&CGEvent>) -> CGEventType {
        extern "C-unwind" {
            fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType;
        }
        unsafe { CGEventGetType(event) }
    }

    /// Sets the event type of a Quartz event (left mouse down, for example).
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - type: The new event type of the specified event. The return value is one of the constants listed in [`CGEventType`](https://developer.apple.com/documentation/coregraphics/cgeventtype).
    ///
    #[doc(alias = "CGEventSetType")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_type(event: Option<&CGEvent>, r#type: CGEventType) {
        extern "C-unwind" {
            fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType);
        }
        unsafe { CGEventSetType(event, r#type) }
    }

    /// Returns the timestamp of a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    ///
    /// ## Return Value
    ///
    /// The current timestamp of the specified event.
    ///
    ///
    #[doc(alias = "CGEventGetTimestamp")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn timestamp(event: Option<&CGEvent>) -> CGEventTimestamp {
        extern "C-unwind" {
            fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp;
        }
        unsafe { CGEventGetTimestamp(event) }
    }

    /// Sets the timestamp of a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - timestamp: The new timestamp of the specified event.
    ///
    #[doc(alias = "CGEventSetTimestamp")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_timestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp) {
        extern "C-unwind" {
            fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp);
        }
        unsafe { CGEventSetTimestamp(event, timestamp) }
    }

    /// Returns the location of a Quartz mouse event.
    ///
    /// Parameters:
    /// - event: The mouse event to locate.
    ///
    ///
    /// ## Return Value
    ///
    /// The current location of the specified mouse event in global display coordinates.
    ///
    ///
    #[doc(alias = "CGEventGetLocation")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn location(event: Option<&CGEvent>) -> CGPoint {
        extern "C-unwind" {
            fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint;
        }
        unsafe { CGEventGetLocation(event) }
    }

    /// Returns the location of a Quartz mouse event.
    ///
    /// Parameters:
    /// - event: The mouse event whose location you wish to obtain.
    ///
    ///
    /// ## Return Value
    ///
    /// The current location of the specified mouse event relative to the lower-left corner of the main display.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns the location of the mouse cursor associated with the event.  The coordinate system used is relative to the lower-left corner of the main display, and is compatible with the global coordinate system used by the Application Kit.
    ///
    /// Note that the y-coordinate of the returned location is off by one from an idealized coordinate system originating at the lower-left corner of the main display. Effectively, the function is defined as follows:
    ///
    /// ```objc
    /// CGPoint p = CGEventGetLocation(event);
    /// p.y = main_display_height - p.y;
    /// /* not p.y = (main_display_height - 1) - p.y */
    /// return p;
    /// ```
    ///
    ///
    #[doc(alias = "CGEventGetUnflippedLocation")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn unflipped_location(event: Option<&CGEvent>) -> CGPoint {
        extern "C-unwind" {
            fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint;
        }
        unsafe { CGEventGetUnflippedLocation(event) }
    }

    /// Sets the location of a Quartz mouse event.
    ///
    /// Parameters:
    /// - event: The mouse event whose location to set.
    ///
    /// - location: The new location of the specified mouse event in global display coordinates.
    ///
    #[doc(alias = "CGEventSetLocation")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_location(event: Option<&CGEvent>, location: CGPoint) {
        extern "C-unwind" {
            fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint);
        }
        unsafe { CGEventSetLocation(event, location) }
    }

    /// Returns the event flags of a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    ///
    /// ## Return Value
    ///
    /// The current flags of the specified event. For more information, see [`CGEventFlags`](https://developer.apple.com/documentation/coregraphics/cgeventflags).
    ///
    ///
    #[doc(alias = "CGEventGetFlags")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn flags(event: Option<&CGEvent>) -> CGEventFlags {
        extern "C-unwind" {
            fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags;
        }
        unsafe { CGEventGetFlags(event) }
    }

    /// Sets the event flags of a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - flags: The new flags of the specified event. See [`CGEventFlags`](https://developer.apple.com/documentation/coregraphics/cgeventflags).
    ///
    #[doc(alias = "CGEventSetFlags")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_flags(event: Option<&CGEvent>, flags: CGEventFlags) {
        extern "C-unwind" {
            fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags);
        }
        unsafe { CGEventSetFlags(event, flags) }
    }

    /// Returns the Unicode string associated with a Quartz keyboard event.
    ///
    /// Parameters:
    /// - event: The keyboard event to access.
    ///
    /// - maxStringLength: The length of the array you provide in the `unicodeString` parameter.
    ///
    /// - actualStringLength: A pointer to a `UniCharCount` variable. On return, the variable contains the actual count of Unicode characters in the event data.
    ///
    /// - unicodeString: A pointer to a `UniChar` array. You are responsible for allocating storage for the array. On return, your array contains the Unicode string associated with the specified event.
    ///
    ///
    /// ## Discussion
    ///
    /// When you call this function and specify a `NULL` string or a maximum string length of 0, the function still returns the actual count of Unicode characters in the event data.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `actual_string_length` must be a valid pointer or null.
    /// - `unicode_string` must be a valid pointer or null.
    #[doc(alias = "CGEventKeyboardGetUnicodeString")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn keyboard_get_unicode_string(
        event: Option<&CGEvent>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    ) {
        extern "C-unwind" {
            fn CGEventKeyboardGetUnicodeString(
                event: Option<&CGEvent>,
                max_string_length: UniCharCount,
                actual_string_length: *mut UniCharCount,
                unicode_string: *mut UniChar,
            );
        }
        unsafe {
            CGEventKeyboardGetUnicodeString(
                event,
                max_string_length,
                actual_string_length,
                unicode_string,
            )
        }
    }

    /// Sets the Unicode string associated with a Quartz keyboard event.
    ///
    /// Parameters:
    /// - event: The keyboard event to access.
    ///
    /// - stringLength: The length of the array you provide in the `unicodeString` parameter.
    ///
    /// - unicodeString: An array that contains the new Unicode string associated with the specified event.
    ///
    ///
    /// ## Discussion
    ///
    /// By default, the system translates the virtual key code in a keyboard event into a Unicode string based on the keyboard ID in the event source. This function allows you to manually override this string. Note that application frameworks may ignore the Unicode string in a keyboard event and do their own translation based on the virtual keycode and perceived event state.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `unicode_string` must be a valid pointer or null.
    #[doc(alias = "CGEventKeyboardSetUnicodeString")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn keyboard_set_unicode_string(
        event: Option<&CGEvent>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    ) {
        extern "C-unwind" {
            fn CGEventKeyboardSetUnicodeString(
                event: Option<&CGEvent>,
                string_length: UniCharCount,
                unicode_string: *const UniChar,
            );
        }
        unsafe { CGEventKeyboardSetUnicodeString(event, string_length, unicode_string) }
    }

    /// Returns the integer value of a field in a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - field: A field in the specified event. Pass one of the constants listed in [`CGEventField`](https://developer.apple.com/documentation/coregraphics/cgeventfield).
    ///
    ///
    /// ## Return Value
    ///
    /// A 64-bit integer representation of the current value of the specified field.
    ///
    ///
    #[doc(alias = "CGEventGetIntegerValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn integer_value_field(event: Option<&CGEvent>, field: CGEventField) -> i64 {
        extern "C-unwind" {
            fn CGEventGetIntegerValueField(event: Option<&CGEvent>, field: CGEventField) -> i64;
        }
        unsafe { CGEventGetIntegerValueField(event, field) }
    }

    /// Sets the integer value of a field in a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - field: A field in the specified event. Pass one of the constants listed in [`CGEventField`](https://developer.apple.com/documentation/coregraphics/cgeventfield).
    ///
    /// - value: The new value of the specified field.
    ///
    ///
    /// ## Discussion
    ///
    /// Before calling this function, the event type must be set using a typed event creation function such as [`CGEventCreateMouseEvent`](https://developer.apple.com/documentation/coregraphics/cgevent/init(mouseeventsource:mousetype:mousecursorposition:mousebutton:)), or by calling [`CGEventSetType`](https://developer.apple.com/documentation/coregraphics/cgeventsettype).
    ///
    /// If you are creating a mouse event generated by a tablet, call this function and specify the field `kCGMouseEventSubtype` with a value of `kCGEventMouseSubtypeTabletPoint` or `kCGEventMouseSubtypeTabletProximity` before setting other parameters.
    ///
    ///
    #[doc(alias = "CGEventSetIntegerValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_integer_value_field(event: Option<&CGEvent>, field: CGEventField, value: i64) {
        extern "C-unwind" {
            fn CGEventSetIntegerValueField(
                event: Option<&CGEvent>,
                field: CGEventField,
                value: i64,
            );
        }
        unsafe { CGEventSetIntegerValueField(event, field, value) }
    }

    /// Returns the floating-point value of a field in a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - field: A field in the specified event. Pass one of the constants listed in [`CGEventField`](https://developer.apple.com/documentation/coregraphics/cgeventfield).
    ///
    ///
    /// ## Return Value
    ///
    /// A floating point representation of the current value of the specified field.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In cases where the field value is represented within the event by a fixed point number or an integer, the result is scaled to the appropriate range as part of creating the floating point representation.
    ///
    ///
    #[doc(alias = "CGEventGetDoubleValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn double_value_field(event: Option<&CGEvent>, field: CGEventField) -> c_double {
        extern "C-unwind" {
            fn CGEventGetDoubleValueField(event: Option<&CGEvent>, field: CGEventField)
                -> c_double;
        }
        unsafe { CGEventGetDoubleValueField(event, field) }
    }

    /// Sets the floating-point value of a field in a Quartz event.
    ///
    /// Parameters:
    /// - event: The event to access.
    ///
    /// - field: A field in the specified event. Pass one of the constants listed in [`CGEventField`](https://developer.apple.com/documentation/coregraphics/cgeventfield).
    ///
    /// - value: The new value of the specified field.
    ///
    ///
    /// ## Discussion
    ///
    /// Before calling this function, the event type must be set using a typed event creation function such as [`CGEventCreateMouseEvent`](https://developer.apple.com/documentation/coregraphics/cgevent/init(mouseeventsource:mousetype:mousecursorposition:mousebutton:)), or by calling [`CGEventSetType`](https://developer.apple.com/documentation/coregraphics/cgeventsettype).
    ///
    /// In cases where the field’s value is represented within the event by a fixed point number or integer, the `value` parameter is scaled as needed and converted to the appropriate type.
    ///
    ///
    #[doc(alias = "CGEventSetDoubleValueField")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn set_double_value_field(event: Option<&CGEvent>, field: CGEventField, value: c_double) {
        extern "C-unwind" {
            fn CGEventSetDoubleValueField(
                event: Option<&CGEvent>,
                field: CGEventField,
                value: c_double,
            );
        }
        unsafe { CGEventSetDoubleValueField(event, field, value) }
    }

    /// Creates an event tap.
    ///
    /// Parameters:
    /// - tap: The location of the new event tap. Pass one of the constants listed in [`CGEventTapLocation`](https://developer.apple.com/documentation/coregraphics/cgeventtaplocation). Only processes running as the root user may locate an event tap at the point where HID events enter the window server; for other users, this function returns `NULL`.
    ///
    /// - place: The placement of the new event tap in the list of active event taps. Pass one of the constants listed in [`CGEventTapPlacement`](https://developer.apple.com/documentation/coregraphics/cgeventtapplacement).
    ///
    /// - options: A constant that specifies whether the new event tap is a passive listener or an active filter.
    ///
    /// - eventsOfInterest: A bit mask that specifies the set of events to be observed. For a list of possible events, see [`CGEventType`](https://developer.apple.com/documentation/coregraphics/cgeventtype). For information on how to specify the mask, see [`CGEventMask`](https://developer.apple.com/documentation/coregraphics/cgeventmask). If the event tap is not permitted to monitor one or more of the events specified in the `eventsOfInterest` parameter, then the appropriate bits in the mask are cleared. If that action results in an empty mask, this function returns `NULL`.
    ///
    /// - callback: An event tap callback function that you provide. Your callback function is invoked from the run loop to which the event tap is added as a source. The thread safety of the callback is defined by the run loop’s environment. To learn more about event tap callbacks, see [`CGEventTapCallBack`](https://developer.apple.com/documentation/coregraphics/cgeventtapcallback).
    ///
    /// - userInfo: A pointer to user-defined data. This pointer is passed into the callback function specified in the `callback` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A Core Foundation mach port that represents the new event tap, or `NULL` if the event tap could not be created. When you are finished using the event tap, you should release the mach port using the function `CFRelease`. Releasing the mach port also releases the tap.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Event taps receive key up and key down events if one of the following conditions is true:
    ///
    /// - The current process is running as the root user.
    ///
    /// - Access for assistive devices is enabled. In OS X v10.4, you can enable this feature using System Preferences, Universal Access panel, Keyboard view.
    ///
    /// After creating an event tap, you can add it to a run loop as follows:
    ///
    /// 1. Pass the event tap to the [`CFMachPortCreateRunLoopSource`](https://developer.apple.com/documentation/corefoundation/cfmachportcreaterunloopsource(_:_:_:)) function to create a run loop event source.
    ///
    /// 2. Call the [`CFRunLoopAddSource`](https://developer.apple.com/documentation/corefoundation/cfrunloopaddsource(_:_:_:)) function to add the source to the appropriate run loop.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[doc(alias = "CGEventTapCreate")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn tap_create(
        tap: CGEventTapLocation,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> Option<CFRetained<CFMachPort>> {
        extern "C-unwind" {
            fn CGEventTapCreate(
                tap: CGEventTapLocation,
                place: CGEventTapPlacement,
                options: CGEventTapOptions,
                events_of_interest: CGEventMask,
                callback: CGEventTapCallBack,
                user_info: *mut c_void,
            ) -> Option<NonNull<CFMachPort>>;
        }
        let ret = unsafe {
            CGEventTapCreate(tap, place, options, events_of_interest, callback, user_info)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an event tap for a specified process.
    ///
    /// Parameters:
    /// - processSerialNumber: The process to monitor.
    ///
    /// - place: The placement of the new event tap in the list of active event taps. Pass one of the constants listed in [`CGEventTapPlacement`](https://developer.apple.com/documentation/coregraphics/cgeventtapplacement).
    ///
    /// - options: A constant that specifies whether the new event tap is a passive listener or an active filter.
    ///
    /// - eventsOfInterest: A bit mask that specifies the set of events to be observed. For a list of possible events, see [`CGEventType`](https://developer.apple.com/documentation/coregraphics/cgeventtype). For information on how to specify the mask, see [`CGEventMask`](https://developer.apple.com/documentation/coregraphics/cgeventmask). If the event tap is not permitted to monitor one or more of the events specified in the `eventsOfInterest` parameter, then the appropriate bits in the mask are cleared. If that action results in an empty mask, this function returns `NULL`.
    ///
    /// - callback: An event tap callback function that you provide. Your callback function is invoked from the run loop to which the event tap is added as a source. The thread safety of the callback is defined by the run loop’s environment. To learn more about event tap callbacks, see [`CGEventTapCallBack`](https://developer.apple.com/documentation/coregraphics/cgeventtapcallback).
    ///
    /// - userInfo: A pointer to user-defined data. This pointer is passed into the callback function specified in the `callback` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A Core Foundation mach port that represents the new event tap, or `NULL` if the event tap could not be created. When you are finished using the event tap, you should release the mach port using the function `CFRelease`. Releasing the mach port also releases the tap.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function creates an event tap that receives events being routed by the window server to the specified process. For more information about creating event taps, see [`CGEventTapCreate`](https://developer.apple.com/documentation/coregraphics/cgevent/tapcreate(tap:place:options:eventsofinterest:callback:userinfo:)).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `process_serial_number` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[doc(alias = "CGEventTapCreateForPSN")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn tap_create_for_psn(
        process_serial_number: NonNull<c_void>,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> Option<CFRetained<CFMachPort>> {
        extern "C-unwind" {
            fn CGEventTapCreateForPSN(
                process_serial_number: NonNull<c_void>,
                place: CGEventTapPlacement,
                options: CGEventTapOptions,
                events_of_interest: CGEventMask,
                callback: CGEventTapCallBack,
                user_info: *mut c_void,
            ) -> Option<NonNull<CFMachPort>>;
        }
        let ret = unsafe {
            CGEventTapCreateForPSN(
                process_serial_number,
                place,
                options,
                events_of_interest,
                callback,
                user_info,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[doc(alias = "CGEventTapCreateForPid")]
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    #[inline]
    pub unsafe fn tap_create_for_pid(
        pid: libc::pid_t,
        place: CGEventTapPlacement,
        options: CGEventTapOptions,
        events_of_interest: CGEventMask,
        callback: CGEventTapCallBack,
        user_info: *mut c_void,
    ) -> Option<CFRetained<CFMachPort>> {
        extern "C-unwind" {
            fn CGEventTapCreateForPid(
                pid: libc::pid_t,
                place: CGEventTapPlacement,
                options: CGEventTapOptions,
                events_of_interest: CGEventMask,
                callback: CGEventTapCallBack,
                user_info: *mut c_void,
            ) -> Option<NonNull<CFMachPort>>;
        }
        let ret = unsafe {
            CGEventTapCreateForPid(pid, place, options, events_of_interest, callback, user_info)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Enables or disables an event tap.
    ///
    /// Parameters:
    /// - tap: The event tap to enable or disable.
    ///
    /// - enable: Pass `true` to enable the event tap. To disable it, pass `false`.
    ///
    ///
    /// ## Discussion
    ///
    /// Event taps are normally enabled when created. If an event tap becomes unresponsive, or if a user requests that event taps be disabled, then a `kCGEventTapDisabled` event is passed to the event tap callback function. Event taps may be re-enabled by calling this function.
    ///
    ///
    #[doc(alias = "CGEventTapEnable")]
    #[inline]
    pub fn tap_enable(tap: &CFMachPort, enable: bool) {
        extern "C-unwind" {
            fn CGEventTapEnable(tap: &CFMachPort, enable: bool);
        }
        unsafe { CGEventTapEnable(tap, enable) }
    }

    /// Returns a Boolean value indicating whether an event tap is enabled.
    ///
    /// Parameters:
    /// - tap: The event tap to test.
    ///
    ///
    /// ## Return Value
    ///
    /// If [`true`](https://developer.apple.com/documentation/swift/true), the specified event tap is enabled; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For more information, see the function [`CGEventTapEnable`](https://developer.apple.com/documentation/coregraphics/cgevent/tapenable(tap:enable:)).
    ///
    ///
    #[doc(alias = "CGEventTapIsEnabled")]
    #[inline]
    pub fn tap_is_enabled(tap: &CFMachPort) -> bool {
        extern "C-unwind" {
            fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool;
        }
        unsafe { CGEventTapIsEnabled(tap) }
    }

    /// Posts a Quartz event from an event tap into the event stream.
    ///
    /// Parameters:
    /// - proxy: A proxy that identifies the event tap posting the event. Your event tap callback function is passed this proxy when it is invoked.
    ///
    /// - event: The event to post.
    ///
    ///
    /// ## Discussion
    ///
    /// You can use this function to post a new event at the same point to which an event returned from an event tap callback function would be posted. The new event enters the system before the event returned by the callback enters the system. Events posted into the system will be seen by all taps placed after the tap posting the event.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `proxy` must be a valid pointer or null.
    #[doc(alias = "CGEventTapPostEvent")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn tap_post_event(proxy: CGEventTapProxy, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEvent>);
        }
        unsafe { CGEventTapPostEvent(proxy, event) }
    }

    /// Posts a Quartz event into the event stream at a specified location.
    ///
    /// Parameters:
    /// - tap: The location at which to post the event. Pass one of the constants listed in [`CGEventTapLocation`](https://developer.apple.com/documentation/coregraphics/cgeventtaplocation).
    ///
    /// - event: The event to post.
    ///
    ///
    /// ## Discussion
    ///
    /// This function posts the specified event immediately before any event taps instantiated for that location, and the event passes through any such taps.
    ///
    ///
    #[doc(alias = "CGEventPost")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub fn post(tap: CGEventTapLocation, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>);
        }
        unsafe { CGEventPost(tap, event) }
    }

    /// Posts a Quartz event into the event stream for a specific application.
    ///
    /// Parameters:
    /// - processSerialNumber: The process to receive the event.
    ///
    /// - event: The event to post.
    ///
    ///
    /// ## Discussion
    ///
    /// This function makes it possible for an application to establish an event routing policy, for example, by tapping events at the `kCGAnnotatedSessionEventTap` location and then posting the events to another desired process.
    ///
    /// This function posts the specified event immediately before any event taps instantiated for the specified process, and the event passes through any such taps.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `process_serial_number` must be a valid pointer or null.
    #[doc(alias = "CGEventPostToPSN")]
    #[cfg(feature = "CGEventTypes")]
    #[inline]
    pub unsafe fn post_to_psn(process_serial_number: *mut c_void, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEvent>);
        }
        unsafe { CGEventPostToPSN(process_serial_number, event) }
    }

    #[doc(alias = "CGEventPostToPid")]
    #[cfg(all(feature = "CGEventTypes", feature = "libc"))]
    #[inline]
    pub fn post_to_pid(pid: libc::pid_t, event: Option<&CGEvent>) {
        extern "C-unwind" {
            fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>);
        }
        unsafe { CGEventPostToPid(pid, event) }
    }
}

extern "C-unwind" {
    /// Gets a list of currently installed event taps.
    ///
    /// Parameters:
    /// - maxNumberOfTaps: The length of the array you provide in the `tapList` parameter.
    ///
    /// - tapList: An array of event tap information structures. You are responsible for allocating storage for the array. On return, your array contains a list of currently installed event taps. If you pass `NULL` in this parameter, the `maxNumberOfTaps` parameter is ignored, and the `eventTapCount` variable is filled in with the number of event taps that are currently installed.
    ///
    /// - eventTapCount: A pointer to a `CGTableCount` variable. On return, the variable contains actual number of array elements filled in.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See the result codes described in [Quartz Display Services](https://developer.apple.com/documentation/coregraphics/quartz-display-services).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each call to this function has the side effect of resetting the minimum and maximum latency values in the `tapList` parameter to the corresponding average values. Values reported in these fields reflect the minimum and maximum values seen since the preceding call, or the instantiation of the tap. This allows a monitoring tool to evaluate the best and worst case latency over time and under various operating conditions.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `tap_list` must be a valid pointer or null.
    /// - `event_tap_count` must be a valid pointer or null.
    #[cfg(all(feature = "CGError", feature = "CGEventTypes", feature = "libc"))]
    pub fn CGGetEventTapList(
        max_number_of_taps: u32,
        tap_list: *mut CGEventTapInformation,
        event_tap_count: *mut u32,
    ) -> CGError;
}

#[inline]
pub extern "C-unwind" fn CGPreflightListenEventAccess() -> bool {
    extern "C-unwind" {
        fn CGPreflightListenEventAccess() -> bool;
    }
    unsafe { CGPreflightListenEventAccess() }
}

#[inline]
pub extern "C-unwind" fn CGRequestListenEventAccess() -> bool {
    extern "C-unwind" {
        fn CGRequestListenEventAccess() -> bool;
    }
    unsafe { CGRequestListenEventAccess() }
}

#[inline]
pub extern "C-unwind" fn CGPreflightPostEventAccess() -> bool {
    extern "C-unwind" {
        fn CGPreflightPostEventAccess() -> bool;
    }
    unsafe { CGPreflightPostEventAccess() }
}

#[inline]
pub extern "C-unwind" fn CGRequestPostEventAccess() -> bool {
    extern "C-unwind" {
        fn CGRequestPostEventAccess() -> bool;
    }
    unsafe { CGRequestPostEventAccess() }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new`"]
#[inline]
pub extern "C-unwind" fn CGEventCreate(
    source: Option<&CGEventSource>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreate(source: Option<&CGEventSource>) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreate(source) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_data`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateData(
    allocator: Option<&CFAllocator>,
    event: Option<&CGEvent>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CGEventCreateData(
            allocator: Option<&CFAllocator>,
            event: Option<&CGEvent>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CGEventCreateData(allocator, event) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::from_data`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateFromData(
    allocator: Option<&CFAllocator>,
    data: Option<&CFData>,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateFromData(
            allocator: Option<&CFAllocator>,
            data: Option<&CFData>,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreateFromData(allocator, data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_mouse_event`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateMouseEvent(
    source: Option<&CGEventSource>,
    mouse_type: CGEventType,
    mouse_cursor_position: CGPoint,
    mouse_button: CGMouseButton,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateMouseEvent(
            source: Option<&CGEventSource>,
            mouse_type: CGEventType,
            mouse_cursor_position: CGPoint,
            mouse_button: CGMouseButton,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret =
        unsafe { CGEventCreateMouseEvent(source, mouse_type, mouse_cursor_position, mouse_button) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGEventTypes", feature = "CGRemoteOperation"))]
#[deprecated = "renamed to `CGEvent::new_keyboard_event`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateKeyboardEvent(
    source: Option<&CGEventSource>,
    virtual_key: CGKeyCode,
    key_down: bool,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateKeyboardEvent(
            source: Option<&CGEventSource>,
            virtual_key: CGKeyCode,
            key_down: bool,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreateKeyboardEvent(source, virtual_key, key_down) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_scroll_wheel_event2`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateScrollWheelEvent2(
    source: Option<&CGEventSource>,
    units: CGScrollEventUnit,
    wheel_count: u32,
    wheel1: i32,
    wheel2: i32,
    wheel3: i32,
) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateScrollWheelEvent2(
            source: Option<&CGEventSource>,
            units: CGScrollEventUnit,
            wheel_count: u32,
            wheel1: i32,
            wheel2: i32,
            wheel3: i32,
        ) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe {
        CGEventCreateScrollWheelEvent2(source, units, wheel_count, wheel1, wheel2, wheel3)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_copy`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateCopy(event: Option<&CGEvent>) -> Option<CFRetained<CGEvent>> {
    extern "C-unwind" {
        fn CGEventCreateCopy(event: Option<&CGEvent>) -> Option<NonNull<CGEvent>>;
    }
    let ret = unsafe { CGEventCreateCopy(event) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::new_source_from_event`"]
#[inline]
pub extern "C-unwind" fn CGEventCreateSourceFromEvent(
    event: Option<&CGEvent>,
) -> Option<CFRetained<CGEventSource>> {
    extern "C-unwind" {
        fn CGEventCreateSourceFromEvent(event: Option<&CGEvent>) -> Option<NonNull<CGEventSource>>;
    }
    let ret = unsafe { CGEventCreateSourceFromEvent(event) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_source`"]
#[inline]
pub extern "C-unwind" fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>) {
    extern "C-unwind" {
        fn CGEventSetSource(event: Option<&CGEvent>, source: Option<&CGEventSource>);
    }
    unsafe { CGEventSetSource(event, source) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::type`"]
#[inline]
pub extern "C-unwind" fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType {
    extern "C-unwind" {
        fn CGEventGetType(event: Option<&CGEvent>) -> CGEventType;
    }
    unsafe { CGEventGetType(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_type`"]
#[inline]
pub extern "C-unwind" fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType) {
    extern "C-unwind" {
        fn CGEventSetType(event: Option<&CGEvent>, r#type: CGEventType);
    }
    unsafe { CGEventSetType(event, r#type) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::timestamp`"]
#[inline]
pub extern "C-unwind" fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp {
    extern "C-unwind" {
        fn CGEventGetTimestamp(event: Option<&CGEvent>) -> CGEventTimestamp;
    }
    unsafe { CGEventGetTimestamp(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_timestamp`"]
#[inline]
pub extern "C-unwind" fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp) {
    extern "C-unwind" {
        fn CGEventSetTimestamp(event: Option<&CGEvent>, timestamp: CGEventTimestamp);
    }
    unsafe { CGEventSetTimestamp(event, timestamp) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::location`"]
#[inline]
pub extern "C-unwind" fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint {
    extern "C-unwind" {
        fn CGEventGetLocation(event: Option<&CGEvent>) -> CGPoint;
    }
    unsafe { CGEventGetLocation(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::unflipped_location`"]
#[inline]
pub extern "C-unwind" fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint {
    extern "C-unwind" {
        fn CGEventGetUnflippedLocation(event: Option<&CGEvent>) -> CGPoint;
    }
    unsafe { CGEventGetUnflippedLocation(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_location`"]
#[inline]
pub extern "C-unwind" fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint) {
    extern "C-unwind" {
        fn CGEventSetLocation(event: Option<&CGEvent>, location: CGPoint);
    }
    unsafe { CGEventSetLocation(event, location) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::flags`"]
#[inline]
pub extern "C-unwind" fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags {
    extern "C-unwind" {
        fn CGEventGetFlags(event: Option<&CGEvent>) -> CGEventFlags;
    }
    unsafe { CGEventGetFlags(event) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_flags`"]
#[inline]
pub extern "C-unwind" fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags) {
    extern "C-unwind" {
        fn CGEventSetFlags(event: Option<&CGEvent>, flags: CGEventFlags);
    }
    unsafe { CGEventSetFlags(event, flags) }
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::keyboard_get_unicode_string`"]
    pub fn CGEventKeyboardGetUnicodeString(
        event: Option<&CGEvent>,
        max_string_length: UniCharCount,
        actual_string_length: *mut UniCharCount,
        unicode_string: *mut UniChar,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::keyboard_set_unicode_string`"]
    pub fn CGEventKeyboardSetUnicodeString(
        event: Option<&CGEvent>,
        string_length: UniCharCount,
        unicode_string: *const UniChar,
    );
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::integer_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventGetIntegerValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
) -> i64 {
    extern "C-unwind" {
        fn CGEventGetIntegerValueField(event: Option<&CGEvent>, field: CGEventField) -> i64;
    }
    unsafe { CGEventGetIntegerValueField(event, field) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_integer_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventSetIntegerValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
    value: i64,
) {
    extern "C-unwind" {
        fn CGEventSetIntegerValueField(event: Option<&CGEvent>, field: CGEventField, value: i64);
    }
    unsafe { CGEventSetIntegerValueField(event, field, value) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::double_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventGetDoubleValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
) -> c_double {
    extern "C-unwind" {
        fn CGEventGetDoubleValueField(event: Option<&CGEvent>, field: CGEventField) -> c_double;
    }
    unsafe { CGEventGetDoubleValueField(event, field) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::set_double_value_field`"]
#[inline]
pub extern "C-unwind" fn CGEventSetDoubleValueField(
    event: Option<&CGEvent>,
    field: CGEventField,
    value: c_double,
) {
    extern "C-unwind" {
        fn CGEventSetDoubleValueField(
            event: Option<&CGEvent>,
            field: CGEventField,
            value: c_double,
        );
    }
    unsafe { CGEventSetDoubleValueField(event, field, value) }
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::tap_create`"]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreate(
    tap: CGEventTapLocation,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreate(
            tap: CGEventTapLocation,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> Option<NonNull<CFMachPort>>;
    }
    let ret =
        unsafe { CGEventTapCreate(tap, place, options, events_of_interest, callback, user_info) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::tap_create_for_psn`"]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreateForPSN(
    process_serial_number: NonNull<c_void>,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreateForPSN(
            process_serial_number: NonNull<c_void>,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> Option<NonNull<CFMachPort>>;
    }
    let ret = unsafe {
        CGEventTapCreateForPSN(
            process_serial_number,
            place,
            options,
            events_of_interest,
            callback,
            user_info,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGEventTypes", feature = "libc"))]
#[deprecated = "renamed to `CGEvent::tap_create_for_pid`"]
#[inline]
pub unsafe extern "C-unwind" fn CGEventTapCreateForPid(
    pid: libc::pid_t,
    place: CGEventTapPlacement,
    options: CGEventTapOptions,
    events_of_interest: CGEventMask,
    callback: CGEventTapCallBack,
    user_info: *mut c_void,
) -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGEventTapCreateForPid(
            pid: libc::pid_t,
            place: CGEventTapPlacement,
            options: CGEventTapOptions,
            events_of_interest: CGEventMask,
            callback: CGEventTapCallBack,
            user_info: *mut c_void,
        ) -> Option<NonNull<CFMachPort>>;
    }
    let ret = unsafe {
        CGEventTapCreateForPid(pid, place, options, events_of_interest, callback, user_info)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGEvent::tap_enable`"]
#[inline]
pub extern "C-unwind" fn CGEventTapEnable(tap: &CFMachPort, enable: bool) {
    extern "C-unwind" {
        fn CGEventTapEnable(tap: &CFMachPort, enable: bool);
    }
    unsafe { CGEventTapEnable(tap, enable) }
}

#[deprecated = "renamed to `CGEvent::tap_is_enabled`"]
#[inline]
pub extern "C-unwind" fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool {
    extern "C-unwind" {
        fn CGEventTapIsEnabled(tap: &CFMachPort) -> bool;
    }
    unsafe { CGEventTapIsEnabled(tap) }
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::tap_post_event`"]
    pub fn CGEventTapPostEvent(proxy: CGEventTapProxy, event: Option<&CGEvent>);
}

#[cfg(feature = "CGEventTypes")]
#[deprecated = "renamed to `CGEvent::post`"]
#[inline]
pub extern "C-unwind" fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>) {
    extern "C-unwind" {
        fn CGEventPost(tap: CGEventTapLocation, event: Option<&CGEvent>);
    }
    unsafe { CGEventPost(tap, event) }
}

extern "C-unwind" {
    #[cfg(feature = "CGEventTypes")]
    #[deprecated = "renamed to `CGEvent::post_to_psn`"]
    pub fn CGEventPostToPSN(process_serial_number: *mut c_void, event: Option<&CGEvent>);
}

#[cfg(all(feature = "CGEventTypes", feature = "libc"))]
#[deprecated = "renamed to `CGEvent::post_to_pid`"]
#[inline]
pub extern "C-unwind" fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>) {
    extern "C-unwind" {
        fn CGEventPostToPid(pid: libc::pid_t, event: Option<&CGEvent>);
    }
    unsafe { CGEventPostToPid(pid, event) }
}
