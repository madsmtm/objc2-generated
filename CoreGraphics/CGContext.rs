//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcontext?language=objc)
#[doc(alias = "CGContextRef")]
#[repr(C)]
pub struct CGContext {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGContext {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGContext"> for CGContext {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpathdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGPathDrawingMode(pub i32);
impl CGPathDrawingMode {
    #[doc(alias = "kCGPathFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "kCGPathEOFill")]
    pub const EOFill: Self = Self(1);
    #[doc(alias = "kCGPathStroke")]
    pub const Stroke: Self = Self(2);
    #[doc(alias = "kCGPathFillStroke")]
    pub const FillStroke: Self = Self(3);
    #[doc(alias = "kCGPathEOFillStroke")]
    pub const EOFillStroke: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPathDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPathDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextdrawingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGTextDrawingMode(pub i32);
impl CGTextDrawingMode {
    #[doc(alias = "kCGTextFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "kCGTextStroke")]
    pub const Stroke: Self = Self(1);
    #[doc(alias = "kCGTextFillStroke")]
    pub const FillStroke: Self = Self(2);
    #[doc(alias = "kCGTextInvisible")]
    pub const Invisible: Self = Self(3);
    #[doc(alias = "kCGTextFillClip")]
    pub const FillClip: Self = Self(4);
    #[doc(alias = "kCGTextStrokeClip")]
    pub const StrokeClip: Self = Self(5);
    #[doc(alias = "kCGTextFillStrokeClip")]
    pub const FillStrokeClip: Self = Self(6);
    #[doc(alias = "kCGTextClip")]
    pub const Clip: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextDrawingMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextDrawingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgtextencoding?language=objc)
// NS_ENUM
#[deprecated = "No longer supported"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGTextEncoding(pub i32);
impl CGTextEncoding {
    #[doc(alias = "kCGEncodingFontSpecific")]
    #[deprecated = "No longer supported"]
    pub const EncodingFontSpecific: Self = Self(0);
    #[doc(alias = "kCGEncodingMacRoman")]
    #[deprecated = "No longer supported"]
    pub const EncodingMacRoman: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGTextEncoding {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGTextEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cginterpolationquality?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGInterpolationQuality(pub i32);
impl CGInterpolationQuality {
    #[doc(alias = "kCGInterpolationDefault")]
    pub const Default: Self = Self(0);
    #[doc(alias = "kCGInterpolationNone")]
    pub const None: Self = Self(1);
    #[doc(alias = "kCGInterpolationLow")]
    pub const Low: Self = Self(2);
    #[doc(alias = "kCGInterpolationMedium")]
    pub const Medium: Self = Self(4);
    #[doc(alias = "kCGInterpolationHigh")]
    pub const High: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGInterpolationQuality {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGInterpolationQuality {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgblendmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGBlendMode(pub i32);
impl CGBlendMode {
    #[doc(alias = "kCGBlendModeNormal")]
    pub const Normal: Self = Self(0);
    #[doc(alias = "kCGBlendModeMultiply")]
    pub const Multiply: Self = Self(1);
    #[doc(alias = "kCGBlendModeScreen")]
    pub const Screen: Self = Self(2);
    #[doc(alias = "kCGBlendModeOverlay")]
    pub const Overlay: Self = Self(3);
    #[doc(alias = "kCGBlendModeDarken")]
    pub const Darken: Self = Self(4);
    #[doc(alias = "kCGBlendModeLighten")]
    pub const Lighten: Self = Self(5);
    #[doc(alias = "kCGBlendModeColorDodge")]
    pub const ColorDodge: Self = Self(6);
    #[doc(alias = "kCGBlendModeColorBurn")]
    pub const ColorBurn: Self = Self(7);
    #[doc(alias = "kCGBlendModeSoftLight")]
    pub const SoftLight: Self = Self(8);
    #[doc(alias = "kCGBlendModeHardLight")]
    pub const HardLight: Self = Self(9);
    #[doc(alias = "kCGBlendModeDifference")]
    pub const Difference: Self = Self(10);
    #[doc(alias = "kCGBlendModeExclusion")]
    pub const Exclusion: Self = Self(11);
    #[doc(alias = "kCGBlendModeHue")]
    pub const Hue: Self = Self(12);
    #[doc(alias = "kCGBlendModeSaturation")]
    pub const Saturation: Self = Self(13);
    #[doc(alias = "kCGBlendModeColor")]
    pub const Color: Self = Self(14);
    #[doc(alias = "kCGBlendModeLuminosity")]
    pub const Luminosity: Self = Self(15);
    #[doc(alias = "kCGBlendModeClear")]
    pub const Clear: Self = Self(16);
    #[doc(alias = "kCGBlendModeCopy")]
    pub const Copy: Self = Self(17);
    #[doc(alias = "kCGBlendModeSourceIn")]
    pub const SourceIn: Self = Self(18);
    #[doc(alias = "kCGBlendModeSourceOut")]
    pub const SourceOut: Self = Self(19);
    #[doc(alias = "kCGBlendModeSourceAtop")]
    pub const SourceAtop: Self = Self(20);
    #[doc(alias = "kCGBlendModeDestinationOver")]
    pub const DestinationOver: Self = Self(21);
    #[doc(alias = "kCGBlendModeDestinationIn")]
    pub const DestinationIn: Self = Self(22);
    #[doc(alias = "kCGBlendModeDestinationOut")]
    pub const DestinationOut: Self = Self(23);
    #[doc(alias = "kCGBlendModeDestinationAtop")]
    pub const DestinationAtop: Self = Self(24);
    #[doc(alias = "kCGBlendModeXOR")]
    pub const XOR: Self = Self(25);
    #[doc(alias = "kCGBlendModePlusDarker")]
    pub const PlusDarker: Self = Self(26);
    #[doc(alias = "kCGBlendModePlusLighter")]
    pub const PlusLighter: Self = Self(27);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGBlendMode {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGBlendMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CGContext {
    #[doc(alias = "CGContextGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGContextGetTypeID() -> CFTypeID;
        }
        unsafe { CGContextGetTypeID() }
    }
}

impl CGContext {
    /// Graphics state functions. *
    #[doc(alias = "CGContextSaveGState")]
    #[inline]
    pub fn save_g_state(&self) {
        extern "C-unwind" {
            fn CGContextSaveGState(c: &CGContext);
        }
        unsafe { CGContextSaveGState(self) }
    }

    #[doc(alias = "CGContextRestoreGState")]
    #[inline]
    pub fn restore_g_state(&self) {
        extern "C-unwind" {
            fn CGContextRestoreGState(c: &CGContext);
        }
        unsafe { CGContextRestoreGState(self) }
    }

    /// Coordinate space transformations. *
    #[doc(alias = "CGContextScaleCTM")]
    #[inline]
    pub fn scale_ctm(&self, sx: CGFloat, sy: CGFloat) {
        extern "C-unwind" {
            fn CGContextScaleCTM(c: &CGContext, sx: CGFloat, sy: CGFloat);
        }
        unsafe { CGContextScaleCTM(self, sx, sy) }
    }

    #[doc(alias = "CGContextTranslateCTM")]
    #[inline]
    pub fn translate_ctm(&self, tx: CGFloat, ty: CGFloat) {
        extern "C-unwind" {
            fn CGContextTranslateCTM(c: &CGContext, tx: CGFloat, ty: CGFloat);
        }
        unsafe { CGContextTranslateCTM(self, tx, ty) }
    }

    #[doc(alias = "CGContextRotateCTM")]
    #[inline]
    pub fn rotate_ctm(&self, angle: CGFloat) {
        extern "C-unwind" {
            fn CGContextRotateCTM(c: &CGContext, angle: CGFloat);
        }
        unsafe { CGContextRotateCTM(self, angle) }
    }

    #[doc(alias = "CGContextConcatCTM")]
    #[inline]
    pub fn concat_ctm(&self, transform: CGAffineTransform) {
        extern "C-unwind" {
            fn CGContextConcatCTM(c: &CGContext, transform: CGAffineTransform);
        }
        unsafe { CGContextConcatCTM(self, transform) }
    }

    #[doc(alias = "CGContextGetCTM")]
    #[inline]
    pub fn ctm(&self) -> CGAffineTransform {
        extern "C-unwind" {
            fn CGContextGetCTM(c: &CGContext) -> CGAffineTransform;
        }
        unsafe { CGContextGetCTM(self) }
    }

    /// Drawing attribute functions. *
    #[doc(alias = "CGContextSetLineWidth")]
    #[inline]
    pub fn set_line_width(&self, width: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetLineWidth(c: &CGContext, width: CGFloat);
        }
        unsafe { CGContextSetLineWidth(self, width) }
    }

    #[doc(alias = "CGContextSetLineCap")]
    #[cfg(feature = "CGPath")]
    #[inline]
    pub fn set_line_cap(&self, cap: CGLineCap) {
        extern "C-unwind" {
            fn CGContextSetLineCap(c: &CGContext, cap: CGLineCap);
        }
        unsafe { CGContextSetLineCap(self, cap) }
    }

    #[doc(alias = "CGContextSetLineJoin")]
    #[cfg(feature = "CGPath")]
    #[inline]
    pub fn set_line_join(&self, join: CGLineJoin) {
        extern "C-unwind" {
            fn CGContextSetLineJoin(c: &CGContext, join: CGLineJoin);
        }
        unsafe { CGContextSetLineJoin(self, join) }
    }

    #[doc(alias = "CGContextSetMiterLimit")]
    #[inline]
    pub fn set_miter_limit(&self, limit: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetMiterLimit(c: &CGContext, limit: CGFloat);
        }
        unsafe { CGContextSetMiterLimit(self, limit) }
    }

    /// # Safety
    ///
    /// `lengths` must be a valid pointer or null.
    #[doc(alias = "CGContextSetLineDash")]
    #[inline]
    pub unsafe fn set_line_dash(&self, phase: CGFloat, lengths: *const CGFloat, count: usize) {
        extern "C-unwind" {
            fn CGContextSetLineDash(
                c: &CGContext,
                phase: CGFloat,
                lengths: *const CGFloat,
                count: usize,
            );
        }
        unsafe { CGContextSetLineDash(self, phase, lengths, count) }
    }

    #[doc(alias = "CGContextSetFlatness")]
    #[inline]
    pub fn set_flatness(&self, flatness: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetFlatness(c: &CGContext, flatness: CGFloat);
        }
        unsafe { CGContextSetFlatness(self, flatness) }
    }

    #[doc(alias = "CGContextSetAlpha")]
    #[inline]
    pub fn set_alpha(&self, alpha: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetAlpha(c: &CGContext, alpha: CGFloat);
        }
        unsafe { CGContextSetAlpha(self, alpha) }
    }

    #[doc(alias = "CGContextSetBlendMode")]
    #[inline]
    pub fn set_blend_mode(&self, mode: CGBlendMode) {
        extern "C-unwind" {
            fn CGContextSetBlendMode(c: &CGContext, mode: CGBlendMode);
        }
        unsafe { CGContextSetBlendMode(self, mode) }
    }

    /// Path construction functions. *
    #[doc(alias = "CGContextBeginPath")]
    #[inline]
    pub fn begin_path(&self) {
        extern "C-unwind" {
            fn CGContextBeginPath(c: &CGContext);
        }
        unsafe { CGContextBeginPath(self) }
    }

    #[doc(alias = "CGContextMoveToPoint")]
    #[inline]
    pub fn move_to_point(&self, x: CGFloat, y: CGFloat) {
        extern "C-unwind" {
            fn CGContextMoveToPoint(c: &CGContext, x: CGFloat, y: CGFloat);
        }
        unsafe { CGContextMoveToPoint(self, x, y) }
    }

    #[doc(alias = "CGContextAddLineToPoint")]
    #[inline]
    pub fn add_line_to_point(&self, x: CGFloat, y: CGFloat) {
        extern "C-unwind" {
            fn CGContextAddLineToPoint(c: &CGContext, x: CGFloat, y: CGFloat);
        }
        unsafe { CGContextAddLineToPoint(self, x, y) }
    }

    #[doc(alias = "CGContextAddCurveToPoint")]
    #[inline]
    pub fn add_curve_to_point(
        &self,
        cp1x: CGFloat,
        cp1y: CGFloat,
        cp2x: CGFloat,
        cp2y: CGFloat,
        x: CGFloat,
        y: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGContextAddCurveToPoint(
                c: &CGContext,
                cp1x: CGFloat,
                cp1y: CGFloat,
                cp2x: CGFloat,
                cp2y: CGFloat,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGContextAddCurveToPoint(self, cp1x, cp1y, cp2x, cp2y, x, y) }
    }

    #[doc(alias = "CGContextAddQuadCurveToPoint")]
    #[inline]
    pub fn add_quad_curve_to_point(&self, cpx: CGFloat, cpy: CGFloat, x: CGFloat, y: CGFloat) {
        extern "C-unwind" {
            fn CGContextAddQuadCurveToPoint(
                c: &CGContext,
                cpx: CGFloat,
                cpy: CGFloat,
                x: CGFloat,
                y: CGFloat,
            );
        }
        unsafe { CGContextAddQuadCurveToPoint(self, cpx, cpy, x, y) }
    }

    #[doc(alias = "CGContextClosePath")]
    #[inline]
    pub fn close_path(&self) {
        extern "C-unwind" {
            fn CGContextClosePath(c: &CGContext);
        }
        unsafe { CGContextClosePath(self) }
    }

    /// Path construction convenience functions. *
    #[doc(alias = "CGContextAddRect")]
    #[inline]
    pub fn add_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextAddRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextAddRect(self, rect) }
    }

    /// # Safety
    ///
    /// `rects` must be a valid pointer or null.
    #[doc(alias = "CGContextAddRects")]
    #[inline]
    pub unsafe fn add_rects(&self, rects: *const CGRect, count: usize) {
        extern "C-unwind" {
            fn CGContextAddRects(c: &CGContext, rects: *const CGRect, count: usize);
        }
        unsafe { CGContextAddRects(self, rects, count) }
    }

    /// # Safety
    ///
    /// `points` must be a valid pointer or null.
    #[doc(alias = "CGContextAddLines")]
    #[inline]
    pub unsafe fn add_lines(&self, points: *const CGPoint, count: usize) {
        extern "C-unwind" {
            fn CGContextAddLines(c: &CGContext, points: *const CGPoint, count: usize);
        }
        unsafe { CGContextAddLines(self, points, count) }
    }

    #[doc(alias = "CGContextAddEllipseInRect")]
    #[inline]
    pub fn add_ellipse_in_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextAddEllipseInRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextAddEllipseInRect(self, rect) }
    }

    #[doc(alias = "CGContextAddArc")]
    #[inline]
    pub fn add_arc(
        &self,
        x: CGFloat,
        y: CGFloat,
        radius: CGFloat,
        start_angle: CGFloat,
        end_angle: CGFloat,
        clockwise: c_int,
    ) {
        extern "C-unwind" {
            fn CGContextAddArc(
                c: &CGContext,
                x: CGFloat,
                y: CGFloat,
                radius: CGFloat,
                start_angle: CGFloat,
                end_angle: CGFloat,
                clockwise: c_int,
            );
        }
        unsafe { CGContextAddArc(self, x, y, radius, start_angle, end_angle, clockwise) }
    }

    #[doc(alias = "CGContextAddArcToPoint")]
    #[inline]
    pub fn add_arc_to_point(
        &self,
        x1: CGFloat,
        y1: CGFloat,
        x2: CGFloat,
        y2: CGFloat,
        radius: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGContextAddArcToPoint(
                c: &CGContext,
                x1: CGFloat,
                y1: CGFloat,
                x2: CGFloat,
                y2: CGFloat,
                radius: CGFloat,
            );
        }
        unsafe { CGContextAddArcToPoint(self, x1, y1, x2, y2, radius) }
    }

    #[doc(alias = "CGContextAddPath")]
    #[cfg(feature = "CGPath")]
    #[inline]
    pub fn add_path(&self, path: &CGPath) {
        extern "C-unwind" {
            fn CGContextAddPath(c: &CGContext, path: &CGPath);
        }
        unsafe { CGContextAddPath(self, path) }
    }

    #[doc(alias = "CGContextReplacePathWithStrokedPath")]
    #[inline]
    pub fn replace_path_with_stroked_path(&self) {
        extern "C-unwind" {
            fn CGContextReplacePathWithStrokedPath(c: &CGContext);
        }
        unsafe { CGContextReplacePathWithStrokedPath(self) }
    }

    /// Path information functions. *
    #[doc(alias = "CGContextIsPathEmpty")]
    #[inline]
    pub fn is_path_empty(&self) -> bool {
        extern "C-unwind" {
            fn CGContextIsPathEmpty(c: &CGContext) -> bool;
        }
        unsafe { CGContextIsPathEmpty(self) }
    }

    #[doc(alias = "CGContextGetPathCurrentPoint")]
    #[inline]
    pub fn path_current_point(&self) -> CGPoint {
        extern "C-unwind" {
            fn CGContextGetPathCurrentPoint(c: &CGContext) -> CGPoint;
        }
        unsafe { CGContextGetPathCurrentPoint(self) }
    }

    #[doc(alias = "CGContextGetPathBoundingBox")]
    #[inline]
    pub fn path_bounding_box(&self) -> CGRect {
        extern "C-unwind" {
            fn CGContextGetPathBoundingBox(c: &CGContext) -> CGRect;
        }
        unsafe { CGContextGetPathBoundingBox(self) }
    }

    #[doc(alias = "CGContextCopyPath")]
    #[cfg(feature = "CGPath")]
    #[inline]
    pub fn path(&self) -> Option<CFRetained<CGPath>> {
        extern "C-unwind" {
            fn CGContextCopyPath(c: &CGContext) -> Option<NonNull<CGPath>>;
        }
        let ret = unsafe { CGContextCopyPath(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGContextPathContainsPoint")]
    #[inline]
    pub fn path_contains_point(&self, point: CGPoint, mode: CGPathDrawingMode) -> bool {
        extern "C-unwind" {
            fn CGContextPathContainsPoint(
                c: &CGContext,
                point: CGPoint,
                mode: CGPathDrawingMode,
            ) -> bool;
        }
        unsafe { CGContextPathContainsPoint(self, point, mode) }
    }

    /// Path drawing functions. *
    #[doc(alias = "CGContextDrawPath")]
    #[inline]
    pub fn draw_path(&self, mode: CGPathDrawingMode) {
        extern "C-unwind" {
            fn CGContextDrawPath(c: &CGContext, mode: CGPathDrawingMode);
        }
        unsafe { CGContextDrawPath(self, mode) }
    }

    /// Path drawing convenience functions. *
    #[doc(alias = "CGContextFillPath")]
    #[inline]
    pub fn fill_path(&self) {
        extern "C-unwind" {
            fn CGContextFillPath(c: &CGContext);
        }
        unsafe { CGContextFillPath(self) }
    }

    #[doc(alias = "CGContextEOFillPath")]
    #[inline]
    pub fn eo_fill_path(&self) {
        extern "C-unwind" {
            fn CGContextEOFillPath(c: &CGContext);
        }
        unsafe { CGContextEOFillPath(self) }
    }

    #[doc(alias = "CGContextStrokePath")]
    #[inline]
    pub fn stroke_path(&self) {
        extern "C-unwind" {
            fn CGContextStrokePath(c: &CGContext);
        }
        unsafe { CGContextStrokePath(self) }
    }

    #[doc(alias = "CGContextFillRect")]
    #[inline]
    pub fn fill_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextFillRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextFillRect(self, rect) }
    }

    /// # Safety
    ///
    /// `rects` must be a valid pointer or null.
    #[doc(alias = "CGContextFillRects")]
    #[inline]
    pub unsafe fn fill_rects(&self, rects: *const CGRect, count: usize) {
        extern "C-unwind" {
            fn CGContextFillRects(c: &CGContext, rects: *const CGRect, count: usize);
        }
        unsafe { CGContextFillRects(self, rects, count) }
    }

    #[doc(alias = "CGContextStrokeRect")]
    #[inline]
    pub fn stroke_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextStrokeRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextStrokeRect(self, rect) }
    }

    #[doc(alias = "CGContextStrokeRectWithWidth")]
    #[inline]
    pub fn stroke_rect_with_width(&self, rect: CGRect, width: CGFloat) {
        extern "C-unwind" {
            fn CGContextStrokeRectWithWidth(c: &CGContext, rect: CGRect, width: CGFloat);
        }
        unsafe { CGContextStrokeRectWithWidth(self, rect, width) }
    }

    #[doc(alias = "CGContextClearRect")]
    #[inline]
    pub fn clear_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextClearRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextClearRect(self, rect) }
    }

    #[doc(alias = "CGContextFillEllipseInRect")]
    #[inline]
    pub fn fill_ellipse_in_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextFillEllipseInRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextFillEllipseInRect(self, rect) }
    }

    #[doc(alias = "CGContextStrokeEllipseInRect")]
    #[inline]
    pub fn stroke_ellipse_in_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextStrokeEllipseInRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextStrokeEllipseInRect(self, rect) }
    }

    /// # Safety
    ///
    /// `points` must be a valid pointer or null.
    #[doc(alias = "CGContextStrokeLineSegments")]
    #[inline]
    pub unsafe fn stroke_line_segments(&self, points: *const CGPoint, count: usize) {
        extern "C-unwind" {
            fn CGContextStrokeLineSegments(c: &CGContext, points: *const CGPoint, count: usize);
        }
        unsafe { CGContextStrokeLineSegments(self, points, count) }
    }

    /// Clipping functions. *
    #[doc(alias = "CGContextClip")]
    #[inline]
    pub fn clip(&self) {
        extern "C-unwind" {
            fn CGContextClip(c: &CGContext);
        }
        unsafe { CGContextClip(self) }
    }

    #[doc(alias = "CGContextEOClip")]
    #[inline]
    pub fn eo_clip(&self) {
        extern "C-unwind" {
            fn CGContextEOClip(c: &CGContext);
        }
        unsafe { CGContextEOClip(self) }
    }

    #[doc(alias = "CGContextResetClip")]
    #[inline]
    pub fn reset_clip(&self) {
        extern "C-unwind" {
            fn CGContextResetClip(c: &CGContext);
        }
        unsafe { CGContextResetClip(self) }
    }

    #[doc(alias = "CGContextClipToMask")]
    #[cfg(feature = "CGImage")]
    #[inline]
    pub fn clip_to_mask(&self, rect: CGRect, mask: &CGImage) {
        extern "C-unwind" {
            fn CGContextClipToMask(c: &CGContext, rect: CGRect, mask: &CGImage);
        }
        unsafe { CGContextClipToMask(self, rect, mask) }
    }

    #[doc(alias = "CGContextGetClipBoundingBox")]
    #[inline]
    pub fn clip_bounding_box(&self) -> CGRect {
        extern "C-unwind" {
            fn CGContextGetClipBoundingBox(c: &CGContext) -> CGRect;
        }
        unsafe { CGContextGetClipBoundingBox(self) }
    }

    /// Clipping convenience functions. *
    #[doc(alias = "CGContextClipToRect")]
    #[inline]
    pub fn clip_to_rect(&self, rect: CGRect) {
        extern "C-unwind" {
            fn CGContextClipToRect(c: &CGContext, rect: CGRect);
        }
        unsafe { CGContextClipToRect(self, rect) }
    }

    /// # Safety
    ///
    /// `rects` must be a valid pointer.
    #[doc(alias = "CGContextClipToRects")]
    #[inline]
    pub unsafe fn clip_to_rects(&self, rects: NonNull<CGRect>, count: usize) {
        extern "C-unwind" {
            fn CGContextClipToRects(c: &CGContext, rects: NonNull<CGRect>, count: usize);
        }
        unsafe { CGContextClipToRects(self, rects, count) }
    }

    /// Primitive color functions. *
    #[doc(alias = "CGContextSetFillColorWithColor")]
    #[cfg(feature = "CGColor")]
    #[inline]
    pub fn set_fill_color_with_color(&self, color: &CGColor) {
        extern "C-unwind" {
            fn CGContextSetFillColorWithColor(c: &CGContext, color: &CGColor);
        }
        unsafe { CGContextSetFillColorWithColor(self, color) }
    }

    #[doc(alias = "CGContextSetStrokeColorWithColor")]
    #[cfg(feature = "CGColor")]
    #[inline]
    pub fn set_stroke_color_with_color(&self, color: &CGColor) {
        extern "C-unwind" {
            fn CGContextSetStrokeColorWithColor(c: &CGContext, color: &CGColor);
        }
        unsafe { CGContextSetStrokeColorWithColor(self, color) }
    }

    /// Color space functions. *
    #[doc(alias = "CGContextSetFillColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn set_fill_color_space(&self, space: &CGColorSpace) {
        extern "C-unwind" {
            fn CGContextSetFillColorSpace(c: &CGContext, space: &CGColorSpace);
        }
        unsafe { CGContextSetFillColorSpace(self, space) }
    }

    #[doc(alias = "CGContextSetStrokeColorSpace")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn set_stroke_color_space(&self, space: &CGColorSpace) {
        extern "C-unwind" {
            fn CGContextSetStrokeColorSpace(c: &CGContext, space: &CGColorSpace);
        }
        unsafe { CGContextSetStrokeColorSpace(self, space) }
    }

    /// Color functions. *
    ///
    /// # Safety
    ///
    /// `components` must be a valid pointer.
    #[doc(alias = "CGContextSetFillColor")]
    #[inline]
    pub unsafe fn set_fill_color(&self, components: NonNull<CGFloat>) {
        extern "C-unwind" {
            fn CGContextSetFillColor(c: &CGContext, components: NonNull<CGFloat>);
        }
        unsafe { CGContextSetFillColor(self, components) }
    }

    /// # Safety
    ///
    /// `components` must be a valid pointer.
    #[doc(alias = "CGContextSetStrokeColor")]
    #[inline]
    pub unsafe fn set_stroke_color(&self, components: NonNull<CGFloat>) {
        extern "C-unwind" {
            fn CGContextSetStrokeColor(c: &CGContext, components: NonNull<CGFloat>);
        }
        unsafe { CGContextSetStrokeColor(self, components) }
    }

    /// Pattern functions. *
    ///
    /// # Safety
    ///
    /// `components` must be a valid pointer.
    #[doc(alias = "CGContextSetFillPattern")]
    #[cfg(feature = "CGPattern")]
    #[inline]
    pub unsafe fn set_fill_pattern(&self, pattern: &CGPattern, components: NonNull<CGFloat>) {
        extern "C-unwind" {
            fn CGContextSetFillPattern(
                c: &CGContext,
                pattern: &CGPattern,
                components: NonNull<CGFloat>,
            );
        }
        unsafe { CGContextSetFillPattern(self, pattern, components) }
    }

    /// # Safety
    ///
    /// `components` must be a valid pointer.
    #[doc(alias = "CGContextSetStrokePattern")]
    #[cfg(feature = "CGPattern")]
    #[inline]
    pub unsafe fn set_stroke_pattern(&self, pattern: &CGPattern, components: NonNull<CGFloat>) {
        extern "C-unwind" {
            fn CGContextSetStrokePattern(
                c: &CGContext,
                pattern: &CGPattern,
                components: NonNull<CGFloat>,
            );
        }
        unsafe { CGContextSetStrokePattern(self, pattern, components) }
    }

    #[doc(alias = "CGContextSetPatternPhase")]
    #[inline]
    pub fn set_pattern_phase(&self, phase: CGSize) {
        extern "C-unwind" {
            fn CGContextSetPatternPhase(c: &CGContext, phase: CGSize);
        }
        unsafe { CGContextSetPatternPhase(self, phase) }
    }

    /// Color convenience functions. *
    #[doc(alias = "CGContextSetGrayFillColor")]
    #[inline]
    pub fn set_gray_fill_color(&self, gray: CGFloat, alpha: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetGrayFillColor(c: &CGContext, gray: CGFloat, alpha: CGFloat);
        }
        unsafe { CGContextSetGrayFillColor(self, gray, alpha) }
    }

    #[doc(alias = "CGContextSetGrayStrokeColor")]
    #[inline]
    pub fn set_gray_stroke_color(&self, gray: CGFloat, alpha: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetGrayStrokeColor(c: &CGContext, gray: CGFloat, alpha: CGFloat);
        }
        unsafe { CGContextSetGrayStrokeColor(self, gray, alpha) }
    }

    #[doc(alias = "CGContextSetRGBFillColor")]
    #[inline]
    pub fn set_rgb_fill_color(&self, red: CGFloat, green: CGFloat, blue: CGFloat, alpha: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetRGBFillColor(
                c: &CGContext,
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            );
        }
        unsafe { CGContextSetRGBFillColor(self, red, green, blue, alpha) }
    }

    #[doc(alias = "CGContextSetRGBStrokeColor")]
    #[inline]
    pub fn set_rgb_stroke_color(
        &self,
        red: CGFloat,
        green: CGFloat,
        blue: CGFloat,
        alpha: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGContextSetRGBStrokeColor(
                c: &CGContext,
                red: CGFloat,
                green: CGFloat,
                blue: CGFloat,
                alpha: CGFloat,
            );
        }
        unsafe { CGContextSetRGBStrokeColor(self, red, green, blue, alpha) }
    }

    #[doc(alias = "CGContextSetCMYKFillColor")]
    #[inline]
    pub fn set_cmyk_fill_color(
        &self,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGContextSetCMYKFillColor(
                c: &CGContext,
                cyan: CGFloat,
                magenta: CGFloat,
                yellow: CGFloat,
                black: CGFloat,
                alpha: CGFloat,
            );
        }
        unsafe { CGContextSetCMYKFillColor(self, cyan, magenta, yellow, black, alpha) }
    }

    #[doc(alias = "CGContextSetCMYKStrokeColor")]
    #[inline]
    pub fn set_cmyk_stroke_color(
        &self,
        cyan: CGFloat,
        magenta: CGFloat,
        yellow: CGFloat,
        black: CGFloat,
        alpha: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGContextSetCMYKStrokeColor(
                c: &CGContext,
                cyan: CGFloat,
                magenta: CGFloat,
                yellow: CGFloat,
                black: CGFloat,
                alpha: CGFloat,
            );
        }
        unsafe { CGContextSetCMYKStrokeColor(self, cyan, magenta, yellow, black, alpha) }
    }

    /// Rendering intent. *
    #[doc(alias = "CGContextSetRenderingIntent")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn set_rendering_intent(&self, intent: CGColorRenderingIntent) {
        extern "C-unwind" {
            fn CGContextSetRenderingIntent(c: &CGContext, intent: CGColorRenderingIntent);
        }
        unsafe { CGContextSetRenderingIntent(self, intent) }
    }

    #[doc(alias = "CGContextSetEDRTargetHeadroom")]
    #[inline]
    pub fn set_edr_target_headroom(&self, headroom: c_float) -> bool {
        extern "C-unwind" {
            fn CGContextSetEDRTargetHeadroom(c: &CGContext, headroom: c_float) -> bool;
        }
        unsafe { CGContextSetEDRTargetHeadroom(self, headroom) }
    }

    #[doc(alias = "CGContextGetEDRTargetHeadroom")]
    #[inline]
    pub fn edr_target_headroom(&self) -> c_float {
        extern "C-unwind" {
            fn CGContextGetEDRTargetHeadroom(c: &CGContext) -> c_float;
        }
        unsafe { CGContextGetEDRTargetHeadroom(self) }
    }

    /// Image functions. *
    #[doc(alias = "CGContextDrawImage")]
    #[cfg(feature = "CGImage")]
    #[inline]
    pub fn draw_image(&self, rect: CGRect, image: &CGImage) {
        extern "C-unwind" {
            fn CGContextDrawImage(c: &CGContext, rect: CGRect, image: &CGImage);
        }
        unsafe { CGContextDrawImage(self, rect, image) }
    }

    #[doc(alias = "CGContextDrawTiledImage")]
    #[cfg(feature = "CGImage")]
    #[inline]
    pub fn draw_tiled_image(&self, rect: CGRect, image: &CGImage) {
        extern "C-unwind" {
            fn CGContextDrawTiledImage(c: &CGContext, rect: CGRect, image: &CGImage);
        }
        unsafe { CGContextDrawTiledImage(self, rect, image) }
    }

    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGContextDrawImageApplyingToneMapping")]
    #[cfg(all(feature = "CGImage", feature = "CGToneMapping"))]
    #[inline]
    pub unsafe fn draw_image_applying_tone_mapping(
        &self,
        r: CGRect,
        image: &CGImage,
        method: CGToneMapping,
        options: Option<&CFDictionary>,
    ) -> bool {
        extern "C-unwind" {
            fn CGContextDrawImageApplyingToneMapping(
                c: &CGContext,
                r: CGRect,
                image: &CGImage,
                method: CGToneMapping,
                options: Option<&CFDictionary>,
            ) -> bool;
        }
        unsafe { CGContextDrawImageApplyingToneMapping(self, r, image, method, options) }
    }

    #[doc(alias = "CGContextGetContentToneMappingInfo")]
    #[cfg(feature = "CGToneMapping")]
    #[inline]
    pub fn content_tone_mapping_info(&self) -> CGContentToneMappingInfo {
        extern "C-unwind" {
            fn CGContextGetContentToneMappingInfo(c: &CGContext) -> CGContentToneMappingInfo;
        }
        unsafe { CGContextGetContentToneMappingInfo(self) }
    }

    /// # Safety
    ///
    /// `info` struct field 2 must be a valid pointer or null.
    #[doc(alias = "CGContextSetContentToneMappingInfo")]
    #[cfg(feature = "CGToneMapping")]
    #[inline]
    pub unsafe fn set_content_tone_mapping_info(&self, info: CGContentToneMappingInfo) {
        extern "C-unwind" {
            fn CGContextSetContentToneMappingInfo(c: &CGContext, info: CGContentToneMappingInfo);
        }
        unsafe { CGContextSetContentToneMappingInfo(self, info) }
    }

    #[doc(alias = "CGContextGetInterpolationQuality")]
    #[inline]
    pub fn interpolation_quality(&self) -> CGInterpolationQuality {
        extern "C-unwind" {
            fn CGContextGetInterpolationQuality(c: &CGContext) -> CGInterpolationQuality;
        }
        unsafe { CGContextGetInterpolationQuality(self) }
    }

    #[doc(alias = "CGContextSetInterpolationQuality")]
    #[inline]
    pub fn set_interpolation_quality(&self, quality: CGInterpolationQuality) {
        extern "C-unwind" {
            fn CGContextSetInterpolationQuality(c: &CGContext, quality: CGInterpolationQuality);
        }
        unsafe { CGContextSetInterpolationQuality(self, quality) }
    }

    #[doc(alias = "CGContextSetShadowWithColor")]
    #[cfg(feature = "CGColor")]
    #[inline]
    pub fn set_shadow_with_color(&self, offset: CGSize, blur: CGFloat, color: Option<&CGColor>) {
        extern "C-unwind" {
            fn CGContextSetShadowWithColor(
                c: &CGContext,
                offset: CGSize,
                blur: CGFloat,
                color: Option<&CGColor>,
            );
        }
        unsafe { CGContextSetShadowWithColor(self, offset, blur, color) }
    }

    #[doc(alias = "CGContextSetShadow")]
    #[inline]
    pub fn set_shadow(&self, offset: CGSize, blur: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetShadow(c: &CGContext, offset: CGSize, blur: CGFloat);
        }
        unsafe { CGContextSetShadow(self, offset, blur) }
    }

    #[doc(alias = "CGContextDrawLinearGradient")]
    #[cfg(feature = "CGGradient")]
    #[inline]
    pub fn draw_linear_gradient(
        &self,
        gradient: &CGGradient,
        start_point: CGPoint,
        end_point: CGPoint,
        options: CGGradientDrawingOptions,
    ) {
        extern "C-unwind" {
            fn CGContextDrawLinearGradient(
                c: &CGContext,
                gradient: &CGGradient,
                start_point: CGPoint,
                end_point: CGPoint,
                options: CGGradientDrawingOptions,
            );
        }
        unsafe { CGContextDrawLinearGradient(self, gradient, start_point, end_point, options) }
    }

    #[doc(alias = "CGContextDrawRadialGradient")]
    #[cfg(feature = "CGGradient")]
    #[inline]
    pub fn draw_radial_gradient(
        &self,
        gradient: &CGGradient,
        start_center: CGPoint,
        start_radius: CGFloat,
        end_center: CGPoint,
        end_radius: CGFloat,
        options: CGGradientDrawingOptions,
    ) {
        extern "C-unwind" {
            fn CGContextDrawRadialGradient(
                c: &CGContext,
                gradient: &CGGradient,
                start_center: CGPoint,
                start_radius: CGFloat,
                end_center: CGPoint,
                end_radius: CGFloat,
                options: CGGradientDrawingOptions,
            );
        }
        unsafe {
            CGContextDrawRadialGradient(
                self,
                gradient,
                start_center,
                start_radius,
                end_center,
                end_radius,
                options,
            )
        }
    }

    #[doc(alias = "CGContextDrawConicGradient")]
    #[cfg(feature = "CGGradient")]
    #[inline]
    pub fn draw_conic_gradient(
        &self,
        gradient: Option<&CGGradient>,
        center: CGPoint,
        angle: CGFloat,
    ) {
        extern "C-unwind" {
            fn CGContextDrawConicGradient(
                c: &CGContext,
                gradient: Option<&CGGradient>,
                center: CGPoint,
                angle: CGFloat,
            );
        }
        unsafe { CGContextDrawConicGradient(self, gradient, center, angle) }
    }

    #[doc(alias = "CGContextDrawShading")]
    #[cfg(feature = "CGShading")]
    #[inline]
    pub fn draw_shading(&self, shading: &CGShading) {
        extern "C-unwind" {
            fn CGContextDrawShading(c: &CGContext, shading: &CGShading);
        }
        unsafe { CGContextDrawShading(self, shading) }
    }

    /// Text functions. *
    #[doc(alias = "CGContextSetCharacterSpacing")]
    #[inline]
    pub fn set_character_spacing(&self, spacing: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetCharacterSpacing(c: &CGContext, spacing: CGFloat);
        }
        unsafe { CGContextSetCharacterSpacing(self, spacing) }
    }

    #[doc(alias = "CGContextSetTextPosition")]
    #[inline]
    pub fn set_text_position(&self, x: CGFloat, y: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetTextPosition(c: &CGContext, x: CGFloat, y: CGFloat);
        }
        unsafe { CGContextSetTextPosition(self, x, y) }
    }

    #[doc(alias = "CGContextGetTextPosition")]
    #[inline]
    pub fn text_position(&self) -> CGPoint {
        extern "C-unwind" {
            fn CGContextGetTextPosition(c: &CGContext) -> CGPoint;
        }
        unsafe { CGContextGetTextPosition(self) }
    }

    #[doc(alias = "CGContextSetTextMatrix")]
    #[inline]
    pub fn set_text_matrix(&self, t: CGAffineTransform) {
        extern "C-unwind" {
            fn CGContextSetTextMatrix(c: &CGContext, t: CGAffineTransform);
        }
        unsafe { CGContextSetTextMatrix(self, t) }
    }

    #[doc(alias = "CGContextGetTextMatrix")]
    #[inline]
    pub fn text_matrix(&self) -> CGAffineTransform {
        extern "C-unwind" {
            fn CGContextGetTextMatrix(c: &CGContext) -> CGAffineTransform;
        }
        unsafe { CGContextGetTextMatrix(self) }
    }

    #[doc(alias = "CGContextSetTextDrawingMode")]
    #[inline]
    pub fn set_text_drawing_mode(&self, mode: CGTextDrawingMode) {
        extern "C-unwind" {
            fn CGContextSetTextDrawingMode(c: &CGContext, mode: CGTextDrawingMode);
        }
        unsafe { CGContextSetTextDrawingMode(self, mode) }
    }

    #[doc(alias = "CGContextSetFont")]
    #[cfg(feature = "CGFont")]
    #[inline]
    pub fn set_font(&self, font: &CGFont) {
        extern "C-unwind" {
            fn CGContextSetFont(c: &CGContext, font: &CGFont);
        }
        unsafe { CGContextSetFont(self, font) }
    }

    #[doc(alias = "CGContextSetFontSize")]
    #[inline]
    pub fn set_font_size(&self, size: CGFloat) {
        extern "C-unwind" {
            fn CGContextSetFontSize(c: &CGContext, size: CGFloat);
        }
        unsafe { CGContextSetFontSize(self, size) }
    }

    /// # Safety
    ///
    /// - `glyphs` must be a valid pointer.
    /// - `lpositions` must be a valid pointer.
    #[doc(alias = "CGContextShowGlyphsAtPositions")]
    #[cfg(feature = "CGFont")]
    #[inline]
    pub unsafe fn show_glyphs_at_positions(
        &self,
        glyphs: NonNull<CGGlyph>,
        lpositions: NonNull<CGPoint>,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGContextShowGlyphsAtPositions(
                c: &CGContext,
                glyphs: NonNull<CGGlyph>,
                lpositions: NonNull<CGPoint>,
                count: usize,
            );
        }
        unsafe { CGContextShowGlyphsAtPositions(self, glyphs, lpositions, count) }
    }

    /// PDF functions. *
    #[doc(alias = "CGContextDrawPDFPage")]
    #[cfg(feature = "CGPDFPage")]
    #[inline]
    pub fn draw_pdf_page(&self, page: &CGPDFPage) {
        extern "C-unwind" {
            fn CGContextDrawPDFPage(c: &CGContext, page: &CGPDFPage);
        }
        unsafe { CGContextDrawPDFPage(self, page) }
    }

    /// Output page functions. *
    ///
    /// # Safety
    ///
    /// `media_box` must be a valid pointer or null.
    #[doc(alias = "CGContextBeginPage")]
    #[inline]
    pub unsafe fn begin_page(&self, media_box: *const CGRect) {
        extern "C-unwind" {
            fn CGContextBeginPage(c: &CGContext, media_box: *const CGRect);
        }
        unsafe { CGContextBeginPage(self, media_box) }
    }

    #[doc(alias = "CGContextEndPage")]
    #[inline]
    pub fn end_page(&self) {
        extern "C-unwind" {
            fn CGContextEndPage(c: &CGContext);
        }
        unsafe { CGContextEndPage(self) }
    }

    #[doc(alias = "CGContextFlush")]
    #[inline]
    pub fn flush(&self) {
        extern "C-unwind" {
            fn CGContextFlush(c: &CGContext);
        }
        unsafe { CGContextFlush(self) }
    }

    #[doc(alias = "CGContextSynchronize")]
    #[inline]
    pub fn synchronize(&self) {
        extern "C-unwind" {
            fn CGContextSynchronize(c: &CGContext);
        }
        unsafe { CGContextSynchronize(self) }
    }

    #[doc(alias = "CGContextSynchronizeAttributes")]
    #[inline]
    pub fn synchronize_attributes(&self) {
        extern "C-unwind" {
            fn CGContextSynchronizeAttributes(c: &CGContext);
        }
        unsafe { CGContextSynchronizeAttributes(self) }
    }

    #[doc(alias = "CGContextSetShouldAntialias")]
    #[inline]
    pub fn set_should_antialias(&self, should_antialias: bool) {
        extern "C-unwind" {
            fn CGContextSetShouldAntialias(c: &CGContext, should_antialias: bool);
        }
        unsafe { CGContextSetShouldAntialias(self, should_antialias) }
    }

    #[doc(alias = "CGContextSetAllowsAntialiasing")]
    #[inline]
    pub fn set_allows_antialiasing(&self, allows_antialiasing: bool) {
        extern "C-unwind" {
            fn CGContextSetAllowsAntialiasing(c: &CGContext, allows_antialiasing: bool);
        }
        unsafe { CGContextSetAllowsAntialiasing(self, allows_antialiasing) }
    }

    #[doc(alias = "CGContextSetShouldSmoothFonts")]
    #[inline]
    pub fn set_should_smooth_fonts(&self, should_smooth_fonts: bool) {
        extern "C-unwind" {
            fn CGContextSetShouldSmoothFonts(c: &CGContext, should_smooth_fonts: bool);
        }
        unsafe { CGContextSetShouldSmoothFonts(self, should_smooth_fonts) }
    }

    #[doc(alias = "CGContextSetAllowsFontSmoothing")]
    #[inline]
    pub fn set_allows_font_smoothing(&self, allows_font_smoothing: bool) {
        extern "C-unwind" {
            fn CGContextSetAllowsFontSmoothing(c: &CGContext, allows_font_smoothing: bool);
        }
        unsafe { CGContextSetAllowsFontSmoothing(self, allows_font_smoothing) }
    }

    #[doc(alias = "CGContextSetShouldSubpixelPositionFonts")]
    #[inline]
    pub fn set_should_subpixel_position_fonts(&self, should_subpixel_position_fonts: bool) {
        extern "C-unwind" {
            fn CGContextSetShouldSubpixelPositionFonts(
                c: &CGContext,
                should_subpixel_position_fonts: bool,
            );
        }
        unsafe { CGContextSetShouldSubpixelPositionFonts(self, should_subpixel_position_fonts) }
    }

    #[doc(alias = "CGContextSetAllowsFontSubpixelPositioning")]
    #[inline]
    pub fn set_allows_font_subpixel_positioning(&self, allows_font_subpixel_positioning: bool) {
        extern "C-unwind" {
            fn CGContextSetAllowsFontSubpixelPositioning(
                c: &CGContext,
                allows_font_subpixel_positioning: bool,
            );
        }
        unsafe { CGContextSetAllowsFontSubpixelPositioning(self, allows_font_subpixel_positioning) }
    }

    #[doc(alias = "CGContextSetShouldSubpixelQuantizeFonts")]
    #[inline]
    pub fn set_should_subpixel_quantize_fonts(&self, should_subpixel_quantize_fonts: bool) {
        extern "C-unwind" {
            fn CGContextSetShouldSubpixelQuantizeFonts(
                c: &CGContext,
                should_subpixel_quantize_fonts: bool,
            );
        }
        unsafe { CGContextSetShouldSubpixelQuantizeFonts(self, should_subpixel_quantize_fonts) }
    }

    #[doc(alias = "CGContextSetAllowsFontSubpixelQuantization")]
    #[inline]
    pub fn set_allows_font_subpixel_quantization(&self, allows_font_subpixel_quantization: bool) {
        extern "C-unwind" {
            fn CGContextSetAllowsFontSubpixelQuantization(
                c: &CGContext,
                allows_font_subpixel_quantization: bool,
            );
        }
        unsafe {
            CGContextSetAllowsFontSubpixelQuantization(self, allows_font_subpixel_quantization)
        }
    }

    /// Transparency layer support. *
    ///
    /// # Safety
    ///
    /// - `auxiliary_info` generic must be of the correct type.
    /// - `auxiliary_info` generic must be of the correct type.
    #[doc(alias = "CGContextBeginTransparencyLayer")]
    #[inline]
    pub unsafe fn begin_transparency_layer(&self, auxiliary_info: Option<&CFDictionary>) {
        extern "C-unwind" {
            fn CGContextBeginTransparencyLayer(
                c: &CGContext,
                auxiliary_info: Option<&CFDictionary>,
            );
        }
        unsafe { CGContextBeginTransparencyLayer(self, auxiliary_info) }
    }

    /// # Safety
    ///
    /// - `aux_info` generic must be of the correct type.
    /// - `aux_info` generic must be of the correct type.
    #[doc(alias = "CGContextBeginTransparencyLayerWithRect")]
    #[inline]
    pub unsafe fn begin_transparency_layer_with_rect(
        &self,
        rect: CGRect,
        aux_info: Option<&CFDictionary>,
    ) {
        extern "C-unwind" {
            fn CGContextBeginTransparencyLayerWithRect(
                c: &CGContext,
                rect: CGRect,
                aux_info: Option<&CFDictionary>,
            );
        }
        unsafe { CGContextBeginTransparencyLayerWithRect(self, rect, aux_info) }
    }

    #[doc(alias = "CGContextEndTransparencyLayer")]
    #[inline]
    pub fn end_transparency_layer(&self) {
        extern "C-unwind" {
            fn CGContextEndTransparencyLayer(c: &CGContext);
        }
        unsafe { CGContextEndTransparencyLayer(self) }
    }

    /// User space to device space tranformations. *
    #[doc(alias = "CGContextGetUserSpaceToDeviceSpaceTransform")]
    #[inline]
    pub fn user_space_to_device_space_transform(&self) -> CGAffineTransform {
        extern "C-unwind" {
            fn CGContextGetUserSpaceToDeviceSpaceTransform(c: &CGContext) -> CGAffineTransform;
        }
        unsafe { CGContextGetUserSpaceToDeviceSpaceTransform(self) }
    }

    #[doc(alias = "CGContextConvertPointToDeviceSpace")]
    #[inline]
    pub fn convert_point_to_device_space(&self, point: CGPoint) -> CGPoint {
        extern "C-unwind" {
            fn CGContextConvertPointToDeviceSpace(c: &CGContext, point: CGPoint) -> CGPoint;
        }
        unsafe { CGContextConvertPointToDeviceSpace(self, point) }
    }

    #[doc(alias = "CGContextConvertPointToUserSpace")]
    #[inline]
    pub fn convert_point_to_user_space(&self, point: CGPoint) -> CGPoint {
        extern "C-unwind" {
            fn CGContextConvertPointToUserSpace(c: &CGContext, point: CGPoint) -> CGPoint;
        }
        unsafe { CGContextConvertPointToUserSpace(self, point) }
    }

    #[doc(alias = "CGContextConvertSizeToDeviceSpace")]
    #[inline]
    pub fn convert_size_to_device_space(&self, size: CGSize) -> CGSize {
        extern "C-unwind" {
            fn CGContextConvertSizeToDeviceSpace(c: &CGContext, size: CGSize) -> CGSize;
        }
        unsafe { CGContextConvertSizeToDeviceSpace(self, size) }
    }

    #[doc(alias = "CGContextConvertSizeToUserSpace")]
    #[inline]
    pub fn convert_size_to_user_space(&self, size: CGSize) -> CGSize {
        extern "C-unwind" {
            fn CGContextConvertSizeToUserSpace(c: &CGContext, size: CGSize) -> CGSize;
        }
        unsafe { CGContextConvertSizeToUserSpace(self, size) }
    }

    #[doc(alias = "CGContextConvertRectToDeviceSpace")]
    #[inline]
    pub fn convert_rect_to_device_space(&self, rect: CGRect) -> CGRect {
        extern "C-unwind" {
            fn CGContextConvertRectToDeviceSpace(c: &CGContext, rect: CGRect) -> CGRect;
        }
        unsafe { CGContextConvertRectToDeviceSpace(self, rect) }
    }

    #[doc(alias = "CGContextConvertRectToUserSpace")]
    #[inline]
    pub fn convert_rect_to_user_space(&self, rect: CGRect) -> CGRect {
        extern "C-unwind" {
            fn CGContextConvertRectToUserSpace(c: &CGContext, rect: CGRect) -> CGRect;
        }
        unsafe { CGContextConvertRectToUserSpace(self, rect) }
    }

    /// # Safety
    ///
    /// `name` must be a valid pointer.
    #[doc(alias = "CGContextSelectFont")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn select_font(
        &self,
        name: NonNull<c_char>,
        size: CGFloat,
        text_encoding: CGTextEncoding,
    ) {
        extern "C-unwind" {
            fn CGContextSelectFont(
                c: &CGContext,
                name: NonNull<c_char>,
                size: CGFloat,
                text_encoding: CGTextEncoding,
            );
        }
        unsafe { CGContextSelectFont(self, name, size, text_encoding) }
    }

    /// # Safety
    ///
    /// `string` must be a valid pointer.
    #[doc(alias = "CGContextShowText")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn show_text(&self, string: NonNull<c_char>, length: usize) {
        extern "C-unwind" {
            fn CGContextShowText(c: &CGContext, string: NonNull<c_char>, length: usize);
        }
        unsafe { CGContextShowText(self, string, length) }
    }

    /// # Safety
    ///
    /// `string` must be a valid pointer.
    #[doc(alias = "CGContextShowTextAtPoint")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn show_text_at_point(
        &self,
        x: CGFloat,
        y: CGFloat,
        string: NonNull<c_char>,
        length: usize,
    ) {
        extern "C-unwind" {
            fn CGContextShowTextAtPoint(
                c: &CGContext,
                x: CGFloat,
                y: CGFloat,
                string: NonNull<c_char>,
                length: usize,
            );
        }
        unsafe { CGContextShowTextAtPoint(self, x, y, string, length) }
    }

    /// # Safety
    ///
    /// `g` must be a valid pointer or null.
    #[doc(alias = "CGContextShowGlyphs")]
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn show_glyphs(&self, g: *const CGGlyph, count: usize) {
        extern "C-unwind" {
            fn CGContextShowGlyphs(c: &CGContext, g: *const CGGlyph, count: usize);
        }
        unsafe { CGContextShowGlyphs(self, g, count) }
    }

    /// # Safety
    ///
    /// `glyphs` must be a valid pointer or null.
    #[doc(alias = "CGContextShowGlyphsAtPoint")]
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn show_glyphs_at_point(
        &self,
        x: CGFloat,
        y: CGFloat,
        glyphs: *const CGGlyph,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGContextShowGlyphsAtPoint(
                c: &CGContext,
                x: CGFloat,
                y: CGFloat,
                glyphs: *const CGGlyph,
                count: usize,
            );
        }
        unsafe { CGContextShowGlyphsAtPoint(self, x, y, glyphs, count) }
    }

    /// # Safety
    ///
    /// - `glyphs` must be a valid pointer or null.
    /// - `advances` must be a valid pointer or null.
    #[doc(alias = "CGContextShowGlyphsWithAdvances")]
    #[cfg(feature = "CGFont")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn show_glyphs_with_advances(
        &self,
        glyphs: *const CGGlyph,
        advances: *const CGSize,
        count: usize,
    ) {
        extern "C-unwind" {
            fn CGContextShowGlyphsWithAdvances(
                c: &CGContext,
                glyphs: *const CGGlyph,
                advances: *const CGSize,
                count: usize,
            );
        }
        unsafe { CGContextShowGlyphsWithAdvances(self, glyphs, advances, count) }
    }

    #[doc(alias = "CGContextDrawPDFDocument")]
    #[cfg(feature = "CGPDFDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn draw_pdf_document(&self, rect: CGRect, document: &CGPDFDocument, page: c_int) {
        extern "C-unwind" {
            fn CGContextDrawPDFDocument(
                c: &CGContext,
                rect: CGRect,
                document: &CGPDFDocument,
                page: c_int,
            );
        }
        unsafe { CGContextDrawPDFDocument(self, rect, document, page) }
    }
}
