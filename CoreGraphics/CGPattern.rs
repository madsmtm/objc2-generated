//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A 2D pattern to be used for drawing graphics paths.
///
/// ## Overview
///
/// Core Graphics tiles the pattern cell for you, based on parameters you specify when you call [`CGPatternCreate`](https://developer.apple.com/documentation/coregraphics/cgpattern/init(info:bounds:matrix:xstep:ystep:tiling:iscolored:callbacks:)).
///
/// To create a dashed line, see [`CGContextSetLineDash`](https://developer.apple.com/documentation/coregraphics/cgcontextsetlinedash).
///
///
#[doc(alias = "CGPatternRef")]
#[repr(C)]
pub struct CGPattern {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGPattern {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGPattern"> for CGPattern {}
);

/// Different methods for rendering a tiled pattern.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGPatternTiling(pub i32);
impl CGPatternTiling {
    /// The pattern cell is not distorted when painted.The spacing between pattern cells may vary by as much as 1 devicepixel.
    #[doc(alias = "kCGPatternTilingNoDistortion")]
    pub const NoDistortion: Self = Self(0);
    /// Pattern cells are spaced consistently. Thepattern cell may be distorted by as much as 1 device pixel whenthe pattern is painted.
    #[doc(alias = "kCGPatternTilingConstantSpacingMinimalDistortion")]
    pub const ConstantSpacingMinimalDistortion: Self = Self(1);
    /// Pattern cells are spaced consistently, as with [`kCGPatternTilingConstantSpacingMinimalDistortion`](https://developer.apple.com/documentation/coregraphics/cgpatterntiling/constantspacingminimaldistortion).The pattern cell may be distorted additionally to permit a moreefficient implementation.
    #[doc(alias = "kCGPatternTilingConstantSpacing")]
    pub const ConstantSpacing: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGPatternTiling {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGPatternTiling {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Draws a pattern cell.
///
/// Parameters:
/// - info: A generic pointer to private data associated with the pattern. This is the same pointer you supplied to [`CGPatternCreate`](https://developer.apple.com/documentation/coregraphics/cgpattern/init(info:bounds:matrix:xstep:ystep:tiling:iscolored:callbacks:)).
///
/// - context: The graphics context for drawing the pattern cell.
///
///
/// ## Discussion
///
/// When a pattern is used to stroke or fill a graphics path,Quartz calls your custom drawing function at the appropriatetime to draw the pattern cell. The cell should be drawn exactly thesame way each time the drawing function is called.
///
/// In a drawing function associated with an uncolored pattern,you should not attempt to set a stroke or fill color or color space—ifyou do so, the result is undefined.
///
/// To learn how to associate your drawing function with a Quartzpattern, see [`CGPatternCreate`](https://developer.apple.com/documentation/coregraphics/cgpattern/init(info:bounds:matrix:xstep:ystep:tiling:iscolored:callbacks:)) and [`CGPatternCallbacks`](https://developer.apple.com/documentation/coregraphics/cgpatterncallbacks).
///
///
#[cfg(feature = "CGContext")]
pub type CGPatternDrawPatternCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut CGContext)>;

/// Release private data or resources associated with the pattern.
///
/// Parameters:
/// - info: A generic pointer to private data shared among your callback functions. This is the same pointer you supplied to [`CGPatternCreate`](https://developer.apple.com/documentation/coregraphics/cgpattern/init(info:bounds:matrix:xstep:ystep:tiling:iscolored:callbacks:)).
///
///
/// ## Discussion
///
/// Quartz calls your release function when it frees your pattern object.
///
/// To learn how to associate your release function with a Quartz pattern, see [`CGPatternCreate`](https://developer.apple.com/documentation/coregraphics/cgpattern/init(info:bounds:matrix:xstep:ystep:tiling:iscolored:callbacks:)) and [`CGPatternCallbacks`](https://developer.apple.com/documentation/coregraphics/cgpatterncallbacks).
///
///
pub type CGPatternReleaseInfoCallback = Option<unsafe extern "C-unwind" fn(*mut c_void)>;

/// A structure that holds a version and two callback functions for drawing a custom pattern.
///
/// ## Overview
///
/// You supply a [`CGPatternCallbacks`](https://developer.apple.com/documentation/coregraphics/cgpatterncallbacks) structure to the function [`CGPatternCreate`](https://developer.apple.com/documentation/coregraphics/cgpattern/init(info:bounds:matrix:xstep:ystep:tiling:iscolored:callbacks:)) to create a data provider for direct access. The functions specified by the [`CGPatternCallbacks`](https://developer.apple.com/documentation/coregraphics/cgpatterncallbacks) structure are responsible for drawing the pattern and for handling the pattern’s memory management.
///
///
#[cfg(feature = "CGContext")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CGPatternCallbacks {
    pub version: c_uint,
    pub drawPattern: CGPatternDrawPatternCallback,
    pub releaseInfo: CGPatternReleaseInfoCallback,
}

#[cfg(all(feature = "CGContext", feature = "objc2"))]
unsafe impl Encode for CGPatternCallbacks {
    const ENCODING: Encoding = Encoding::Struct(
        "CGPatternCallbacks",
        &[
            <c_uint>::ENCODING,
            <CGPatternDrawPatternCallback>::ENCODING,
            <CGPatternReleaseInfoCallback>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CGContext", feature = "objc2"))]
unsafe impl RefEncode for CGPatternCallbacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CGPattern {
    /// Returns the type identifier for Core Graphics patterns.
    ///
    /// ## Return Value
    ///
    /// The identifier for the opaque type [`CGPatternRef`](https://developer.apple.com/documentation/coregraphics/cgpattern).
    ///
    ///
    #[doc(alias = "CGPatternGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGPatternGetTypeID() -> CFTypeID;
        }
        unsafe { CGPatternGetTypeID() }
    }
}

impl CGPattern {
    /// Creates a pattern object.
    ///
    /// Parameters:
    /// - info: A pointer to private storage used by your pattern drawing function, or `NULL`. For more information, see the discussion below.
    ///
    /// - bounds: The bounding box of the pattern cell, specified in pattern space. (Pattern space is an abstract space that maps to the default user space by the transformation matrix you specify with the `matrix` parameter.)The drawing done in your pattern drawing function is clipped to this rectangle.
    ///
    /// - matrix: A matrix that represents a transform from pattern space to the default user space of the context in which the pattern is used. If no transform is needed, pass the identity matrix.
    ///
    /// - xStep: The horizontal displacement between cells, specified in pattern space. For no additional horizontal space between cells (so that each pattern cells abuts the previous pattern cell in the horizontal direction), pass the width of the pattern cell.
    ///
    /// - yStep: The vertical displacement between cells, specified in pattern space. For no additional vertical space between cells(so that each pattern cells abuts the previous pattern cell in the vertical direction), pass the height of the pattern cell.
    ///
    /// - tiling: A [`CGPatternTiling`](https://developer.apple.com/documentation/coregraphics/cgpatterntiling) constant that specifies the desired tiling method.
    ///
    /// - isColored: If you want to draw your pattern using its own intrinsic color, pass [`true`](https://developer.apple.com/documentation/swift/true). If you want to draw an uncolored (or masking) pattern that uses the fill or stroke color in the graphics state, pass [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    /// - callbacks: A pointer to a pattern  callback function table—your pattern drawing function is an entry in this table. See [`CGPatternCallbacks`](https://developer.apple.com/documentation/coregraphics/cgpatterncallbacks) for more information about callback function tables for patterns.
    ///
    ///
    /// ## Return Value
    ///
    /// A new Core Graphics pattern. In Objective-C, you’re responsible for releasing this object using [`CGPatternRelease`](https://developer.apple.com/documentation/coregraphics/cgpatternrelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Core Graphics calls your drawing function at the appropriate timeto draw the pattern cell. A pattern cell must be invariant—thatis, the pattern cell should be drawn exactly the same way each timethe drawing function is called.
    ///
    /// The appearance of a pattern cell is unaffected by changesin the graphics state of the context in which the pattern is used.
    ///
    /// See [`CGPatternDrawPatternCallback`](https://developer.apple.com/documentation/coregraphics/cgpatterndrawpatterncallback) formore information about pattern drawing functions.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `info` must be a valid pointer or null.
    /// - `callbacks` must be a valid pointer or null.
    #[doc(alias = "CGPatternCreate")]
    #[cfg(feature = "CGContext")]
    #[inline]
    pub unsafe fn new(
        info: *mut c_void,
        bounds: CGRect,
        matrix: CGAffineTransform,
        x_step: CGFloat,
        y_step: CGFloat,
        tiling: CGPatternTiling,
        is_colored: bool,
        callbacks: *const CGPatternCallbacks,
    ) -> Option<CFRetained<CGPattern>> {
        extern "C-unwind" {
            fn CGPatternCreate(
                info: *mut c_void,
                bounds: CGRect,
                matrix: CGAffineTransform,
                x_step: CGFloat,
                y_step: CGFloat,
                tiling: CGPatternTiling,
                is_colored: bool,
                callbacks: *const CGPatternCallbacks,
            ) -> Option<NonNull<CGPattern>>;
        }
        let ret = unsafe {
            CGPatternCreate(
                info, bounds, matrix, x_step, y_step, tiling, is_colored, callbacks,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "CGContext")]
#[deprecated = "renamed to `CGPattern::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CGPatternCreate(
    info: *mut c_void,
    bounds: CGRect,
    matrix: CGAffineTransform,
    x_step: CGFloat,
    y_step: CGFloat,
    tiling: CGPatternTiling,
    is_colored: bool,
    callbacks: *const CGPatternCallbacks,
) -> Option<CFRetained<CGPattern>> {
    extern "C-unwind" {
        fn CGPatternCreate(
            info: *mut c_void,
            bounds: CGRect,
            matrix: CGAffineTransform,
            x_step: CGFloat,
            y_step: CGFloat,
            tiling: CGPatternTiling,
            is_colored: bool,
            callbacks: *const CGPatternCallbacks,
        ) -> Option<NonNull<CGPattern>>;
    }
    let ret = unsafe {
        CGPatternCreate(
            info, bounds, matrix, x_step, y_step, tiling, is_colored, callbacks,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
