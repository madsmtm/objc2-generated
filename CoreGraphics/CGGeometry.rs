//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpointzero?language=objc)
    pub static CGPointZero: CGPoint;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgsizezero?language=objc)
    pub static CGSizeZero: CGSize;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectzero?language=objc)
    pub static CGRectZero: CGRect;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectnull?language=objc)
    pub static CGRectNull: CGRect;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectinfinite?language=objc)
    pub static CGRectInfinite: CGRect;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

extern "C-unwind" {
    pub fn CGRectGetMinX(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMidX(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMaxX(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMinY(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMidY(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetMaxY(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetWidth(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGRectGetHeight(rect: CGRect) -> CGFloat;
}

extern "C-unwind" {
    pub fn CGPointEqualToPoint(point1: CGPoint, point2: CGPoint) -> bool;
}

extern "C-unwind" {
    pub fn CGSizeEqualToSize(size1: CGSize, size2: CGSize) -> bool;
}

extern "C-unwind" {
    pub fn CGRectEqualToRect(rect1: CGRect, rect2: CGRect) -> bool;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectStandardize(rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    pub fn CGRectIsEmpty(rect: CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGRectIsNull(rect: CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGRectIsInfinite(rect: CGRect) -> bool;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectInset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectIntegral(rect: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectUnion(r1: CGRect, r2: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectIntersection(r1: CGRect, r2: CGRect) -> CGRect;
}

extern "C-unwind" {
    #[must_use]
    pub fn CGRectOffset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `slice` must be a valid pointer.
    /// - `remainder` must be a valid pointer.
    pub fn CGRectDivide(
        rect: CGRect,
        slice: NonNull<CGRect>,
        remainder: NonNull<CGRect>,
        amount: CGFloat,
        edge: CGRectEdge,
    );
}

extern "C-unwind" {
    pub fn CGRectContainsPoint(rect: CGRect, point: CGPoint) -> bool;
}

extern "C-unwind" {
    pub fn CGRectContainsRect(rect1: CGRect, rect2: CGRect) -> bool;
}

extern "C-unwind" {
    pub fn CGRectIntersectsRect(rect1: CGRect, rect2: CGRect) -> bool;
}

/// * Persistent representations. **
#[inline]
pub unsafe extern "C-unwind" fn CGPointCreateDictionaryRepresentation(
    point: CGPoint,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGPointCreateDictionaryRepresentation(point: CGPoint) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGPointCreateDictionaryRepresentation(point) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `dict` generics must be of the correct type.
    /// - `point` must be a valid pointer or null.
    pub fn CGPointMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        point: *mut CGPoint,
    ) -> bool;
}

#[inline]
pub unsafe extern "C-unwind" fn CGSizeCreateDictionaryRepresentation(
    size: CGSize,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGSizeCreateDictionaryRepresentation(size: CGSize) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGSizeCreateDictionaryRepresentation(size) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `dict` generics must be of the correct type.
    /// - `size` must be a valid pointer or null.
    pub fn CGSizeMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        size: *mut CGSize,
    ) -> bool;
}

#[inline]
pub unsafe extern "C-unwind" fn CGRectCreateDictionaryRepresentation(
    param1: CGRect,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGRectCreateDictionaryRepresentation(param1: CGRect) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGRectCreateDictionaryRepresentation(param1) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `dict` generics must be of the correct type.
    /// - `rect` must be a valid pointer or null.
    pub fn CGRectMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        rect: *mut CGRect,
    ) -> bool;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

// TODO: pub fn __CGPointEqualToPoint(point1: CGPoint,point2: CGPoint,) -> bool;

// TODO: pub fn __CGSizeEqualToSize(size1: CGSize,size2: CGSize,) -> bool;
