//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// A point constant with location `(0,0)`. The zero point is equivalent to `CGPointMake(0,0)`.
    pub static CGPointZero: CGPoint;
}

extern "C" {
    /// A size constant with width and height of `0`. The zero size is equivalent to `CGSizeMake(0,0)`.
    pub static CGSizeZero: CGSize;
}

extern "C" {
    /// A rectangle constant with location `(0,0)`, and width and height of 0. The zero rectangle is equivalent to `CGRectMake(0,0,0,0)`.
    pub static CGRectZero: CGRect;
}

extern "C" {
    /// The null rectangle, representing an invalid value.
    ///
    /// ## Discussion
    ///
    /// This is the rectangle returned when, for example, you intersect two disjoint rectangles. Note that the null rectangle is not the same as the [`CGRectZero`](https://developer.apple.com/documentation/coregraphics/cgrectzero) rectangle. For example, the union of a rectangle with the null rectangle is the original rectangle (that is, the null rectangle contributes nothing).
    ///
    ///
    pub static CGRectNull: CGRect;
}

extern "C" {
    /// A rectangle that has infinite extent.
    pub static CGRectInfinite: CGRect;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

/// Returns the smallest value for the x-coordinate of the rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The smallest value for the x-coordinate of the rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetMinX(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMinX(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMinX(rect) }
}

/// Returns the x- coordinate that establishes the center of a rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The x-coordinate of the center of the specified rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetMidX(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMidX(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMidX(rect) }
}

/// Returns the largest value of the x-coordinate for the rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The largest value of the x-coordinate for the rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetMaxX(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMaxX(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMaxX(rect) }
}

/// Returns the smallest value for the y-coordinate of the rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The smallest value for the y-coordinate of the rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetMinY(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMinY(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMinY(rect) }
}

/// Returns the y-coordinate that establishes the center of the rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The y-coordinate of the center of the specified rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetMidY(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMidY(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMidY(rect) }
}

/// Returns the largest value for the y-coordinate of the rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The largest value for the y-coordinate of the rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetMaxY(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMaxY(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMaxY(rect) }
}

/// Returns the width of a rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The width of the specified rectangle.
///
///
///
/// ## Discussion
///
/// Regardless of whether the width is stored in the [`CGRect`](https://developer.apple.com/documentation/corefoundation/cgrect) data structure as a positive or negative number, this function returns the width as if the rectangle were standardized.  That is, the result is never a negative number.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetWidth(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetWidth(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetWidth(rect) }
}

/// Returns the height of a rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// The height of the specified rectangle.
///
///
///
/// ## Discussion
///
/// Regardless of whether the height is stored in the [`CGRect`](https://developer.apple.com/documentation/corefoundation/cgrect) data structure as a positive or negative number, this function returns the height as if the rectangle were standardized. That is, the result is never a negative number.
///
///
#[inline]
pub extern "C-unwind" fn CGRectGetHeight(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetHeight(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetHeight(rect) }
}

/// Returns whether two points are equal.
#[inline]
pub extern "C-unwind" fn CGPointEqualToPoint(point1: CGPoint, point2: CGPoint) -> bool {
    extern "C-unwind" {
        fn CGPointEqualToPoint(point1: CGPoint, point2: CGPoint) -> bool;
    }
    unsafe { CGPointEqualToPoint(point1, point2) }
}

/// Returns whether two sizes are equal.
#[inline]
pub extern "C-unwind" fn CGSizeEqualToSize(size1: CGSize, size2: CGSize) -> bool {
    extern "C-unwind" {
        fn CGSizeEqualToSize(size1: CGSize, size2: CGSize) -> bool;
    }
    unsafe { CGSizeEqualToSize(size1, size2) }
}

/// Returns whether two rectangles are equal in size and position.
///
/// Parameters:
/// - rect1: The first rectangle to examine.
///
/// - rect2: The second rectangle to examine.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the two specified rectangles have equal size and origin values, or if both rectangles are null rectangles. Otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
///
///
#[inline]
pub extern "C-unwind" fn CGRectEqualToRect(rect1: CGRect, rect2: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectEqualToRect(rect1: CGRect, rect2: CGRect) -> bool;
    }
    unsafe { CGRectEqualToRect(rect1, rect2) }
}

/// Returns a rectangle with a positive width and height.
///
/// Parameters:
/// - rect: The source rectangle.
///
///
/// ## Return Value
///
/// A rectangle that represents the source rectangle, but with positive width and height values. Returns a null rectangle if `rect` is a null rectangle.
///
///
#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectStandardize(rect: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectStandardize(rect: CGRect) -> CGRect;
    }
    unsafe { CGRectStandardize(rect) }
}

/// Returns whether a rectangle has zero width or height, or is a null rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the specified rectangle is empty; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// An empty rectangle is either a null rectangle or a valid rectangle with zero height or width.
///
///
#[inline]
pub extern "C-unwind" fn CGRectIsEmpty(rect: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIsEmpty(rect: CGRect) -> bool;
    }
    unsafe { CGRectIsEmpty(rect) }
}

/// Returns whether the rectangle is equal to the null rectangle.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the specified rectangle is null; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// A null rectangle is the equivalent of an empty set. For example, the result of intersecting two disjoint rectangles is a null rectangle. A null rectangle cannot be drawn and interacts with other rectangles in special ways.
///
///
#[inline]
pub extern "C-unwind" fn CGRectIsNull(rect: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIsNull(rect: CGRect) -> bool;
    }
    unsafe { CGRectIsNull(rect) }
}

/// Returns whether a rectangle is infinite.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
///
/// ## Return Value
///
/// Returns [`true`](https://developer.apple.com/documentation/swift/true) if the specified rectangle is infinite; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// An infinite rectangle is one that has no defined bounds. Infinite rectangles can be created as output from a tiling filter. For example, the Core Image framework perspective tile filter creates an image whose extent is described by an infinite rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectIsInfinite(rect: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIsInfinite(rect: CGRect) -> bool;
    }
    unsafe { CGRectIsInfinite(rect) }
}

/// Returns a rectangle that is smaller or larger than the source rectangle, with the same center point.
///
/// Parameters:
/// - rect: The source [`CGRect`](https://developer.apple.com/documentation/corefoundation/cgrect) structure.
///
/// - dx: The x-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
///
/// - dy: The y-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
///
///
/// ## Return Value
///
/// A rectangle. The origin value is offset in the x-axis by the distance specified by the `dx` parameter and in the y-axis by the distance specified by the `dy` parameter, and its size adjusted by `(2*dx,2*dy)`, relative to the source rectangle. If `dx` and `dy` are positive values, then the rectangle’s size is decreased. If `dx` and `dy` are negative values, the rectangle’s size is increased.
///
///
///
/// ## Discussion
///
/// The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a null rectangle is returned.
///
///
#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectInset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect {
    extern "C-unwind" {
        fn CGRectInset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
    }
    unsafe { CGRectInset(rect, dx, dy) }
}

/// Returns the smallest rectangle that results from converting the source rectangle values to integers.
///
/// Parameters:
/// - rect: The source rectangle.
///
///
/// ## Return Value
///
/// A rectangle with the smallest integer values for its origin and size that contains the source rectangle. That is, given a rectangle with fractional origin or size values, `CGRectIntegral` rounds the rectangle’s origin downward and its size upward to the nearest whole integers, such that the result contains the original rectangle. Returns a null rectangle if `rect` is a null rectangle.
///
///
#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectIntegral(rect: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectIntegral(rect: CGRect) -> CGRect;
    }
    unsafe { CGRectIntegral(rect) }
}

/// Returns the smallest rectangle that contains the two source rectangles.
///
/// Parameters:
/// - r1: The first source rectangle.
///
/// - r2: The second source rectangle.
///
///
/// ## Return Value
///
/// The smallest rectangle that completely contains both of the source rectangles.
///
///
///
/// ## Discussion
///
/// Both rectangles are standardized prior to calculating the union. If either of the rectangles is a null rectangle, a copy of the other rectangle is returned (resulting in a null rectangle if both rectangles are null). Otherwise a rectangle that completely contains the source rectangles is returned.
///
///
#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectUnion(r1: CGRect, r2: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectUnion(r1: CGRect, r2: CGRect) -> CGRect;
    }
    unsafe { CGRectUnion(r1, r2) }
}

/// Returns the intersection of two rectangles.
///
/// Parameters:
/// - r1: The first source rectangle.
///
/// - r2: The second source rectangle.
///
///
/// ## Return Value
///
/// A rectangle that represents the intersection of the two specified rectangles. If the two rectangles do not intersect, returns the null rectangle. To check for this condition, use [`CGRectIsNull`](https://developer.apple.com/documentation/coregraphics/cgrectisnull(_:)).
///
///
///
/// ## Discussion
///
/// Both rectangles are standardized prior to calculating the intersection.
///
///
#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectIntersection(r1: CGRect, r2: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectIntersection(r1: CGRect, r2: CGRect) -> CGRect;
    }
    unsafe { CGRectIntersection(r1, r2) }
}

/// Returns a rectangle with an origin that is offset from that of the source rectangle.
///
/// Parameters:
/// - rect: The source rectangle.
///
/// - dx: The offset value for the x-coordinate.
///
/// - dy: The offset value for the  y-coordinate.
///
///
/// ## Return Value
///
/// A rectangle that is the same size as the source, but with its origin offset by `dx` units along the x-axis and `dy` units along the y-axis with respect to the source. Returns a null rectangle if `rect` is a null rectangle.
///
///
#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectOffset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect {
    extern "C-unwind" {
        fn CGRectOffset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
    }
    unsafe { CGRectOffset(rect, dx, dy) }
}

extern "C-unwind" {
    /// Divides a source rectangle into two component rectangles.
    ///
    /// Parameters:
    /// - rect: The source rectangle.
    ///
    /// - slice: On input, a pointer to an uninitialized rectangle. On return, the rectangle is filled in with the specified edge and values that extends the distance beyond the edge specified by the `amount` parameter. Must not be `NULL`.
    ///
    /// - remainder: On input, a pointer to an uninitialized rectangle. On return, the rectangle contains the portion of the source rectangle that remains after [`CGRectEdge`](https://developer.apple.com/documentation/corefoundation/cgrectedge) produces the “slice” rectangle. Must not be `NULL`.
    ///
    /// - amount: A distance from the rectangle side that is specified in the `edge` parameter. This distance defines the line, parallel to the specified side, that Core Graphics uses to divide the source rectangle.
    ///
    /// - edge: An edge value that specifies the side of the rectangle from which the distance passed in the `amount` parameter is measured. [`CGRectDivide`](https://developer.apple.com/documentation/coregraphics/cgrectdivide) produces a “slice” rectangle that contains the specified edge and extends `amount` distance beyond it.
    ///
    ///
    /// ## Discussion
    ///
    /// If `rect` is a null rectangle, this function outputs [`CGRectNull`](https://developer.apple.com/documentation/coregraphics/cgrectnull) for both the `slice` and `remainder` rectangles.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `slice` must be a valid pointer.
    /// - `remainder` must be a valid pointer.
    pub fn CGRectDivide(
        rect: CGRect,
        slice: NonNull<CGRect>,
        remainder: NonNull<CGRect>,
        amount: CGFloat,
        edge: CGRectEdge,
    );
}

/// Returns whether a rectangle contains a specified point.
///
/// Parameters:
/// - rect: The rectangle to examine.
///
/// - point: The point to examine.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the rectangle is not null or empty and the point is located within the rectangle; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// A point is considered inside the rectangle if its coordinates lie inside the rectangle or on the minimum X or minimum Y edge.
///
///
#[inline]
pub extern "C-unwind" fn CGRectContainsPoint(rect: CGRect, point: CGPoint) -> bool {
    extern "C-unwind" {
        fn CGRectContainsPoint(rect: CGRect, point: CGPoint) -> bool;
    }
    unsafe { CGRectContainsPoint(rect, point) }
}

/// Returns whether the first rectangle contains the second rectangle.
///
/// Parameters:
/// - rect1: The rectangle to examine for containment of the rectangle passed in `rect2`.
///
/// - rect2: The rectangle to examine for being contained in the rectangle passed in `rect1`.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the rectangle specified by `rect2` is contained in the rectangle passed in `rect1`; otherwise, [`false`](https://developer.apple.com/documentation/swift/false). The first rectangle contains the second if the union of the two rectangles is equal to the first rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectContainsRect(rect1: CGRect, rect2: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectContainsRect(rect1: CGRect, rect2: CGRect) -> bool;
    }
    unsafe { CGRectContainsRect(rect1, rect2) }
}

/// Returns whether two rectangles intersect.
///
/// Parameters:
/// - rect1: The first rectangle to examine.
///
/// - rect2: The second rectangle to examine.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the two specified rectangles intersect; otherwise, [`false`](https://developer.apple.com/documentation/swift/false). The first rectangle intersects the second if the intersection of the rectangles is not equal to the null rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectIntersectsRect(rect1: CGRect, rect2: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIntersectsRect(rect1: CGRect, rect2: CGRect) -> bool;
    }
    unsafe { CGRectIntersectsRect(rect1, rect2) }
}

/// Returns a dictionary representation of the specified point.
///
/// Parameters:
/// - point: A point.
///
///
/// ## Return Value
///
/// The dictionary representation of the point.
///
///
/// * Persistent representations. **
#[inline]
pub extern "C-unwind" fn CGPointCreateDictionaryRepresentation(
    point: CGPoint,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGPointCreateDictionaryRepresentation(point: CGPoint) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGPointCreateDictionaryRepresentation(point) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Fills in a point using the contents of the specified dictionary.
    ///
    /// Parameters:
    /// - dict: A dictionary that was previously returned from the function [`CGPointCreateDictionaryRepresentation`](https://developer.apple.com/documentation/coregraphics/cgpointcreatedictionaryrepresentation(_:)).
    ///
    /// - point: On return, the point created from the provided dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if successful; otherwise [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `point` must be a valid pointer or null.
    pub fn CGPointMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        point: *mut CGPoint,
    ) -> bool;
}

/// Returns a dictionary representation of the specified size.
///
/// Parameters:
/// - size: A size.
///
///
/// ## Return Value
///
/// The dictionary representation of the size.
///
///
#[inline]
pub extern "C-unwind" fn CGSizeCreateDictionaryRepresentation(
    size: CGSize,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGSizeCreateDictionaryRepresentation(size: CGSize) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGSizeCreateDictionaryRepresentation(size) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Fills in a size using the contents of the specified dictionary.
    ///
    /// Parameters:
    /// - dict: A dictionary that was previously returned from the function [`CGSizeCreateDictionaryRepresentation`](https://developer.apple.com/documentation/coregraphics/cgsizecreatedictionaryrepresentation(_:)).
    ///
    /// - size: On return, the size created from the specified dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if successful; otherwise [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `size` must be a valid pointer or null.
    pub fn CGSizeMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        size: *mut CGSize,
    ) -> bool;
}

/// Returns a dictionary representation of the provided rectangle.
///
/// ## Return Value
///
/// The dictionary representation of the rectangle.
///
///
#[inline]
pub extern "C-unwind" fn CGRectCreateDictionaryRepresentation(
    param1: CGRect,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGRectCreateDictionaryRepresentation(param1: CGRect) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGRectCreateDictionaryRepresentation(param1) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Fills in a rectangle using the contents of the specified dictionary.
    ///
    /// Parameters:
    /// - dict: A dictionary that was previously returned from the function [`CGRectCreateDictionaryRepresentation`](https://developer.apple.com/documentation/coregraphics/cgrectcreatedictionaryrepresentation(_:)).
    ///
    /// - rect: On return, the rectangle created from the specified dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if successful; otherwise [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `rect` must be a valid pointer or null.
    pub fn CGRectMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        rect: *mut CGRect,
    ) -> bool;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

// TODO: pub fn __CGPointEqualToPoint(point1: CGPoint,point2: CGPoint,) -> bool;

// TODO: pub fn __CGSizeEqualToSize(size1: CGSize,size2: CGSize,) -> bool;
