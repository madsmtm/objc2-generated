//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgpointzero?language=objc)
    pub static CGPointZero: CGPoint;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgsizezero?language=objc)
    pub static CGSizeZero: CGSize;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectzero?language=objc)
    pub static CGRectZero: CGRect;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectnull?language=objc)
    pub static CGRectNull: CGRect;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgrectinfinite?language=objc)
    pub static CGRectInfinite: CGRect;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

#[inline]
pub extern "C-unwind" fn CGRectGetMinX(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMinX(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMinX(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetMidX(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMidX(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMidX(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetMaxX(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMaxX(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMaxX(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetMinY(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMinY(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMinY(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetMidY(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMidY(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMidY(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetMaxY(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetMaxY(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetMaxY(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetWidth(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetWidth(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetWidth(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectGetHeight(rect: CGRect) -> CGFloat {
    extern "C-unwind" {
        fn CGRectGetHeight(rect: CGRect) -> CGFloat;
    }
    unsafe { CGRectGetHeight(rect) }
}

#[inline]
pub extern "C-unwind" fn CGPointEqualToPoint(point1: CGPoint, point2: CGPoint) -> bool {
    extern "C-unwind" {
        fn CGPointEqualToPoint(point1: CGPoint, point2: CGPoint) -> bool;
    }
    unsafe { CGPointEqualToPoint(point1, point2) }
}

#[inline]
pub extern "C-unwind" fn CGSizeEqualToSize(size1: CGSize, size2: CGSize) -> bool {
    extern "C-unwind" {
        fn CGSizeEqualToSize(size1: CGSize, size2: CGSize) -> bool;
    }
    unsafe { CGSizeEqualToSize(size1, size2) }
}

#[inline]
pub extern "C-unwind" fn CGRectEqualToRect(rect1: CGRect, rect2: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectEqualToRect(rect1: CGRect, rect2: CGRect) -> bool;
    }
    unsafe { CGRectEqualToRect(rect1, rect2) }
}

#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectStandardize(rect: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectStandardize(rect: CGRect) -> CGRect;
    }
    unsafe { CGRectStandardize(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectIsEmpty(rect: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIsEmpty(rect: CGRect) -> bool;
    }
    unsafe { CGRectIsEmpty(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectIsNull(rect: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIsNull(rect: CGRect) -> bool;
    }
    unsafe { CGRectIsNull(rect) }
}

#[inline]
pub extern "C-unwind" fn CGRectIsInfinite(rect: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIsInfinite(rect: CGRect) -> bool;
    }
    unsafe { CGRectIsInfinite(rect) }
}

#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectInset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect {
    extern "C-unwind" {
        fn CGRectInset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
    }
    unsafe { CGRectInset(rect, dx, dy) }
}

#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectIntegral(rect: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectIntegral(rect: CGRect) -> CGRect;
    }
    unsafe { CGRectIntegral(rect) }
}

#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectUnion(r1: CGRect, r2: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectUnion(r1: CGRect, r2: CGRect) -> CGRect;
    }
    unsafe { CGRectUnion(r1, r2) }
}

#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectIntersection(r1: CGRect, r2: CGRect) -> CGRect {
    extern "C-unwind" {
        fn CGRectIntersection(r1: CGRect, r2: CGRect) -> CGRect;
    }
    unsafe { CGRectIntersection(r1, r2) }
}

#[must_use]
#[inline]
pub extern "C-unwind" fn CGRectOffset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect {
    extern "C-unwind" {
        fn CGRectOffset(rect: CGRect, dx: CGFloat, dy: CGFloat) -> CGRect;
    }
    unsafe { CGRectOffset(rect, dx, dy) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `slice` must be a valid pointer.
    /// - `remainder` must be a valid pointer.
    pub fn CGRectDivide(
        rect: CGRect,
        slice: NonNull<CGRect>,
        remainder: NonNull<CGRect>,
        amount: CGFloat,
        edge: CGRectEdge,
    );
}

#[inline]
pub extern "C-unwind" fn CGRectContainsPoint(rect: CGRect, point: CGPoint) -> bool {
    extern "C-unwind" {
        fn CGRectContainsPoint(rect: CGRect, point: CGPoint) -> bool;
    }
    unsafe { CGRectContainsPoint(rect, point) }
}

#[inline]
pub extern "C-unwind" fn CGRectContainsRect(rect1: CGRect, rect2: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectContainsRect(rect1: CGRect, rect2: CGRect) -> bool;
    }
    unsafe { CGRectContainsRect(rect1, rect2) }
}

#[inline]
pub extern "C-unwind" fn CGRectIntersectsRect(rect1: CGRect, rect2: CGRect) -> bool {
    extern "C-unwind" {
        fn CGRectIntersectsRect(rect1: CGRect, rect2: CGRect) -> bool;
    }
    unsafe { CGRectIntersectsRect(rect1, rect2) }
}

/// * Persistent representations. **
#[inline]
pub extern "C-unwind" fn CGPointCreateDictionaryRepresentation(
    point: CGPoint,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGPointCreateDictionaryRepresentation(point: CGPoint) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGPointCreateDictionaryRepresentation(point) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `point` must be a valid pointer or null.
    pub fn CGPointMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        point: *mut CGPoint,
    ) -> bool;
}

#[inline]
pub extern "C-unwind" fn CGSizeCreateDictionaryRepresentation(
    size: CGSize,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGSizeCreateDictionaryRepresentation(size: CGSize) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGSizeCreateDictionaryRepresentation(size) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `size` must be a valid pointer or null.
    pub fn CGSizeMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        size: *mut CGSize,
    ) -> bool;
}

#[inline]
pub extern "C-unwind" fn CGRectCreateDictionaryRepresentation(
    param1: CGRect,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CGRectCreateDictionaryRepresentation(param1: CGRect) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGRectCreateDictionaryRepresentation(param1) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `rect` must be a valid pointer or null.
    pub fn CGRectMakeWithDictionaryRepresentation(
        dict: Option<&CFDictionary>,
        rect: *mut CGRect,
    ) -> bool;
}

// TODO: pub fn CGPointMake(x: CGFloat,y: CGFloat,) -> CGPoint;

// TODO: pub fn CGSizeMake(width: CGFloat,height: CGFloat,) -> CGSize;

// TODO: pub fn CGVectorMake(dx: CGFloat,dy: CGFloat,) -> CGVector;

// TODO: pub fn CGRectMake(x: CGFloat,y: CGFloat,width: CGFloat,height: CGFloat,) -> CGRect;

// TODO: pub fn __CGPointEqualToPoint(point1: CGPoint,point2: CGPoint,) -> bool;

// TODO: pub fn __CGSizeEqualToSize(size1: CGSize,size2: CGSize,) -> bool;
