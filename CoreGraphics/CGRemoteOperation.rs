//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

pub const kCGMouseDownEventMaskingDeadSwitchTimeout: c_float = 60.0;
pub const kCGEventFilterMaskPermitAllEvents: c_uint = CGEventFilterMask::PermitLocalMouseEvents.0
    | CGEventFilterMask::PermitLocalKeyboardEvents.0
    | CGEventFilterMask::PermitSystemDefinedEvents.0;
pub const kCGEventSupressionStateSupressionInterval: c_uint =
    CGEventSuppressionState::EventSuppressionStateSuppressionInterval.0;
pub const kCGEventSupressionStateRemoteMouseDrag: c_uint =
    CGEventSuppressionState::EventSuppressionStateRemoteMouseDrag.0;
pub const kCGNumberOfEventSupressionStates: c_uint =
    CGEventSuppressionState::NumberOfEventSuppressionStates.0;
#[cfg(feature = "CGError")]
pub type CGEventErr = CGError;

/// Represents the number of buttons being set in a synthetic mouse event.
///
/// ## Discussion
///
/// In mouse events, the button count parameter ranges from 0 to 31. See the function [`CGPostMouseEvent`](https://developer.apple.com/documentation/coregraphics/cgpostmouseevent).
///
///
pub type CGButtonCount = u32;

/// Represents the number of wheels being set in a scroll wheel event.
///
/// ## Discussion
///
/// See the function [`CGPostScrollWheelEvent`](https://developer.apple.com/documentation/coregraphics/cgpostscrollwheelevent).
///
///
pub type CGWheelCount = u32;

/// Represents a character generated by pressing one or more keys on a keyboard.
///
/// ## Discussion
///
/// This data type represents a 16-bit character code. Values of this type may or may not correspond to UTF-16 character codes. See the function [`CGPostKeyboardEvent`](https://developer.apple.com/documentation/coregraphics/cgpostkeyboardevent(_:_:_:)).
///
///
pub type CGCharCode = u16;

/// Represents the virtual key codes used in keyboard events.
///
/// ## Discussion
///
/// In macOS, the hardware scan codes generated by keyboards are mapped to a set of virtual key codes that are hardware-independent. Pressing a given key always generates the same virtual key code on any supported keyboard.
///
/// As keys are pressed, the system uses the virtual key codes to create low-level keyboard events. For information on how to simulate a keyboard event, see the function [`CGEventCreateKeyboardEvent`](https://developer.apple.com/documentation/coregraphics/cgevent/init(keyboardeventsource:virtualkey:keydown:)).
///
///
pub type CGKeyCode = u16;

/// A client-supplied callback function that’s invoked when an area of the display is modified or refreshed.
///
/// Parameters:
/// - count: The number of rectangles in the `rectArray` parameter.
///
/// - rectArray: A list of the rectangles in the refreshed areas, specified in the global display coordinate space. The origin is the upper-left corner of the main display. You should not modify or deallocate memory pointed to by `rectArray`.
///
/// - userParameter: The user data you specify when you register this callback.
///
///
/// ## Discussion
///
/// To register a screen-refresh callback function, you call the function [`CGRegisterScreenRefreshCallback`](https://developer.apple.com/documentation/coregraphics/cgregisterscreenrefreshcallback(_:_:)). Quartz invokes your callback function when operations such as drawing, window movement, scrolling, or display reconfiguration occur on local displays. When you finish using a callback registration, you should call the function [`CGUnregisterScreenRefreshCallback`](https://developer.apple.com/documentation/coregraphics/cgunregisterscreenrefreshcallback(_:_:)) to remove it.
///
/// Note that a single rectangle may occupy multiple displays, either by overlapping the displays or by residing on coincident displays when mirroring is active. You can use the function [`CGGetDisplaysWithRect`](https://developer.apple.com/documentation/coregraphics/cggetdisplayswithrect(_:_:_:_:)) to determine the displays a rectangle occupies.
///
///
pub type CGScreenRefreshCallback =
    Option<unsafe extern "C-unwind" fn(u32, NonNull<CGRect>, *mut c_void)>;

extern "C-unwind" {
    /// Registers a callback function to be invoked when local displays are refreshed or modified.
    ///
    /// Parameters:
    /// - callback: A pointer to the callback function to be registered.
    ///
    /// - userInfo: A pointer to user-defined data, or `NULL`. The `userParameter` argument is passed back to the callback function each time it’s invoked.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Core Graphics Data Types and Constants`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A callback function may be registered multiple times with different user-defined data pointers, resulting in multiple registration entries.  For each registration, when notification is no longer needed, you should call the function [`CGUnregisterScreenRefreshCallback`](https://developer.apple.com/documentation/coregraphics/cgunregisterscreenrefreshcallback(_:_:)) to remove the registration.
    ///
    /// The callback function you register is invoked only if your application has an active event loop. The callback is invoked in the same thread of execution that is processing events within your application.
    ///
    /// ### Special Considerations
    ///
    /// In OS X v10.4 and earlier, the result code returned by this function is a random value and should be ignored. In macOS 10.5 and later, the result code is valid.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[cfg(feature = "CGError")]
    #[deprecated = "No longer supported"]
    pub fn CGRegisterScreenRefreshCallback(
        callback: CGScreenRefreshCallback,
        user_info: *mut c_void,
    ) -> CGError;
}

extern "C-unwind" {
    /// Removes a previously registered callback function invoked when local displays are refreshed or modified.
    ///
    /// Parameters:
    /// - callback: A pointer to the callback function to be unregistered.
    ///
    /// - userInfo: A pointer to user-defined data, or `NULL`. You should pass the same value you used when you registered the callback function.
    ///
    ///
    /// ## Discussion
    ///
    /// When you call this function, the two arguments must match the registered entry to be removed.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[deprecated = "No longer supported"]
    pub fn CGUnregisterScreenRefreshCallback(
        callback: CGScreenRefreshCallback,
        user_info: *mut c_void,
    );
}

extern "C-unwind" {
    /// Waits for screen refresh operations.
    ///
    /// Parameters:
    /// - rects: A pointer to a `CGRect*` variable. On return, the variable contains an array of rectangles that bound the refreshed areas, specified in the global display coordinate space. When you no longer need the array, you should deallocate it by calling [`CGReleaseScreenRefreshRects`](https://developer.apple.com/documentation/coregraphics/cgreleasescreenrefreshrects(_:)).
    ///
    /// - count: A pointer to a `CGRectCount` variable. On return, the variable contains the number of entries in the returned array of rectangles.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Core Graphics Data Types and Constants`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In some applications it may be preferable to wait for screen-refresh data synchronously, using this function. You should call this function in a thread other than the main event-processing thread.
    ///
    /// As an alternative, Quartz also supports asynchronous notification—see [`CGRegisterScreenRefreshCallback`](https://developer.apple.com/documentation/coregraphics/cgregisterscreenrefreshcallback(_:_:)). If refresh callback functions are registered, this function should not be used.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `rects` must be a valid pointer or null.
    /// - `count` must be a valid pointer or null.
    #[cfg(feature = "CGError")]
    #[deprecated = "No longer supported"]
    pub fn CGWaitForScreenRefreshRects(rects: *mut *mut CGRect, count: *mut u32) -> CGError;
}

/// Types of screen-update operations.
///
/// ## Overview
///
/// For information about how these constants are used, see the function [`CGWaitForScreenUpdateRects`](https://developer.apple.com/documentation/coregraphics/cgwaitforscreenupdaterects(_:_:_:_:_:)).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGScreenUpdateOperation(pub u32);
bitflags::bitflags! {
    impl CGScreenUpdateOperation: u32 {
/// A screen-refresh operation.
        #[doc(alias = "kCGScreenUpdateOperationRefresh")]
        const Refresh = 0;
/// A screen-move operation.
        #[doc(alias = "kCGScreenUpdateOperationMove")]
        const Move = 1<<0;
///
/// ## Discussion
///
/// When presented as part of the requested operations to the function [`CGWaitForScreenUpdateRects`](https://developer.apple.com/documentation/coregraphics/cgwaitforscreenupdaterects(_:_:_:_:_:)), specifies that the function should try to minimize the number of rectangles returned to represent the changed areas of the display.  The function may combine adjacent rectangles within a larger bounding rectangle, which may include unmodified areas of the display.
///
///
        #[doc(alias = "kCGScreenUpdateOperationReducedDirtyRectangleCount")]
        const ReducedDirtyRectangleCount = 1<<31;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGScreenUpdateOperation {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGScreenUpdateOperation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The distance, in pixel units, that an onscreen region moves.
///
/// ## Overview
///
/// Move operation notifications are restricted to changes that move a region by an integer number of pixels. The fields `dX` and `dY` describe the direction of movement:
///
/// - Positive values of `dX` indicate movement to the right.
///
/// - Negative values of `dX` indicate movement to the left.
///
/// - Positive values of `dY` indicate movement downward.
///
/// - Negative values of `dY` indicate movement upward.
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CGScreenUpdateMoveDelta {
    pub dX: i32,
    pub dY: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGScreenUpdateMoveDelta {
    const ENCODING: Encoding = Encoding::Struct(
        "CGScreenUpdateMoveDelta",
        &[<i32>::ENCODING, <i32>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGScreenUpdateMoveDelta {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A client-supplied callback function invoked when an area of the display is moved.
///
/// Parameters:
/// - delta: The distance, in pixel unites, that the display area has moved.
///
/// - count: The number of rectangles in the `rectArray` parameter.
///
/// - rectArray: A list of the rectangles in the moved areas, specified in the global display coordinate space. The origin is the upper-left corner of the main display. The rectangles describe the area prior to the move operation. You should not modify or deallocate memory pointed to by `rectArray`.
///
/// - userParameter: The user data you specify when you register this callback.
///
///
/// ## Discussion
///
/// To register a screen-move callback function, you call the function [`CGScreenRegisterMoveCallback`](https://developer.apple.com/documentation/coregraphics/cgscreenregistermovecallback(_:_:)). Quartz invokes your callback function when operations such as window movement or scrolling occur on local displays. When you finish using a callback registration, you should call the function [`CGScreenUnregisterMoveCallback`](https://developer.apple.com/documentation/coregraphics/cgscreenunregistermovecallback(_:_:)) to remove it.
///
/// Note that a single rectangle may occupy multiple displays, either by overlapping the displays or by residing on coincident displays when mirroring is active. You can use the function [`CGGetDisplaysWithRect`](https://developer.apple.com/documentation/coregraphics/cggetdisplayswithrect(_:_:_:_:)) to determine the displays a rectangle occupies.
///
///
pub type CGScreenUpdateMoveCallback = Option<
    unsafe extern "C-unwind" fn(CGScreenUpdateMoveDelta, usize, NonNull<CGRect>, *mut c_void),
>;

extern "C-unwind" {
    /// Registers a callback function to be invoked when an area of the display is moved.
    ///
    /// Parameters:
    /// - callback: A pointer to the callback function to be registered.
    ///
    /// - userInfo: A pointer to user-defined data, or `NULL`. The `userInfo` argument is passed back to the callback function each time it’s invoked.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Core Graphics Data Types and Constants`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A callback function may be registered multiple times with different user-defined data pointers, resulting in multiple registration entries.  For each registration, when notification is no longer needed, you should remove the registration by calling the function [`CGScreenUnregisterMoveCallback`](https://developer.apple.com/documentation/coregraphics/cgscreenunregistermovecallback(_:_:)).
    ///
    /// The callback function you register is invoked only if your application has an active event loop. The callback is invoked in the same thread of execution that is processing events within your application.
    ///
    /// ### Special Considerations
    ///
    /// This function is implemented in macOS 10.4.3 and later.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[cfg(feature = "CGError")]
    #[deprecated = "No longer supported"]
    pub fn CGScreenRegisterMoveCallback(
        callback: CGScreenUpdateMoveCallback,
        user_info: *mut c_void,
    ) -> CGError;
}

extern "C-unwind" {
    /// Removes a previously registered callback function invoked when an area of the display is moved.
    ///
    /// Parameters:
    /// - callback: A pointer to the callback function to be unregistered.
    ///
    /// - userInfo: A pointer to user-defined data, or `NULL`. You should pass the same value you used when you registered the callback function.
    ///
    ///
    /// ## Discussion
    ///
    /// When you call this function, the two arguments must match the registered entry to be removed.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `user_info` must be a valid pointer or null.
    #[deprecated = "No longer supported"]
    pub fn CGScreenUnregisterMoveCallback(
        callback: CGScreenUpdateMoveCallback,
        user_info: *mut c_void,
    );
}

extern "C-unwind" {
    /// Waits for screen update operations.
    ///
    /// Parameters:
    /// - requestedOperations: The desired types of screen update operations. There are several possible choices:
    ///
    /// - Specify `kCGScreenUpdateOperationRefresh` if you want all move operations to be returned as refresh operations.
    ///
    /// - Specify `(kCGScreenUpdateOperationRefresh | kCGScreenUpdateOperationMove)` if you want to distinguish between move and refresh operations.
    ///
    /// - Add `kCGScreenUpdateOperationReducedDirtyRectangleCount` to the screen operations if you want to minimize the number of rectangles returned to represent changed areas of the display.
    ///
    /// - currentOperation: A pointer to a `CGScreenUpdateOperation` variable. On return, the variable indicates the type of update operation (refresh or move).
    ///
    /// - rects: A pointer to a `CGRect*` variable. On return, the variable contains an array of rectangles that bound the updated areas, specified in the global display coordinate space. When you no longer need the array, you should deallocate it by calling [`CGReleaseScreenRefreshRects`](https://developer.apple.com/documentation/coregraphics/cgreleasescreenrefreshrects(_:)).
    ///
    /// - rectCount: A pointer to a `size_t` variable. On return, the variable contains the number of entries in the returned array of rectangles.
    ///
    /// - delta: A pointer to a `CGScreenUpdateMoveDelta` variable. On return, if the value of the `currentOperation` parameter is `kCGScreenUpdateOperationMove`, the variable contains the distance moved.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Core Graphics Data Types and Constants`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In some applications it may be preferable to wait for screen-update data synchronously, using this function. You should call this function in a thread other than the main event-processing thread.
    ///
    /// As an alternative, Quartz also supports asynchronous notification—see [`CGRegisterScreenRefreshCallback`](https://developer.apple.com/documentation/coregraphics/cgregisterscreenrefreshcallback(_:_:)) and [`CGScreenRegisterMoveCallback`](https://developer.apple.com/documentation/coregraphics/cgscreenregistermovecallback(_:_:)). If refresh or move callback functions are registered, this function should not be used.
    ///
    /// ### Special Considerations
    ///
    /// This function is implemented in macOS 10.4.3 and later.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `current_operation` must be a valid pointer or null.
    /// - `rects` must be a valid pointer or null.
    /// - `rect_count` must be a valid pointer or null.
    /// - `delta` must be a valid pointer or null.
    #[cfg(feature = "CGError")]
    #[deprecated = "No longer supported"]
    pub fn CGWaitForScreenUpdateRects(
        requested_operations: CGScreenUpdateOperation,
        current_operation: *mut CGScreenUpdateOperation,
        rects: *mut *mut CGRect,
        rect_count: *mut usize,
        delta: *mut CGScreenUpdateMoveDelta,
    ) -> CGError;
}

extern "C-unwind" {
    /// Deallocates a list of rectangles that represent changed areas on local displays.
    ///
    /// Parameters:
    /// - rects: A list of rectangles obtained by calling [`CGWaitForScreenRefreshRects`](https://developer.apple.com/documentation/coregraphics/cgwaitforscreenrefreshrects(_:_:)) or [`CGWaitForScreenUpdateRects`](https://developer.apple.com/documentation/coregraphics/cgwaitforscreenupdaterects(_:_:_:_:_:)).
    ///
    ///
    /// # Safety
    ///
    /// `rects` must be a valid pointer or null.
    #[deprecated = "No longer supported"]
    pub fn CGReleaseScreenRefreshRects(rects: *mut CGRect);
}

/// Returns a Boolean value indicating whether the mouse cursor is visible.
///
/// ## Return Value
///
/// If `true`, the cursor is visible on any display; otherwise, `false`.
///
///
///
/// ## Discussion
///
/// To hide or show the cursor, you can use the functions [`CGDisplayHideCursor`](https://developer.apple.com/documentation/coregraphics/cgdisplayhidecursor(_:)) and [`CGDisplayShowCursor`](https://developer.apple.com/documentation/coregraphics/cgdisplayshowcursor(_:)).
///
///
#[cfg(feature = "libc")]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGCursorIsVisible() -> bool {
    extern "C-unwind" {
        fn CGCursorIsVisible() -> libc::boolean_t;
    }
    let ret = unsafe { CGCursorIsVisible() };
    ret != 0
}

/// Returns a Boolean value indicating whether the mouse cursor is drawn in framebuffer memory.
///
/// ## Return Value
///
/// If `true`, the cursor is drawn in framebuffer memory; otherwise, `false`.
///
///
///
/// ## Discussion
///
/// This function returns a Boolean value that indicates whether or not the cursor is drawn in the framebuffer. (The cursor could exist in an overlay plane or a similar mechanism that puts pixels on-screen without altering framebuffer content.) If the cursor is drawn in the framebuffer, it is read back along with window data.
///
/// The reported Boolean value is based on the union of the state of the cursor on all displays.  If the cursor is drawn in the framebuffer on any display, the function returns `true`.
///
///
#[cfg(feature = "libc")]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGCursorIsDrawnInFramebuffer() -> bool {
    extern "C-unwind" {
        fn CGCursorIsDrawnInFramebuffer() -> libc::boolean_t;
    }
    let ret = unsafe { CGCursorIsDrawnInFramebuffer() };
    ret != 0
}

/// Moves the mouse cursor without generating events.
///
/// Parameters:
/// - newCursorPosition: The new mouse cursor position in the global display coordinate space.
///
///
/// ## Return Value
///
/// A result code. See `Core Graphics Data Types and Constants`.
///
///
///
/// ## Discussion
///
/// You can use this function to “warp” or alter the cursor position without generating or posting an event. For example, this function is often used to move the cursor position back to the center of the screen by games that do not want the cursor pinned by display edges.
///
///
#[cfg(feature = "CGError")]
#[inline]
pub extern "C-unwind" fn CGWarpMouseCursorPosition(new_cursor_position: CGPoint) -> CGError {
    extern "C-unwind" {
        fn CGWarpMouseCursorPosition(new_cursor_position: CGPoint) -> CGError;
    }
    unsafe { CGWarpMouseCursorPosition(new_cursor_position) }
}

/// Connects or disconnects the mouse and cursor while an application is in the foreground.
///
/// Parameters:
/// - connected: Pass [`true`](https://developer.apple.com/documentation/swift/true) to connect the mouse and cursor; otherwise, pass [`false`](https://developer.apple.com/documentation/swift/false).
///
///
/// ## Return Value
///
/// A result code. To interpret the result code, see [`CGError`](https://developer.apple.com/documentation/coregraphics/cgerror).
///
///
///
/// ## Discussion
///
/// Call this function to disconnect the mouse from the cursor. When you call this function, the events your application receives from the system have a constant absolute location but contain delta updates to the X and Y coordinates of the mouse. You can hide the cursor or change it into something appropriate for your application. You can reposition the cursor by using the function [`CGDisplayMoveCursorToPoint`](https://developer.apple.com/documentation/coregraphics/cgdisplaymovecursortopoint(_:_:)) or the function [`CGWarpMouseCursorPosition`](https://developer.apple.com/documentation/coregraphics/cgwarpmousecursorposition(_:)).
///
///
#[cfg(all(feature = "CGError", feature = "libc"))]
#[inline]
pub extern "C-unwind" fn CGAssociateMouseAndMouseCursorPosition(connected: bool) -> CGError {
    extern "C-unwind" {
        fn CGAssociateMouseAndMouseCursorPosition(connected: libc::boolean_t) -> CGError;
    }
    unsafe { CGAssociateMouseAndMouseCursorPosition(connected as _) }
}

#[inline]
pub extern "C-unwind" fn CGWindowServerCreateServerPort() -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGWindowServerCreateServerPort() -> Option<NonNull<CFMachPort>>;
    }
    let ret = unsafe { CGWindowServerCreateServerPort() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Enables or disables the merging of actual key and mouse state with the application-specified state in a synthetic event.
///
/// Parameters:
/// - combineState: Pass `true` to specify that the actual key and mouse state are merged with the application-specified state in a synthetic event; otherwise, pass `false`.
///
///
/// ## Return Value
///
/// A result code. See the result codes described in [Quartz Display Services](https://developer.apple.com/documentation/coregraphics/quartz-display-services).
///
///
///
/// ## Discussion
///
/// By default, the flags that indicate modifier key state (Command, Option, Shift, Control, and so on) from the system’s keyboard and from other event sources are ORed together as an event is posted into the system, and current key and mouse button state is considered in generating new events. This function allows your application to enable or disable the merging of event state. When combining is turned off, the event state propagated in the events posted by your application reflect state built up only by your application. The state within your application’s generated event will not be combined with the system’s current state, so the system-wide state reflecting key and mouse button state will remain unchanged. When called with `doCombineState` equal to `false`, this function initializes local (per application) state tracking information to a state of all keys, modifiers, and mouse buttons up. When called with `doCombineState` equal to `true`, the current global state of keys, modifiers, and mouse buttons are used in generating events.
///
/// This function is not recommended for general use because of undocumented special cases and undesirable side effects. The recommended replacement for this function is to use Quartz events and Quartz event sources. This allows you to control exactly which, if any, external event sources will contribute to the state used to create an event.
///
///
#[cfg(all(feature = "CGError", feature = "libc"))]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGEnableEventStateCombining(combine_state: bool) -> CGError {
    extern "C-unwind" {
        fn CGEnableEventStateCombining(combine_state: libc::boolean_t) -> CGError;
    }
    unsafe { CGEnableEventStateCombining(combine_state as _) }
}

/// Turns off local hardware events in the current session.
///
/// Parameters:
/// - inhibit: Pass `true` to specify that local hardware events on the remote system should be inhibited; otherwise, pass `false`.
///
///
/// ## Return Value
///
/// A result code. See the result codes described in [Quartz Display Services](https://developer.apple.com/documentation/coregraphics/quartz-display-services).
///
///
///
/// ## Discussion
///
/// This function is typically used during remote operation of a system to disconnect the keyboard and mouse for a short period of time, as in automated system testing or telecommuting applications.
///
/// The `CGInhibitLocalEvents` function is not recommended for general use because of undocumented special cases and undesirable side effects. For example, this function can permanently disable the keyboard and mouse, rendering the system unusable. The recommended replacement for this function is [`CGEventSourceSetLocalEventsFilterDuringSuppressionState`](https://developer.apple.com/documentation/coregraphics/cgeventsource/setlocaleventsfilterduringsuppressionstate(_:state:)).
///
/// ### Special Considerations
///
/// In OS X v10.2 and earlier, this function inhibits local events only after a synthetic keyboard or mouse event is posted by the calling application. In macOS 10.3 and later, event inhibition takes effect immediately. If your application terminates for any reason, event inhibition on the remote system is immediately turned off.
///
///
#[cfg(all(feature = "CGError", feature = "libc"))]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGInhibitLocalEvents(inhibit: bool) -> CGError {
    extern "C-unwind" {
        fn CGInhibitLocalEvents(inhibit: libc::boolean_t) -> CGError;
    }
    unsafe { CGInhibitLocalEvents(inhibit as _) }
}

/// Synthesizes a low-level keyboard event on the local machine.
///
/// Parameters:
/// - keyChar: The value of the character to generate, or 0 to specify that the system should guess an appropriate value based on the default key mapping.
///
/// - virtualKey: The virtual key code for the event. See [`CGKeyCode`](https://developer.apple.com/documentation/coregraphics/cgkeycode).
///
/// - keyDown: Pass `true` to specify that the key position is down; otherwise, pass `false`.
///
///
/// ## Return Value
///
/// A result code. See the result codes described in [Quartz Display Services](https://developer.apple.com/documentation/coregraphics/quartz-display-services).
///
///
///
/// ## Discussion
///
/// This function is not recommended for general use because of undocumented special cases and undesirable side effects. The recommended replacement for this function is [`CGEventCreateKeyboardEvent`](https://developer.apple.com/documentation/coregraphics/cgevent/init(keyboardeventsource:virtualkey:keydown:)), which allows you to create a keyboard event and customize the event before posting it to the event system.
///
///
#[cfg(all(feature = "CGError", feature = "libc"))]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGPostKeyboardEvent(
    key_char: CGCharCode,
    virtual_key: CGKeyCode,
    key_down: bool,
) -> CGError {
    extern "C-unwind" {
        fn CGPostKeyboardEvent(
            key_char: CGCharCode,
            virtual_key: CGKeyCode,
            key_down: libc::boolean_t,
        ) -> CGError;
    }
    unsafe { CGPostKeyboardEvent(key_char, virtual_key, key_down as _) }
}

/// Specify masks for classes of low-level events that can be filtered during event suppression states.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGEventFilterMask(pub u32);
bitflags::bitflags! {
    impl CGEventFilterMask: u32 {
        #[doc(alias = "kCGEventFilterMaskPermitLocalMouseEvents")]
        const PermitLocalMouseEvents = 0x00000001;
        #[doc(alias = "kCGEventFilterMaskPermitLocalKeyboardEvents")]
        const PermitLocalKeyboardEvents = 0x00000002;
        #[doc(alias = "kCGEventFilterMaskPermitSystemDefinedEvents")]
        const PermitSystemDefinedEvents = 0x00000004;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGEventFilterMask {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGEventFilterMask {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Specify the event suppression states that can occur after posting an event.
///
/// ## Overview
///
/// These constants specify the types of event suppression intervals during which an event filter is applied after posting an event.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGEventSuppressionState(pub u32);
impl CGEventSuppressionState {
    /// Specifies that certain local hardware events may be suppressed for a short interval after posting an event.
    #[doc(alias = "kCGEventSuppressionStateSuppressionInterval")]
    pub const EventSuppressionStateSuppressionInterval: Self = Self(0);
    /// Specifies that certain local hardware events may be suppressed during a mouse drag operation (mouse movement with the left or only mouse button down).
    #[doc(alias = "kCGEventSuppressionStateRemoteMouseDrag")]
    pub const EventSuppressionStateRemoteMouseDrag: Self = Self(1);
    #[doc(alias = "kCGNumberOfEventSuppressionStates")]
    pub const NumberOfEventSuppressionStates: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGEventSuppressionState {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGEventSuppressionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Filters local hardware events from the keyboard and mouse during the short interval after a synthetic event is posted.
///
/// Parameters:
/// - filter: The class of local hardware events to enable after a synthetic event is posted. Pass one of the constants listed in [`CGEventFilterMask`](https://developer.apple.com/documentation/coregraphics/cgeventfiltermask).
///
/// - state: The type of interval during which the filter is applied. Pass one of the constants listed in [`CGEventSuppressionState`](https://developer.apple.com/documentation/coregraphics/cgeventsuppressionstate).
///
///
/// ## Return Value
///
/// A result code. See the result codes described in [Quartz Display Services](https://developer.apple.com/documentation/coregraphics/quartz-display-services).
///
///
///
/// ## Discussion
///
/// By default, the system suppresses local hardware events from the keyboard and mouse during a short interval after a synthetic event is posted and during a synthetic mouse drag (mouse movement with the left or only mouse button down).
///
/// Some applications may want to enable events from some of the local hardware. For example, if you post mouse events only, you may wish to permit local keyboard hardware events to pass through.
///
/// This function lets you specify a state (event suppression interval or mouse drag), and a mask of event categories to be passed through. The new filter state takes effect with the next synthetic event you post.
///
/// This function is not recommended for general use because of undocumented special cases and undesirable side effects. The recommended replacement for this function is [`CGEventSourceSetLocalEventsFilterDuringSuppressionState`](https://developer.apple.com/documentation/coregraphics/cgeventsource/setlocaleventsfilterduringsuppressionstate(_:state:)), which allows the filter behavior to be associated only with events created from a specific event source.
///
///
#[cfg(feature = "CGError")]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGSetLocalEventsFilterDuringSuppressionState(
    filter: CGEventFilterMask,
    state: CGEventSuppressionState,
) -> CGError {
    extern "C-unwind" {
        fn CGSetLocalEventsFilterDuringSuppressionState(
            filter: CGEventFilterMask,
            state: CGEventSuppressionState,
        ) -> CGError;
    }
    unsafe { CGSetLocalEventsFilterDuringSuppressionState(filter, state) }
}

/// Sets the time interval in seconds that local hardware events are suppressed after posting a synthetic event.
///
/// Parameters:
/// - seconds: The desired time interval in seconds. The value should be a number in the range [0.0, 10.0].
///
///
/// ## Return Value
///
/// A result code. If the `seconds` parameter is outside the allowed range, returns `kCGErrorRangeCheck`.
///
///
///
/// ## Discussion
///
/// This function determines how long local events matching an event filter are to be suppressed following the posting of a synthetic event. The default time interval for event suppression is 0.25 seconds.
///
/// This function is not recommended for general use because of undocumented special cases and undesirable side effects. The recommended replacement for this function is [`CGEventSourceSetLocalEventsSuppressionInterval`](https://developer.apple.com/documentation/coregraphics/cgeventsourcesetlocaleventssuppressioninterval), which allows the suppression interval to be adjusted for a specific event source, affecting only events posted using that event source.
///
///
#[cfg(feature = "CGError")]
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGSetLocalEventsSuppressionInterval(seconds: CFTimeInterval) -> CGError {
    extern "C-unwind" {
        fn CGSetLocalEventsSuppressionInterval(seconds: CFTimeInterval) -> CGError;
    }
    unsafe { CGSetLocalEventsSuppressionInterval(seconds) }
}

/// Returns a Core Foundation Mach port (CFMachPort) that corresponds to the macOS window server.
///
/// ## Return Value
///
/// A Core Foundation Mach port, or `NULL` if the window server is not running. When you no longer need the port, you should release it using the function `CFRelease`.
///
///
///
/// ## Discussion
///
/// You can use this function to detect whether the window server process exits or is not running. If this function returns `NULL`, the window server is not running. This code example shows how to register a callback function to detect when the window server exits:
///
/// ```objc
/// static void handleWindowServerDeath( CFMachPortRef port, void *info  )
/// {
///     printf( "Window Server port death detected!\n" );
///     CFRelease(port);
///     exit(1);
/// }
///  
/// static void watchForWindowServerDeath()
/// {
///     CFMachPortRef port = CGWindowServerCFMachPort();
///     CFMachPortSetInvalidationCallBack(port, handleWindowServerDeath);
/// }
/// ```
///
/// Note that this callback only works if your program has an active run loop.
///
///
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn CGWindowServerCFMachPort() -> Option<CFRetained<CFMachPort>> {
    extern "C-unwind" {
        fn CGWindowServerCFMachPort() -> Option<NonNull<CFMachPort>>;
    }
    let ret = unsafe { CGWindowServerCFMachPort() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// The size of an array of Quartz rectangles.
///
/// ## Discussion
///
/// For example, see the function [`CGWaitForScreenRefreshRects`](https://developer.apple.com/documentation/coregraphics/cgwaitforscreenrefreshrects(_:_:)).
///
///
pub type CGRectCount = u32;
