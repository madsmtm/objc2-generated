//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A definition for a smooth transition between colors for drawing radial and axial gradient fills.
///
/// ## Overview
///
/// A gradient defines a smooth transition between colors across an area. A `CGGradient` has a color space, two or more colors, and a location for each color. The color space cannot be a pattern or indexed color space, otherwise it can be any Core Graphics color space ([`CGColorSpaceRef`](https://developer.apple.com/documentation/coregraphics/cgcolorspace)).
///
/// Colors can be provided as component values (such as red, green, blue) or as Core Graphics color objects ([`CGColorRef`](https://developer.apple.com/documentation/coregraphics/cgcolor)). Component values can vary from 0.0 to 1.0, designating the proportion of the component present in the color.
///
/// A location is a normalized value. When it comes time to paint the gradient, Core Graphics maps the normalized location values to the points in coordinate space that you provide.
///
/// For more precise control over gradients, see [`CGShadingRef`](https://developer.apple.com/documentation/coregraphics/cgshading).
///
///
#[doc(alias = "CGGradientRef")]
#[repr(C)]
pub struct CGGradient {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGGradient {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGGradient"> for CGGradient {}
);

/// Drawing locations for gradients.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGGradientDrawingOptions(pub u32);
bitflags::bitflags! {
    impl CGGradientDrawingOptions: u32 {
/// The fill should extend beyond the starting location. The color that extends beyond the starting point is the solid color defined by the [`CGGradientRef`](https://developer.apple.com/documentation/coregraphics/cggradient) object to be at location 0.
        #[doc(alias = "kCGGradientDrawsBeforeStartLocation")]
        const DrawsBeforeStartLocation = 1<<0;
/// The fill should extend beyond the ending location. The color that extends beyond the ending point is the solid color defined by the [`CGGradientRef`](https://developer.apple.com/documentation/coregraphics/cggradient) object to be at location 1.
        #[doc(alias = "kCGGradientDrawsAfterEndLocation")]
        const DrawsAfterEndLocation = 1<<1;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGGradientDrawingOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGGradientDrawingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CGGradient {
    /// Returns the Core Foundation type identifier for CGGradient objects.
    ///
    /// ## Return Value
    ///
    /// The Core Foundation identifier for the opaque type `CGGradientRef`.
    ///
    ///
    #[doc(alias = "CGGradientGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGGradientGetTypeID() -> CFTypeID;
        }
        unsafe { CGGradientGetTypeID() }
    }
}

impl CGGradient {
    /// Creates a CGGradient object from a color space and the provided color components and locations.
    ///
    /// Parameters:
    /// - space: The color space to use for the gradient. You cannot use a pattern or indexed color space.
    ///
    /// - components: The color components for each color that defines the gradient. The components should be in the color space specified by `space`. If you are unsure of the number of components, you can call the function [`CGColorSpaceGetNumberOfComponents`](https://developer.apple.com/documentation/coregraphics/cgcolorspace/numberofcomponents).
    ///
    /// The number of items in this array should be the product of `count` and the number of components in the color space. For example, if the color space is an RGBA color space and you want to use two colors in the gradient (one for a starting location and another for an ending location), then you need to provide 8 values in `components`â€”red, green, blue, and alpha values for the first color, followed by red, green, blue, and alpha values for the second color.
    ///
    /// - locations: The location for each color provided in `components`. Each location must be a `CGFloat` value in the range of 0 to 1, inclusive. If 0 and 1 are not in the `locations` array, Quartz uses the colors provided that are closest to 0 and 1 for those locations.
    ///
    /// If `locations`  is `NULL`, the first color in `colors`  is assigned to location `0`, the last color in`colors`  is assigned to location `1`, and intervening colors are assigned locations that are at equal intervals in between.
    ///
    /// - count: The number of locations provided in the `locations` parameters.
    ///
    ///
    /// ## Return Value
    ///
    /// A CGGradient object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `components` must be a valid pointer or null.
    /// - `locations` must be a valid pointer or null.
    #[doc(alias = "CGGradientCreateWithColorComponents")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn with_color_components(
        space: Option<&CGColorSpace>,
        components: *const CGFloat,
        locations: *const CGFloat,
        count: usize,
    ) -> Option<CFRetained<CGGradient>> {
        extern "C-unwind" {
            fn CGGradientCreateWithColorComponents(
                space: Option<&CGColorSpace>,
                components: *const CGFloat,
                locations: *const CGFloat,
                count: usize,
            ) -> Option<NonNull<CGGradient>>;
        }
        let ret =
            unsafe { CGGradientCreateWithColorComponents(space, components, locations, count) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `components` must be a valid pointer or null.
    /// - `locations` must be a valid pointer or null.
    #[doc(alias = "CGGradientCreateWithContentHeadroom")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn with_content_headroom(
        headroom: c_float,
        space: Option<&CGColorSpace>,
        components: *const CGFloat,
        locations: *const CGFloat,
        count: usize,
    ) -> Option<CFRetained<CGGradient>> {
        extern "C-unwind" {
            fn CGGradientCreateWithContentHeadroom(
                headroom: c_float,
                space: Option<&CGColorSpace>,
                components: *const CGFloat,
                locations: *const CGFloat,
                count: usize,
            ) -> Option<NonNull<CGGradient>>;
        }
        let ret = unsafe {
            CGGradientCreateWithContentHeadroom(headroom, space, components, locations, count)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a gradient object from a color space and the provided color objects and locations.
    ///
    /// Parameters:
    /// - space: The color space to use for the gradient. You cannot use a pattern or indexed color space.
    ///
    /// - colors: A non-empty array of [`CGColorRef`](https://developer.apple.com/documentation/coregraphics/cgcolor) objects that should be in the color space specified by `space`. If `space` is not `NULL`, each color will be converted (if necessary) to that color space and the gradient will drawn in that color space. Otherwise, each color will be converted to and drawn in the GenericRGB color space.
    ///
    /// - locations: The location for each color provided in `colors`; each location must be a [`CGFloat`](https://developer.apple.com/documentation/corefoundation/cgfloat-swift.struct) value in the range of `0` to `1`, inclusive. If `0` and `1` are not in the `locations` array, Quartz uses the colors provided that are closest to `0` and `1` for those locations.
    ///
    /// If `locations` is `NULL`, the first color in `colors` is assigned to location `0`, the last color in `colors` is assigned to location `1`, and intervening colors are assigned locations that are at equal intervals in between.
    ///
    /// The `locations` array should contain the same number of items as the `colors` array.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`CGGradientRef`](https://developer.apple.com/documentation/coregraphics/cggradient) object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `colors` generic must be of the correct type.
    /// - `locations` must be a valid pointer or null.
    #[doc(alias = "CGGradientCreateWithColors")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn with_colors(
        space: Option<&CGColorSpace>,
        colors: Option<&CFArray>,
        locations: *const CGFloat,
    ) -> Option<CFRetained<CGGradient>> {
        extern "C-unwind" {
            fn CGGradientCreateWithColors(
                space: Option<&CGColorSpace>,
                colors: Option<&CFArray>,
                locations: *const CGFloat,
            ) -> Option<NonNull<CGGradient>>;
        }
        let ret = unsafe { CGGradientCreateWithColors(space, colors, locations) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGGradientGetContentHeadroom")]
    #[inline]
    pub fn content_headroom(gradient: Option<&CGGradient>) -> c_float {
        extern "C-unwind" {
            fn CGGradientGetContentHeadroom(gradient: Option<&CGGradient>) -> c_float;
        }
        unsafe { CGGradientGetContentHeadroom(gradient) }
    }
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGGradient::with_color_components`"]
#[inline]
pub unsafe extern "C-unwind" fn CGGradientCreateWithColorComponents(
    space: Option<&CGColorSpace>,
    components: *const CGFloat,
    locations: *const CGFloat,
    count: usize,
) -> Option<CFRetained<CGGradient>> {
    extern "C-unwind" {
        fn CGGradientCreateWithColorComponents(
            space: Option<&CGColorSpace>,
            components: *const CGFloat,
            locations: *const CGFloat,
            count: usize,
        ) -> Option<NonNull<CGGradient>>;
    }
    let ret = unsafe { CGGradientCreateWithColorComponents(space, components, locations, count) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGGradient::with_content_headroom`"]
#[inline]
pub unsafe extern "C-unwind" fn CGGradientCreateWithContentHeadroom(
    headroom: c_float,
    space: Option<&CGColorSpace>,
    components: *const CGFloat,
    locations: *const CGFloat,
    count: usize,
) -> Option<CFRetained<CGGradient>> {
    extern "C-unwind" {
        fn CGGradientCreateWithContentHeadroom(
            headroom: c_float,
            space: Option<&CGColorSpace>,
            components: *const CGFloat,
            locations: *const CGFloat,
            count: usize,
        ) -> Option<NonNull<CGGradient>>;
    }
    let ret = unsafe {
        CGGradientCreateWithContentHeadroom(headroom, space, components, locations, count)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGGradient::with_colors`"]
#[inline]
pub unsafe extern "C-unwind" fn CGGradientCreateWithColors(
    space: Option<&CGColorSpace>,
    colors: Option<&CFArray>,
    locations: *const CGFloat,
) -> Option<CFRetained<CGGradient>> {
    extern "C-unwind" {
        fn CGGradientCreateWithColors(
            space: Option<&CGColorSpace>,
            colors: Option<&CFArray>,
            locations: *const CGFloat,
        ) -> Option<NonNull<CGGradient>>;
    }
    let ret = unsafe { CGGradientCreateWithColors(space, colors, locations) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGGradient::content_headroom`"]
#[inline]
pub extern "C-unwind" fn CGGradientGetContentHeadroom(gradient: Option<&CGGradient>) -> c_float {
    extern "C-unwind" {
        fn CGGradientGetContentHeadroom(gradient: Option<&CGGradient>) -> c_float;
    }
    unsafe { CGGradientGetContentHeadroom(gradient) }
}
