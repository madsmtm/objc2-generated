//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// An object that describes how to convert between color spaces for use by other system services.
///
/// ## Overview
///
/// A [`CGColorConversionInfoRef`](https://developer.apple.com/documentation/coregraphics/cgcolorconversioninfo) object specifies a conversion between two or more color spaces, including information about the intent of the conversion. You use color conversion objects to specify the work to be done by an [`MPSImageConversion`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageconversion) filter, which can then perform GPU-accelerated image conversion.
///
///
#[doc(alias = "CGColorConversionInfoRef")]
#[repr(C)]
pub struct CGColorConversionInfo {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGColorConversionInfo {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGColorConversionInfo"> for CGColorConversionInfo {}
);

unsafe impl ConcreteType for CGColorConversionInfo {
    /// Returns the Core Foundation type identifier for a color conversion info data type.
    ///
    /// ## Return Value
    ///
    /// The Core Foundation type identifier for [`CGColorConversionInfoRef`](https://developer.apple.com/documentation/coregraphics/cgcolorconversioninfo).
    ///
    ///
    #[doc(alias = "CGColorConversionInfoGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGColorConversionInfoGetTypeID() -> CFTypeID;
        }
        unsafe { CGColorConversionInfoGetTypeID() }
    }
}

/// Constants describing how a color conversion uses color spaces.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGColorConversionInfoTransformType(pub u32);
impl CGColorConversionInfoTransformType {
    /// Specifies a color conversion from a device color space to a color profile.
    #[doc(alias = "kCGColorConversionTransformFromSpace")]
    pub const TransformFromSpace: Self = Self(0);
    /// Specifies a color conversion from a color profile to a device color space.
    #[doc(alias = "kCGColorConversionTransformToSpace")]
    pub const TransformToSpace: Self = Self(1);
    /// Specifies a color conversion between one color profile and another.
    #[doc(alias = "kCGColorConversionTransformApplySpace")]
    pub const TransformApplySpace: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGColorConversionInfoTransformType {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGColorConversionInfoTransformType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGColorConversionInfo {
    /// Creates a conversion between two specified color spaces.
    ///
    /// Parameters:
    /// - src: The source color space from which color values are to be converted.
    ///
    /// - dst: The destination color space to which colors are to be converted.
    ///
    ///
    /// ## Return Value
    ///
    /// A color conversion object, or `nil` if no conversion between the specified color spaces is allowed.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The source and destination color spaces must be calibrated color spaces (that is, not device-specific or indexed color spaces).
    ///
    /// You can use a color conversion object to create [`MPSImageConversion`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageconversion) filters that perform GPU-accelerated color space conversion.
    ///
    ///
    #[doc(alias = "CGColorConversionInfoCreate")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub fn new(
        src: Option<&CGColorSpace>,
        dst: Option<&CGColorSpace>,
    ) -> Option<CFRetained<CGColorConversionInfo>> {
        extern "C-unwind" {
            fn CGColorConversionInfoCreate(
                src: Option<&CGColorSpace>,
                dst: Option<&CGColorSpace>,
            ) -> Option<NonNull<CGColorConversionInfo>>;
        }
        let ret = unsafe { CGColorConversionInfoCreate(src, dst) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGColorConversionInfoCreateWithOptions")]
    #[cfg(feature = "CGColorSpace")]
    #[inline]
    pub unsafe fn with_options(
        src: &CGColorSpace,
        dst: &CGColorSpace,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGColorConversionInfo>> {
        extern "C-unwind" {
            fn CGColorConversionInfoCreateWithOptions(
                src: &CGColorSpace,
                dst: &CGColorSpace,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGColorConversionInfo>>;
        }
        let ret = unsafe { CGColorConversionInfoCreateWithOptions(src, dst, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "CGColorConversionInfoCreateForToneMapping")]
    #[cfg(all(feature = "CGColorSpace", feature = "CGToneMapping"))]
    #[inline]
    pub unsafe fn new_for_tone_mapping(
        from: &CGColorSpace,
        source_headroom: c_float,
        to: &CGColorSpace,
        target_headroom: c_float,
        method: CGToneMapping,
        options: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CGColorConversionInfo>> {
        extern "C-unwind" {
            fn CGColorConversionInfoCreateForToneMapping(
                from: &CGColorSpace,
                source_headroom: c_float,
                to: &CGColorSpace,
                target_headroom: c_float,
                method: CGToneMapping,
                options: Option<&CFDictionary>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CGColorConversionInfo>>;
        }
        let ret = unsafe {
            CGColorConversionInfoCreateForToneMapping(
                from,
                source_headroom,
                to,
                target_headroom,
                method,
                options,
                error,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "CGImage")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CGColorBufferFormat {
    pub version: u32,
    pub bitmapInfo: CGBitmapInfo,
    pub bitsPerComponent: usize,
    pub bitsPerPixel: usize,
    pub bytesPerRow: usize,
}

#[cfg(all(feature = "CGImage", feature = "objc2"))]
unsafe impl Encode for CGColorBufferFormat {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <CGBitmapInfo>::ENCODING,
            <usize>::ENCODING,
            <usize>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CGImage", feature = "objc2"))]
unsafe impl RefEncode for CGColorBufferFormat {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGColorConversionInfo {
    /// # Safety
    ///
    /// - `dst_data` must be a valid pointer.
    /// - `src_data` must be a valid pointer.
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGColorConversionInfoConvertData")]
    #[cfg(feature = "CGImage")]
    #[inline]
    pub unsafe fn convert_data(
        &self,
        width: usize,
        height: usize,
        dst_data: NonNull<c_void>,
        dst_format: CGColorBufferFormat,
        src_data: NonNull<c_void>,
        src_format: CGColorBufferFormat,
        options: Option<&CFDictionary>,
    ) -> bool {
        extern "C-unwind" {
            fn CGColorConversionInfoConvertData(
                info: &CGColorConversionInfo,
                width: usize,
                height: usize,
                dst_data: NonNull<c_void>,
                dst_format: CGColorBufferFormat,
                src_data: NonNull<c_void>,
                src_format: CGColorBufferFormat,
                options: Option<&CFDictionary>,
            ) -> bool;
        }
        unsafe {
            CGColorConversionInfoConvertData(
                self, width, height, dst_data, dst_format, src_data, src_format, options,
            )
        }
    }
}

extern "C" {
    /// An option for whether to apply black point compensation when converting between color profiles.
    ///
    /// ## Discussion
    ///
    /// ICC profiles specify how to convert the lightest level of white between color spaces, but they do not specify how black should be converted. To account for this, set a value of [`true`](https://developer.apple.com/documentation/swift/true) for this key when creating a color conversion with the [`CGColorConversionInfoCreateFromList`](https://developer.apple.com/documentation/coregraphics/cgcolorconversioninfocreatefromlist) function.
    ///
    ///
    pub static kCGColorConversionBlackPointCompensation: &'static CFString;
}

extern "C" {
    pub static kCGColorConversionTRCSize: &'static CFString;
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGColorConversionInfo::new`"]
#[inline]
pub extern "C-unwind" fn CGColorConversionInfoCreate(
    src: Option<&CGColorSpace>,
    dst: Option<&CGColorSpace>,
) -> Option<CFRetained<CGColorConversionInfo>> {
    extern "C-unwind" {
        fn CGColorConversionInfoCreate(
            src: Option<&CGColorSpace>,
            dst: Option<&CGColorSpace>,
        ) -> Option<NonNull<CGColorConversionInfo>>;
    }
    let ret = unsafe { CGColorConversionInfoCreate(src, dst) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGColorSpace")]
#[deprecated = "renamed to `CGColorConversionInfo::with_options`"]
#[inline]
pub unsafe extern "C-unwind" fn CGColorConversionInfoCreateWithOptions(
    src: &CGColorSpace,
    dst: &CGColorSpace,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGColorConversionInfo>> {
    extern "C-unwind" {
        fn CGColorConversionInfoCreateWithOptions(
            src: &CGColorSpace,
            dst: &CGColorSpace,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGColorConversionInfo>>;
    }
    let ret = unsafe { CGColorConversionInfoCreateWithOptions(src, dst, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CGColorSpace", feature = "CGToneMapping"))]
#[deprecated = "renamed to `CGColorConversionInfo::new_for_tone_mapping`"]
#[inline]
pub unsafe extern "C-unwind" fn CGColorConversionInfoCreateForToneMapping(
    from: &CGColorSpace,
    source_headroom: c_float,
    to: &CGColorSpace,
    target_headroom: c_float,
    method: CGToneMapping,
    options: Option<&CFDictionary>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CGColorConversionInfo>> {
    extern "C-unwind" {
        fn CGColorConversionInfoCreateForToneMapping(
            from: &CGColorSpace,
            source_headroom: c_float,
            to: &CGColorSpace,
            target_headroom: c_float,
            method: CGToneMapping,
            options: Option<&CFDictionary>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CGColorConversionInfo>>;
    }
    let ret = unsafe {
        CGColorConversionInfoCreateForToneMapping(
            from,
            source_headroom,
            to,
            target_headroom,
            method,
            options,
            error,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CGImage")]
    #[deprecated = "renamed to `CGColorConversionInfo::convert_data`"]
    pub fn CGColorConversionInfoConvertData(
        info: &CGColorConversionInfo,
        width: usize,
        height: usize,
        dst_data: NonNull<c_void>,
        dst_format: CGColorBufferFormat,
        src_data: NonNull<c_void>,
        src_format: CGColorBufferFormat,
        options: Option<&CFDictionary>,
    ) -> bool;
}
