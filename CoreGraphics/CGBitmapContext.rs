//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgbitmapcontextreleasedatacallback?language=objc)
pub type CGBitmapContextReleaseDataCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void)>;

/// # Safety
///
/// - `data` must be a valid pointer or null.
/// - `release_callback` must be implemented correctly.
/// - `release_info` must be a valid pointer or null.
#[cfg(all(feature = "CGColorSpace", feature = "CGContext"))]
#[inline]
pub unsafe extern "C-unwind" fn CGBitmapContextCreateWithData(
    data: *mut c_void,
    width: usize,
    height: usize,
    bits_per_component: usize,
    bytes_per_row: usize,
    space: Option<&CGColorSpace>,
    bitmap_info: u32,
    release_callback: CGBitmapContextReleaseDataCallback,
    release_info: *mut c_void,
) -> Option<CFRetained<CGContext>> {
    extern "C-unwind" {
        fn CGBitmapContextCreateWithData(
            data: *mut c_void,
            width: usize,
            height: usize,
            bits_per_component: usize,
            bytes_per_row: usize,
            space: Option<&CGColorSpace>,
            bitmap_info: u32,
            release_callback: CGBitmapContextReleaseDataCallback,
            release_info: *mut c_void,
        ) -> Option<NonNull<CGContext>>;
    }
    let ret = unsafe {
        CGBitmapContextCreateWithData(
            data,
            width,
            height,
            bits_per_component,
            bytes_per_row,
            space,
            bitmap_info,
            release_callback,
            release_info,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// # Safety
///
/// `data` must be a valid pointer or null.
#[cfg(all(feature = "CGColorSpace", feature = "CGContext"))]
#[inline]
pub unsafe extern "C-unwind" fn CGBitmapContextCreate(
    data: *mut c_void,
    width: usize,
    height: usize,
    bits_per_component: usize,
    bytes_per_row: usize,
    space: Option<&CGColorSpace>,
    bitmap_info: u32,
) -> Option<CFRetained<CGContext>> {
    extern "C-unwind" {
        fn CGBitmapContextCreate(
            data: *mut c_void,
            width: usize,
            height: usize,
            bits_per_component: usize,
            bytes_per_row: usize,
            space: Option<&CGColorSpace>,
            bitmap_info: u32,
        ) -> Option<NonNull<CGContext>>;
    }
    let ret = unsafe {
        CGBitmapContextCreate(
            data,
            width,
            height,
            bits_per_component,
            bytes_per_row,
            space,
            bitmap_info,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CGContext")]
    pub fn CGBitmapContextGetData(context: Option<&CGContext>) -> *mut c_void;
}

extern "C-unwind" {
    #[cfg(feature = "CGContext")]
    pub fn CGBitmapContextGetWidth(context: Option<&CGContext>) -> usize;
}

extern "C-unwind" {
    #[cfg(feature = "CGContext")]
    pub fn CGBitmapContextGetHeight(context: Option<&CGContext>) -> usize;
}

extern "C-unwind" {
    #[cfg(feature = "CGContext")]
    pub fn CGBitmapContextGetBitsPerComponent(context: Option<&CGContext>) -> usize;
}

extern "C-unwind" {
    #[cfg(feature = "CGContext")]
    pub fn CGBitmapContextGetBitsPerPixel(context: Option<&CGContext>) -> usize;
}

extern "C-unwind" {
    #[cfg(feature = "CGContext")]
    pub fn CGBitmapContextGetBytesPerRow(context: Option<&CGContext>) -> usize;
}

#[cfg(all(feature = "CGColorSpace", feature = "CGContext"))]
#[inline]
pub unsafe extern "C-unwind" fn CGBitmapContextGetColorSpace(
    context: Option<&CGContext>,
) -> Option<CFRetained<CGColorSpace>> {
    extern "C-unwind" {
        fn CGBitmapContextGetColorSpace(
            context: Option<&CGContext>,
        ) -> Option<NonNull<CGColorSpace>>;
    }
    let ret = unsafe { CGBitmapContextGetColorSpace(context) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "CGContext", feature = "CGImage"))]
    pub fn CGBitmapContextGetAlphaInfo(context: Option<&CGContext>) -> CGImageAlphaInfo;
}

extern "C-unwind" {
    #[cfg(all(feature = "CGContext", feature = "CGImage"))]
    pub fn CGBitmapContextGetBitmapInfo(context: Option<&CGContext>) -> CGBitmapInfo;
}

#[cfg(all(feature = "CGContext", feature = "CGImage"))]
#[inline]
pub unsafe extern "C-unwind" fn CGBitmapContextCreateImage(
    context: Option<&CGContext>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGBitmapContextCreateImage(context: Option<&CGContext>) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGBitmapContextCreateImage(context) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
