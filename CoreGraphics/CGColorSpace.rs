//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcolorspace?language=objc)
#[doc(alias = "CGColorSpaceRef")]
#[repr(C)]
pub struct CGColorSpace {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGColorSpace {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGColorSpace"> for CGColorSpace {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcolorrenderingintent?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGColorRenderingIntent(pub i32);
impl CGColorRenderingIntent {
    #[doc(alias = "kCGRenderingIntentDefault")]
    pub const RenderingIntentDefault: Self = Self(0);
    #[doc(alias = "kCGRenderingIntentAbsoluteColorimetric")]
    pub const RenderingIntentAbsoluteColorimetric: Self = Self(1);
    #[doc(alias = "kCGRenderingIntentRelativeColorimetric")]
    pub const RenderingIntentRelativeColorimetric: Self = Self(2);
    #[doc(alias = "kCGRenderingIntentPerceptual")]
    pub const RenderingIntentPerceptual: Self = Self(3);
    #[doc(alias = "kCGRenderingIntentSaturation")]
    pub const RenderingIntentSaturation: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGColorRenderingIntent {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGColorRenderingIntent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/cgcolorspacemodel?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGColorSpaceModel(pub i32);
impl CGColorSpaceModel {
    #[doc(alias = "kCGColorSpaceModelUnknown")]
    pub const Unknown: Self = Self(-1);
    #[doc(alias = "kCGColorSpaceModelMonochrome")]
    pub const Monochrome: Self = Self(0);
    #[doc(alias = "kCGColorSpaceModelRGB")]
    pub const RGB: Self = Self(1);
    #[doc(alias = "kCGColorSpaceModelCMYK")]
    pub const CMYK: Self = Self(2);
    #[doc(alias = "kCGColorSpaceModelLab")]
    pub const Lab: Self = Self(3);
    #[doc(alias = "kCGColorSpaceModelDeviceN")]
    pub const DeviceN: Self = Self(4);
    #[doc(alias = "kCGColorSpaceModelIndexed")]
    pub const Indexed: Self = Self(5);
    #[doc(alias = "kCGColorSpaceModelPattern")]
    pub const Pattern: Self = Self(6);
    #[doc(alias = "kCGColorSpaceModelXYZ")]
    pub const XYZ: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGColorSpaceModel {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGColorSpaceModel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericgray?language=objc)
    pub static kCGColorSpaceGenericGray: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericrgb?language=objc)
    pub static kCGColorSpaceGenericRGB: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericcmyk?language=objc)
    pub static kCGColorSpaceGenericCMYK: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacedisplayp3?language=objc)
    pub static kCGColorSpaceDisplayP3: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericrgblinear?language=objc)
    pub static kCGColorSpaceGenericRGBLinear: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceadobergb1998?language=objc)
    pub static kCGColorSpaceAdobeRGB1998: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacesrgb?language=objc)
    pub static kCGColorSpaceSRGB: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericgraygamma2_2?language=objc)
    pub static kCGColorSpaceGenericGrayGamma2_2: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericxyz?language=objc)
    pub static kCGColorSpaceGenericXYZ: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacegenericlab?language=objc)
    pub static kCGColorSpaceGenericLab: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceacescglinear?language=objc)
    pub static kCGColorSpaceACESCGLinear: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_709?language=objc)
    pub static kCGColorSpaceITUR_709: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_709_pq?language=objc)
    pub static kCGColorSpaceITUR_709_PQ: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_709_hlg?language=objc)
    pub static kCGColorSpaceITUR_709_HLG: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2020?language=objc)
    pub static kCGColorSpaceITUR_2020: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2020_srgbgamma?language=objc)
    pub static kCGColorSpaceITUR_2020_sRGBGamma: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacerommrgb?language=objc)
    pub static kCGColorSpaceROMMRGB: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacedcip3?language=objc)
    pub static kCGColorSpaceDCIP3: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacelinearitur_2020?language=objc)
    pub static kCGColorSpaceLinearITUR_2020: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendeditur_2020?language=objc)
    pub static kCGColorSpaceExtendedITUR_2020: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedlinearitur_2020?language=objc)
    pub static kCGColorSpaceExtendedLinearITUR_2020: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacelineardisplayp3?language=objc)
    pub static kCGColorSpaceLinearDisplayP3: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendeddisplayp3?language=objc)
    pub static kCGColorSpaceExtendedDisplayP3: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedlineardisplayp3?language=objc)
    pub static kCGColorSpaceExtendedLinearDisplayP3: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2100_pq?language=objc)
    pub static kCGColorSpaceITUR_2100_PQ: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2100_hlg?language=objc)
    pub static kCGColorSpaceITUR_2100_HLG: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacedisplayp3_pq?language=objc)
    pub static kCGColorSpaceDisplayP3_PQ: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacedisplayp3_hlg?language=objc)
    pub static kCGColorSpaceDisplayP3_HLG: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2020_pq?language=objc)
    #[deprecated = "No longer supported"]
    pub static kCGColorSpaceITUR_2020_PQ: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2020_hlg?language=objc)
    #[deprecated = "No longer supported"]
    pub static kCGColorSpaceITUR_2020_HLG: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacedisplayp3_pq_eotf?language=objc)
    #[deprecated = "No longer supported"]
    pub static kCGColorSpaceDisplayP3_PQ_EOTF: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceitur_2020_pq_eotf?language=objc)
    #[deprecated = "No longer supported"]
    pub static kCGColorSpaceITUR_2020_PQ_EOTF: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedsrgb?language=objc)
    pub static kCGColorSpaceExtendedSRGB: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacelinearsrgb?language=objc)
    pub static kCGColorSpaceLinearSRGB: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedlinearsrgb?language=objc)
    pub static kCGColorSpaceExtendedLinearSRGB: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedgray?language=objc)
    pub static kCGColorSpaceExtendedGray: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacelineargray?language=objc)
    pub static kCGColorSpaceLinearGray: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedlineargray?language=objc)
    pub static kCGColorSpaceExtendedLinearGray: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspacecoremedia709?language=objc)
    pub static kCGColorSpaceCoreMedia709: &'static CFString;
}

impl CGColorSpace {
    #[doc(alias = "CGColorSpaceCreateDeviceGray")]
    #[inline]
    pub fn new_device_gray() -> CFRetained<CGColorSpace> {
        extern "C-unwind" {
            fn CGColorSpaceCreateDeviceGray() -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateDeviceGray() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorSpaceCreateDeviceRGB")]
    #[inline]
    pub fn new_device_rgb() -> CFRetained<CGColorSpace> {
        extern "C-unwind" {
            fn CGColorSpaceCreateDeviceRGB() -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateDeviceRGB() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorSpaceCreateDeviceCMYK")]
    #[inline]
    pub fn new_device_cmyk() -> CFRetained<CGColorSpace> {
        extern "C-unwind" {
            fn CGColorSpaceCreateDeviceCMYK() -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateDeviceCMYK() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorSpaceCreateCalibratedGray")]
    #[inline]
    pub fn new_calibrated_gray(
        white_point: &[CGFloat; 3],
        black_point: Option<&[CGFloat; 3]>,
        gamma: CGFloat,
    ) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateCalibratedGray(
                white_point: &[CGFloat; 3],
                black_point: Option<&[CGFloat; 3]>,
                gamma: CGFloat,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateCalibratedGray(white_point, black_point, gamma) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCreateCalibratedRGB")]
    #[inline]
    pub fn new_calibrated_rgb(
        white_point: &[CGFloat; 3],
        black_point: Option<&[CGFloat; 3]>,
        gamma: Option<&[CGFloat; 3]>,
        matrix: Option<&[CGFloat; 9]>,
    ) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateCalibratedRGB(
                white_point: &[CGFloat; 3],
                black_point: Option<&[CGFloat; 3]>,
                gamma: Option<&[CGFloat; 3]>,
                matrix: Option<&[CGFloat; 9]>,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret =
            unsafe { CGColorSpaceCreateCalibratedRGB(white_point, black_point, gamma, matrix) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCreateLab")]
    #[inline]
    pub fn new_lab(
        white_point: &[CGFloat; 3],
        black_point: Option<&[CGFloat; 3]>,
        range: Option<&[CGFloat; 4]>,
    ) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateLab(
                white_point: &[CGFloat; 3],
                black_point: Option<&[CGFloat; 3]>,
                range: Option<&[CGFloat; 4]>,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateLab(white_point, black_point, range) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `data` should be of the correct type.
    #[doc(alias = "CGColorSpaceCreateWithICCData")]
    #[inline]
    pub unsafe fn with_icc_data(data: &CFType) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateWithICCData(data: &CFType) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateWithICCData(data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `range` must be a valid pointer or null.
    #[doc(alias = "CGColorSpaceCreateICCBased")]
    #[cfg(feature = "CGDataProvider")]
    #[inline]
    pub unsafe fn new_icc_based(
        n_components: usize,
        range: *const CGFloat,
        profile: &CGDataProvider,
        alternate: Option<&CGColorSpace>,
    ) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateICCBased(
                n_components: usize,
                range: *const CGFloat,
                profile: &CGDataProvider,
                alternate: Option<&CGColorSpace>,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateICCBased(n_components, range, profile, alternate) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `color_table` must be a valid pointer.
    #[doc(alias = "CGColorSpaceCreateIndexed")]
    #[inline]
    pub unsafe fn indexed(
        &self,
        last_index: usize,
        color_table: NonNull<c_uchar>,
    ) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateIndexed(
                base_space: &CGColorSpace,
                last_index: usize,
                color_table: NonNull<c_uchar>,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateIndexed(self, last_index, color_table) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCreatePattern")]
    #[inline]
    pub fn new_pattern(base_space: Option<&CGColorSpace>) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreatePattern(
                base_space: Option<&CGColorSpace>,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreatePattern(base_space) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coregraphics/kcgcolorspaceextendedrange?language=objc)
    pub static kCGColorSpaceExtendedRange: &'static CFString;
}

impl CGColorSpace {
    #[doc(alias = "CGColorSpaceCreateWithName")]
    #[inline]
    pub fn with_name(name: &CFString) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateWithName(name: &CFString) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateWithName(name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCopyName")]
    #[inline]
    pub fn name(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGColorSpaceCopyName(space: &CGColorSpace) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGColorSpaceCopyName(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

unsafe impl ConcreteType for CGColorSpace {
    #[doc(alias = "CGColorSpaceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGColorSpaceGetTypeID() -> CFTypeID;
        }
        unsafe { CGColorSpaceGetTypeID() }
    }
}

impl CGColorSpace {
    #[doc(alias = "CGColorSpaceGetNumberOfComponents")]
    #[inline]
    pub fn number_of_components(&self) -> usize {
        extern "C-unwind" {
            fn CGColorSpaceGetNumberOfComponents(space: &CGColorSpace) -> usize;
        }
        unsafe { CGColorSpaceGetNumberOfComponents(self) }
    }

    #[doc(alias = "CGColorSpaceGetModel")]
    #[inline]
    pub fn model(&self) -> CGColorSpaceModel {
        extern "C-unwind" {
            fn CGColorSpaceGetModel(space: &CGColorSpace) -> CGColorSpaceModel;
        }
        unsafe { CGColorSpaceGetModel(self) }
    }

    #[doc(alias = "CGColorSpaceGetBaseColorSpace")]
    #[inline]
    pub fn base_color_space(&self) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceGetBaseColorSpace(space: &CGColorSpace)
                -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceGetBaseColorSpace(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CGColorSpaceCopyBaseColorSpace")]
    #[inline]
    pub fn copy_base_color_space(&self) -> CFRetained<CGColorSpace> {
        extern "C-unwind" {
            fn CGColorSpaceCopyBaseColorSpace(
                space: &CGColorSpace,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCopyBaseColorSpace(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorSpaceGetColorTableCount")]
    #[inline]
    pub fn color_table_count(&self) -> usize {
        extern "C-unwind" {
            fn CGColorSpaceGetColorTableCount(space: &CGColorSpace) -> usize;
        }
        unsafe { CGColorSpaceGetColorTableCount(self) }
    }

    /// # Safety
    ///
    /// `table` must be a valid pointer.
    #[doc(alias = "CGColorSpaceGetColorTable")]
    #[inline]
    pub unsafe fn color_table(&self, table: NonNull<u8>) {
        extern "C-unwind" {
            fn CGColorSpaceGetColorTable(space: &CGColorSpace, table: NonNull<u8>);
        }
        unsafe { CGColorSpaceGetColorTable(self, table) }
    }

    #[doc(alias = "CGColorSpaceCopyICCData")]
    #[inline]
    pub fn icc_data(&self) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CGColorSpaceCopyICCData(space: &CGColorSpace) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CGColorSpaceCopyICCData(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceIsWideGamutRGB")]
    #[inline]
    pub fn is_wide_gamut_rgb(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceIsWideGamutRGB(param1: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceIsWideGamutRGB(self) }
    }

    #[doc(alias = "CGColorSpaceIsHDR")]
    #[inline]
    pub fn is_hdr(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceIsHDR(param1: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceIsHDR(self) }
    }

    #[doc(alias = "CGColorSpaceUsesITUR_2100TF")]
    #[inline]
    pub fn uses_itur_2100_tf(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceUsesITUR_2100TF(param1: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceUsesITUR_2100TF(self) }
    }

    #[doc(alias = "CGColorSpaceIsPQBased")]
    #[inline]
    pub fn is_pq_based(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceIsPQBased(s: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceIsPQBased(self) }
    }

    #[doc(alias = "CGColorSpaceIsHLGBased")]
    #[inline]
    pub fn is_hlg_based(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceIsHLGBased(s: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceIsHLGBased(self) }
    }

    #[doc(alias = "CGColorSpaceSupportsOutput")]
    #[inline]
    pub fn supports_output(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceSupportsOutput(space: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceSupportsOutput(self) }
    }

    #[doc(alias = "CGColorSpaceCopyPropertyList")]
    #[inline]
    pub fn property_list(&self) -> Option<CFRetained<CFPropertyList>> {
        extern "C-unwind" {
            fn CGColorSpaceCopyPropertyList(
                space: &CGColorSpace,
            ) -> Option<NonNull<CFPropertyList>>;
        }
        let ret = unsafe { CGColorSpaceCopyPropertyList(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `plist` should be of the correct type.
    #[doc(alias = "CGColorSpaceCreateWithPropertyList")]
    #[inline]
    pub unsafe fn with_property_list(plist: &CFPropertyList) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateWithPropertyList(
                plist: &CFPropertyList,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateWithPropertyList(plist) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceUsesExtendedRange")]
    #[inline]
    pub fn uses_extended_range(&self) -> bool {
        extern "C-unwind" {
            fn CGColorSpaceUsesExtendedRange(space: &CGColorSpace) -> bool;
        }
        unsafe { CGColorSpaceUsesExtendedRange(self) }
    }

    #[doc(alias = "CGColorSpaceCreateLinearized")]
    #[inline]
    pub fn linearized(&self) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateLinearized(space: &CGColorSpace) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateLinearized(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCreateExtended")]
    #[inline]
    pub fn extended(&self) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateExtended(space: &CGColorSpace) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateExtended(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCreateExtendedLinearized")]
    #[inline]
    pub fn extended_linearized(&self) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateExtendedLinearized(
                space: &CGColorSpace,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateExtendedLinearized(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCreateCopyWithStandardRange")]
    #[inline]
    pub fn copy_with_standard_range(&self) -> CFRetained<CGColorSpace> {
        extern "C-unwind" {
            fn CGColorSpaceCreateCopyWithStandardRange(
                space: &CGColorSpace,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateCopyWithStandardRange(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGColorSpaceCreateWithICCProfile")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn with_icc_profile(data: &CFData) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateWithICCProfile(data: &CFData) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateWithICCProfile(data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGColorSpaceCopyICCProfile")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub fn icc_profile(&self) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CGColorSpaceCopyICCProfile(space: &CGColorSpace) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CGColorSpaceCopyICCProfile(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `ref` must be a valid pointer.
    #[doc(alias = "CGColorSpaceCreateWithPlatformColorSpace")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn with_platform_color_space(
        r#ref: NonNull<c_void>,
    ) -> Option<CFRetained<CGColorSpace>> {
        extern "C-unwind" {
            fn CGColorSpaceCreateWithPlatformColorSpace(
                r#ref: NonNull<c_void>,
            ) -> Option<NonNull<CGColorSpace>>;
        }
        let ret = unsafe { CGColorSpaceCreateWithPlatformColorSpace(r#ref) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}
