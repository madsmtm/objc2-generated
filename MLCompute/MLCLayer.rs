//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The base class for all MLCompute layers
    ///
    /// There are as many MLCLayer subclasses as there are MLCompute neural network layer objects. Make one of those.
    /// This class defines an polymorphic interface for them.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mlcompute/mlclayer?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated]
    pub struct MLCLayer;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MLCLayer {}
);

impl MLCLayer {
    extern_methods!(
        /// The layer ID
        ///
        /// A unique number to identify each layer.  Assigned when the layer is created.
        #[deprecated]
        #[unsafe(method(layerID))]
        #[unsafe(method_family = none)]
        pub unsafe fn layerID(&self) -> NSUInteger;

        /// A string to help identify this object.
        #[deprecated]
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        pub unsafe fn label(&self) -> Retained<NSString>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated]
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLabel(&self, label: &NSString);

        /// A flag to identify if we want to debug this layer when executing a graph that includes this layer
        ///
        /// If this is set, we will make sure that the result tensor and gradient tensors are available for reading on CPU
        /// The default is NO.  If isDebuggingEnabled is set to YES,  make sure to set options to enable debugging when
        /// compiling the graph.  Otherwise this property may be ignored.
        #[deprecated]
        #[unsafe(method(isDebuggingEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isDebuggingEnabled(&self) -> bool;

        /// Setter for [`isDebuggingEnabled`][Self::isDebuggingEnabled].
        #[deprecated]
        #[unsafe(method(setIsDebuggingEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIsDebuggingEnabled(&self, is_debugging_enabled: bool);

        #[cfg(all(feature = "MLCDevice", feature = "MLCTypes"))]
        /// Determine whether instances of this layer accept source tensors of the given data type on the given device.
        ///
        /// Parameter `dataType`: A data type of a possible input tensor to the layer
        ///
        /// Parameter `device`: A device
        ///
        /// Returns: A boolean indicating whether the data type is supported
        #[deprecated]
        #[unsafe(method(supportsDataType:onDevice:))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsDataType_onDevice(data_type: MLCDataType, device: &MLCDevice)
            -> bool;

        #[cfg(feature = "MLCTypes")]
        /// The device type where this layer will be executed
        ///
        /// Typically the MLCDevice passed to compileWithOptions will be the device used to execute layers in the graph.
        /// If MLCDeviceTypeANE is selected, it is possible that some of the layers of the graph may not be executed on the ANE
        /// but instead on the CPU or GPU.  This property can be used to determine which device type the layer will be executed on.
        #[unsafe(method(deviceType))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceType(&self) -> MLCDeviceType;

        #[deprecated]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[deprecated]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}
