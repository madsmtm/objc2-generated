//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
use objc2_app_kit::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// A property to observe to determine when the title or subtitle information of an annotation object changes.
    ///
    /// ## Discussion
    ///
    /// This notification supports legacy applications and is no longer necessary. MapKit tracks changes to the title and subtitle of an annotation using KVO notifications.
    ///
    ///
    pub static MKAnnotationCalloutInfoDidChangeNotification: &'static NSString;
}

/// Constants that indicate the drag state of an annotation view.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MKAnnotationViewDragState(pub NSUInteger);
impl MKAnnotationViewDragState {
    /// An annotation view that doesn’t have a drag operation.
    ///
    /// ## Discussion
    ///
    /// The view isn’t involved in a drag operation. The annotation view is responsible for returning itself to this state when a drag ends or cancels.
    ///
    ///
    #[doc(alias = "MKAnnotationViewDragStateNone")]
    pub const None: Self = Self(0);
    /// An annotation view begins dragging.
    ///
    /// ## Discussion
    ///
    /// A user action causes the view to begin the drag operation. The map view automatically moves annotation views to this state in response to appropriate user actions.
    ///
    ///
    #[doc(alias = "MKAnnotationViewDragStateStarting")]
    pub const Starting: Self = Self(1);
    /// An annotation view is actively dragging.
    ///
    /// ## Discussion
    ///
    /// The view is in the middle of a drag operation and is tracking progress.
    ///
    ///
    #[doc(alias = "MKAnnotationViewDragStateDragging")]
    pub const Dragging: Self = Self(2);
    /// An annotation view cancels drag operation.
    ///
    /// ## Discussion
    ///
    /// A user action causes the view to cancel the drag operation. You can put an annotation view into this state to abort the operation.
    ///
    ///
    #[doc(alias = "MKAnnotationViewDragStateCanceling")]
    pub const Canceling: Self = Self(3);
    /// An annotation view ends dragging.
    ///
    /// ## Discussion
    ///
    /// A user action indicates the user dropped the view. The map view automatically moves annotation views to this state in response to appropriate user actions.
    ///
    ///
    #[doc(alias = "MKAnnotationViewDragStateEnding")]
    pub const Ending: Self = Self(4);
}

unsafe impl Encode for MKAnnotationViewDragState {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MKAnnotationViewDragState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicates the display priority for annotations.
// NS_TYPED_EXTENSIBLE_ENUM
pub type MKFeatureDisplayPriority = c_float;

/// A constant indicating that the item is required.
///
/// ## Discussion
///
/// An annotation view with this priority does not participate in clustering.
///
///
pub static MKFeatureDisplayPriorityRequired: MKFeatureDisplayPriority = 1000 as _;

/// A constant indicating that the item’s display priority is high.
///
/// ## Discussion
///
/// An annotation view with this priority is removed from the map when its bounds collide with the bounds of another view with a higher priority. If the priorities of the two views are equal, the view furthest from the center of the map’s visible region is hidden first.
///
///
pub static MKFeatureDisplayPriorityDefaultHigh: MKFeatureDisplayPriority = 750 as _;

/// A constant indicating that the item’s display priority is low.
///
/// ## Discussion
///
/// An annotation view with this priority is removed from the map when its bounds collide with the bounds of another view with a higher priority. If the priorities of the two views are equal, the view furthest from the center of the map’s visible region is hidden first.
///
///
pub static MKFeatureDisplayPriorityDefaultLow: MKFeatureDisplayPriority = 250 as _;

/// Constants that indicates the priority for ordering overlapping annotation views.
// NS_TYPED_EXTENSIBLE_ENUM
pub type MKAnnotationViewZPriority = c_float;

/// The maximum allowed priority for overlapping views.
pub static MKAnnotationViewZPriorityMax: MKAnnotationViewZPriority = 1000 as _;

/// The default view overlapping priority for a selected view.
pub static MKAnnotationViewZPriorityDefaultSelected: MKAnnotationViewZPriority = 1000 as _;

/// The default view overlapping priority for an unselected view.
pub static MKAnnotationViewZPriorityDefaultUnselected: MKAnnotationViewZPriority = 500 as _;

/// The minimum allowed priority for overlapping views.
pub static MKAnnotationViewZPriorityMin: MKAnnotationViewZPriority = 0 as _;

/// Constants that indicates how to interpret the collision frame rectangle of an annotation view.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MKAnnotationViewCollisionMode(pub NSInteger);
impl MKAnnotationViewCollisionMode {
    /// A constant that indicates that the annotation view uses the full collision frame rectangle for detecting collisions.
    #[doc(alias = "MKAnnotationViewCollisionModeRectangle")]
    pub const Rectangle: Self = Self(0);
    /// A constant that indicates that the annotation view uses an inscribed circle in the collision frame rectangle to determine collisions.
    #[doc(alias = "MKAnnotationViewCollisionModeCircle")]
    pub const Circle: Self = Self(1);
    /// A constant indicating that collisions can’t occur.
    #[doc(alias = "MKAnnotationViewCollisionModeNone")]
    pub const None: Self = Self(2);
}

unsafe impl Encode for MKAnnotationViewCollisionMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MKAnnotationViewCollisionMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The visual representation of one of your annotation objects.
    ///
    /// ## Overview
    ///
    /// _Annotation views_ are loosely coupled to a corresponding _annotation object_, which is an object that conforms to the [`MKAnnotation`](https://developer.apple.com/documentation/mapkit/mkannotation) protocol. When an annotation’s coordinate point is in the map’s visible region, the map view asks its delegate to provide a corresponding annotation view. MapKit may recycle annotation views and put them into a reuse queue that the map view maintains.
    ///
    /// The most efficient way to provide the content for an annotation view is to set its [`image`](https://developer.apple.com/documentation/mapkit/mkannotationview/image) property. The annotation view sizes itself automatically to the image you specify and draws that image for its contents. Because it’s a view, you can also override the [`drawRect:`](https://developer.apple.com/documentation/uikit/uiview/draw(_:)) method and draw your view’s content manually. If you choose to override [`drawRect:`](https://developer.apple.com/documentation/uikit/uiview/draw(_:)) directly and you don’t specify a custom image in the [`image`](https://developer.apple.com/documentation/mapkit/mkannotationview/image) property, the annotation view sets the width and height of the annotation view’s frame to `0` by default. Before the framework can draw your custom content, you need to set the width and height to nonzero values by modifying the view’s [`frame`](https://developer.apple.com/documentation/uikit/uiview/frame) property. In general, if your content consists entirely of static images, it’s more efficient to set the [`image`](https://developer.apple.com/documentation/mapkit/mkannotationview/image) property and change it as necessary than to draw the images yourself.
    ///
    /// Annotation views anchor to the map at the point that their associated annotation object specifies. Although they scroll with the map contents, annotation views reside in a separate display layer and don’t scale when the size of the visible map region changes.
    ///
    /// Additionally, annotation views support the concept of a _selection state_, which determines whether the map displays the annotation view as unselected, selected, or selected and displaying a standard callout view. The user toggles between the selection states through interactions with the annotation view. In the unselected state, the map displays the annotation view, but doesn’t highlight it. In the selected state, the framework highlights the annotation, but doesn’t display the callout. Finally, the map view can display the annotation with both a highlight and a callout. The callout view displays additional information, such as a title string and controls for viewing more information. The annotation object provides the title information, but your annotation view is responsible for providing any custom controls. For more information, see the [Subclassing notes](https://developer.apple.com/documentation/mapkit/mkannotationview#subclassing-notes) section below.
    ///
    /// ### Reuse annotation views
    ///
    /// The design of annotation views enables their reuse as the user (or your app) changes the visible map region. The reuse of annotation views provides significant performance improvements during scrolling by avoiding the creation of new view objects during this time-critical operation. For this reason, don’t tightly couple annotation views to the contents of their associated annotation. Instead, use the properties of an annotation view (or setter methods) to configure the view for a new annotation object.
    ///
    /// Whenever you initialize a new annotation view, specify a reuse identifier for that view. When the framework no longer needs annotation views, the map view may put them into a reuse queue. As the framework adds new annotations to the map view, the delegate object can then dequeue and reconfigure an existing view (rather than create a new one) using the [`dequeueReusableAnnotationViewWithIdentifier:`](https://developer.apple.com/documentation/mapkit/mkmapview/dequeuereusableannotationview(withidentifier:)) method of [`MKMapView`](https://developer.apple.com/documentation/mapkit/mkmapview).
    ///
    /// ### Subclassing notes
    ///
    /// You can use the `MKAnnotationView` class as-is or subclass it to provide custom behavior as necessary. The [`image`](https://developer.apple.com/documentation/mapkit/mkannotationview/image) property of the class lets you set the appearance of the annotation view without subclassing directly. You might also create custom subclasses as a convenience and use them to put the annotation view in a known state.
    ///
    /// There are no special requirements for subclassing `MKAnnotationView`. However, the following list includes some reasons you might want to subclass, and the methods to override to implement the desired behavior:
    ///
    /// - To put the annotation view into a consistent state, provide a custom initialization method. Your custom initialization method then calls [`initWithAnnotation:reuseIdentifier:`](https://developer.apple.com/documentation/mapkit/mkannotationview/init(annotation:reuseidentifier:)) to initialize the superclass.
    ///
    /// - To provide custom callout views, override the [`leftCalloutAccessoryView`](https://developer.apple.com/documentation/mapkit/mkannotationview/leftcalloutaccessoryview) method and use it to return the views.
    ///
    /// If you support draggable annotation views in iOS, your subclass is responsible for changing the value in the [`dragState`](https://developer.apple.com/documentation/mapkit/mkannotationview/dragstate-swift.property) property to appropriate values at key transition points in the drag operation. For more information, see the description of that property.
    ///
    ///
    #[unsafe(super(NSView, NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2-app-kit")]
    #[cfg(target_os = "macos")]
    pub struct MKAnnotationView;
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSAccessibility for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSAnimatablePropertyContainer for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSAppearanceCustomization for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSCoding for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSDraggingDestination for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for MKAnnotationView {}
);

#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
impl MKAnnotationView {
    extern_methods!(
        #[cfg(feature = "MKAnnotation")]
        #[unsafe(method(initWithAnnotation:reuseIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAnnotation_reuseIdentifier(
            this: Allocated<Self>,
            annotation: Option<&ProtocolObject<dyn MKAnnotation>>,
            reuse_identifier: Option<&NSString>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(reuseIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn reuseIdentifier(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(prepareForReuse))]
        #[unsafe(method_family = none)]
        pub unsafe fn prepareForReuse(&self);

        #[unsafe(method(prepareForDisplay))]
        #[unsafe(method_family = none)]
        pub unsafe fn prepareForDisplay(&self);

        #[cfg(feature = "MKAnnotation")]
        #[unsafe(method(annotation))]
        #[unsafe(method_family = none)]
        pub unsafe fn annotation(&self) -> Option<Retained<ProtocolObject<dyn MKAnnotation>>>;

        #[cfg(feature = "MKAnnotation")]
        /// Setter for [`annotation`][Self::annotation].
        #[unsafe(method(setAnnotation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnnotation(&self, annotation: Option<&ProtocolObject<dyn MKAnnotation>>);

        #[unsafe(method(image))]
        #[unsafe(method_family = none)]
        pub unsafe fn image(&self) -> Option<Retained<NSImage>>;

        /// Setter for [`image`][Self::image].
        #[unsafe(method(setImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setImage(&self, image: Option<&NSImage>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(centerOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn centerOffset(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`centerOffset`][Self::centerOffset].
        #[unsafe(method(setCenterOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCenterOffset(&self, center_offset: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(accessoryOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn accessoryOffset(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`accessoryOffset`][Self::accessoryOffset].
        #[unsafe(method(setAccessoryOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAccessoryOffset(&self, accessory_offset: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(calloutOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn calloutOffset(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`calloutOffset`][Self::calloutOffset].
        #[unsafe(method(setCalloutOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCalloutOffset(&self, callout_offset: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(leftCalloutOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftCalloutOffset(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`leftCalloutOffset`][Self::leftCalloutOffset].
        #[unsafe(method(setLeftCalloutOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLeftCalloutOffset(&self, left_callout_offset: CGPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(rightCalloutOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightCalloutOffset(&self) -> CGPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`rightCalloutOffset`][Self::rightCalloutOffset].
        #[unsafe(method(setRightCalloutOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRightCalloutOffset(&self, right_callout_offset: CGPoint);

        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        #[unsafe(method(isHighlighted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isHighlighted(&self) -> bool;

        /// Setter for [`isHighlighted`][Self::isHighlighted].
        #[unsafe(method(setHighlighted:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHighlighted(&self, highlighted: bool);

        #[unsafe(method(isSelected))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSelected(&self) -> bool;

        /// Setter for [`isSelected`][Self::isSelected].
        #[unsafe(method(setSelected:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSelected(&self, selected: bool);

        #[unsafe(method(setSelected:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSelected_animated(&self, selected: bool, animated: bool);

        #[unsafe(method(canShowCallout))]
        #[unsafe(method_family = none)]
        pub unsafe fn canShowCallout(&self) -> bool;

        /// Setter for [`canShowCallout`][Self::canShowCallout].
        #[unsafe(method(setCanShowCallout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCanShowCallout(&self, can_show_callout: bool);

        #[unsafe(method(leftCalloutAccessoryView))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftCalloutAccessoryView(&self) -> Option<Retained<NSView>>;

        /// Setter for [`leftCalloutAccessoryView`][Self::leftCalloutAccessoryView].
        #[unsafe(method(setLeftCalloutAccessoryView:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLeftCalloutAccessoryView(
            &self,
            left_callout_accessory_view: Option<&NSView>,
        );

        #[unsafe(method(rightCalloutAccessoryView))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightCalloutAccessoryView(&self) -> Option<Retained<NSView>>;

        /// Setter for [`rightCalloutAccessoryView`][Self::rightCalloutAccessoryView].
        #[unsafe(method(setRightCalloutAccessoryView:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRightCalloutAccessoryView(
            &self,
            right_callout_accessory_view: Option<&NSView>,
        );

        #[unsafe(method(detailCalloutAccessoryView))]
        #[unsafe(method_family = none)]
        pub unsafe fn detailCalloutAccessoryView(&self) -> Option<Retained<NSView>>;

        /// Setter for [`detailCalloutAccessoryView`][Self::detailCalloutAccessoryView].
        #[unsafe(method(setDetailCalloutAccessoryView:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDetailCalloutAccessoryView(
            &self,
            detail_callout_accessory_view: Option<&NSView>,
        );

        #[unsafe(method(isDraggable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isDraggable(&self) -> bool;

        /// Setter for [`isDraggable`][Self::isDraggable].
        #[unsafe(method(setDraggable:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDraggable(&self, draggable: bool);

        #[unsafe(method(dragState))]
        #[unsafe(method_family = none)]
        pub unsafe fn dragState(&self) -> MKAnnotationViewDragState;

        /// Setter for [`dragState`][Self::dragState].
        #[unsafe(method(setDragState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDragState(&self, drag_state: MKAnnotationViewDragState);

        #[unsafe(method(setDragState:animated:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDragState_animated(
            &self,
            new_drag_state: MKAnnotationViewDragState,
            animated: bool,
        );

        #[unsafe(method(clusteringIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn clusteringIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`clusteringIdentifier`][Self::clusteringIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setClusteringIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClusteringIdentifier(&self, clustering_identifier: Option<&NSString>);

        #[unsafe(method(clusterAnnotationView))]
        #[unsafe(method_family = none)]
        pub unsafe fn clusterAnnotationView(&self) -> Option<Retained<MKAnnotationView>>;

        #[unsafe(method(displayPriority))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayPriority(&self) -> MKFeatureDisplayPriority;

        /// Setter for [`displayPriority`][Self::displayPriority].
        #[unsafe(method(setDisplayPriority:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisplayPriority(&self, display_priority: MKFeatureDisplayPriority);

        #[unsafe(method(zPriority))]
        #[unsafe(method_family = none)]
        pub unsafe fn zPriority(&self) -> MKAnnotationViewZPriority;

        /// Setter for [`zPriority`][Self::zPriority].
        #[unsafe(method(setZPriority:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZPriority(&self, z_priority: MKAnnotationViewZPriority);

        #[unsafe(method(selectedZPriority))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectedZPriority(&self) -> MKAnnotationViewZPriority;

        /// Setter for [`selectedZPriority`][Self::selectedZPriority].
        #[unsafe(method(setSelectedZPriority:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSelectedZPriority(&self, selected_z_priority: MKAnnotationViewZPriority);

        #[unsafe(method(collisionMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn collisionMode(&self) -> MKAnnotationViewCollisionMode;

        /// Setter for [`collisionMode`][Self::collisionMode].
        #[unsafe(method(setCollisionMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCollisionMode(&self, collision_mode: MKAnnotationViewCollisionMode);
    );
}

/// Methods declared on superclass `NSView`.
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
impl MKAnnotationView {
    extern_methods!(
        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFrame(this: Allocated<Self>, frame_rect: NSRect) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
impl MKAnnotationView {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
impl MKAnnotationView {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
