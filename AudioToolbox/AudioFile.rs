//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// An album.
pub const kAFInfoDictionary_Album: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"album\0") };
/// An approximate duration in seconds.
pub const kAFInfoDictionary_ApproximateDurationInSeconds: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"approximate duration in seconds\0") };
/// An artist.
pub const kAFInfoDictionary_Artist: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"artist\0") };
/// A channel layout.
pub const kAFInfoDictionary_ChannelLayout: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"channel layout\0") };
/// Comments.
pub const kAFInfoDictionary_Comments: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"comments\0") };
/// A composer.
pub const kAFInfoDictionary_Composer: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"composer\0") };
/// Copyright.
pub const kAFInfoDictionary_Copyright: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"copyright\0") };
/// An encoding application.
pub const kAFInfoDictionary_EncodingApplication: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"encoding application\0") };
/// A genre.
pub const kAFInfoDictionary_Genre: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"genre\0") };
/// An International Standard Recording Code.
pub const kAFInfoDictionary_ISRC: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"ISRC\0") };
/// A key signature.
pub const kAFInfoDictionary_KeySignature: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"key signature\0") };
/// A lyricist.
pub const kAFInfoDictionary_Lyricist: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"lyricist\0") };
/// A nominal bit rate.
pub const kAFInfoDictionary_NominalBitRate: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"nominal bit rate\0") };
/// A recorded date.
pub const kAFInfoDictionary_RecordedDate: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"recorded date\0") };
/// The bit depth of the source audio stream.
///
/// ## Discussion
///
/// See [`kAudioFilePropertySourceBitDepth`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertysourcebitdepth).
///
///
pub const kAFInfoDictionary_SourceBitDepth: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"source bit depth\0") };
/// A source encoder.
pub const kAFInfoDictionary_SourceEncoder: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"source encoder\0") };
/// A subtitle.
pub const kAFInfoDictionary_SubTitle: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"subtitle\0") };
/// A tempo.
pub const kAFInfoDictionary_Tempo: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"tempo\0") };
/// A time signature.
pub const kAFInfoDictionary_TimeSignature: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"time signature\0") };
/// A title.
pub const kAFInfoDictionary_Title: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"title\0") };
/// A track number.
pub const kAFInfoDictionary_TrackNumber: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"track number\0") };
/// A year.
pub const kAFInfoDictionary_Year: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"year\0") };
/// Operating system constants that indicate the type of file to be written or a hint about what type of file to expect from data provided.
/// Identifier for an audio file type.
pub type AudioFileTypeID = u32;

/// An Audio Interchange File Format (AIFF) file.
pub const kAudioFileAIFFType: AudioFileTypeID = 0x41494646;
/// An Audio Interchange File Format Compressed (AIFF-C) file.
pub const kAudioFileAIFCType: AudioFileTypeID = 0x41494643;
/// A Microsoft WAVE file.
pub const kAudioFileWAVEType: AudioFileTypeID = 0x57415645;
pub const kAudioFileRF64Type: AudioFileTypeID = 0x52463634;
pub const kAudioFileBW64Type: AudioFileTypeID = 0x42573634;
pub const kAudioFileWave64Type: AudioFileTypeID = 0x57363466;
/// A Sound Designer II file.
pub const kAudioFileSoundDesigner2Type: AudioFileTypeID = 0x53643266;
/// A NeXT or Sun Microsystems file.
pub const kAudioFileNextType: AudioFileTypeID = 0x4e655854;
/// An MPEG Audio Layer 3 (`.mp3`) file.
pub const kAudioFileMP3Type: AudioFileTypeID = 0x4d504733;
/// An MPEG Audio Layer 2 (`.mp2`) file.
pub const kAudioFileMP2Type: AudioFileTypeID = 0x4d504732;
/// An MPEG Audio Layer 1 (`.mp1`) file.
pub const kAudioFileMP1Type: AudioFileTypeID = 0x4d504731;
/// An AC-3 file.
pub const kAudioFileAC3Type: AudioFileTypeID = 0x61632d33;
/// An Advanced Audio Coding (AAC) Audio Data Transport Stream (ADTS) file.
pub const kAudioFileAAC_ADTSType: AudioFileTypeID = 0x61647473;
/// An MPEG 4 file.
pub const kAudioFileMPEG4Type: AudioFileTypeID = 0x6d703466;
/// An M4A file.
pub const kAudioFileM4AType: AudioFileTypeID = 0x6d346166;
pub const kAudioFileM4BType: AudioFileTypeID = 0x6d346266;
/// A Core Audio File Format file.
pub const kAudioFileCAFType: AudioFileTypeID = 0x63616666;
/// A 3GPP file, suitable for video content on GSM mobile phones.
pub const kAudioFile3GPType: AudioFileTypeID = 0x33677070;
/// A 3GPP2 file, suitable for video content on CDMA mobile phones.
pub const kAudioFile3GP2Type: AudioFileTypeID = 0x33677032;
/// An AMR (Adaptive Multi-Rate) file suitable for compressed speech.
pub const kAudioFileAMRType: AudioFileTypeID = 0x616d7266;
pub const kAudioFileFLACType: AudioFileTypeID = 0x666c6163;
pub const kAudioFileLATMInLOASType: AudioFileTypeID = 0x6c6f6173;

/// An unspecified error has occurred.
pub const kAudioFileUnspecifiedError: OSStatus = 0x7768743f;
/// The file type is not supported.
pub const kAudioFileUnsupportedFileTypeError: OSStatus = 0x7479703f;
/// The data format is not supported by this file type.
pub const kAudioFileUnsupportedDataFormatError: OSStatus = 0x666d743f;
/// The property is not supported.
pub const kAudioFileUnsupportedPropertyError: OSStatus = 0x7074793f;
/// The size of the property data was not correct.
pub const kAudioFileBadPropertySizeError: OSStatus = 0x2173697a;
/// The operation violated the file permissions. For example, an attempt was made to write to a file opened with the `kAudioFileReadPermission` constant.
pub const kAudioFilePermissionsError: OSStatus = 0x70726d3f;
/// The chunks following the audio data chunk are preventing the extension of the audio data chunk. To write more data, you must optimize the file.
pub const kAudioFileNotOptimizedError: OSStatus = 0x6f70746d;
/// Either the chunk does not exist in the file or it is not supported by the file.
pub const kAudioFileInvalidChunkError: OSStatus = 0x63686b3f;
/// The file offset was too large for the file type. The AIFF and WAVE file format types have 32-bit file size limits.
pub const kAudioFileDoesNotAllow64BitDataSizeError: OSStatus = 0x6f66663f;
/// A packet offset was past the end of the file, or not at the end of the file when a VBR format was written,  or a corrupt packet size was read when the packet table was built.
pub const kAudioFileInvalidPacketOffsetError: OSStatus = 0x70636b3f;
pub const kAudioFileInvalidPacketDependencyError: OSStatus = 0x6465703f;
/// The file is malformed, or otherwise not a valid instance of an audio file of its type.
pub const kAudioFileInvalidFileError: OSStatus = 0x6474613f;
/// The operation cannot be performed.
///
/// ## Discussion
///
/// For example, setting the [`kAudioFilePropertyAudioDataByteCount`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertyaudiodatabytecount) constant to increase the size of the audio data in a file is not a supported operation. Write the data instead.
///
///
pub const kAudioFileOperationNotSupportedError: OSStatus = 0x6F703F3F;
/// The file is closed.
pub const kAudioFileNotOpenError: OSStatus = -38;
/// End of file.
pub const kAudioFileEndOfFileError: OSStatus = -39;
/// Invalid file position.
pub const kAudioFilePositionError: OSStatus = -40;
/// File not found.
pub const kAudioFileFileNotFoundError: OSStatus = -43;

/// These are flags that can be used with the CreateURL API call
///
/// If set, then the CreateURL call will erase the contents of an existing file
/// If not set, then the CreateURL call will fail if the file already exists
///
/// Normally, newly created and optimized files will have padding added in order to page align
/// the data to 4KB boundaries. This makes reading the data more efficient.
/// When disk space is a concern, this flag can be set so that the padding will not be added.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioFileFlags(pub u32);
bitflags::bitflags! {
    impl AudioFileFlags: u32 {
///
/// ## Discussion
///
/// If set, the [`AudioFileCreateWithURL`](https://developer.apple.com/documentation/audiotoolbox/audiofilecreatewithurl(_:_:_:_:_:)) function erases the contents of an existing file. If not set, then the function fails if the file already exists.
///
///
        #[doc(alias = "kAudioFileFlags_EraseFile")]
        const EraseFile = 1;
/// Typically, the audio data in a file is page aligned. To make reading the file data as fast as possible, you can use page-aligned data to take advantage of optimized code paths in the file system. However, when space is at a premium, you might want to avoid the additional padding required to attain alignment. To do so, set this flag when calling [`AudioFileCreate`](https://developer.apple.com/documentation/audiotoolbox/audiofilecreate) or [`AudioFileCreateWithURL`](https://developer.apple.com/documentation/audiotoolbox/audiofilecreatewithurl(_:_:_:_:_:)).
        #[doc(alias = "kAudioFileFlags_DontPageAlignAudioData")]
        const DontPageAlignAudioData = 2;
    }
}

unsafe impl Encode for AudioFileFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioFileFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for use when opening an audio file.
///
/// ## Overview
///
/// Use these flags with the [`AudioFileOpenURL`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenurl(_:_:_:_:)) and [`AudioFileOpen`](https://developer.apple.com/documentation/audiotoolbox/audiofileopen) functions.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AudioFilePermissions(pub i8);
impl AudioFilePermissions {
    /// File is read-only.
    #[doc(alias = "kAudioFileReadPermission")]
    pub const ReadPermission: Self = Self(0x01);
    /// File is write-only.
    #[doc(alias = "kAudioFileWritePermission")]
    pub const WritePermission: Self = Self(0x02);
    /// File has read-write permission.
    #[doc(alias = "kAudioFileReadWritePermission")]
    pub const ReadWritePermission: Self = Self(0x03);
}

unsafe impl Encode for AudioFilePermissions {
    const ENCODING: Encoding = i8::ENCODING;
}

unsafe impl RefEncode for AudioFilePermissions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueAudioFileID {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaqueAudioFileID {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("OpaqueAudioFileID", &[]));
}

/// An opaque data type that represents an audio file object.
/// An opaque reference to an AudioFile object.
pub type AudioFileID = *mut OpaqueAudioFileID;

/// An audio file property identifier.
///
/// ## Discussion
///
/// For a list of audio file properties, see [Audio File Properties](https://developer.apple.com/documentation/audiotoolbox/1576499-audio-file-properties).
///
///
/// A constant for an AudioFile property.
pub type AudioFilePropertyID = u32;

/// The segment is not looped.
pub const kAudioFileLoopDirection_NoLooping: u32 = 0;
/// Play the segment forward.
pub const kAudioFileLoopDirection_Forward: u32 = 1;
/// Play the segment forward and backward.
pub const kAudioFileLoopDirection_ForwardAndBackward: u32 = 2;
/// Play the segment backward.
pub const kAudioFileLoopDirection_Backward: u32 = 3;

/// A data structure for describing SMPTE (Society of Motion Picture and Television Engineers) time.
/// A struct for describing a SMPTE time.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioFile_SMPTE_Time {
    pub mHours: i8,
    pub mMinutes: u8,
    pub mSeconds: u8,
    pub mFrames: u8,
    pub mSubFrameSampleOffset: u32,
}

unsafe impl Encode for AudioFile_SMPTE_Time {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFile_SMPTE_Time",
        &[
            <i8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AudioFile_SMPTE_Time {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A generic marker.
pub const kAudioFileMarkerType_Generic: u32 = 0;

/// Annotates a position in an audio file.
/// A marker annotates a position in an audio file with additional information.
///
/// (description)
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioFileMarker {
    pub mFramePosition: f64,
    pub mName: *const CFString,
    pub mMarkerID: i32,
    pub mSMPTETime: AudioFile_SMPTE_Time,
    pub mType: u32,
    pub mReserved: u16,
    pub mChannel: u16,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AudioFileMarker {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFileMarker",
        &[
            <f64>::ENCODING,
            <*const CFString>::ENCODING,
            <i32>::ENCODING,
            <AudioFile_SMPTE_Time>::ENCODING,
            <u32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AudioFileMarker {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A list of markers associated with an audio file, including their SMPTE time type, the number of markers, and the markers themselves.
/// A list of AudioFileMarker.
///
/// This defines the SMPTE timing scheme used in the marker list. See CAFFile.h for the values used here.
///
/// The number of markers in the mMarkers list.
///
/// A list of AudioFileMarker.
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioFileMarkerList {
    pub mSMPTE_TimeType: u32,
    pub mNumberMarkers: u32,
    pub mMarkers: [AudioFileMarker; 1],
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AudioFileMarkerList {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFileMarkerList",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[AudioFileMarker; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AudioFileMarkerList {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// TODO: pub fn NumBytesToNumAudioFileMarkers(in_num_bytes: usize,) -> usize;

// TODO: pub fn NumAudioFileMarkersToNumBytes(in_num_markers: usize,) -> usize;

/// Flags that specify a playback direction for an audio file region structure.
///
/// ## Overview
///
/// You can set one or more of these flags. For example, if both `kAudioFileRegionFlag_LoopEnable` and `kAudioFileRegionFlag_PlayForward` are set, the region plays as a forward loop. If only  `kAudioFileRegionFlag_PlayForward` is set, the region is played forward once. if both `kAudioFileRegionFlag_PlayForward` and `kAudioFileRegionFlag_PlayBackward` are set, the region plays forward then backward, then forward.
///
///
/// These are flags for an AudioFileRegion that specify a playback direction.
///
/// One or multiple of these flags can be set. For example, if both kAudioFileRegionFlag_LoopEnable and
/// kAudioFileRegionFlag_PlayForward are set, then the region will play as a forward loop. If only
/// kAudioFileRegionFlag_PlayForward is set, then the region will be played forward once.
///
/// If this flag is set, the region will be looped. One or both of the following must also be set.
///
/// If this flag is set, the region will be played forward.
///
/// If this flag is set, the region will be played backward.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioFileRegionFlags(pub u32);
bitflags::bitflags! {
    impl AudioFileRegionFlags: u32 {
/// If set, the region is looped. You must set one or both of the remaining flags must also be set for the region to be looped.
        #[doc(alias = "kAudioFileRegionFlag_LoopEnable")]
        const LoopEnable = 1;
/// If set, the region is played forward.
        #[doc(alias = "kAudioFileRegionFlag_PlayForward")]
        const PlayForward = 2;
/// If set, the region is played backward.
        #[doc(alias = "kAudioFileRegionFlag_PlayBackward")]
        const PlayBackward = 4;
    }
}

unsafe impl Encode for AudioFileRegionFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioFileRegionFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An audio file region specifies a segment of audio data.
///
/// ## Overview
///
/// Typically, a region consists of at least two markers designating the beginning and end of the segment. Other markers might define additional meta information such as sync point.
///
///
/// An AudioFileRegion specifies a segment of audio data.
///
/// Generally a region consists of at least two markers marking the beginning and end of the segment.
/// There may also be other markers defining other meta information such as sync point.
///
/// each region must have a unique ID.
///
/// The name of the region.
///
/// AudioFileRegionFlags.
///
/// The number of markers in the mMarkers array.
///
/// A variable length array of AudioFileMarkers.
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioFileRegion {
    pub mRegionID: u32,
    pub mName: NonNull<CFString>,
    pub mFlags: AudioFileRegionFlags,
    pub mNumberMarkers: u32,
    pub mMarkers: [AudioFileMarker; 1],
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AudioFileRegion {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFileRegion",
        &[
            <u32>::ENCODING,
            <NonNull<CFString>>::ENCODING,
            <AudioFileRegionFlags>::ENCODING,
            <u32>::ENCODING,
            <[AudioFileMarker; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AudioFileRegion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A list of the audio file regions in a file.
///
/// ## Overview
///
/// This structure is used by the [`kAudioFilePropertyRegionList`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertyregionlist) property.
///
///
/// A list of the AudioFileRegions in a file.
///
/// This is the struct used by the kAudioFilePropertyRegionList property.
///
/// This defines the SMPTE timing scheme used in the file. See CAFFile.h for the values used here.
///
/// The number of regions in the mRegions list.
///
/// A list of AudioFileRegions. Note that AudioFileMarkers are variable length, so this list cannot
/// be accessed as an array. Use the NextAudioFileRegion macro for traversing the list instead.
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioFileRegionList {
    pub mSMPTE_TimeType: u32,
    pub mNumberRegions: u32,
    pub mRegions: [AudioFileRegion; 1],
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AudioFileRegionList {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFileRegionList",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[AudioFileRegion; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AudioFileRegionList {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// TODO: pub fn NextAudioFileRegion(in_af_region_ptr: NonNull<AudioFileRegion>,)-> Option<NonNull<AudioFileRegion>>;

/// A structure that specifies frame and packet translations.
///
/// ## Overview
///
/// A data structure used by the [`kAudioFilePropertyPacketToFrame`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertypackettoframe) and [`kAudioFilePropertyFrameToPacket`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertyframetopacket) properties.
///
///
/// used for properties kAudioFilePropertyPacketToFrame and kAudioFilePropertyFrameToPacket
///
/// See description of kAudioFilePropertyPacketToFrame and kAudioFilePropertyFrameToPacket
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioFramePacketTranslation {
    pub mFrame: i64,
    pub mPacket: i64,
    pub mFrameOffsetInPacket: u32,
}

unsafe impl Encode for AudioFramePacketTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFramePacketTranslation",
        &[<i64>::ENCODING, <i64>::ENCODING, <u32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioFramePacketTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// flags for the AudioBytePacketTranslation mFlags field
///
/// There is currently only one flag.
///
///
/// If the set then the result value is an estimate.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioBytePacketTranslationFlags(pub u32);
bitflags::bitflags! {
    impl AudioBytePacketTranslationFlags: u32 {
/// If set, the result value is an estimate.
        #[doc(alias = "kBytePacketTranslationFlag_IsEstimate")]
        const BytePacketTranslationFlag_IsEstimate = 1;
    }
}

unsafe impl Encode for AudioBytePacketTranslationFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioBytePacketTranslationFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A data structure used by the [`kAudioFilePropertyByteToPacket`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertybytetopacket) and [`kAudioFilePropertyPacketToByte`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertypackettobyte) properties.
/// used for properties kAudioFileByteToPacket and kAudioFilePacketToByte
///
/// See description of kAudioFileByteToPacket and kAudioFilePacketToByte
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioBytePacketTranslation {
    pub mByte: i64,
    pub mPacket: i64,
    pub mByteOffsetInPacket: u32,
    pub mFlags: AudioBytePacketTranslationFlags,
}

unsafe impl Encode for AudioBytePacketTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioBytePacketTranslation",
        &[
            <i64>::ENCODING,
            <i64>::ENCODING,
            <u32>::ENCODING,
            <AudioBytePacketTranslationFlags>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AudioBytePacketTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Contains information about the number of valid frames in a file and where they begin and end.
///
/// ## Overview
///
/// Some data formats might have packets with contents that are not completely valid, but that represent priming or remainder frames not intended for playback. For example, a file with 100 packets of AAC is nominally 1024 * 100 = 102400 frames of data. However, the first 2112 frames might be priming frames.
///
/// A number of remainder frames might be added to pad out to a full packet of 1024 frames. Discard the priming and remainder frames.
///
/// The total number of packets in the file times the frames per packet (or counting each packet’s frames individually for a variable frames per packet format) minus `mPrimingFrames`, minus `mRemainderFrames`, should equal `mNumberValidFrames`.
///
///
/// This contains information about the number of valid frames in a file and where they begin and end.
///
/// Some data formats may have packets whose contents are not completely valid, but represent priming or remainder
/// frames that are not meant to be played. For example a file with 100 packets of AAC is nominally 1024 * 100 = 102400 frames
/// of data. However the first 2112 frames of that may be priming frames and there may be some
/// number of remainder frames added to pad out to a full packet of 1024 frames. The priming and remainder frames should be
/// discarded. The total number of packets in the file times the frames per packet (or counting each packet's frames
/// individually for a variable frames per packet format) minus mPrimingFrames, minus mRemainderFrames, should
/// equal mNumberValidFrames.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioFilePacketTableInfo {
    pub mNumberValidFrames: i64,
    pub mPrimingFrames: i32,
    pub mRemainderFrames: i32,
}

unsafe impl Encode for AudioFilePacketTableInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFilePacketTableInfo",
        &[<i64>::ENCODING, <i32>::ENCODING, <i32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioFilePacketTableInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// used for property kAudioFilePropertyPacketRangeByteCountUpperBound
///
/// See description of kAudioFilePropertyPacketRangeByteCountUpperBound
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioPacketRangeByteCountTranslation {
    pub mPacket: i64,
    pub mPacketCount: i64,
    pub mByteCountUpperBound: i64,
}

unsafe impl Encode for AudioPacketRangeByteCountTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioPacketRangeByteCountTranslation",
        &[<i64>::ENCODING, <i64>::ENCODING, <i64>::ENCODING],
    );
}

unsafe impl RefEncode for AudioPacketRangeByteCountTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// used for property kAudioFilePropertyPacketToRollDistance
///
/// See descriptions of kAudioFilePropertyPacketToRollDistance and kAudioFilePropertyRestrictsRandomAccess
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioPacketRollDistanceTranslation {
    pub mPacket: i64,
    pub mRollDistance: i64,
}

unsafe impl Encode for AudioPacketRollDistanceTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioPacketRollDistanceTranslation",
        &[<i64>::ENCODING, <i64>::ENCODING],
    );
}

unsafe impl RefEncode for AudioPacketRollDistanceTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// used for property kAudioFilePropertyPreviousIndependentPacket and kAudioFilePropertyNextIndependentPacket
///
/// See descriptions of kAudioFilePropertyPreviousIndependentPacket and kAudioFilePropertyNextIndependentPacket
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioIndependentPacketTranslation {
    pub mPacket: i64,
    pub mIndependentlyDecodablePacket: i64,
}

unsafe impl Encode for AudioIndependentPacketTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioIndependentPacketTranslation",
        &[<i64>::ENCODING, <i64>::ENCODING],
    );
}

unsafe impl RefEncode for AudioIndependentPacketTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// used for property kAudioFilePropertyPacketToDependencyInfo
///
/// See descriptions of kAudioFilePropertyPacketToDependencyInfo and kAudioFilePropertyRestrictsRandomAccess
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioPacketDependencyInfoTranslation {
    pub mPacket: i64,
    pub mIsIndependentlyDecodable: u32,
    pub mNumberPrerollPackets: u32,
}

unsafe impl Encode for AudioPacketDependencyInfoTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioPacketDependencyInfoTranslation",
        &[<i64>::ENCODING, <u32>::ENCODING, <u32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioPacketDependencyInfoTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Creates a new audio file, or initializes an existing file, specified by a URL.
    ///
    /// Parameters:
    /// - inFileRef: The fully specified path of the file to create or initialize.
    ///
    /// - inFileType: The type of audio file to create.  See [`AudioFileTypeID`](https://developer.apple.com/documentation/audiotoolbox/audiofiletypeid) for constants that can be used.
    ///
    /// - inFormat: A pointer to the structure that describes the format of the data.
    ///
    /// - inFlags: Relevant flags for creating or opening the file. If [`kAudioFileFlags_EraseFile`](https://developer.apple.com/documentation/audiotoolbox/audiofileflags/erasefile) is set, it erases an existing file. If the flag is not set, the function fails fails if the URL is an existing file.
    ///
    /// - outAudioFile: On output, a pointer to a newly created or initialized file.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function uses a `CFURLRef` type rather than the `FSRef` type used by the deprecated [`AudioFileCreate`](https://developer.apple.com/documentation/audiotoolbox/audiofilecreate) function.
    ///
    ///
    /// creates a new audio file (or initialises an existing file)
    ///
    /// creates a new (or initialises an existing) audio file specified by the URL.
    /// Upon success, an AudioFileID is returned which can be used for subsequent calls
    /// to the AudioFile APIs.
    ///
    /// Parameter `inFileRef`: an CFURLRef fully specifying the path of the file to create/initialise
    ///
    /// Parameter `inFileType`: an AudioFileTypeID indicating the type of audio file to create.
    ///
    /// Parameter `inFormat`: an AudioStreamBasicDescription describing the data format that will be
    /// added to the audio file.
    ///
    /// Parameter `inFlags`: relevant flags for creating/opening the file.
    /// if kAudioFileFlags_EraseFile is set, it will erase an existing file
    /// if not set, then the Create call will fail if the URL is an existing file
    ///
    /// Parameter `outAudioFile`: if successful, an AudioFileID that can be used for subsequent AudioFile calls.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_format` must be a valid pointer.
    /// - `out_audio_file` must be a valid pointer.
    #[cfg(all(feature = "objc2-core-audio-types", feature = "objc2-core-foundation"))]
    pub fn AudioFileCreateWithURL(
        in_file_ref: &CFURL,
        in_file_type: AudioFileTypeID,
        in_format: NonNull<AudioStreamBasicDescription>,
        in_flags: AudioFileFlags,
        out_audio_file: NonNull<AudioFileID>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Open an existing audio file specified by a URL.
    ///
    /// Parameters:
    /// - inFileRef: The URL of an existing audio file.
    ///
    /// - inPermissions: The read-write permissions you want to assign to the file. Use the permission constants in [`AudioFilePermissions`](https://developer.apple.com/documentation/audiotoolbox/audiofilepermissions).
    ///
    /// - inFileTypeHint: A hint for the file type of the designated file. For files without filename extensions and with types not easily or uniquely determined from the data (such as ADTS or AC3), use this hint to indicate the file type. Otherwise,  pass `0`. Only use this hint in macOS versions 10.3.1 or greater. In all earlier versions, any attempt to open these files fails.
    ///
    /// - outAudioFile: On output, a pointer to the newly opened audio file.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    /// Open an existing audio file.
    ///
    /// Open an existing audio file for reading or reading and writing.
    ///
    /// Parameter `inFileRef`: the CFURLRef of an existing audio file.
    ///
    /// Parameter `inPermissions`: use the permission constants
    ///
    /// Parameter `inFileTypeHint`: For files which have no filename extension and whose type cannot be easily or
    /// uniquely determined from the data (ADTS,AC3), this hint can be used to indicate the file type.
    /// Otherwise you can pass zero for this. The hint is only used on OS versions 10.3.1 or greater.
    /// For OS versions prior to that, opening files of the above description will fail.
    ///
    /// Parameter `outAudioFile`: upon success, an AudioFileID that can be used for subsequent
    /// AudioFile calls.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// `out_audio_file` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn AudioFileOpenURL(
        in_file_ref: &CFURL,
        in_permissions: AudioFilePermissions,
        in_file_type_hint: AudioFileTypeID,
        out_audio_file: NonNull<AudioFileID>,
    ) -> OSStatus;
}

/// Reads audio data when used in conjunction with the [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) or [`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)) functions.)
///
/// Parameters:
/// - inClientData: A pointer to the client data as set in the `inClientData` parameter to [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) or [`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)).
///
/// - inPosition: An offset into the data from which to read.
///
/// - requestCount: The number of bytes to read.
///
/// - buffer: A pointer to the buffer in which to put the data read.
///
/// - actualCount: On output, the callback should set this parameter to a pointer to the number of bytes successfully read.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// If you named your function `MyAudioFile_ReadProc`, you would declare it like this:
///
/// ### Discussion
///
/// This callback function is called when Audio File Services needs to read data.
///
///
/// A callback for reading data. used with AudioFileOpenWithCallbacks or AudioFileInitializeWithCallbacks.
///
/// a function that will be called when AudioFile needs to read data.
///
/// Parameter `inClientData`: A pointer to the client data as set in the inClientData parameter to AudioFileXXXWithCallbacks.
///
/// Parameter `inPosition`: An offset into the data from which to read.
///
/// Parameter `requestCount`: The number of bytes to read.
///
/// Parameter `buffer`: The buffer in which to put the data read.
///
/// Parameter `actualCount`: The callback should set this to the number of bytes successfully read.
///
/// Returns: The callback should return noErr on success, or an appropriate error code on failure.
pub type AudioFile_ReadProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        i64,
        u32,
        NonNull<c_void>,
        NonNull<u32>,
    ) -> OSStatus,
>;

/// A callback for writing file data when used in conjunction with the [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) or [`AudioFileCreateWithURL`](https://developer.apple.com/documentation/audiotoolbox/audiofilecreatewithurl(_:_:_:_:_:)) functions.
///
/// Parameters:
/// - inClientData: A pointer to the client data as set in the `inClientData` parameter to [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) or[`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)).
///
/// - inPosition: An offset into the data from which to read.
///
/// - requestCount: The number of bytes to write.
///
/// - buffer: A pointer to the buffer containing the data to write.
///
/// - actualCount: Upon completion, the callback should set this to a pointer to the number of bytes successfully written.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// If you named your function `MyAudioFile_WriteProc`, you would declare it like this:
///
/// ### Discussion
///
/// This callback function is invoked when Audio File Services needs to write data.
///
///
/// A callback for writing data. used with AudioFileOpenWithCallbacks or AudioFileInitializeWithCallbacks.
///
/// a function that will be called when AudioFile needs to write data.
///
/// Parameter `inClientData`: A pointer to the client data as set in the inClientData parameter to AudioFileXXXWithCallbacks.
///
/// Parameter `inPosition`: An offset into the data from which to read.
///
/// Parameter `requestCount`: The number of bytes to write.
///
/// Parameter `buffer`: The buffer containing the data to write.
///
/// Parameter `actualCount`: The callback should set this to the number of bytes successfully written.
///
/// Returns: The callback should return noErr on success, or an appropriate error code on failure.
pub type AudioFile_WriteProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        i64,
        u32,
        NonNull<c_void>,
        NonNull<u32>,
    ) -> OSStatus,
>;

/// Gets file data size.
///
/// Parameters:
/// - inClientData: A pointer to the client data as set in the `inClientData` parameter to the [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) or [`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)) functions.
///
///
/// ## Return Value
///
/// The callback should return the size of the data.
///
///
///
/// ## Discussion
///
/// If you named your function `MyAudioFile_GetSizeProc`, you would declare it like this:
///
/// ### Discussion
///
/// This callback gets invoked by an audio file object when it needs to get audio file data size. You pass this callback as a parameter when calling the [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) and [`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)) functions.
///
///
/// A callback for getting the size of the file data. used with AudioFileOpenWithCallbacks or AudioFileInitializeWithCallbacks.
///
/// a function that will be called when AudioFile needs to determine the size of the file data. This size is for all of the
/// data in the file, not just the audio data.
///
/// Parameter `inClientData`: A pointer to the client data as set in the inClientData parameter to AudioFileXXXWithCallbacks.
///
/// Returns: The callback should return the size of the data.
pub type AudioFile_GetSizeProc = Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> i64>;

/// Sets file data size.
///
/// Parameters:
/// - inClientData: A pointer to the client data as set in the `inClientData` parameter to the [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) or [`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)) functions.
///
///
/// ## Return Value
///
/// The callback should return the size of the data.
///
///
///
/// ## Discussion
///
/// If you named your function `MyAudioFile_SetSizeProc`, you would declare it like this:
///
/// ### Discussion
///
/// This callback gets invoked by an audio file object when it needs to set audio file data size. You pass this callback as a parameter when calling the [`AudioFileOpenWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileopenwithcallbacks(_:_:_:_:_:_:_:)) and [`AudioFileInitializeWithCallbacks`](https://developer.apple.com/documentation/audiotoolbox/audiofileinitializewithcallbacks(_:_:_:_:_:_:_:_:_:)) functions.
///
///
/// A callback for setting the size of the file data. used with AudioFileOpenWithCallbacks or AudioFileInitializeWithCallbacks.
///
/// a function that will be called when AudioFile needs to set the size of the file data. This size is for all of the
/// data in the file, not just the audio data. This will only be called if the file is written to.
///
/// Parameter `inClientData`: A pointer to the client data as set in the inClientData parameter to AudioFileXXXWithCallbacks.
///
/// Returns: The callback should return the size of the data.
pub type AudioFile_SetSizeProc =
    Option<unsafe extern "C-unwind" fn(NonNull<c_void>, i64) -> OSStatus>;

extern "C-unwind" {
    /// Deletes the content of an existing file and assigns callbacks to the audio file object.
    ///
    /// Parameters:
    /// - inClientData: A pointer to a constant passed to your callbacks. Th constant should contain any information you use to manage the state for reading data from the file.
    ///
    /// - inReadFunc: A callback function invoked when the audio file object wants to read data.
    ///
    /// - inWriteFunc: A callback function invoked when the audio file object wants to write data.
    ///
    /// - inGetSizeFunc: A callback function invoked when the audio file object wants to know the size of the file.
    ///
    /// - inSetSizeFunc: A callback function invoked when the audio file object wants to set the size of the file.
    ///
    /// - inFileType: The type of audio file to initialize
    ///
    /// - inFormat: The format for the audio data in the file.
    ///
    /// - inFlags: Flags for creating or opening the file. Set to `0`.
    ///
    /// - outAudioFile: On output, a pointer to the newly initialized audio file.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    /// Wipe clean an existing file. You provide callbacks that the AudioFile API
    /// will use to get the data.
    ///
    /// Parameter `inClientData`: a constant that will be passed to your callbacks.
    ///
    /// Parameter `inReadFunc`: a function that will be called when AudioFile needs to read data.
    ///
    /// Parameter `inWriteFunc`: a function that will be called when AudioFile needs to write data.
    ///
    /// Parameter `inGetSizeFunc`: a function that will be called when AudioFile needs to know the file size.
    ///
    /// Parameter `inSetSizeFunc`: a function that will be called when AudioFile needs to set the file size.
    ///
    ///
    /// Parameter `inFileType`: an AudioFileTypeID indicating the type of audio file to which to initialize the file.
    ///
    /// Parameter `inFormat`: an AudioStreamBasicDescription describing the data format that will be
    /// added to the audio file.
    ///
    /// Parameter `inFlags`: flags for creating/opening the file. Currently zero.
    ///
    /// Parameter `outAudioFile`: upon success, an AudioFileID that can be used for subsequent
    /// AudioFile calls.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_client_data` must be a valid pointer.
    /// - `in_read_func` must be implemented correctly.
    /// - `in_write_func` must be implemented correctly.
    /// - `in_get_size_func` must be implemented correctly.
    /// - `in_set_size_func` must be implemented correctly.
    /// - `in_format` must be a valid pointer.
    /// - `out_audio_file` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioFileInitializeWithCallbacks(
        in_client_data: NonNull<c_void>,
        in_read_func: AudioFile_ReadProc,
        in_write_func: AudioFile_WriteProc,
        in_get_size_func: AudioFile_GetSizeProc,
        in_set_size_func: AudioFile_SetSizeProc,
        in_file_type: AudioFileTypeID,
        in_format: NonNull<AudioStreamBasicDescription>,
        in_flags: AudioFileFlags,
        out_audio_file: NonNull<AudioFileID>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Opens an existing file with callbacks you provide.
    ///
    /// Parameters:
    /// - inClientData: A pointer to a constant passed to your callbacks. The constant should contain any information you use to manage the state for reading data from the file.
    ///
    /// - inReadFunc: A callback function invoked when the audio file object wants to read data.
    ///
    /// - inWriteFunc: A callback function called when the audio file object wants to write data.
    ///
    /// - inGetSizeFunc: A callback function called when the audio file object wants to know the file size.
    ///
    /// - inSetSizeFunc: A callback function called when the audio file object wants to set the file size.
    ///
    /// - inFileTypeHint: A hint about the type of the designated file. For files with no filename extension and without a type easily or uniquely determined from the data (ADTS,AC3), use this hint to indicate the file type. Otherwise, pass `0` for this parameter. The hint is only available in macOS versions 10.3.1 or greater. In versions prior to OS X 10.3.1, opening files such files fails.
    ///
    /// - outAudioFile: On output, a pointer to the newly opened file.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    /// Open an existing file. You provide callbacks that the AudioFile API
    /// will use to get the data.
    ///
    /// Parameter `inClientData`: a constant that will be passed to your callbacks.
    ///
    /// Parameter `inReadFunc`: a function that will be called when AudioFile needs to read data.
    ///
    /// Parameter `inWriteFunc`: a function that will be called when AudioFile needs to write data.
    ///
    /// Parameter `inGetSizeFunc`: a function that will be called when AudioFile needs to know the total file size.
    ///
    /// Parameter `inSetSizeFunc`: a function that will be called when AudioFile needs to set the file size.
    ///
    ///
    /// Parameter `inFileTypeHint`: For files which have no filename extension and whose type cannot be easily or
    /// uniquely determined from the data (ADTS,AC3), this hint can be used to indicate the file type.
    /// Otherwise you can pass zero for this. The hint is only used on OS versions 10.3.1 or greater.
    /// For OS versions prior to that, opening files of the above description will fail.
    ///
    /// Parameter `outAudioFile`: upon success, an AudioFileID that can be used for subsequent
    /// AudioFile calls.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_client_data` must be a valid pointer.
    /// - `in_read_func` must be implemented correctly.
    /// - `in_write_func` must be implemented correctly.
    /// - `in_get_size_func` must be implemented correctly.
    /// - `in_set_size_func` must be implemented correctly.
    /// - `out_audio_file` must be a valid pointer.
    pub fn AudioFileOpenWithCallbacks(
        in_client_data: NonNull<c_void>,
        in_read_func: AudioFile_ReadProc,
        in_write_func: AudioFile_WriteProc,
        in_get_size_func: AudioFile_GetSizeProc,
        in_set_size_func: AudioFile_SetSizeProc,
        in_file_type_hint: AudioFileTypeID,
        out_audio_file: NonNull<AudioFileID>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Closes an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The file you want to close.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    /// Close an existing audio file.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// `in_audio_file` must be a valid pointer.
    pub fn AudioFileClose(in_audio_file: AudioFileID) -> OSStatus;
}

extern "C-unwind" {
    /// Consolidates audio data and performs other internal optimizations of the file structure.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file you want to optimize.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function optimizes the file so additional audio information can be appended to the existing data. Typically, this function consolidates the file’s audio data at the end of the file. This improves performance, such as when writing additional data to the file.
    ///
    /// Do not use this potentially expensive and time-consuming operation during time-critical operations. Instead, use the [`kAudioFilePropertyIsOptimized`](https://developer.apple.com/documentation/audiotoolbox/kaudiofilepropertyisoptimized) property to check the optimization state of a file. You can then optimize when it won’t adversely affect your application.
    ///
    ///
    /// Move the audio data to the end of the file and other internal optimizations of the file structure.
    ///
    /// Optimize the file so additional audio data can be appended to
    /// the existing data. Generally, this will place the audio data at
    /// the end of the file so additional writes can be placed to the
    /// file end. This can be a potentially expensive and time-consuming operation
    /// and should not be used during time critical operations. There is
    /// a kAudioFilePropertyIsOptimized property for checking on the optimized state
    /// of the file.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// `in_audio_file` must be a valid pointer.
    pub fn AudioFileOptimize(in_audio_file: AudioFileID) -> OSStatus;
}

/// Reads bytes of audio data from an audio file.
///
/// Parameters:
/// - inAudioFile: The audio file whose bytes of audio data you want to read.
///
/// - inUseCache: Set to `true` if you want to cache the data. You should cache reads and writes if you read or write the same portion of a file multiple times. To request that the data not be cached, if possible, set to `false`. You should not cache reads and writes if you read or write data from a file only once.
///
/// - inStartingByte: The byte offset of the audio data you want to be returned.
///
/// - ioNumBytes: On input, a pointer to the number of bytes to read. On output, a pointer to the number of bytes actually read.
///
/// - outBuffer: A pointer to user-allocated memory large enough for the requested bytes.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// In most cases, you should use [`AudioFileReadPackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilereadpackets(_:_:_:_:_:_:_:)) instead of this function.
///
/// This function returns `eofErr` when the read operation encounters the end of the file.  Note that Audio File Services only reads one 32-bit chunk of a file at a time.
///
///
/// Read bytes of audio data from the audio file.
///
///
/// Returns kAudioFileEndOfFileError when read encounters end of file.
///
/// Parameter `inAudioFile`: an AudioFileID.
///
/// Parameter `inUseCache`: true if it is desired to cache the data upon read, else false
///
/// Parameter `inStartingByte`: the byte offset of the audio data desired to be returned
///
/// Parameter `ioNumBytes`: on input, the number of bytes to read, on output, the number of
/// bytes actually read.
///
/// Parameter `outBuffer`: outBuffer should be a void * to user allocated memory large enough for the requested bytes.
///
/// Returns: returns noErr if successful.
///
/// # Safety
///
/// - `in_audio_file` must be a valid pointer.
/// - `io_num_bytes` must be a valid pointer.
/// - `out_buffer` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn AudioFileReadBytes(
    in_audio_file: AudioFileID,
    in_use_cache: bool,
    in_starting_byte: i64,
    io_num_bytes: NonNull<u32>,
    out_buffer: NonNull<c_void>,
) -> OSStatus {
    extern "C-unwind" {
        fn AudioFileReadBytes(
            in_audio_file: AudioFileID,
            in_use_cache: Boolean,
            in_starting_byte: i64,
            io_num_bytes: NonNull<u32>,
            out_buffer: NonNull<c_void>,
        ) -> OSStatus;
    }
    unsafe {
        AudioFileReadBytes(
            in_audio_file,
            in_use_cache as _,
            in_starting_byte,
            io_num_bytes,
            out_buffer,
        )
    }
}

/// Writes bytes of audio data to an audio file.
///
/// Parameters:
/// - inAudioFile: The audio file to which you want to write bytes of data.
///
/// - inUseCache: Set to `true` if you want to cache the data. Otherwise, set to `false`.
///
/// - inStartingByte: The byte offset where the audio data should be written.
///
/// - ioNumBytes: On input, a pointer the number of bytes to write. On output, a pointer to the number of bytes actually written.
///
/// - inBuffer: A pointer to a buffer containing the bytes to be written.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// In most cases, you should use [`AudioFileWritePackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilewritepackets(_:_:_:_:_:_:_:)) instead of this function.
///
///
/// Write bytes of audio data to the audio file.
///
/// Parameter `inAudioFile`: an AudioFileID.
///
/// Parameter `inUseCache`: true if it is desired to cache the data upon write, else false
///
/// Parameter `inStartingByte`: the byte offset where the audio data should be written
///
/// Parameter `ioNumBytes`: on input, the number of bytes to write, on output, the number of
/// bytes actually written.
///
/// Parameter `inBuffer`: inBuffer should be a void * containing the bytes to be written
///
/// Returns: returns noErr if successful.
///
/// # Safety
///
/// - `in_audio_file` must be a valid pointer.
/// - `io_num_bytes` must be a valid pointer.
/// - `in_buffer` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn AudioFileWriteBytes(
    in_audio_file: AudioFileID,
    in_use_cache: bool,
    in_starting_byte: i64,
    io_num_bytes: NonNull<u32>,
    in_buffer: NonNull<c_void>,
) -> OSStatus {
    extern "C-unwind" {
        fn AudioFileWriteBytes(
            in_audio_file: AudioFileID,
            in_use_cache: Boolean,
            in_starting_byte: i64,
            io_num_bytes: NonNull<u32>,
            in_buffer: NonNull<c_void>,
        ) -> OSStatus;
    }
    unsafe {
        AudioFileWriteBytes(
            in_audio_file,
            in_use_cache as _,
            in_starting_byte,
            io_num_bytes,
            in_buffer,
        )
    }
}

/// Reads packets of audio data from an audio file.
///
/// Parameters:
/// - inAudioFile: The audio file whose audio packets you want to read.
///
/// - inUseCache: Set to `true` to cache the data. Otherwise, set to `false`.
///
/// - ioNumBytes: On input, the size of the `outBuffer` parameter, in bytes. On output, the number of bytes actually read.
///
/// You will see a difference in the input and output values if the byte size for the number of packets you request in the `ioNumPackets` parameter is smaller than the buffer size you pass in the `outBuffer` parameter. In this case, the output value for this parameter is smaller than its input value.
///
/// - outPacketDescriptions: On output, an array of packet descriptions for the packets that were read. The array that you pass in this parameter must be large enough to accommodate descriptions for the number of packets requested in the `ioNumPackets` parameter.
///
/// This parameter applies only to variable bit-rate data. If the file being read contains constant bit-rate (CBR) data, such as linear PCM, this parameter does not get filled. Pass `NULL` if the file’s data format is CBR.
///
/// - inStartingPacket: The packet index of the first packet you want to read.
///
/// - ioNumPackets: On input, the number of packets to read. On output, the number of packets actually read.
///
/// - outBuffer: Memory that you allocate to hold the read packets. Determine an appropriate size by multiplying the number of packets requested (in the `ioNumPackets` parameter) by the typical packet size for the audio data in the file. For uncompressed audio formats, a packet is equal to a frame.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// Using this function is memory efficient when reading variable bit-rate (VBR) audio data, whose packet sizes can vary for a given duration of sound.
///
/// If the buffer you provide in the `outBuffer` parameter is too small to hold the packets you request in `ioNumPackets`, the output values of `ioNumPackets` and `ioNumBytes` are reduced to reflect the packets that were placed into the buffer. You also see a difference in the input and output values for `ioNumPackets` when this function has reached the end of the file you are reading. In this case, the output value for this parameter is smaller than its input value.
///
/// This function is more efficient than [`AudioFileReadPackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilereadpackets(_:_:_:_:_:_:_:)) when reading compressed file formats that do not have packet tables, such as MP3 or ADTS. This function is a good choice for reading either CBR (constant bit-rate) or VBR data if you do not need to read a fixed duration of audio. If you do need to read a fixed duration of audio, whether CBR  or VBR, use [`AudioFileReadPackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilereadpackets(_:_:_:_:_:_:_:)) instead.
///
/// Audio File Services reads one 32-bit chunk of a file at a time.
///
///
/// Read packets of audio data from the audio file.
///
/// AudioFileReadPacketData reads as many of the requested number of packets
/// as will fit in the buffer size given by ioNumPackets.
/// Unlike the deprecated AudioFileReadPackets, ioNumPackets must be initialized.
/// If the byte size of the number packets requested is
/// less than the buffer size, ioNumBytes will be reduced.
/// If the buffer is too small for the number of packets
/// requested, ioNumPackets and ioNumBytes will be reduced
/// to the number of packets that can be accommodated and their byte size.
/// Returns kAudioFileEndOfFileError when read encounters end of file.
/// For all uncompressed formats, packets == frames.
///
///
/// Parameter `inAudioFile`: an AudioFileID.
///
/// Parameter `inUseCache`: true if it is desired to cache the data upon read, else false
///
/// Parameter `ioNumBytes`: on input the size of outBuffer in bytes.
/// on output, the number of bytes actually returned.
///
/// Parameter `outPacketDescriptions`: An array of packet descriptions describing the packets being returned.
/// The size of the array must be greater or equal to the number of packets requested.
/// On return the packet description will be filled out with the packet offsets and sizes.
/// Packet descriptions are ignored for CBR data.
///
/// Parameter `inStartingPacket`: The packet index of the first packet desired to be returned
///
/// Parameter `ioNumPackets`: on input, the number of packets to read, on output, the number of
/// packets actually read.
///
/// Parameter `outBuffer`: outBuffer should be a pointer to user allocated memory.
///
/// Returns: returns noErr if successful.
///
/// # Safety
///
/// - `in_audio_file` must be a valid pointer.
/// - `io_num_bytes` must be a valid pointer.
/// - `out_packet_descriptions` must be a valid pointer or null.
/// - `io_num_packets` must be a valid pointer.
/// - `out_buffer` must be a valid pointer or null.
#[cfg(feature = "objc2-core-audio-types")]
#[inline]
pub unsafe extern "C-unwind" fn AudioFileReadPacketData(
    in_audio_file: AudioFileID,
    in_use_cache: bool,
    io_num_bytes: NonNull<u32>,
    out_packet_descriptions: *mut AudioStreamPacketDescription,
    in_starting_packet: i64,
    io_num_packets: NonNull<u32>,
    out_buffer: *mut c_void,
) -> OSStatus {
    extern "C-unwind" {
        fn AudioFileReadPacketData(
            in_audio_file: AudioFileID,
            in_use_cache: Boolean,
            io_num_bytes: NonNull<u32>,
            out_packet_descriptions: *mut AudioStreamPacketDescription,
            in_starting_packet: i64,
            io_num_packets: NonNull<u32>,
            out_buffer: *mut c_void,
        ) -> OSStatus;
    }
    unsafe {
        AudioFileReadPacketData(
            in_audio_file,
            in_use_cache as _,
            io_num_bytes,
            out_packet_descriptions,
            in_starting_packet,
            io_num_packets,
            out_buffer,
        )
    }
}

/// Reads a fixed duration of audio data from an audio file.
///
/// Parameters:
/// - inAudioFile: The audio file whose audio packets you want to read.
///
/// - inUseCache: Set to `true` to cache the data. Otherwise, set to `false`.
///
/// - outNumBytes: On output, the number of bytes actually read.
///
/// - outPacketDescriptions: On output, an array of packet descriptions for the packets that were read. The array that you pass must be large enough to accommodate descriptions for the number of packets requested in the `ioNumPackets` parameter.
///
/// This parameter applies only to variable bit-rate data. If the file being read contains constant bit-rate (CBR) data, such as linear PCM, this parameter does not get filled. Pass `NULL` if the file’s data format is CBR.
///
/// - inStartingPacket: The packet index of the first packet you want to read.
///
/// - ioNumPackets: On input, the number of packets to read. On output, the number of packets actually read.
///
/// You will see a difference in the input and output values when this function has reached the end of the file you are reading. In this case, the output value for this parameter is smaller than its input value.
///
/// - outBuffer: Memory that you allocate to hold the read packets. Determine an appropriate size by multiplying the number of packets requested (in the `ioNumPackets` parameter) by the maximum (or upper bound for) packet size of the audio file. For uncompressed audio formats, a packet is equal to a frame.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// If you do not need to read a fixed duration of audio data, but rather want to use your memory buffer most efficiently, use [`AudioFileReadPacketData`](https://developer.apple.com/documentation/audiotoolbox/audiofilereadpacketdata(_:_:_:_:_:_:_:)) instead of this function.
///
/// When reading variable bit-rate (VBR) audio data, using this function requires that you allocate more memory than you would for the [`AudioFileReadPacketData`](https://developer.apple.com/documentation/audiotoolbox/audiofilereadpacketdata(_:_:_:_:_:_:_:)) function. See the descriptions for the `outBuffer` parameter in each of these two functions.
///
/// In addition, this function is less efficient than [`AudioFileReadPacketData`](https://developer.apple.com/documentation/audiotoolbox/audiofilereadpacketdata(_:_:_:_:_:_:_:)) when reading compressed file formats that do not have packet tables, such as MP3 or ADTS. Use this function only when you need to read a fixed duration of audio data, or when you are reading only uncompressed audio.
///
/// Audio File Services reads one 32-bit chunk of a file at a time.
///
///
/// Read packets of audio data from the audio file.
///
/// AudioFileReadPackets is DEPRECATED. Use AudioFileReadPacketData instead.
/// READ THE HEADER DOC FOR AudioFileReadPacketData. It is not a drop-in replacement.
/// In particular, for AudioFileReadPacketData ioNumBytes must be initialized to the buffer size.
/// AudioFileReadPackets assumes you have allocated your buffer to ioNumPackets times the maximum packet size.
/// For many compressed formats this will only use a portion of the buffer since the ratio of the maximum
/// packet size to the typical packet size can be large. Use AudioFileReadPacketData instead.
///
///
/// Parameter `inAudioFile`: an AudioFileID.
///
/// Parameter `inUseCache`: true if it is desired to cache the data upon read, else false
///
/// Parameter `outNumBytes`: on output, the number of bytes actually returned
///
/// Parameter `outPacketDescriptions`: on output, an array of packet descriptions describing
/// the packets being returned. NULL may be passed for this
/// parameter. Nothing will be returned for linear pcm data.
///
/// Parameter `inStartingPacket`: the packet index of the first packet desired to be returned
///
/// Parameter `ioNumPackets`: on input, the number of packets to read, on output, the number of
/// packets actually read.
///
/// Parameter `outBuffer`: outBuffer should be a pointer to user allocated memory of size:
/// number of packets requested times file's maximum (or upper bound on)
/// packet size.
///
/// Returns: returns noErr if successful.
///
/// # Safety
///
/// - `in_audio_file` must be a valid pointer.
/// - `out_num_bytes` must be a valid pointer.
/// - `out_packet_descriptions` must be a valid pointer or null.
/// - `io_num_packets` must be a valid pointer.
/// - `out_buffer` must be a valid pointer or null.
#[cfg(feature = "objc2-core-audio-types")]
#[deprecated = "no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn AudioFileReadPackets(
    in_audio_file: AudioFileID,
    in_use_cache: bool,
    out_num_bytes: NonNull<u32>,
    out_packet_descriptions: *mut AudioStreamPacketDescription,
    in_starting_packet: i64,
    io_num_packets: NonNull<u32>,
    out_buffer: *mut c_void,
) -> OSStatus {
    extern "C-unwind" {
        fn AudioFileReadPackets(
            in_audio_file: AudioFileID,
            in_use_cache: Boolean,
            out_num_bytes: NonNull<u32>,
            out_packet_descriptions: *mut AudioStreamPacketDescription,
            in_starting_packet: i64,
            io_num_packets: NonNull<u32>,
            out_buffer: *mut c_void,
        ) -> OSStatus;
    }
    unsafe {
        AudioFileReadPackets(
            in_audio_file,
            in_use_cache as _,
            out_num_bytes,
            out_packet_descriptions,
            in_starting_packet,
            io_num_packets,
            out_buffer,
        )
    }
}

/// Writes packets of audio data to an audio data file.
///
/// Parameters:
/// - inAudioFile: The audio file to write to.
///
/// - inUseCache: Set to `true` if you want to cache the data. Otherwise, set to `false`.
///
/// - inNumBytes: The number of bytes of audio data being written.
///
/// - inPacketDescriptions: A pointer to an array of packet descriptions for the audio data. Not all formats require packet descriptions. If no packet descriptions are required, for instance, if you are writing CBR data,  pass `NULL`.
///
/// - inStartingPacket: The packet index for the placement of the first provided packet.
///
/// - ioNumPackets: On input, a pointer to the number of packets to write. On output, a pointer to the number of packets actually written.
///
/// - inBuffer: A pointer to user-allocated memory containing the new audio data to write to the audio data file.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// For all uncompressed formats, this function equates packets with frames.
///
///
/// Write packets of audio data to the audio file.
///
/// For all uncompressed formats, packets == frames.
///
/// Parameter `inAudioFile`: an AudioFileID.
///
/// Parameter `inUseCache`: true if it is desired to cache the data upon write, else false
///
/// Parameter `inNumBytes`: the number of bytes being provided for write
///
/// Parameter `inPacketDescriptions`: an array of packet descriptions describing the packets being
/// provided. Not all formats require packet descriptions to be
/// provided. NULL may be passed if no descriptions are required.
///
/// Parameter `inStartingPacket`: the packet index of where the first packet provided should be placed.
///
/// Parameter `ioNumPackets`: on input, the number of packets to write, on output, the number of
/// packets actually written.
///
/// Parameter `inBuffer`: a void * to user allocated memory containing the packets to write.
///
/// Returns: returns noErr if successful.
///
/// # Safety
///
/// - `in_audio_file` must be a valid pointer.
/// - `in_packet_descriptions` must be a valid pointer or null.
/// - `io_num_packets` must be a valid pointer.
/// - `in_buffer` must be a valid pointer.
#[cfg(feature = "objc2-core-audio-types")]
#[inline]
pub unsafe extern "C-unwind" fn AudioFileWritePackets(
    in_audio_file: AudioFileID,
    in_use_cache: bool,
    in_num_bytes: u32,
    in_packet_descriptions: *const AudioStreamPacketDescription,
    in_starting_packet: i64,
    io_num_packets: NonNull<u32>,
    in_buffer: NonNull<c_void>,
) -> OSStatus {
    extern "C-unwind" {
        fn AudioFileWritePackets(
            in_audio_file: AudioFileID,
            in_use_cache: Boolean,
            in_num_bytes: u32,
            in_packet_descriptions: *const AudioStreamPacketDescription,
            in_starting_packet: i64,
            io_num_packets: NonNull<u32>,
            in_buffer: NonNull<c_void>,
        ) -> OSStatus;
    }
    unsafe {
        AudioFileWritePackets(
            in_audio_file,
            in_use_cache as _,
            in_num_bytes,
            in_packet_descriptions,
            in_starting_packet,
            io_num_packets,
            in_buffer,
        )
    }
}

///
/// Parameters:
/// - inAudioFile: The audio file to write to.
///
/// - inUseCache: Set to `true` if you want to cache the data. Otherwise, set to `false`.
///
/// - inNumBytes: The number of bytes of audio data being written.
///
/// - inPacketDescriptions: A pointer to an array of packet descriptions for the audio data. Not all formats require packet descriptions. If no packet descriptions are required, for instance, if you are writing CBR data,  pass `NULL`.
///
/// - inPacketDependencies: A pointer to an array of packet dependencies for the audio data. This must not be `NULL`.  To write packets without dependencies, use [`AudioFileWritePackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilewritepackets(_:_:_:_:_:_:_:)) instead.
///
/// - inStartingPacket: The packet index for the placement of the first provided packet.
///
/// - ioNumPackets: On input, a pointer to the number of packets to write. On output, a pointer to the number of packets actually written.
///
/// - inBuffer: A pointer to user-allocated memory containing the new audio data to write to the audio data file.
///
///
/// ## Return Value
///
/// A result code. See Result Codes.
///
///
///
/// ## Discussion
///
/// Write packets of audio data with corresponding packet dependencies to an audio data file.
///
/// For all uncompressed formats, `packets == frames`.
///
///
/// Write packets of audio data with corresponding packet dependencies to an audio data file.
///
/// For all uncompressed formats, `packets == frames`.
///
/// Parameter `inAudioFile`: The audio file to write to.
///
/// Parameter `inUseCache`: Set to `true` if you want to cache the data. Otherwise, set to `false`.
///
/// Parameter `inNumBytes`: The number of bytes of audio data being written.
///
/// Parameter `inPacketDescriptions`: A pointer to an array of packet descriptions for the audio data.
/// Not all formats require packet descriptions. If no packet descriptions
/// are required, for instance, if you are writing CBR data,  pass `NULL`.
///
/// Parameter `inPacketDependencies`: A pointer to an array of packet dependencies for the audio data.
/// This must not be `NULL`.  To write packets without dependencies,
/// use ``AudioFileWritePackets`` instead.
///
/// Parameter `inStartingPacket`: The packet index for the placement of the first provided packet.
///
/// Parameter `ioNumPackets`: On input, a pointer to the number of packets to write.
/// On output, a pointer to the number of packets actually written.
///
/// Parameter `inBuffer`: A pointer to user-allocated memory containing the new audio data
/// to write to the audio data file.
///
/// Returns: A result code. See Result Codes.
///
/// # Safety
///
/// - `in_audio_file` must be a valid pointer.
/// - `in_packet_descriptions` must be a valid pointer or null.
/// - `in_packet_dependencies` must be a valid pointer.
/// - `io_num_packets` must be a valid pointer.
/// - `in_buffer` must be a valid pointer.
#[cfg(feature = "objc2-core-audio-types")]
#[inline]
pub unsafe extern "C-unwind" fn AudioFileWritePacketsWithDependencies(
    in_audio_file: AudioFileID,
    in_use_cache: bool,
    in_num_bytes: u32,
    in_packet_descriptions: *const AudioStreamPacketDescription,
    in_packet_dependencies: NonNull<AudioStreamPacketDependencyDescription>,
    in_starting_packet: i64,
    io_num_packets: NonNull<u32>,
    in_buffer: NonNull<c_void>,
) -> OSStatus {
    extern "C-unwind" {
        fn AudioFileWritePacketsWithDependencies(
            in_audio_file: AudioFileID,
            in_use_cache: Boolean,
            in_num_bytes: u32,
            in_packet_descriptions: *const AudioStreamPacketDescription,
            in_packet_dependencies: NonNull<AudioStreamPacketDependencyDescription>,
            in_starting_packet: i64,
            io_num_packets: NonNull<u32>,
            in_buffer: NonNull<c_void>,
        ) -> OSStatus;
    }
    unsafe {
        AudioFileWritePacketsWithDependencies(
            in_audio_file,
            in_use_cache as _,
            in_num_bytes,
            in_packet_descriptions,
            in_packet_dependencies,
            in_starting_packet,
            io_num_packets,
            in_buffer,
        )
    }
}

extern "C-unwind" {
    /// Gets the number of user data items with a specified ID in a file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file whose user data items are to be counted.
    ///
    /// - inUserDataID: The four-character code (such as `COMM`) of the user data item.
    ///
    /// - outNumberItems: On output, a pointer to the number of user data items of this type in the file.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In this function, _user data_ refers to:
    ///
    /// - Chunks in AIFF, CAF, and WAVE files
    ///
    /// - Resources in Sound Designer II files
    ///
    /// - Other types of information in other files
    ///
    ///
    /// Get the number of user data items with a certain ID in the file
    ///
    /// "User Data" refers to chunks in AIFF, CAF and WAVE files, or resources
    /// in Sound Designer II files, and possibly other things in other files.
    /// For simplicity, referred to below as "chunks".
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `outNumberItems`: on output, if successful, number of chunks of this type in the file.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `out_number_items` must be a valid pointer.
    pub fn AudioFileCountUserData(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        out_number_items: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the size of a user data item in an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file whose user data item size you want.
    ///
    /// - inUserDataID: The four-character code of the designated user data item.
    ///
    /// - inIndex: An index of the user data item with the four-character code specified in `inUserDataID` that you want to query.
    ///
    /// - outUserDataSize: On output, if successful, the size of the user data item.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In this function, _user data_ refers to:
    ///
    /// - Chunks in AIFF, CAF, and WAVE files
    ///
    /// - Resources in Sound Designer II files
    ///
    /// - Other types of information in other files
    ///
    ///
    /// Get the size of user data in a file
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `inIndex`: an index specifying which chunk if there are more than one.
    ///
    /// Parameter `outUserDataSize`: on output, if successful, the size of the user data chunk.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `out_user_data_size` must be a valid pointer.
    pub fn AudioFileGetUserDataSize(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        in_index: u32,
        out_user_data_size: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the size of a user data item in an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file whose user data item size you want.
    ///
    /// - inUserDataID: The four-character code of the designated user data item.
    ///
    /// - inIndex: An index of the user data item with the four-character code specified in `inUserDataID` that you want to query.
    ///
    /// - outUserDataSize: On output, if successful, the size of the user data item.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In this function, _user data_ refers to:
    ///
    /// - Chunks in AIFF, CAF, and WAVE files
    ///
    /// - Resources in Sound Designer II files
    ///
    /// - Other types of information in other files
    ///
    /// Very large user data chunks, such as the Audio Definition Model (ADM) chunks that movie production uses, can exceed the 32-bit size limit or be prohibitively expensive to allocate large enough memory blocks to read them.
    ///
    /// The BW64 format is 64-bit and based on WAVE. Parsing the ADM of a BW64 file with metadata becomes an iterative process that doesn’t require large memory buffers. In the following example, `ADMBuilder` is a type that uses the Builder pattern to parse an ADM document from sequentially provided segments:
    ///
    /// ```objc
    /// constexpr size_t CHUNK_BUFFER_SIZE = 16 * 1024;  // Arbitrary, but 16K is the typical page size.
    ///     AudioFileID inputAudioFile;
    ///     
    ///     // Assume that the system successfully opened the audio file.
    ///     
    ///     uint64_t chunkSize = 0;
    ///     auto err = AudioFileGetUserDataSize64(inputAudioFile, 'axml', 0, &chunkSize);
    ///     
    ///     if (err != noErr) {
    ///         if (err == kAudioFileInvalidChunkError) {
    ///             fprintf(stderr, "The input file doesn't appear to have an ADM document attached.\n");
    ///             return EXIT_FAILURE;
    ///         }
    ///         fprintf(stderr, "AudioFileGetUserDataSize64 returned error: %d.\n", (int)err);
    ///         return EXIT_FAILURE;
    ///     }
    ///     
    ///     printf("ADM is %" PRIu64 " bytes in size.\n", chunkSize);
    ///     ADMBuilder admBuilder;
    ///     std::vector<uint8_t> buffer(CHUNK_BUFFER_SIZE);
    ///     uint64_t offset = 0;
    ///     
    ///     while (offset < chunkSize) {
    ///         auto readSize = (uint32_t)std::min((uint64_t)CHUNK_BUFFER_SIZE, chunkSize - offset);
    ///         
    ///         err = AudioFileGetUserDataAtOffset(inputAudioFile, 'axml', 0, offset, &readSize, buffer.data());        
    ///         if (err != noErr) {
    ///             fprintf(stderr, "AudioFileGetUserDataAtOffset returned error: %d.\n", (int)err);
    ///             return EXIT_FAILURE;
    ///         }
    ///         
    ///         err = admBuilder.parse((const char*)buffer.data(), (int)readSize, offset + readSize >= chunkSize);
    ///         if (err != noErr) {
    ///             fprintf(stderr, "ADMBuilder::parse returned error: %d.\n", (int)err);
    ///             return EXIT_FAILURE;
    ///         }
    ///         
    ///         offset += (uint64_t)readSize;
    ///     }
    ///     
    ///     // Assume that the system reads and uses the audio frames from the file, along
    ///     // with the parsed ADM document, and the system eventually closes the audio file.
    ///     
    ///     return EXIT_SUCCESS;
    ///
    /// ```
    ///
    ///
    /// Get the 64-bit size of user data in a file
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `inIndex`: an index specifying which chunk if there are more than one.
    ///
    /// Parameter `outUserDataSize`: on output, if successful, the size of the user data chunk.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `out_user_data_size` must be a valid pointer.
    pub fn AudioFileGetUserDataSize64(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        in_index: u32,
        out_user_data_size: NonNull<u64>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets a chunk from an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file whose chunk you want to get.
    ///
    /// - inUserDataID: The four-character code of the designated chunk.
    ///
    /// - inIndex: An index that specifies which chunk with the four-character code specified in the `inUserDataID` parameter you want to query.
    ///
    /// - ioUserDataSize: On input, a pointer to the size of the buffer that contains the designated chunk. On output, a pointer to the size of bytes that the system copied to the buffer.
    ///
    /// - outUserData: A pointer to a buffer in which to copy the chunk data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    /// Get the data of a chunk in a file.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `inIndex`: an index specifying which chunk if there are more than one.
    ///
    /// Parameter `ioUserDataSize`: the size of the buffer on input, size of bytes copied to buffer on output
    ///
    /// Parameter `outUserData`: a pointer to a buffer in which to copy the chunk data.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `io_user_data_size` must be a valid pointer.
    /// - `out_user_data` must be a valid pointer.
    pub fn AudioFileGetUserData(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        in_index: u32,
        io_user_data_size: NonNull<u32>,
        out_user_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets part of the data from a chunk in an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file whose chunk you want to get data from.
    ///
    /// - inUserDataID: The four-character code of the designated chunk.
    ///
    /// - inIndex: An index that specifies which chunk with the four-character code specified in the `inUserDataID` parameter you want to query.
    ///
    /// - inOffset: An offset from the first byte of the chunk to the first byte to get.
    ///
    /// - ioUserDataSize: On input, a pointer to the size of the buffer that contains the designated chunk. On output, a pointer to the size of bytes that the system copied to the buffer.
    ///
    /// - outUserData: A pointer to a buffer in which to copy the chunk data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// See [`AudioFileGetUserDataSize64`](https://developer.apple.com/documentation/audiotoolbox/audiofilegetuserdatasize64(_:_:_:_:)) for an example of using this function to parse the Audio Definition Model (ADM) of a BW64 file, which is 64-bit and based on WAVE.
    ///
    ///
    /// Get a part of the data of a chunk in a file.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `inIndex`: an index specifying which chunk if there are more than one.
    ///
    /// Parameter `inOffset`: offset from the first byte of the chunk to the first byte to get.
    ///
    /// Parameter `ioUserDataSize`: the size of the buffer on input, size of bytes copied to buffer on output
    ///
    /// Parameter `outUserData`: a pointer to a buffer in which to copy the chunk data.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `io_user_data_size` must be a valid pointer.
    /// - `out_user_data` must be a valid pointer.
    pub fn AudioFileGetUserDataAtOffset(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        in_index: u32,
        in_offset: i64,
        io_user_data_size: NonNull<u32>,
        out_user_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets a user data item in an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file that you want to set a user data item in.
    ///
    /// - inUserDataID: The four-character code for the user data item.
    ///
    /// - inIndex: An index specifying the user data item you want to set. You use this parameter if the file contains more than one user data item with the four-character code specified in the `inUserDataID` parameter.
    ///
    /// - inUserDataSize: On input, the size of the data to copy. On output, the size of the bytes copied from the buffer.
    ///
    /// - inUserData: A pointer to a buffer from which to copy the user data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    /// Set the data of a chunk in a file.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `inIndex`: an index specifying which chunk if there are more than one.
    ///
    /// Parameter `inUserDataSize`: on input the size of the data to copy, on output, size of bytes copied from the buffer
    ///
    /// Parameter `inUserData`: a pointer to a buffer from which to copy the chunk data
    /// (only the contents of the chunk, not including the chunk header).
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `in_user_data` must be a valid pointer.
    pub fn AudioFileSetUserData(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        in_index: u32,
        in_user_data_size: u32,
        in_user_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Removes a user data item from an audio file.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file that contains the user data item you want to remove.
    ///
    /// - inUserDataID: The four-character code such as `COMM` of the user data item.
    ///
    /// - inIndex: An index specifying the chunk to remove. Use this parameter if the file contains more than one user data item with the four-character code that you specified in the `inUserDataID` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code if there’s an error (see Result Codes) or `noErr` if the operation succeeds.
    ///
    ///
    /// Remove a user chunk in a file.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inUserDataID`: the four char code of the chunk.
    ///
    /// Parameter `inIndex`: an index specifying which chunk if there are more than one.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// `in_audio_file` must be a valid pointer.
    pub fn AudioFileRemoveUserData(
        in_audio_file: AudioFileID,
        in_user_data_id: u32,
        in_index: u32,
    ) -> OSStatus;
}

/// The format of the audio data file.
pub const kAudioFilePropertyFileFormat: AudioFilePropertyID = 0x66666d74;
/// An audio stream basic description containing the format of the audio data.
pub const kAudioFilePropertyDataFormat: AudioFilePropertyID = 0x64666d74;
/// Indicates whether a designated audio file has been optimized, that is, ready to start having sound data written to it. A value of `0` indicates the file needs to be optimized. A value of `1` indicates the file is currently optimized.
pub const kAudioFilePropertyIsOptimized: AudioFilePropertyID = 0x6f70746d;
/// A pointer to memory set up by the caller. Some file types require that a magic cookie be provided before packets can be written to an audio file. Set this property before you call [`AudioFileWriteBytes`](https://developer.apple.com/documentation/audiotoolbox/audiofilewritebytes(_:_:_:_:_:)) or [`AudioFileWritePackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilewritepackets(_:_:_:_:_:_:_:)) if a magic cookie exists.
pub const kAudioFilePropertyMagicCookieData: AudioFilePropertyID = 0x6d676963;
/// Indicates the number of bytes of audio data in the designated file.
pub const kAudioFilePropertyAudioDataByteCount: AudioFilePropertyID = 0x62636e74;
/// Indicates the number of packets of audio data in the designated file.
pub const kAudioFilePropertyAudioDataPacketCount: AudioFilePropertyID = 0x70636e74;
/// Indicates the maximum size of a packet for the data in the designated file.
pub const kAudioFilePropertyMaximumPacketSize: AudioFilePropertyID = 0x70737a65;
/// Indicates the byte offset in the file of the designated audio data.
pub const kAudioFilePropertyDataOffset: AudioFilePropertyID = 0x646f6666;
/// An audio channel layout structure.
pub const kAudioFilePropertyChannelLayout: AudioFilePropertyID = 0x636d6170;
/// The default value (`0`) always updates header. If set to `1`, updating the files sizes in the header is not performed every time data is written. Instead, the updating is deferred until the file has been read, optimized, or closed. This process is more efficient, but not as safe. If an application crashes before the size has been updated, the file might not be readable.
pub const kAudioFilePropertyDeferSizeUpdates: AudioFilePropertyID = 0x64737a75;
/// This constant is deprecated in macOS 10.5 and later. Do not use. Instead, use `kAudioFormatProperty_FormatName` (declared in the `AudioFormat.h` header file).
pub const kAudioFilePropertyDataFormatName: AudioFilePropertyID = 0x666e6d65;
/// A list of audio file markers defined in the file.
///
/// ## Discussion
///
/// A list of [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) objects representing audio file markers defined in the file.
///
/// If you access this property, your app is responsible for releasing the [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) objects.
///
/// Use the `NumBytesToNumAudioFileMarkers` and `NumAudioFileMarkersToNumBytes` functions to convert between audio file markers and the equivalent number of bytes.
///
///
pub const kAudioFilePropertyMarkerList: AudioFilePropertyID = 0x6d6b6c73;
/// The list of audio file region values defined in the file.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) objects.
///
/// Use the `NextAudioFileRegion` function to walk through the region list.
///
///
pub const kAudioFilePropertyRegionList: AudioFilePropertyID = 0x72676c73;
/// Passes an audio frame packet translation structure with the `mPacket` field filled out and returns the `mFrame` field. The `mFrameOffsetInPacket` field is ignored.
pub const kAudioFilePropertyPacketToFrame: AudioFilePropertyID = 0x706b6672;
/// Passes an audio frame packet translation structure with the `mFrame` field filled out and returns the `mPacket` and `mFrameOffsetInPacket` fields.
pub const kAudioFilePropertyFrameToPacket: AudioFilePropertyID = 0x6672706b;
pub const kAudioFilePropertyRestrictsRandomAccess: AudioFilePropertyID = 0x72726170;
pub const kAudioFilePropertyPacketToRollDistance: AudioFilePropertyID = 0x706b726c;
pub const kAudioFilePropertyPreviousIndependentPacket: AudioFilePropertyID = 0x70696e64;
pub const kAudioFilePropertyNextIndependentPacket: AudioFilePropertyID = 0x6e696e64;
pub const kAudioFilePropertyPacketToDependencyInfo: AudioFilePropertyID = 0x706b6470;
/// Passes an audio byte packet translation structure with the `mPacket` field filled out and returns the `mByte` field. The `mByteOffsetInPacket` field is ignored. If the value in the `mByte` field is an estimate then the `kBytePacketTranslationFlag_IsEstimate` flag is set in the `mFlags` field.
pub const kAudioFilePropertyPacketToByte: AudioFilePropertyID = 0x706b6279;
/// Passes an audio byte packet translation structure with the `mByte` field filled out and returns the `mPacket` and `mByteOffsetInPacket` fields. If the value in the `mByte` field is an estimate then the `kBytePacketTranslationFlag_IsEstimate` flag is set in the `mFlags` field.
pub const kAudioFilePropertyByteToPacket: AudioFilePropertyID = 0x6279706b;
/// An array of  four-character codes for each kind of chunk in the file.
pub const kAudioFilePropertyChunkIDs: AudioFilePropertyID = 0x63686964;
/// A CF Dictionary with information about the data in the file.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary) object.
///
/// In macOS, an audio file component (of type `AudioFileComponent` is free to add keys to the dictionaries they return for this property.
///
///
pub const kAudioFilePropertyInfoDictionary: AudioFilePropertyID = 0x696e666f;
/// Gets or sets an audio file packet table information structure for its supporting file types. When setting the structure, the sum of the values of the `mNumberValidFrames`, `mPrimingFrames` and `mRemainderFrames` fields must be the same as the total number of frames in all packets. If not, a `paramErr` is returned. To ensure this result, get the value of the property and make sure the sum of the three values you set has the same sum as the three values you got.
pub const kAudioFilePropertyPacketTableInfo: AudioFilePropertyID = 0x706e666f;
/// To support formats such as AAC SBR in which an encoded data stream can be decoded to multiple destination formats, this property’s value is an array of audio format list item values (declared in `AudioFormat.h`) of those formats. Typically, this is an audio format list item with the same audio stream basic description in the `kAudioFilePropertyDataFormat` property.
pub const kAudioFilePropertyFormatList: AudioFilePropertyID = 0x666c7374;
/// The theoretical maximum packet size in the file. This value is obtained without actually scanning the whole file to find the largest packet, as could happen with `kAudioFilePropertyMaximumPacketSize`.
pub const kAudioFilePropertyPacketSizeUpperBound: AudioFilePropertyID = 0x706b7562;
pub const kAudioFilePropertyPacketRangeByteCountUpperBound: AudioFilePropertyID = 0x70727562;
/// The duration in seconds of the data expected to be written. Set this property before any data has been written to reserve space in the file header for a packet table and other information to appear before the audio data. Otherwise, the packet table might get written at the end of the file, preventing the file from being streamable.
pub const kAudioFilePropertyReserveDuration: AudioFilePropertyID = 0x72737276;
/// An estimated duration in seconds. If this duration can be calculated without scanning the entire file, or all the audio data packets have been scanned, the value accurately reflects the duration of the audio data.
pub const kAudioFilePropertyEstimatedDuration: AudioFilePropertyID = 0x65647572;
/// The actual bit rate (number of audio data bits in the file divided by the duration of the file) for some file types, and the nominal bit rate (which bit rate the encoder was set to) for others.
pub const kAudioFilePropertyBitRate: AudioFilePropertyID = 0x62726174;
/// A `void*` value pointing to memory set up by your application to contain a fully formatted ID3 tag.
///
/// ## Discussion
///
/// When setting, this property must be set before calling the [`AudioFileWritePackets`](https://developer.apple.com/documentation/audiotoolbox/audiofilewritepackets(_:_:_:_:_:_:_:)) function. This property is gettable and settable when using ID3 version 2. It is gettable only for version ID3 version 1. A sound file’s ID3 tag itself is not manipulated when getting or setting this property.
///
///
pub const kAudioFilePropertyID3Tag: AudioFilePropertyID = 0x69643374;
pub const kAudioFilePropertyID3TagOffset: AudioFilePropertyID = 0x6964336f;
/// For compressed data, this property’s value is the bit depth of the source, uncompressed audio stream as an `SInt32` value, if known. The bit depth is expressed as a negative number if the uncompressed source was in a floating point format. For example, a property value of `-32` is used for `float` and a property value of `-64` represents `double`.
pub const kAudioFilePropertySourceBitDepth: AudioFilePropertyID = 0x73627464;
/// An object containing the image data for the album artwork associated with an audio file.
///
/// ## Discussion
///
/// A [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata) object containing an image file associated with the audio file.
///
/// The image data is formatted as either JFIF (JPEG) or PNG (PNG). If you access this property, your app is responsible for releasing the [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata) object.
///
///
pub const kAudioFilePropertyAlbumArtwork: AudioFilePropertyID = 0x61617274;
pub const kAudioFilePropertyAudioTrackCount: AudioFilePropertyID = 0x61746374;
pub const kAudioFilePropertyUseAudioTrack: AudioFilePropertyID = 0x7561746b;

extern "C-unwind" {
    /// Gets information about an audio file property, including the size of the property value and whether the value is writable.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file you want to obtain property value information from.
    ///
    /// - inPropertyID: The property whose value information you want. See [Audio File Properties](https://developer.apple.com/documentation/audiotoolbox/1576499-audio-file-properties) for possible values.
    ///
    /// - outDataSize: On output, the size in bytes of the property value.
    ///
    /// - isWritable: On output, equals `1` if the property is writable, or `0` if it is read-only.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    /// Get information about the size of a property of an AudioFile  and whether it can be set.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inPropertyID`: an AudioFileProperty constant.
    ///
    /// Parameter `outDataSize`: the size in bytes of the current value of the property. In order to get the property value,
    /// you will need a buffer of this size.
    ///
    /// Parameter `isWritable`: will be set to 1 if writable, or 0 if read only.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `out_data_size` must be a valid pointer or null.
    /// - `is_writable` must be a valid pointer or null.
    pub fn AudioFileGetPropertyInfo(
        in_audio_file: AudioFileID,
        in_property_id: AudioFilePropertyID,
        out_data_size: *mut u32,
        is_writable: *mut u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the value of an audio file property.
    ///
    /// Parameters:
    /// - inAudioFile: The audio file you want to obtain a property value from.
    ///
    /// - inPropertyID: The property whose value you want. See [Audio File Properties](https://developer.apple.com/documentation/audiotoolbox/1576499-audio-file-properties) for possible values.
    ///
    /// - ioDataSize: On input, the size of the buffer passed in the `outPropertyData` parameter. On output, the number of bytes written to the buffer. Use the [`AudioFileGetPropertyInfo`](https://developer.apple.com/documentation/audiotoolbox/audiofilegetpropertyinfo(_:_:_:_:)) function to obtain the size of the property value.
    ///
    /// - outPropertyData: On output, the value of the property specified in the `inPropertyID` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Some Core Audio property values are C types and others are Core Foundation objects.
    ///
    /// If you call this function to retrieve a value that is a Core Foundation object, then this function—despite the use of “Get” in its name—duplicates the object. You are responsible for releasing the object, as described in [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029) in [Memory Management Programming Guide for Core Foundation](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i).
    ///
    ///
    /// Copies the value for a property of an AudioFile into a buffer.
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inPropertyID`: an AudioFileProperty constant.
    ///
    /// Parameter `ioDataSize`: on input the size of the outPropertyData buffer. On output the number of bytes written to the buffer.
    ///
    /// Parameter `outPropertyData`: the buffer in which to write the property data.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `io_data_size` must be a valid pointer.
    /// - `out_property_data` must be a valid pointer.
    pub fn AudioFileGetProperty(
        in_audio_file: AudioFileID,
        in_property_id: AudioFilePropertyID,
        io_data_size: NonNull<u32>,
        out_property_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the value of an audio file property
    ///
    /// Parameters:
    /// - inAudioFile: The audio file that you want to set a property value for.
    ///
    /// - inPropertyID: The property whose value you want to set. See [Audio File Properties](https://developer.apple.com/documentation/audiotoolbox/1576499-audio-file-properties) for possible values. Use the [`AudioFileGetPropertyInfo`](https://developer.apple.com/documentation/audiotoolbox/audiofilegetpropertyinfo(_:_:_:_:)) function to determine whether the property value is writable.
    ///
    /// - inDataSize: The size of the value you are passing in the `inPropertyData` parameter.
    ///
    /// - inPropertyData: The new value for the property.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    /// Sets the value for a property of an AudioFile .
    ///
    /// Parameter `inAudioFile`: an AudioFileID.
    ///
    /// Parameter `inPropertyID`: an AudioFileProperty constant.
    ///
    /// Parameter `inDataSize`: the size of the property data.
    ///
    /// Parameter `inPropertyData`: the buffer containing the property data.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_audio_file` must be a valid pointer.
    /// - `in_property_data` must be a valid pointer.
    pub fn AudioFileSetProperty(
        in_audio_file: AudioFileID,
        in_property_id: AudioFilePropertyID,
        in_data_size: u32,
        in_property_data: NonNull<c_void>,
    ) -> OSStatus;
}

/// An array of `UInt32` values containing the file types (such as AIFF, WAVE, and so forth) that can be opened for reading.
///
/// ## Discussion
///
/// When accessing this property’s value, you must set the `inSpecifier` parameter to `NULL`.
///
///
pub const kAudioFileGlobalInfo_ReadableTypes: AudioFilePropertyID = 0x61667266;
/// An array of `UInt32` values containing the file types (such as AIFF, WAVE, and so forth) that can be opened for writing.
///
/// ## Discussion
///
/// When accessing this property’s value, you must set the `inSpecifier` parameter to `NULL`.
///
///
pub const kAudioFileGlobalInfo_WritableTypes: AudioFilePropertyID = 0x61667766;
/// The name for the file type.
///
/// ## Discussion
///
/// A [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) object containing the name for the file type.
///
/// If you access this property, your app is responsible for releasing the [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) object.
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type ID containing a file type.
///
///
pub const kAudioFileGlobalInfo_FileTypeName: AudioFilePropertyID = 0x66746e6d;
/// An array of audio stream basic description structures, which contain all the formats for a particular file type and format ID.
///
/// ## Discussion
///
/// The audio stream basic description structures have the following fields filled in: `mFormatID`, `mFormatFlags`, and `mBitsPerChannel` for writing new files. When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type and format ID structure.
///
///
pub const kAudioFileGlobalInfo_AvailableStreamDescriptionsForFormat: AudioFilePropertyID =
    0x73646964;
/// An array of format IDs for formats that can be read.
///
/// ## Discussion
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type ID containing a file type.
///
///
pub const kAudioFileGlobalInfo_AvailableFormatIDs: AudioFilePropertyID = 0x666d6964;
/// A `CFArray` of `CFStrings` containing all recognized file extensions. You can use this array when creating an `NSOpenPanel` (declared in the AppKit’s `NSOpenPanel.h` header file).
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object.
///
/// When accessing this property’s value, you must set the `inSpecifier` parameter to `NULL`.
///
///
pub const kAudioFileGlobalInfo_AllExtensions: AudioFilePropertyID = 0x616c7874;
/// An array of HFS type codes containing all recognized HFS type codes. For more information on HFS type codes, see Audio Toolbox’s `ExtendedAudioFile.h` header file.
///
/// ## Discussion
///
/// When accessing this property’s value, you must set the `inSpecifier` parameter to `NULL`.
///
///
pub const kAudioFileGlobalInfo_AllHFSTypeCodes: AudioFilePropertyID = 0x61686673;
/// A `CFArray` of `CFString` of all UTIs (Universal Type Identifiers) recognized by Audio File Services.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object.
///
/// When accessing this property’s value, you must set the `inSpecifier` parameter to `NULL`.
///
///
pub const kAudioFileGlobalInfo_AllUTIs: AudioFilePropertyID = 0x61757469;
/// A `CFArray` of CF strings of all MIME types are recognized by Audio File Services.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object.
///
/// When accessing this property’s value, you must set the `inSpecifier` parameter to `NULL`.
///
///
pub const kAudioFileGlobalInfo_AllMIMETypes: AudioFilePropertyID = 0x616d696d;
/// A `CFArray` of CF strings containing the recognized file extensions for a specified type.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object.
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type ID containing a file type.
///
///
pub const kAudioFileGlobalInfo_ExtensionsForType: AudioFilePropertyID = 0x66657874;
/// An array of HFS type codes corresponding to a specified file type. The first type in the array is the preferred one to use.
///
/// ## Discussion
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type ID.
///
///
pub const kAudioFileGlobalInfo_HFSTypeCodesForType: AudioFilePropertyID = 0x66686673;
/// A `CFArray` of `CFString` of all Universal Type Identifiers recognized by a specified file type.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object.
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type ID.
///
///
pub const kAudioFileGlobalInfo_UTIsForType: AudioFilePropertyID = 0x66757469;
/// A `CFArray` of `CFString` of all MIME types recognized by a specified file type.
///
/// ## Discussion
///
/// If you access this property, your app is responsible for releasing the [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object.
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an audio file type ID.
///
///
pub const kAudioFileGlobalInfo_MIMETypesForType: AudioFilePropertyID = 0x666d696d;
/// An array of all audio file type IDs that support a specified MIME type.
///
/// ## Discussion
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to a `CFStringRef` containing a MIME Type.
///
///
pub const kAudioFileGlobalInfo_TypesForMIMEType: AudioFilePropertyID = 0x746d696d;
/// An array of all audio file type IDs that support a specified UTI.
///
/// ## Discussion
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to a `CFStringRef` containing a Universal Type Identifier.
///
///
pub const kAudioFileGlobalInfo_TypesForUTI: AudioFilePropertyID = 0x74757469;
/// An array of all audio file type IDs that support a specified `HFSTypeCode`.
///
/// ## Discussion
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to an `HFSTypeCode`.
///
///
pub const kAudioFileGlobalInfo_TypesForHFSTypeCode: AudioFilePropertyID = 0x74686673;
/// An array of all audio file type IDs that support a specified filename extension.
///
/// ## Discussion
///
/// When accessing this property, provide a pointer, in the `inSpecifier` parameter, to a `CFStringRef` containing a filename extension.
///
///
pub const kAudioFileGlobalInfo_TypesForExtension: AudioFilePropertyID = 0x74657874;

/// A specifier for the constant[`kAudioFileGlobalInfo_AvailableStreamDescriptionsForFormat`](https://developer.apple.com/documentation/audiotoolbox/kaudiofileglobalinfo_availablestreamdescriptionsforformat).
///
/// ## Overview
///
/// This structure specifies a desired audio file type and data format ID so you can obtain a list of stream descriptions of available formats.
///
///
/// This is used as a specifier for kAudioFileGlobalInfo_AvailableStreamDescriptions
///
/// This struct is used to specify a desired audio file type and data format ID  so
/// that a list of stream descriptions of available formats can be obtained.
///
/// a four char code for the file type such as kAudioFileAIFFType, kAudioFileCAFType, etc.
///
/// a four char code for the format ID such as kAudioFormatLinearPCM, kAudioFormatMPEG4AAC, etc.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioFileTypeAndFormatID {
    pub mFileType: AudioFileTypeID,
    pub mFormatID: u32,
}

unsafe impl Encode for AudioFileTypeAndFormatID {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioFileTypeAndFormatID",
        &[<AudioFileTypeID>::ENCODING, <u32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioFileTypeAndFormatID {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Gets the size of a global audio file property.
    ///
    /// Parameters:
    /// - inPropertyID: The property whose data size you want to get. For possible values, see [Audio File Global Info Properties](https://developer.apple.com/documentation/audiotoolbox/1576495-audio-file-global-info-propertie).
    ///
    /// - inSpecifierSize: The size of the specifier data.
    ///
    /// - inSpecifier: A pointer to a _specifier_ (a pointer to a buffer containing some data which is different for each property. The type of the data required is described in the description of each property.)
    ///
    /// - outDataSize: A pointer to the size in bytes of the current value of the property. To get the size of the property value,  you need a buffer of this size.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function can be used to get information about the capabilities of Audio File Service data types, for example, to determine which file types can take which data formats.
    ///
    ///
    /// Get the size of a global property.
    ///
    /// Parameter `inPropertyID`: an AudioFileGlobalInfo property constant.
    ///
    /// Parameter `inSpecifierSize`: The size of the specifier data.
    ///
    /// Parameter `inSpecifier`: A specifier is a buffer of data used as an input argument to some of the global info properties.
    ///
    /// Parameter `outDataSize`: the size in bytes of the current value of the property. In order to get the property value,
    /// you will need a buffer of this size.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_specifier` must be a valid pointer or null.
    /// - `out_data_size` must be a valid pointer.
    pub fn AudioFileGetGlobalInfoSize(
        in_property_id: AudioFilePropertyID,
        in_specifier_size: u32,
        in_specifier: *mut c_void,
        out_data_size: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Copies the value of a global property into a buffer.
    ///
    /// Parameters:
    /// - inPropertyID: The property whose value you want to get. For possible values, see [Audio File Global Info Properties](https://developer.apple.com/documentation/audiotoolbox/1576495-audio-file-global-info-propertie).
    ///
    /// - inSpecifierSize: The size of the specifier data.
    ///
    /// - inSpecifier: A pointer to a _specifier_, which, in this context, is a pointer to a buffer containing some data that is different for each property. The type of the data required is described in the description of each property.
    ///
    /// - ioDataSize: On input, a pointer to the size of the buffer specified in the outPropertyData parameter. On output, a pointer to the number of bytes written to the buffer.
    ///
    /// - outPropertyData: A pointer to the buffer in which to write the property data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See Result Codes.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function can be used to get information about the capabilities of Audio File Services data types, for example, to determine which file types can take which data formats, what file types are supported, what file type can hold a particular data type, and so forth. This function cannot be used to get information about the properties of particular files. So the properties whose information you are obtaining are global to the Audio File Services programming interface, not properties specific to any file.
    ///
    /// ### Special Considerations
    ///
    /// Some Core Audio property values are C types and others are Core Foundation objects.
    ///
    /// If you call this function to retrieve a value that is a Core Foundation object, then this function—despite the use of “Get” in its name—duplicates the object. You are responsible for releasing the object, as described in [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029) in [Memory Management Programming Guide for Core Foundation](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i).
    ///
    ///
    /// Copies the value for a global property into a buffer.
    ///
    /// Parameter `inPropertyID`: an AudioFileGlobalInfo property constant.
    ///
    /// Parameter `inSpecifierSize`: The size of the specifier data.
    ///
    /// Parameter `inSpecifier`: A specifier is a buffer of data used as an input argument to some of the global info properties.
    ///
    /// Parameter `ioDataSize`: on input the size of the outPropertyData buffer. On output the number of bytes written to the buffer.
    ///
    /// Parameter `outPropertyData`: the buffer in which to write the property data.
    ///
    /// Returns: returns noErr if successful.
    ///
    /// # Safety
    ///
    /// - `in_specifier` must be a valid pointer or null.
    /// - `io_data_size` must be a valid pointer.
    /// - `out_property_data` must be a valid pointer.
    pub fn AudioFileGetGlobalInfo(
        in_property_id: AudioFilePropertyID,
        in_specifier_size: u32,
        in_specifier: *mut c_void,
        io_data_size: NonNull<u32>,
        out_property_data: NonNull<c_void>,
    ) -> OSStatus;
}
