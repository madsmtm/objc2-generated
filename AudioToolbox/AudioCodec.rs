//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;

use crate::*;

pub const kAudioSettings_TopLevelKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAudioSettings_Version: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"version\0") };
pub const kAudioSettings_Parameters: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"parameters\0") };
pub const kAudioSettings_SettingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"key\0") };
pub const kAudioSettings_SettingName: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAudioSettings_ValueType: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"value type\0") };
pub const kAudioSettings_AvailableValues: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"available values\0") };
pub const kAudioSettings_LimitedValues: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"limited values\0") };
pub const kAudioSettings_CurrentValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"current value\0") };
pub const kAudioSettings_Summary: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"summary\0") };
pub const kAudioSettings_Hint: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"hint\0") };
pub const kAudioSettings_Unit: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"unit\0") };
/// An instance of a Component Manager component.
#[cfg(feature = "AudioComponent")]
pub type AudioCodec = AudioComponentInstance;

/// An integer identifying an audio codec property.
pub type AudioCodecPropertyID = u32;

/// A structure holding magic cookie information needed by some codecs.
///
/// ## Overview
///
/// This structure is passed as input to the [`AudioCodecGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetproperty(_:_:_:_:)) function for the `kAudioCodecPropertyFormatList` property. The first `4 + sizeof(void *)` bytes of the buffer pointed to by the function’s `outPropertyData` parameter contains this structure on input.
///
///
/// Structure holding the
/// <em>
/// magic cookie
/// </em>
/// information.
///
///
/// Passed as input to AudioCodecGetProperty for kAudioCodecPropertyFormatList.
/// The first four + sizeof(void *) bytes of the buffer pointed at by outPropertyData
/// will contain this struct.
///
///
/// The size of the magic cookie
///
/// Generic const pointer to magic cookie
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioCodecMagicCookieInfo {
    pub mMagicCookieSize: u32,
    pub mMagicCookie: *const c_void,
}

unsafe impl Encode for AudioCodecMagicCookieInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioCodecMagicCookieInfo",
        &[<u32>::ENCODING, <*const c_void>::ENCODING],
    );
}

unsafe impl RefEncode for AudioCodecMagicCookieInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A codec that translates data in some other format into linear PCM.
///
/// ## Discussion
///
/// The component subtype specifies the input format.
///
///
pub const kAudioDecoderComponentType: u32 = 0x61646563;
/// A codec that translates linear PCM data into some other format
///
/// ## Discussion
///
/// The component subtype specifies the output format.
///
///
pub const kAudioEncoderComponentType: u32 = 0x61656e63;
pub const kAudioUnityCodecComponentType: u32 = 0x61636463;

pub const kAudioCodecPropertySupportedInputFormats: AudioCodecPropertyID = 0x69666d23;
pub const kAudioCodecPropertySupportedOutputFormats: AudioCodecPropertyID = 0x6f666d23;
pub const kAudioCodecPropertyAvailableInputSampleRates: AudioCodecPropertyID = 0x61697372;
pub const kAudioCodecPropertyAvailableOutputSampleRates: AudioCodecPropertyID = 0x616f7372;
pub const kAudioCodecPropertyAvailableBitRateRange: AudioCodecPropertyID = 0x61627274;
pub const kAudioCodecPropertyMinimumNumberInputPackets: AudioCodecPropertyID = 0x6d6e6970;
pub const kAudioCodecPropertyMinimumNumberOutputPackets: AudioCodecPropertyID = 0x6d6e6f70;
pub const kAudioCodecPropertyAvailableNumberChannels: AudioCodecPropertyID = 0x636d6e63;
pub const kAudioCodecPropertyDoesSampleRateConversion: AudioCodecPropertyID = 0x6c6d7263;
pub const kAudioCodecPropertyAvailableInputChannelLayoutTags: AudioCodecPropertyID = 0x6169636c;
pub const kAudioCodecPropertyAvailableOutputChannelLayoutTags: AudioCodecPropertyID = 0x616f636c;
pub const kAudioCodecPropertyInputFormatsForOutputFormat: AudioCodecPropertyID = 0x6966346f;
pub const kAudioCodecPropertyOutputFormatsForInputFormat: AudioCodecPropertyID = 0x6f663469;
pub const kAudioCodecPropertyFormatInfo: AudioCodecPropertyID = 0x61636669;

pub const kAudioCodecPropertyInputBufferSize: AudioCodecPropertyID = 0x74627566;
pub const kAudioCodecPropertyPacketFrameSize: AudioCodecPropertyID = 0x70616b66;
pub const kAudioCodecPropertyHasVariablePacketByteSizes: AudioCodecPropertyID = 0x76706b3f;
pub const kAudioCodecPropertyEmploysDependentPackets: AudioCodecPropertyID = 0x64706b3f;
pub const kAudioCodecPropertyMaximumPacketByteSize: AudioCodecPropertyID = 0x70616b62;
pub const kAudioCodecPropertyPacketSizeLimitForVBR: AudioCodecPropertyID = 0x70616b6c;
pub const kAudioCodecPropertyCurrentInputFormat: AudioCodecPropertyID = 0x69666d74;
pub const kAudioCodecPropertyCurrentOutputFormat: AudioCodecPropertyID = 0x6f666d74;
pub const kAudioCodecPropertyMagicCookie: AudioCodecPropertyID = 0x6b756b69;
pub const kAudioCodecPropertyUsedInputBufferSize: AudioCodecPropertyID = 0x75627566;
pub const kAudioCodecPropertyIsInitialized: AudioCodecPropertyID = 0x696e6974;
pub const kAudioCodecPropertyCurrentTargetBitRate: AudioCodecPropertyID = 0x62726174;
pub const kAudioCodecPropertyCurrentInputSampleRate: AudioCodecPropertyID = 0x63697372;
pub const kAudioCodecPropertyCurrentOutputSampleRate: AudioCodecPropertyID = 0x636f7372;
pub const kAudioCodecPropertyQualitySetting: AudioCodecPropertyID = 0x73726371;
pub const kAudioCodecPropertyApplicableBitRateRange: AudioCodecPropertyID = 0x62727461;
pub const kAudioCodecPropertyRecommendedBitRateRange: AudioCodecPropertyID = 0x62727472;
pub const kAudioCodecPropertyApplicableInputSampleRates: AudioCodecPropertyID = 0x69737261;
pub const kAudioCodecPropertyApplicableOutputSampleRates: AudioCodecPropertyID = 0x6f737261;
pub const kAudioCodecPropertyPaddedZeros: AudioCodecPropertyID = 0x70616430;
pub const kAudioCodecPropertyPrimeMethod: AudioCodecPropertyID = 0x70726d6d;
pub const kAudioCodecPropertyPrimeInfo: AudioCodecPropertyID = 0x7072696d;
pub const kAudioCodecPropertyCurrentInputChannelLayout: AudioCodecPropertyID = 0x69636c20;
pub const kAudioCodecPropertyCurrentOutputChannelLayout: AudioCodecPropertyID = 0x6f636c20;
pub const kAudioCodecPropertySettings: AudioCodecPropertyID = 0x61637320;
pub const kAudioCodecPropertyFormatList: AudioCodecPropertyID = 0x6163666c;
pub const kAudioCodecPropertyBitRateControlMode: AudioCodecPropertyID = 0x61636266;
pub const kAudioCodecPropertySoundQualityForVBR: AudioCodecPropertyID = 0x76627271;
pub const kAudioCodecPropertyBitRateForVBR: AudioCodecPropertyID = 0x76627262;
pub const kAudioCodecPropertyDelayMode: AudioCodecPropertyID = 0x646d6f64;
pub const kAudioCodecPropertyAdjustLocalQuality: AudioCodecPropertyID = 0x5e71616c;
pub const kAudioCodecPropertyDynamicRangeControlMode: AudioCodecPropertyID = 0x6d647263;
pub const kAudioCodecPropertyAdjustCompressionProfile: AudioCodecPropertyID = 0x5e70726f;
pub const kAudioCodecPropertyProgramTargetLevelConstant: AudioCodecPropertyID = 0x70746c63;
pub const kAudioCodecPropertyAdjustTargetLevelConstant: AudioCodecPropertyID = 0x5e746c63;
pub const kAudioCodecPropertyProgramTargetLevel: AudioCodecPropertyID = 0x7070746c;
pub const kAudioCodecPropertyAdjustTargetLevel: AudioCodecPropertyID = 0x5e70746c;
pub const kAudioCodecPropertyDynamicRangeControlConfiguration: AudioCodecPropertyID = 0x63647263;
pub const kAudioCodecPropertyContentSource: AudioCodecPropertyID = 0x63737263;
pub const kAudioCodecPropertyASPFrequency: AudioCodecPropertyID = 0x61737066;

pub const kAudioCodecQuality_Max: u32 = 0x7F;
pub const kAudioCodecQuality_High: u32 = 0x60;
pub const kAudioCodecQuality_Medium: u32 = 0x40;
pub const kAudioCodecQuality_Low: u32 = 0x20;
pub const kAudioCodecQuality_Min: u32 = 0;

pub const kAudioCodecPrimeMethod_Pre: u32 = 0;
pub const kAudioCodecPrimeMethod_Normal: u32 = 1;
pub const kAudioCodecPrimeMethod_None: u32 = 2;

pub const kAudioCodecBitRateControlMode_Constant: u32 = 0;
pub const kAudioCodecBitRateControlMode_LongTermAverage: u32 = 1;
pub const kAudioCodecBitRateControlMode_VariableConstrained: u32 = 2;
pub const kAudioCodecBitRateControlMode_Variable: u32 = 3;

pub const kAudioCodecDelayMode_Compatibility: u32 = 0;
pub const kAudioCodecDelayMode_Minimum: u32 = 1;
pub const kAudioCodecDelayMode_Optimal: u32 = 2;

pub const kProgramTargetLevel_None: u32 = 0;
pub const kProgramTargetLevel_Minus31dB: u32 = 1;
pub const kProgramTargetLevel_Minus23dB: u32 = 2;
pub const kProgramTargetLevel_Minus20dB: u32 = 3;

pub const kDynamicRangeControlMode_None: u32 = 0;
pub const kDynamicRangeControlMode_Light: u32 = 1;
pub const kDynamicRangeControlMode_Heavy: u32 = 2;

pub const kDynamicRangeCompressionProfile_None: u32 = 0;
pub const kDynamicRangeCompressionProfile_LateNight: u32 = 1;
pub const kDynamicRangeCompressionProfile_NoisyEnvironment: u32 = 2;
pub const kDynamicRangeCompressionProfile_LimitedPlaybackRange: u32 = 3;
pub const kDynamicRangeCompressionProfile_GeneralCompression: u32 = 6;

pub const kAudioCodecDynamicRangeControlConfiguration_None: u32 = 0;
pub const kAudioCodecDynamicRangeControlConfiguration_Music: u32 = 1;
pub const kAudioCodecDynamicRangeControlConfiguration_Speech: u32 = 2;
pub const kAudioCodecDynamicRangeControlConfiguration_Movie: u32 = 3;
pub const kAudioCodecDynamicRangeControlConfiguration_Capture: u32 = 4;

pub const kAudioCodecContentSource_Unspecified: i32 = -1;
pub const kAudioCodecContentSource_Reserved: i32 = 0;
pub const kAudioCodecContentSource_AppleCapture_Traditional: i32 = 1;
pub const kAudioCodecContentSource_AppleCapture_Spatial: i32 = 2;
pub const kAudioCodecContentSource_AppleCapture_Spatial_Enhanced: i32 = 3;
pub const kAudioCodecContentSource_AppleMusic_Traditional: i32 = 4;
pub const kAudioCodecContentSource_AppleMusic_Spatial: i32 = 5;
pub const kAudioCodecContentSource_AppleAV_Traditional_Offline: i32 = 6;
pub const kAudioCodecContentSource_AppleAV_Spatial_Offline: i32 = 7;
pub const kAudioCodecContentSource_AppleAV_Traditional_Live: i32 = 8;
pub const kAudioCodecContentSource_AppleAV_Spatial_Live: i32 = 9;
pub const kAudioCodecContentSource_ApplePassthrough: i32 = 10;
pub const kAudioCodecContentSource_Capture_Traditional: i32 = 33;
pub const kAudioCodecContentSource_Capture_Spatial: i32 = 34;
pub const kAudioCodecContentSource_Capture_Spatial_Enhanced: i32 = 35;
pub const kAudioCodecContentSource_Music_Traditional: i32 = 36;
pub const kAudioCodecContentSource_Music_Spatial: i32 = 37;
pub const kAudioCodecContentSource_AV_Traditional_Offline: i32 = 38;
pub const kAudioCodecContentSource_AV_Spatial_Offline: i32 = 39;
pub const kAudioCodecContentSource_AV_Traditional_Live: i32 = 40;
pub const kAudioCodecContentSource_AV_Spatial_Live: i32 = 41;
pub const kAudioCodecContentSource_Passthrough: i32 = 42;

/// A structure specifying the number of leading and trailing empty frames to be inserted.
/// Specifies the number of leading and trailing empty frames
/// which have to be inserted.
///
///
/// An unsigned integer specifying the number of leading empty frames
///
/// An unsigned integer specifying the number of trailing empty frames
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioCodecPrimeInfo {
    pub leadingFrames: u32,
    pub trailingFrames: u32,
}

unsafe impl Encode for AudioCodecPrimeInfo {
    const ENCODING: Encoding =
        Encoding::Struct("AudioCodecPrimeInfo", &[<u32>::ENCODING, <u32>::ENCODING]);
}

unsafe impl RefEncode for AudioCodecPrimeInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants to be used with kAudioSettings_Hint
/// in the kAudioCodecPropertySettings property dictionary.
/// Indicates any special characteristics of each parameter within the dictionary,
///
///
/// If set, then the parameter is an expert parameter.
///
/// If set, then the parameter should not be displayed.
///
/// If set, then changing this parameter may affect the values of other parameters.
/// If not set, then this parameter can be set without affecting the values of other parameters.
///
/// If set, then this is only a user interface element and not reflected in the codec's bit stream.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioSettingsFlags(pub u32);
bitflags::bitflags! {
    impl AudioSettingsFlags: u32 {
        #[doc(alias = "kAudioSettingsFlags_ExpertParameter")]
        const ExpertParameter = 1<<0;
        #[doc(alias = "kAudioSettingsFlags_InvisibleParameter")]
        const InvisibleParameter = 1<<1;
        #[doc(alias = "kAudioSettingsFlags_MetaParameter")]
        const MetaParameter = 1<<2;
        #[doc(alias = "kAudioSettingsFlags_UserInterfaceParameter")]
        const UserInterfaceParameter = 1<<3;
    }
}

unsafe impl Encode for AudioSettingsFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioSettingsFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioCodecProduceOutputPacketFailure: u32 = 1;
pub const kAudioCodecProduceOutputPacketSuccess: u32 = 2;
pub const kAudioCodecProduceOutputPacketSuccessHasMore: u32 = 3;
pub const kAudioCodecProduceOutputPacketNeedsMoreInputData: u32 = 4;
pub const kAudioCodecProduceOutputPacketAtEOF: u32 = 5;
pub const kAudioCodecProduceOutputPacketSuccessConcealed: u32 = 6;

pub const kAudioCodecGetPropertyInfoSelect: u32 = 0x0001;
pub const kAudioCodecGetPropertySelect: u32 = 0x0002;
pub const kAudioCodecSetPropertySelect: u32 = 0x0003;
pub const kAudioCodecInitializeSelect: u32 = 0x0004;
pub const kAudioCodecUninitializeSelect: u32 = 0x0005;
pub const kAudioCodecAppendInputDataSelect: u32 = 0x0006;
pub const kAudioCodecProduceOutputDataSelect: u32 = 0x0007;
pub const kAudioCodecResetSelect: u32 = 0x0008;
pub const kAudioCodecAppendInputBufferListSelect: u32 = 0x0009;
pub const kAudioCodecProduceOutputBufferListSelect: u32 = 0x000A;

pub const kAudioCodecNoError: OSStatus = 0;
pub const kAudioCodecUnspecifiedError: OSStatus = 0x77686174;
pub const kAudioCodecUnknownPropertyError: OSStatus = 0x77686f3f;
pub const kAudioCodecBadPropertySizeError: OSStatus = 0x2173697a;
pub const kAudioCodecIllegalOperationError: OSStatus = 0x6e6f7065;
pub const kAudioCodecUnsupportedFormatError: OSStatus = 0x21646174;
pub const kAudioCodecStateError: OSStatus = 0x21737474;
pub const kAudioCodecNotEnoughBufferSpaceError: OSStatus = 0x21627566;
pub const kAudioCodecBadDataError: OSStatus = 0x62616461;

extern "C-unwind" {
    /// Retrieves information about a codec property.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    /// - inPropertyID: Property ID of the property about which you want to obtain information. Codec property IDs are listed in [Global Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494121-global-codec-properties) and [Instance Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494111-instance-codec-properties).
    ///
    /// - outSize: On return, size in bytes of the current value of the property.
    ///
    /// - outWritable: Returns `true` if you can change the value of the property, otherwise `false`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful, otherwise, a result code. See `Result Codes` for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Call this function to:
    ///
    /// - get the size of a property value before calling [`AudioCodecGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetproperty(_:_:_:_:)) to retrieve the value
    ///
    /// - find out if a property value can be modified before calling [`AudioCodecSetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecsetproperty(_:_:_:_:)) to set the value
    ///
    ///
    /// Retrieve information about the given property. The outSize argument
    /// will return the size in bytes of the current value of the property.
    /// The outWritable argument will return whether or not the property
    /// in question can be changed.
    ///
    ///
    /// Parameter `inCodec`: An AudioCodec instance
    ///
    /// Parameter `inPropertyID`: Property ID whose value should be read
    ///
    /// Parameter `outSize`: Size in bytes of the property
    ///
    /// Parameter `outWritable`: Flag indicating wether the underlying property can be modified or not
    ///
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `out_size` must be a valid pointer or null.
    /// - `out_writable` must be a valid pointer or null.
    #[cfg(feature = "AudioComponent")]
    pub fn AudioCodecGetPropertyInfo(
        in_codec: AudioCodec,
        in_property_id: AudioCodecPropertyID,
        out_size: *mut u32,
        out_writable: *mut Boolean,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Retrieves the value of a codec property.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    /// - inPropertyID: Property ID of the property whose value you want to obtain. Codec property IDs are listed in [Global Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494121-global-codec-properties) and [Instance Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494111-instance-codec-properties).
    ///
    /// - ioPropertyDataSize: On input, the size in bytes of the data buffer pointed to by the `outPropertyData` parameter. On output, the amount of data actually written to the buffer.
    ///
    /// - outPropertyData: The property data buffer.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful, otherwise, a result code. See `Result Codes` for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// All property values can be read regardless of the state of the codec. However, the values of some properties depend on whether the codec is initialized. Before calling this function, call the [`AudioCodecGetPropertyInfo`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetpropertyinfo(_:_:_:_:)) function to determine the size of buffer you need for the property value.
    ///
    ///
    /// Retrieve the indicated property data. On input, ioDataSize has the size
    /// of the data pointed to by outPropertyData. On output, ioDataSize will contain
    /// the amount written.
    ///
    ///
    /// Parameter `inCodec`: An AudioCodec instance
    ///
    /// Parameter `inPropertyID`: Property ID whose value should be read
    ///
    /// Parameter `ioPropertyDataSize`: Size in bytes of the property data
    ///
    /// Parameter `outPropertyData`: Pointer to the property data buffer
    ///
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `io_property_data_size` must be a valid pointer.
    /// - `out_property_data` must be a valid pointer.
    #[cfg(feature = "AudioComponent")]
    pub fn AudioCodecGetProperty(
        in_codec: AudioCodec,
        in_property_id: AudioCodecPropertyID,
        io_property_data_size: NonNull<u32>,
        out_property_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the value of a codec property.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    /// - inPropertyID: Property ID of the property whose value you want to set. Settable codec property IDs are listed in [Instance Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494111-instance-codec-properties).
    ///
    /// - inPropertyDataSize: Size in bytes of the property value data.
    ///
    /// - inPropertyData: Pointer to the data buffer containing the property value.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful, otherwise, a result code. See `Result Codes` for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Codec properties are classified as either global properties, which remain the same for all instances of a codec, or instance properties, which may vary from instance to instance. However, not all instance property values can be modified. See [Instance Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494111-instance-codec-properties) for details. No property values can be modified when the codec is in the initialized state. You must call this function before you call the [`AudioCodecInitialize`](https://developer.apple.com/documentation/audiotoolbox/audiocodecinitialize(_:_:_:_:_:)) function, or after you call the [`AudioCodecUninitialize`](https://developer.apple.com/documentation/audiotoolbox/audiocodecuninitialize(_:)) function. Call the [`AudioCodecGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetproperty(_:_:_:_:)) function to retrieve the current value of a property.
    ///
    ///
    /// Set the indicated property data.
    ///
    ///
    /// Parameter `inCodec`: An AudioCodec instance
    ///
    /// Parameter `inPropertyID`: Property ID whose value should be changed
    ///
    /// Parameter `inPropertyDataSize`: Size in bytes of the property data
    ///
    /// Parameter `inPropertyData`: Pointer to the property data buffer
    ///
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `in_property_data` must be a valid pointer.
    #[cfg(feature = "AudioComponent")]
    pub fn AudioCodecSetProperty(
        in_codec: AudioCodec,
        in_property_id: AudioCodecPropertyID,
        in_property_data_size: u32,
        in_property_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets up the specified codec to perform a data format translation.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manager component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    /// - inInputFormat: A structure that describes the format of the input data. See [Core Audio Data Types](https://developer.apple.com/documentation/coreaudio/core-audio-data-types) for a description of this structure and the values of constants that can be used in this structure. If the input data has a variable number of frames per packet, this structure is supplemented with the `AudioStreamPacketDescription` structure passed in the `inPacketDescription` parameter of the [`AudioCodecAppendInputData`](https://developer.apple.com/documentation/audiotoolbox/audiocodecappendinputdata(_:_:_:_:_:)) function.
    ///
    /// - inOutputFormat: A structure that describes the format desired for the output data.
    ///
    /// - inMagicCookie: Magic cookie data, if required for the input format.
    ///
    /// - inMagicCookieByteSize: Size in bytes of the magic cookie data, if any.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful. Returns `kAudioCodecUnsupportedFormatError` if the codec cannot handle the specified data translation.  See `Result Codes` for other possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function allocates any buffers needed, sets the input and output formats, and puts the codec into the initialized state. The codec has to be in the initialized state for the  [`AudioCodecAppendInputData`](https://developer.apple.com/documentation/audiotoolbox/audiocodecappendinputdata(_:_:_:_:_:)) and [`AudioCodecProduceOutputPackets`](https://developer.apple.com/documentation/audiotoolbox/audiocodecproduceoutputpackets(_:_:_:_:_:_:)) functions to work. While in this state, the format information for the translation cannot be changed; you must call the [`AudioCodecUninitialize`](https://developer.apple.com/documentation/audiotoolbox/audiocodecuninitialize(_:)) function before making any changes. A codec’s properties provide information about allowable types of input and output, magic cookies, and so forth. Use the [`AudioCodecGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetproperty(_:_:_:_:)) function to read a codec’s properties. The properties are described in [Global Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494121-global-codec-properties) and [Instance Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494111-instance-codec-properties).
    ///
    /// If any argument is `NULL`, any values previously set for that argument are used. For example, if you are using the same codec repeatedly with the same input and output formats, you only need to enter the formats the first time you initialize the codec. After that, you can uninitialize, change property values as necessary, and then call this function again with `NULL` in the `inInputFormat` and `inOutputFormat` parameters before processing the next set of data.
    ///
    ///
    /// This call will allocate any buffers needed and otherwise set the codec
    /// up to perform the indicated translation. If an argument is NULL, any
    /// previously set properties will be used for preparing the codec for work.
    /// Note that this routine will also validate the format information as useable.
    ///
    ///
    /// Parameter `inCodec`: An AudioCodec instance
    ///
    /// Parameter `inInputFormat`: Pointer to an input format structure
    ///
    /// Parameter `inOutputFormat`: Pointer to an output format structure
    ///
    /// Parameter `inMagicCookie`: Pointer to the magic cookie
    ///
    /// Parameter `inMagicCookieByteSize`: Size in bytes of the magic cookie
    ///
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `in_input_format` must be a valid pointer or null.
    /// - `in_output_format` must be a valid pointer or null.
    /// - `in_magic_cookie` must be a valid pointer or null.
    #[cfg(all(feature = "AudioComponent", feature = "objc2-core-audio-types"))]
    pub fn AudioCodecInitialize(
        in_codec: AudioCodec,
        in_input_format: *const AudioStreamBasicDescription,
        in_output_format: *const AudioStreamBasicDescription,
        in_magic_cookie: *const c_void,
        in_magic_cookie_byte_size: u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Moves the codec from the initialized state back to the uninitialized state.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful, otherwise, a result code. See `Result Codes` for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns the codec to the uninitialized state. The codec may then be configured freely. This function does not flush the input buffer or clear input and output formats, magic cookie data, and other state variables. It is not necessary to call this function before closing the codec.
    ///
    ///
    /// This call will move the codec from the initialized state back to the
    /// uninitialized state. The codec will release any resources it allocated
    /// or claimed in AudioCodecInitialize.
    ///
    ///
    /// Parameter `inCodec`: An AudioCodec instance
    ///
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// `in_codec` must be a valid pointer.
    #[cfg(feature = "AudioComponent")]
    pub fn AudioCodecUninitialize(in_codec: AudioCodec) -> OSStatus;
}

extern "C-unwind" {
    /// Appends audio data to the codec’s input buffer.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    /// - inInputData: The audio data to be sent to the codec.  Indicate there is no more data to process by passing a buffer of `0`bytes.
    ///
    /// - ioInputDataByteSize: On input, the size in bytes of the data pointed to by the `inInputData` parameter. On output, the number of bytes the codec actually appended to its input buffer.
    ///
    /// - ioNumberPackets: On input, the number of elements in the `inPacketDescription` array. Pass `NULL` for this parameter if the input data has a constant number of frames per packet. On return, the number of packets actually processed by the codec.
    ///
    /// - inPacketDescription: For audio data that has a variable number of frames per packet, an array of `AudioStreamPacketDescription` structures that describes the packet layout. Pass `NULL` for this parameter if the input data has a constant number of frames per packet.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful. Returns `kAudioCodecStateError` if the codec has not been initialized. See `Result Codes` for other possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A packet is the smallest, indivisible block of data for a given audio format. For linear PCM (pulse-code modulated) data, each packet contains exactly one frame, where a frame is a set of samples representing one sample for each channel. For compressed audio data formats, the number of frames in a packet depends on the encoding. For example, a packet of AAC represents 1024 frames of PCM. In some formats, the number of frames per packet varies. For such formats, you must include an array of `AudioStreamPacketDescription` structures that describes the packet layout.
    ///
    /// Input data can be fed into an encoder and some decoders in blocks of any size (even byte by byte). However, if the encoded format of the input data fed to a decoder has a variable number of frames per packet, the data must be provided in multiples of whole packets. A codec’s properties provide information about allowable types of input and output, minimum and maximum buffer sizes, and so forth. Use the [`AudioCodecGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetproperty(_:_:_:_:)) function to read a codec’s properties. The properties are described in [Global Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494121-global-codec-properties) and [Instance Codec Properties](https://developer.apple.com/documentation/audiotoolbox/1494111-instance-codec-properties).
    ///
    /// The combination of the [`AudioCodecAppendInputData`](https://developer.apple.com/documentation/audiotoolbox/audiocodecappendinputdata(_:_:_:_:_:)) and [`AudioCodecProduceOutputPackets`](https://developer.apple.com/documentation/audiotoolbox/audiocodecproduceoutputpackets(_:_:_:_:_:_:)) functions implement a “push-pull” model of data handling. First, the input data is pushed into the codec, then the resulting output data is pulled out of that same codec.
    ///
    ///
    /// Append as much of the given data in inInputData to the codec's input buffer as possible
    /// and return in ioInputDataByteSize the amount of data used.
    ///
    /// The inPacketDescription argument is an array of AudioStreamPacketDescription
    /// structs that describes the packet layout. The number of elements in this array
    /// is indicated on input by ioNumberPackets. On return, this number indicates the number
    /// of packets consumed.
    ///
    /// Note also in this case that it is an error to supply less than a full packet
    /// of data at a time.
    ///
    ///
    /// Parameter `inCodec`: An AudioCodec instance
    ///
    /// Parameter `inInputData`: A const pointer to the input data
    ///
    /// Parameter `ioInputDataByteSize`: The size in bytes of the input data in inInputData on input,
    /// the number of bytes consumed on output
    ///
    /// Parameter `ioNumberPackets`: The number of packets
    ///
    /// Parameter `inPacketDescription`: The packet description pointer
    ///
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `in_input_data` must be a valid pointer.
    /// - `io_input_data_byte_size` must be a valid pointer.
    /// - `io_number_packets` must be a valid pointer.
    /// - `in_packet_description` must be a valid pointer or null.
    #[cfg(all(feature = "AudioComponent", feature = "objc2-core-audio-types"))]
    pub fn AudioCodecAppendInputData(
        in_codec: AudioCodec,
        in_input_data: NonNull<c_void>,
        io_input_data_byte_size: NonNull<u32>,
        io_number_packets: NonNull<u32>,
        in_packet_description: *const AudioStreamPacketDescription,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Retrieves output data from a codec.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    /// - outOutputData: The output data buffer.
    ///
    /// - ioOutputDataByteSize: Indicates the size of the output data buffer.
    ///
    /// - ioNumberPackets: On input, the number of packets desired. On output, the number of packets actually placed in the output buffer.
    ///
    /// - outPacketDescription: An array of `AudioStreamPacketDescription` structures that describes the packet layout of the data returned by the `outOutputData` parameter. Pass `NULL` if you do not want this information returned. Note that this information is provided only when the output format is not linear PCM.
    ///
    /// - outStatus: On output, information about the codec’s status to allow for proper data management. See [Output Status Constants](https://developer.apple.com/documentation/audiotoolbox/1494122-output-status-constants) for the possible values that can be returned.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful. Returns `kAudioCodecStateError` if the codec has not been initialized. Returns `kAudioCodecNotEnoughBufferSpaceError` if the output buffer is not large enough for the requested number of packets. See `Result Codes` for other possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function causes the codec to produce as many output packets as requested, provided there is sufficient input data. If there is not enough input data to produce the requested number of output packets, the `outStatus` parameter returns the value `kAudioCodecProduceOutputPacketNeedsMoreInputData` and the `ioNumberPackets` parameter indicates the actual number of packets produced. On the other hand, if there is enough input data to produce at least one additional full packet, the `outStatus` parameter returns the value `kAudioCodecProduceOutputPacketSuccessHasMore`.
    ///
    /// Note that decoders produce linear PCM data only in multiples of the number of frames in a packet of the encoded format. (See the [`AudioCodecAppendInputData`](https://developer.apple.com/documentation/audiotoolbox/audiocodecappendinputdata(_:_:_:_:_:)) function for definitions of _packet_ and _frame_ as used by this API.) You can use the [`AudioCodecGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiocodecgetproperty(_:_:_:_:)) function to obtain this value from the [`kAudioCodecPropertyPacketFrameSize`](https://developer.apple.com/documentation/audiotoolbox/kaudiocodecpropertypacketframesize) property. Similarly, this property indicates how many frames of linear PCM data an encoder needs in order to produce a packet of the specified output format.
    ///
    /// Output data can be produced only in multiples of whole packets.
    ///
    /// The combination of the [`AudioCodecAppendInputData`](https://developer.apple.com/documentation/audiotoolbox/audiocodecappendinputdata(_:_:_:_:_:)) and [`AudioCodecProduceOutputPackets`](https://developer.apple.com/documentation/audiotoolbox/audiocodecproduceoutputpackets(_:_:_:_:_:_:)) functions implement a “push-pull” model of data handling. First, the input data is pushed into the codec, then the resulting output data is pulled out of that same codec.
    ///
    ///
    /// Produce as many output packets as requested and the amount of input data
    /// allows for. The outStatus argument returns information about the codec's
    /// status to allow for proper data management. See the constants above for
    /// the possible values that can be returned.
    ///
    /// The outPacketDescription argument is an array of AudioStreamPacketDescription
    /// structs that describes the packet layout returned in outOutputData. This
    /// argument is optional. Pass NULL if this information is not to be returned.
    /// Note that this information is only provided when the output format isn't
    /// linear PCM.
    ///
    /// Note that decoders will always only produce linear PCM data in multiples of
    /// the number frames in a packet of the encoded format (as returned by
    /// kAudioCodecPropertyPacketFrameSize). Encoders will consume this many frames
    /// of linear PCM data to produce a packet of their format.
    ///
    ///
    /// Parameter `inCodec`: The AudioCodec instance
    ///
    /// Parameter `outOutputData`: Pointer to the output data buffer
    ///
    /// Parameter `ioOutputDataByteSize`: A pointer to the size
    ///
    /// Parameter `ioNumberPackets`: number of input/output packets
    ///
    /// Returns: The OSStatus value
    ///
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    /// - `io_output_data_byte_size` must be a valid pointer.
    /// - `io_number_packets` must be a valid pointer.
    /// - `out_packet_description` must be a valid pointer or null.
    /// - `out_status` must be a valid pointer.
    #[cfg(all(feature = "AudioComponent", feature = "objc2-core-audio-types"))]
    pub fn AudioCodecProduceOutputPackets(
        in_codec: AudioCodec,
        out_output_data: NonNull<c_void>,
        io_output_data_byte_size: NonNull<u32>,
        io_number_packets: NonNull<u32>,
        out_packet_description: *mut AudioStreamPacketDescription,
        out_status: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `in_buffer_list` must be a valid pointer.
    /// - `io_number_packets` must be a valid pointer.
    /// - `in_packet_description` must be a valid pointer or null.
    /// - `out_bytes_consumed` must be a valid pointer.
    #[cfg(all(feature = "AudioComponent", feature = "objc2-core-audio-types"))]
    pub fn AudioCodecAppendInputBufferList(
        in_codec: AudioCodec,
        in_buffer_list: NonNull<AudioBufferList>,
        io_number_packets: NonNull<u32>,
        in_packet_description: *const AudioStreamPacketDescription,
        out_bytes_consumed: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `in_codec` must be a valid pointer.
    /// - `io_buffer_list` must be a valid pointer.
    /// - `io_number_packets` must be a valid pointer.
    /// - `out_packet_description` must be a valid pointer or null.
    /// - `out_status` must be a valid pointer.
    #[cfg(all(feature = "AudioComponent", feature = "objc2-core-audio-types"))]
    pub fn AudioCodecProduceOutputBufferList(
        in_codec: AudioCodec,
        io_buffer_list: NonNull<AudioBufferList>,
        io_number_packets: NonNull<u32>,
        out_packet_description: *mut AudioStreamPacketDescription,
        out_status: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Flushes all the audio data in the codec and clears the input buffer.
    ///
    /// Parameters:
    /// - inCodec: An audio codec object. Because an audio codec object is a Component Manger component instance, you can use the Component Manager (for example, the functions [`FindNextComponent`](https://developer.apple.com/documentation/coreservices/1516552-findnextcomponent) and OpenAComponent) to obtain an audio codec object.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `NoErr` if successful, otherwise, a result code. See `Result Codes` for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The input and output formats, magic cookie data, and other state variables are retained so that you needn’t call the [`AudioCodecInitialize`](https://developer.apple.com/documentation/audiotoolbox/audiocodecinitialize(_:_:_:_:_:)) function again unless the values of some variables have changed.
    ///
    ///
    /// Flushes all the data in the codec and clears the input buffer. Note that
    /// the formats, and magic cookie will be retained so they won't need to be
    /// set up again to decode the same data.
    ///
    ///
    /// Parameter `inCodec`: The audio codec descriptor
    ///
    ///
    /// Returns: the OSStatus value
    ///
    /// # Safety
    ///
    /// `in_codec` must be a valid pointer.
    #[cfg(feature = "AudioComponent")]
    pub fn AudioCodecReset(in_codec: AudioCodec) -> OSStatus;
}

pub type AudioCodecGetPropertyInfoProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        AudioCodecPropertyID,
        *mut u32,
        *mut Boolean,
    ) -> OSStatus,
>;

pub type AudioCodecGetPropertyProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        AudioCodecPropertyID,
        NonNull<u32>,
        NonNull<c_void>,
    ) -> OSStatus,
>;

pub type AudioCodecSetPropertyProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        AudioCodecPropertyID,
        u32,
        NonNull<c_void>,
    ) -> OSStatus,
>;

#[cfg(feature = "objc2-core-audio-types")]
pub type AudioCodecInitializeProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        *const AudioStreamBasicDescription,
        *const AudioStreamBasicDescription,
        *const c_void,
        u32,
    ) -> OSStatus,
>;

pub type AudioCodecUninitializeProc =
    Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> OSStatus>;

#[cfg(feature = "objc2-core-audio-types")]
pub type AudioCodecAppendInputDataProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        NonNull<c_void>,
        NonNull<u32>,
        NonNull<u32>,
        *const AudioStreamPacketDescription,
    ) -> OSStatus,
>;

#[cfg(feature = "objc2-core-audio-types")]
pub type AudioCodecProduceOutputPacketsProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        NonNull<c_void>,
        NonNull<u32>,
        NonNull<u32>,
        *mut AudioStreamPacketDescription,
        NonNull<u32>,
    ) -> OSStatus,
>;

pub type AudioCodecResetProc = Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> OSStatus>;

#[cfg(feature = "objc2-core-audio-types")]
pub type AudioCodecAppendInputBufferListProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        NonNull<AudioBufferList>,
        NonNull<u32>,
        *const AudioStreamPacketDescription,
        NonNull<u32>,
    ) -> OSStatus,
>;

#[cfg(feature = "objc2-core-audio-types")]
pub type AudioCodecProduceOutputBufferListProc = Option<
    unsafe extern "C-unwind" fn(
        NonNull<c_void>,
        NonNull<AudioBufferList>,
        NonNull<u32>,
        *mut AudioStreamPacketDescription,
        NonNull<u32>,
    ) -> OSStatus,
>;

pub const kAudioCodecPropertyMinimumDelayMode: AudioCodecPropertyID = 0x6d64656c;

pub const kAudioCodecPropertyNameCFString: AudioCodecPropertyID = 0x6c6e616d;
pub const kAudioCodecPropertyManufacturerCFString: AudioCodecPropertyID = 0x6c6d616b;
pub const kAudioCodecPropertyFormatCFString: AudioCodecPropertyID = 0x6c666f72;

pub const kAudioCodecPropertyRequiresPacketDescription: AudioCodecPropertyID = 0x70616b64;
pub const kAudioCodecPropertyAvailableBitRates: AudioCodecPropertyID = 0x62727423;
pub const kAudioCodecExtendFrequencies: AudioCodecPropertyID = 0x61636566;
pub const kAudioCodecUseRecommendedSampleRate: AudioCodecPropertyID = 0x75727372;
pub const kAudioCodecOutputPrecedence: AudioCodecPropertyID = 0x6f707072;
pub const kAudioCodecBitRateFormat: AudioCodecPropertyID = kAudioCodecPropertyBitRateControlMode;
pub const kAudioCodecDoesSampleRateConversion: AudioCodecPropertyID =
    kAudioCodecPropertyDoesSampleRateConversion;
pub const kAudioCodecInputFormatsForOutputFormat: AudioCodecPropertyID =
    kAudioCodecPropertyInputFormatsForOutputFormat;
pub const kAudioCodecOutputFormatsForInputFormat: AudioCodecPropertyID =
    kAudioCodecPropertyOutputFormatsForInputFormat;
pub const kAudioCodecPropertyInputChannelLayout: AudioCodecPropertyID =
    kAudioCodecPropertyCurrentInputChannelLayout;
pub const kAudioCodecPropertyOutputChannelLayout: AudioCodecPropertyID =
    kAudioCodecPropertyCurrentOutputChannelLayout;
pub const kAudioCodecPropertyAvailableInputChannelLayouts: AudioCodecPropertyID =
    kAudioCodecPropertyAvailableInputChannelLayoutTags;
pub const kAudioCodecPropertyAvailableOutputChannelLayouts: AudioCodecPropertyID =
    kAudioCodecPropertyAvailableOutputChannelLayoutTags;
pub const kAudioCodecPropertyZeroFramesPadded: AudioCodecPropertyID =
    kAudioCodecPropertyPaddedZeros;

pub const kAudioCodecBitRateFormat_CBR: u32 = kAudioCodecBitRateControlMode_Constant;
pub const kAudioCodecBitRateFormat_ABR: u32 = kAudioCodecBitRateControlMode_LongTermAverage;
pub const kAudioCodecBitRateFormat_VBR: u32 = kAudioCodecBitRateControlMode_VariableConstrained;

pub const kAudioCodecOutputPrecedenceNone: u32 = 0;
pub const kAudioCodecOutputPrecedenceBitRate: u32 = 1;
pub const kAudioCodecOutputPrecedenceSampleRate: u32 = 2;

/// A structure holding magic cookie information.
/// renamed to AudioCodecMagicCookieInfo
#[deprecated]
pub type MagicCookieInfo = AudioCodecMagicCookieInfo;

pub const kHintBasic: u32 = 0;
pub const kHintAdvanced: u32 = 1;
pub const kHintHidden: u32 = 2;
