//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-midi")]
use objc2_core_midi::*;

use crate::*;

/// A null music event.
pub const kMusicEventType_NULL: u32 = 0;
/// A non-MIDI music event with variable number of parameters.
pub const kMusicEventType_ExtendedNote: u32 = 1;
/// An event that signals a change in tempo, in beats-per-minute.
pub const kMusicEventType_ExtendedTempo: u32 = 3;
/// User-defined data.
pub const kMusicEventType_User: u32 = 4;
/// A standard MIDI file metaevent.
pub const kMusicEventType_Meta: u32 = 5;
/// A MIDI note-on message, including duration.
pub const kMusicEventType_MIDINoteMessage: u32 = 6;
/// A MIDI channel message, other than note control.
pub const kMusicEventType_MIDIChannelMessage: u32 = 7;
/// MIDI system-exclusive data.
pub const kMusicEventType_MIDIRawData: u32 = 8;
/// An audio unit parameter event.
pub const kMusicEventType_Parameter: u32 = 9;
/// An event containing an audio unit user preset dictionary.
pub const kMusicEventType_AUPreset: u32 = 10;

/// MIDI and other music event types, used by music event iterator functions.
pub type MusicEventType = u32;

/// Flags used to configure the behavior of the [`MusicSequenceFileLoad`](https://developer.apple.com/documentation/audiotoolbox/musicsequencefileload(_:_:_:_:)) and [`MusicSequenceFileLoadData`](https://developer.apple.com/documentation/audiotoolbox/musicsequencefileloaddata(_:_:_:_:)) functions.
/// Flags used to customise loading behaviour
///
/// If this flag is set the resultant Sequence will contain:
/// a tempo track
/// a track for each track found in the SMF
/// This is the default behavior
///
/// If this flag is set the resultant Sequence will contain:
/// a tempo track
/// 1 track for each MIDI Channel that is found in the SMF
/// 1 track for SysEx or MetaEvents - this will be the last track
/// in the sequence after the LoadSMFWithFlags calls
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MusicSequenceLoadFlags(pub u32);
bitflags::bitflags! {
    impl MusicSequenceLoadFlags: u32 {
        #[doc(alias = "kMusicSequenceLoadSMF_PreserveTracks")]
        const SMF_PreserveTracks = 0;
/// If this flag is set the resultant Sequence will contain a tempo track, 1 track for each MIDI Channel that is found in the SMF, 1 track for SysEx or MetaEvents - and this will be the last track in the sequence after the LoadSMFWithFlags calls.
        #[doc(alias = "kMusicSequenceLoadSMF_ChannelsToTracks")]
        const SMF_ChannelsToTracks = 1<<0;
    }
}

unsafe impl Encode for MusicSequenceLoadFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for MusicSequenceLoadFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The various types of music sequences.
/// A sequence type
///
/// Different sequence types to describe the basic mode of operation of a sequence's time line
/// You cannot change a music sequence's type to samples/seconds if there are tempo events
/// The type will also define how the sequence is saved to a MIDI file:
/// Beats - normal midi file
/// Seconds - midi file with SMPTE time
/// Samples - cannot be saved to a midi file
///
/// The default/normal type of a sequence.
/// Tempo track defines the number of beats per second and can have multiple tempo events
///
/// A music sequence with a single 60bpm tempo event
///
/// A music sequence with a single tempo event that represents the audio sample rate
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MusicSequenceType(pub u32);
impl MusicSequenceType {
    /// Used for a music sequence that corresponds to a normal MIDI file. The tempo track defines the number of beats per second and can have multiple tempo events.
    #[doc(alias = "kMusicSequenceType_Beats")]
    pub const Beats: Self = Self(0x62656174);
    /// Used for a music sequence that corresponds to a MIDI file, but employs SMPTE timecode. The tempo track contains a single tempo event that specifies 60 beat-per-minute.
    #[doc(alias = "kMusicSequenceType_Seconds")]
    pub const Seconds: Self = Self(0x73656373);
    /// Used for audio samples; a music sequence of this type cannot be saved to a MIDI file. The tempo track contains a single tempo event that specifies an audio sample rate in samples-per-second.
    #[doc(alias = "kMusicSequenceType_Samples")]
    pub const Samples: Self = Self(0x73616d70);
}

unsafe impl Encode for MusicSequenceType {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for MusicSequenceType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The various types of files that can be parsed by a music sequence.
/// describes different types of files that can be parsed by a music sequence
///
/// let the system read iMelody files and read and write MIDI files (and any future types)
///
/// read and write MIDI files
///
/// read iMelody files
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MusicSequenceFileTypeID(pub u32);
impl MusicSequenceFileTypeID {
    #[doc(alias = "kMusicSequenceFile_AnyType")]
    pub const AnyType: Self = Self(0);
    /// A MIDI file type
    #[doc(alias = "kMusicSequenceFile_MIDIType")]
    pub const MIDIType: Self = Self(0x6d696469);
    /// An iMelody file type.
    #[doc(alias = "kMusicSequenceFile_iMelodyType")]
    pub const iMelodyType: Self = Self(0x696d656c);
}

unsafe impl Encode for MusicSequenceFileTypeID {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for MusicSequenceFileTypeID {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags that configure the behavior of the [`MusicSequenceFileCreate`](https://developer.apple.com/documentation/audiotoolbox/musicsequencefilecreate(_:_:_:_:_:)) and [`MusicSequenceFileCreateData`](https://developer.apple.com/documentation/audiotoolbox/musicsequencefilecreatedata(_:_:_:_:_:)) functions.
/// controls the behaviour of the create file calls
///
/// Does not overwrite existing files.  Attempts to save over an existing file
/// will return kAudio_FilePermissionError
///
/// Erase an existing file when creating a new file
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MusicSequenceFileFlags(pub u32);
bitflags::bitflags! {
    impl MusicSequenceFileFlags: u32 {
        #[doc(alias = "kMusicSequenceFileFlags_Default")]
        const Default = 0;
/// Specifies that an existing file should be erased when creating a new file.
        #[doc(alias = "kMusicSequenceFileFlags_EraseFile")]
        const EraseFile = 1;
    }
}

unsafe impl Encode for MusicSequenceFileFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for MusicSequenceFileFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A timestamp for use by a music sequence.
/// The type used to refer to time values in a music sequence
pub type MusicTimeStamp = f64;

/// Describes a MIDI note.
/// The parameters to specify a MIDI note
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MIDINoteMessage {
    pub channel: u8,
    pub note: u8,
    pub velocity: u8,
    pub releaseVelocity: u8,
    pub duration: f32,
}

unsafe impl Encode for MIDINoteMessage {
    const ENCODING: Encoding = Encoding::Struct(
        "MIDINoteMessage",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <f32>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for MIDINoteMessage {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes a MIDI channel message.
/// The parameters to specify a MIDI channel message
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MIDIChannelMessage {
    pub status: u8,
    pub data1: u8,
    pub data2: u8,
    pub reserved: u8,
}

unsafe impl Encode for MIDIChannelMessage {
    const ENCODING: Encoding = Encoding::Struct(
        "MIDIChannelMessage",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for MIDIChannelMessage {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes a MIDI system-exclusive (SysEx) message.
/// Generally used to represent a MIDI SysEx message
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MIDIRawData {
    pub length: u32,
    pub data: [u8; 1],
}

unsafe impl Encode for MIDIRawData {
    const ENCODING: Encoding =
        Encoding::Struct("MIDIRawData", &[<u32>::ENCODING, <[u8; 1]>::ENCODING]);
}

unsafe impl RefEncode for MIDIRawData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes a MIDI metaevent such as lyric text, time signature, and so on.
/// The parameters to specify a MIDI meta event
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MIDIMetaEvent {
    pub metaEventType: u8,
    pub unused1: u8,
    pub unused2: u8,
    pub unused3: u8,
    pub dataLength: u32,
    pub data: [u8; 1],
}

unsafe impl Encode for MIDIMetaEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "MIDIMetaEvent",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u32>::ENCODING,
            <[u8; 1]>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for MIDIMetaEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes a user-defined event.
/// Provides a general struct for specifying a user defined event.
///
/// the size in bytes of the data
///
/// size bytes of user defined event data
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MusicEventUserData {
    pub length: u32,
    pub data: [u8; 1],
}

unsafe impl Encode for MusicEventUserData {
    const ENCODING: Encoding = Encoding::Struct(
        "MusicEventUserData",
        &[<u32>::ENCODING, <[u8; 1]>::ENCODING],
    );
}

unsafe impl RefEncode for MusicEventUserData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes a note-on event with extended parameters.
/// The parameters to specify an extended note on event
#[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct ExtendedNoteOnEvent {
    pub instrumentID: MusicDeviceInstrumentID,
    pub groupID: MusicDeviceGroupID,
    pub duration: f32,
    pub extendedParams: MusicDeviceNoteParams,
}

#[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
unsafe impl Encode for ExtendedNoteOnEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "ExtendedNoteOnEvent",
        &[
            <MusicDeviceInstrumentID>::ENCODING,
            <MusicDeviceGroupID>::ENCODING,
            <f32>::ENCODING,
            <MusicDeviceNoteParams>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
unsafe impl RefEncode for ExtendedNoteOnEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes an audio unit parameter automation event.
/// The parameters to specify a parameter event to an audio unit.
#[cfg(feature = "AUComponent")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct ParameterEvent {
    pub parameterID: AudioUnitParameterID,
    pub scope: AudioUnitScope,
    pub element: AudioUnitElement,
    pub value: AudioUnitParameterValue,
}

#[cfg(feature = "AUComponent")]
unsafe impl Encode for ParameterEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "ParameterEvent",
        &[
            <AudioUnitParameterID>::ENCODING,
            <AudioUnitScope>::ENCODING,
            <AudioUnitElement>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
        ],
    );
}

#[cfg(feature = "AUComponent")]
unsafe impl RefEncode for ParameterEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes a music track tempo in beats-per-minute.
/// specifies the value for a tempo in beats per minute
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct ExtendedTempoEvent {
    pub bpm: f64,
}

unsafe impl Encode for ExtendedTempoEvent {
    const ENCODING: Encoding = Encoding::Struct("ExtendedTempoEvent", &[<f64>::ENCODING]);
}

unsafe impl RefEncode for ExtendedTempoEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes an audio unit preset.
/// The parameters to specify a preset for an audio unit.
#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUPresetEvent {
    pub scope: AudioUnitScope,
    pub element: AudioUnitElement,
    pub preset: NonNull<CFPropertyList>,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl Encode for AUPresetEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "AUPresetEvent",
        &[
            <AudioUnitScope>::ENCODING,
            <AudioUnitElement>::ENCODING,
            <NonNull<CFPropertyList>>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl RefEncode for AUPresetEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A display representation of a musical time in beats.
///
/// A clock's internal representation of musical time is in beats based on the
/// beginning of the timeline. Normally, such times should be displayed to the user
/// in terms of bars, beats, and subbeats (sometimes called "units" or "parts per
/// quarter" [PPQ]). This data structure is such a display representation.
///
/// By convention, bar 1 is the beginning of the sequence. Beat 1 is the first beat
/// of the measure. In 4/4 time, beat will have a value from 1 to 4. Music
/// applications often use beat divisions such as 480 and 960.
///
///
/// A measure number.
///
/// A beat number (1..n).
///
/// The numerator of the fractional number of beats.
///
/// The denominator of the fractional number of beats.
///
/// Must be 0.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CABarBeatTime {
    pub bar: i32,
    pub beat: u16,
    pub subbeat: u16,
    pub subbeatDivisor: u16,
    pub reserved: u16,
}

unsafe impl Encode for CABarBeatTime {
    const ENCODING: Encoding = Encoding::Struct(
        "CABarBeatTime",
        &[
            <i32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for CABarBeatTime {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueMusicPlayer {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaqueMusicPlayer {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("OpaqueMusicPlayer", &[]));
}

/// A music player plays a music sequence (of type `MusicSequence`).
pub type MusicPlayer = *mut OpaqueMusicPlayer;

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueMusicSequence {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaqueMusicSequence {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("OpaqueMusicSequence", &[]));
}

/// A music sequence.
pub type MusicSequence = *mut OpaqueMusicSequence;

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueMusicTrack {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaqueMusicTrack {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("OpaqueMusicTrack", &[]));
}

/// A music track consists of a series of music events, each timestamped using units of beats.
///
/// ## Discussion
///
/// A music track (of type `MusicTrack`) has properties which may be inspected and assigned, including support for looping, muting/soloing, and time-stamp interpretation. You can iterate through the events in a music track, and can perform various editing operations on them.
///
/// A music track is a component of a music sequence (of type [`MusicSequence`](https://developer.apple.com/documentation/audiotoolbox/musicsequence)), which in turn is played by a music player (of type [`MusicPlayer`](https://developer.apple.com/documentation/audiotoolbox/musicplayer)).
///
///
pub type MusicTrack = *mut OpaqueMusicTrack;

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueMusicEventIterator {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaqueMusicEventIterator {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("OpaqueMusicEventIterator", &[]));
}

/// A music event iterator sequentially handles events on a music track.
pub type MusicEventIterator = *mut OpaqueMusicEventIterator;

///
/// ## Discussion
///
/// If you named your callback `MyMusicSequenceUserCallback`, you would declare it like this:
///
///
/// See MusicSequenceSetUserCallback
pub type MusicSequenceUserCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        MusicSequence,
        MusicTrack,
        MusicTimeStamp,
        NonNull<MusicEventUserData>,
        MusicTimeStamp,
        MusicTimeStamp,
    ),
>;

pub const kAudioToolboxErr_InvalidSequenceType: OSStatus = -10846;
pub const kAudioToolboxErr_TrackIndexError: OSStatus = -10859;
pub const kAudioToolboxErr_TrackNotFound: OSStatus = -10858;
pub const kAudioToolboxErr_EndOfTrack: OSStatus = -10857;
pub const kAudioToolboxErr_StartOfTrack: OSStatus = -10856;
pub const kAudioToolboxErr_IllegalTrackDestination: OSStatus = -10855;
pub const kAudioToolboxErr_NoSequence: OSStatus = -10854;
pub const kAudioToolboxErr_InvalidEventType: OSStatus = -10853;
pub const kAudioToolboxErr_InvalidPlayerState: OSStatus = -10852;
pub const kAudioToolboxErr_CannotDoInCurrentContext: OSStatus = -10863;
pub const kAudioToolboxError_NoTrackDestination: OSStatus = -66720;

/// Looping information for a music track.
///
/// ## Discussion
///
/// Looping is off by default; by default, a music track plays exactly once. A read/write [`MusicTrackLoopInfo`](https://developer.apple.com/documentation/audiotoolbox/musictrackloopinfo) structure.
///
///
pub const kSequenceTrackProperty_LoopInfo: u32 = 0;
/// A music track’s start time in terms of beat number.
///
/// ## Discussion
///
/// By default this value is 0. A read/write [`MusicTimeStamp`](https://developer.apple.com/documentation/audiotoolbox/musictimestamp) value.
///
///
pub const kSequenceTrackProperty_OffsetTime: u32 = 1;
/// The mute/unmute state of a music track. By default this value is `false` (not muted). A read/write Boolean value.
pub const kSequenceTrackProperty_MuteStatus: u32 = 2;
/// The solo/unsolo state of a music track. By default this value is `false` (not soloed). A read/write Boolean value.
pub const kSequenceTrackProperty_SoloStatus: u32 = 3;
/// Indicates whether or not a music track’s purpose is audio unit parameter automation. If this property’s value is other than 0, music events in the track can only indicate points in an automation curve. A read/write `UInt32` value, where a value other than 0 indicates that the track is for parameter automation.
pub const kSequenceTrackProperty_AutomatedParameters: u32 = 4;
/// The time of the last music event in a music track, plus time required for note fade-outs and so on.
///
/// ## Discussion
///
/// If this property is not set, music track length equals the end of the last active event in the track and is adjusted dynamically as events are added or removed. The value of this property is the specified track length, or the calculated length—whichever is greater. A read/write [`MusicTimeStamp`](https://developer.apple.com/documentation/audiotoolbox/musictimestamp) value.
///
///
pub const kSequenceTrackProperty_TrackLength: u32 = 5;
/// The time resolution for a sequence of music events. For example, this value can indicate the time resolution that was specified by the MIDI file used to construct a sequence.
///
/// ## Discussion
///
/// To use a specific time resolution when writing a new file, retrieve this value and then specify it when calling the [`MusicSequenceFileCreate`](https://developer.apple.com/documentation/audiotoolbox/musicsequencefilecreate(_:_:_:_:_:)) function.
///
/// This value does not directly determine playback rate for a music track, but rather it
///
/// `kSequenceTrackProperty_TimeResolution` is set in two possible ways:
///
/// - If you create a music sequence programmatically, the value is set to 480.
///
/// - If you create a music sequence from a MIDI file, the value is set to the time resolution specified in the MIDI file.
///
/// A read-only `SInt16` value that is valid only for a tempo track.
///
///
pub const kSequenceTrackProperty_TimeResolution: u32 = 6;

/// Supports control of the looping behavior of a music track.
///
/// ## Overview
///
/// This data type is used for the value of the [`kSequenceTrackProperty_LoopInfo`](https://developer.apple.com/documentation/audiotoolbox/ksequencetrackproperty_loopinfo) property.
///
///
/// Used to control the looping behaviour of a track
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MusicTrackLoopInfo {
    pub loopDuration: MusicTimeStamp,
    pub numberOfLoops: i32,
}

unsafe impl Encode for MusicTrackLoopInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "MusicTrackLoopInfo",
        &[<MusicTimeStamp>::ENCODING, <i32>::ENCODING],
    );
}

unsafe impl RefEncode for MusicTrackLoopInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Creates a new music player.
    ///
    /// Parameters:
    /// - outPlayer: On output, the newly created music player.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A music player can send its output to an audio processing graph, to a MIDI endpoint, or to a combination of both.
    ///
    ///
    /// Create a new music player
    ///
    /// A music player is used to play a sequence back. This call is used to create a player
    /// When a sequence is to be played by a player, it can play to either an AUGraph, a MIDI Destination or a
    /// mixture/combination of both.
    ///
    /// Parameter `outPlayer`: the newly created player
    ///
    /// # Safety
    ///
    /// `out_player` must be a valid pointer.
    pub fn NewMusicPlayer(out_player: NonNull<MusicPlayer>) -> OSStatus;
}

extern "C-unwind" {
    /// Disposes of a music player.
    ///
    /// Parameters:
    /// - inPlayer: The music player to dispose of.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    /// Dispose a music player
    ///
    /// Parameter `inPlayer`: the player to dispose
    ///
    /// # Safety
    ///
    /// `in_player` must be a valid pointer.
    pub fn DisposeMusicPlayer(in_player: MusicPlayer) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the music sequence for the music player to play.
    ///
    /// Parameters:
    /// - inPlayer: The music player you are configuring.
    ///
    /// - inSequence: The music sequence for the music player to play.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A music player must be stopped to call this function on it. Setting a music sequence for a player overrides the previously set sequence.
    ///
    ///
    /// Set the sequence for the player to play
    ///
    /// A Sequence cannot be set on a player while it is playing. Setting a sequence
    /// will overide the currently set sequence.
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `inSequence`: the sequence for the player to play
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `in_sequence` must be a valid pointer or null.
    pub fn MusicPlayerSetSequence(in_player: MusicPlayer, in_sequence: MusicSequence) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the music sequence associated with a music player.
    ///
    /// Parameters:
    /// - inPlayer: The music player whose music sequence you want to get.
    ///
    /// - outSequence: On output, the music sequence associated with the music player.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. If the music player does not have a sequence set, this function returns `kAudioToolboxErr_NoSequence`.
    ///
    ///
    /// Get the sequence attached to a player
    ///
    /// If the player does not have a sequence set, this will return the _NoSequence error
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `outSequence`: the sequence currently set on the player
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `out_sequence` must be a valid pointer.
    pub fn MusicPlayerGetSequence(
        in_player: MusicPlayer,
        out_sequence: NonNull<MusicSequence>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the playback point for a music player, in beats.
    ///
    /// Parameters:
    /// - inPlayer: The music player you want to set the playback point on.
    ///
    /// - inTime: The time, in beats, to set the playback point to.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can call this function while a music player is stopped or playing. If playing at the time of the call, playback continues at the specified point. No range checking on the `inTime` value is performed by this function.
    ///
    ///
    /// Set the current time on the player
    ///
    /// The Get and Set Time calls take a specification of time as beats. This positions the player
    /// to the specified time based on the currently set sequence. No range checking on the time value
    /// is done. This can be set on a playing player (in which case playing will be resumed from the
    /// new time).
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `inTime`: the new time value
    ///
    /// # Safety
    ///
    /// `in_player` must be a valid pointer.
    pub fn MusicPlayerSetTime(in_player: MusicPlayer, in_time: MusicTimeStamp) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the playback point for a music player, in beats.
    ///
    /// Parameters:
    /// - inPlayer: The music player you want to get the playback point for.
    ///
    /// - outTime: On output, the playback point for the music player.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For converting between beats and seconds, see [`MusicSequenceGetSecondsForBeats`](https://developer.apple.com/documentation/audiotoolbox/musicsequencegetsecondsforbeats(_:_:_:)) and [`MusicSequenceGetBeatsForSeconds`](https://developer.apple.com/documentation/audiotoolbox/musicsequencegetbeatsforseconds(_:_:_:)).
    ///
    ///
    /// Get the current time of the player
    ///
    /// The Get and Set Time calls take a specification of time as beats. This retrieves the player's
    /// current time. If it is playing this time is the time of the player at the time the call was made.
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `outTime`: the current time value
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `out_time` must be a valid pointer.
    pub fn MusicPlayerGetTime(
        in_player: MusicPlayer,
        out_time: NonNull<MusicTimeStamp>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the host time associated with a specified beat.
    ///
    /// Parameters:
    /// - inPlayer: The music player that you are querying.
    ///
    /// - inBeats: The beat number that you want the host time for.
    ///
    /// - outHostTime: On output, the host time associated with the `inBeats` value.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. This function returns an error if the player is not playing.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is valid only if the music player is playing. For converting between beats and seconds, see [`MusicSequenceGetSecondsForBeats`](https://developer.apple.com/documentation/audiotoolbox/musicsequencegetsecondsforbeats(_:_:_:)) and [`MusicSequenceGetBeatsForSeconds`](https://developer.apple.com/documentation/audiotoolbox/musicsequencegetbeatsforseconds(_:_:_:)).
    ///
    ///
    /// Returns the host time that will be (or was) played at the specified beat.
    ///
    /// This call is only valid if the player is playing and will return an error if the player is not playing
    /// or if the starting position of the player (its "starting beat") was after the specified beat.
    /// For general translation of beats to time in a sequence, see the MusicSequence calls for beat
    /// <
    /// ->seconds.
    ///
    /// The call uses the player's sequence's tempo map to translate a beat time from the starting time and beat
    /// of the player.
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `inBeats`: the specified beat-time value
    ///
    /// Parameter `outHostTime`: the corresponding host time
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `out_host_time` must be a valid pointer.
    pub fn MusicPlayerGetHostTimeForBeats(
        in_player: MusicPlayer,
        in_beats: MusicTimeStamp,
        out_host_time: NonNull<u64>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the beat number associated a specified host time.
    ///
    /// Parameters:
    /// - inPlayer: The music player that you are querying.
    ///
    /// - inHostTime: The host time that you want the beat number for.
    ///
    /// - outBeats: On output, the beat number associated with the `inHostTime` value.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. This function returns an error if the player is not playing.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is valid only if the music player is playing. For converting between beats and seconds, see [`MusicSequenceGetSecondsForBeats`](https://developer.apple.com/documentation/audiotoolbox/musicsequencegetsecondsforbeats(_:_:_:)) and [`MusicSequenceGetBeatsForSeconds`](https://developer.apple.com/documentation/audiotoolbox/musicsequencegetbeatsforseconds(_:_:_:)).
    ///
    ///
    /// Returns the beat that will be (or was) played at the specified host time.
    ///
    /// This call is only valid if the player is playing and will return an error if the player is not playing
    /// or if the starting time of the player was after the specified host time.
    /// For general translation of beats to time in a sequence, see the MusicSequence calls for beat
    /// <
    /// ->seconds.
    ///
    /// The call uses the player's sequence's tempo map to retrieve a beat time from the starting and specified host time.
    ///
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `inHostTime`: the specified host time value
    ///
    /// Parameter `outBeats`: the corresponding beat time
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `out_beats` must be a valid pointer.
    pub fn MusicPlayerGetBeatsForHostTime(
        in_player: MusicPlayer,
        in_host_time: u64,
        out_beats: NonNull<MusicTimeStamp>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Prepares a music player to play.
    ///
    /// Parameters:
    /// - inPlayer: The music player to prepare to play.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Call this function in advance of playback to reduce a music player’s startup latency. If you call [`MusicPlayerStart`](https://developer.apple.com/documentation/audiotoolbox/musicplayerstart(_:)) without first calling this function, the player will call this function before beginning playback.
    ///
    ///
    /// Prepare the player for playing
    ///
    /// Allows the player to prepare its state so that starting is has a lower latency. If a player is started without
    /// being prerolled, the player will pre-roll itself and then start.
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// # Safety
    ///
    /// `in_player` must be a valid pointer.
    pub fn MusicPlayerPreroll(in_player: MusicPlayer) -> OSStatus;
}

extern "C-unwind" {
    /// Starts playback of a music player.
    ///
    /// Parameters:
    /// - inPlayer: The music player to start.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If you call this function without first calling [`MusicPlayerPreroll`](https://developer.apple.com/documentation/audiotoolbox/musicplayerpreroll(_:)), the player will call that function before beginning playback.
    ///
    ///
    /// Start the player
    ///
    /// If the player has not been prerolled, it will pre-roll itself and then start.
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// # Safety
    ///
    /// `in_player` must be a valid pointer.
    pub fn MusicPlayerStart(in_player: MusicPlayer) -> OSStatus;
}

extern "C-unwind" {
    /// Stops playback of a music player.
    ///
    /// Parameters:
    /// - inPlayer: The music player to stop.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Music players must be explicitly stopped. Specifically, a music player does not automatically stop when its associated music sequence has been completely played.
    ///
    ///
    /// Stop the player
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// # Safety
    ///
    /// `in_player` must be a valid pointer.
    pub fn MusicPlayerStop(in_player: MusicPlayer) -> OSStatus;
}

extern "C-unwind" {
    /// Indicates whether or not a music player is playing.
    ///
    /// Parameters:
    /// - inPlayer: The music player to query.
    ///
    /// - outIsPlaying: On output `true` (nonzero) if playing, `false` (zero) if not playing.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If a music player has started playing and has not been explicitly stopped, the `outIsPlaying` value is `true`. Specifically, if the player’s music sequence has completed—so there is no more audible output—but the player has not been explicitly stopped, the `outIsPlaying` value is `true` and the music player’s time value continues to increase.
    ///
    ///
    /// Returns the playing state of the player. "Is it playing?"
    ///
    /// This call returns a non-zero value in outIsPlaying if the player has been
    /// started and not stopped. It may have "played" past the events of the attached
    /// MusicSequence, but it is still considered to be playing (and its time value increasing)
    /// until it is explicitly stopped
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `outIsPlaying`: false if not, true (non-zero) if is playing
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `out_is_playing` must be a valid pointer.
    pub fn MusicPlayerIsPlaying(
        in_player: MusicPlayer,
        out_is_playing: NonNull<Boolean>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets a playback rate multiplier for a music player.
    ///
    /// Parameters:
    /// - inPlayer: The music player that you want to set a playback rate multiplier on.
    ///
    /// - inScaleRate: The playback rate multiplier to apply to the music player. For example, setting this parameter to a value of 2 doubles the playback rate. Must be greater than 0.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A music player’s default playback rate multiplier is 1.0.
    ///
    ///
    /// Scale the playback rate of the player
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `inScaleRate`: a scalar that will be applied to the playback rate. If 2, playback is twice as fast, if
    /// 0.5 it is half as fast. As a scalar, the value must be greater than zero.
    ///
    /// # Safety
    ///
    /// `in_player` must be a valid pointer.
    pub fn MusicPlayerSetPlayRateScalar(in_player: MusicPlayer, in_scale_rate: f64) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the playback rate multiplier for a music player.
    ///
    /// Parameters:
    /// - inPlayer: The music player that you want to get the playback rate multiplier from.
    ///
    /// - outScaleRate: The playback rate multiplier of the music player.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A music player’s default playback rate multiplier is 1.0.
    ///
    ///
    /// Get the playback rate scalar of the player
    ///
    /// Parameter `inPlayer`: the player
    ///
    /// Parameter `outScaleRate`: the current scalar being applied to the player. Default value is 1.0
    ///
    /// # Safety
    ///
    /// - `in_player` must be a valid pointer.
    /// - `out_scale_rate` must be a valid pointer.
    pub fn MusicPlayerGetPlayRateScalar(
        in_player: MusicPlayer,
        out_scale_rate: NonNull<f64>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a new empty music sequence.
    ///
    /// Parameters:
    /// - outSequence: On output, the new, empty music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A new music sequence has only a tempo track, with a default tempo of 120 beats-per-minute. The default sequence type is beat-based. For the various sequence types, see [`MusicSequenceType`](https://developer.apple.com/documentation/audiotoolbox/musicsequencetype).
    ///
    /// To direct the output of a music sequence to an audio processing graph, use the [`MusicSequenceSetAUGraph`](https://developer.apple.com/documentation/audiotoolbox/musicsequencesetaugraph(_:_:)) function. To direct the output instead to a MIDI endpoint, use the [`MusicSequenceSetMIDIEndpoint`](https://developer.apple.com/documentation/audiotoolbox/musicsequencesetmidiendpoint(_:_:)) function.
    ///
    /// To direct the output of a specific music track, use the [`MusicTrackSetDestNode`](https://developer.apple.com/documentation/audiotoolbox/musictracksetdestnode(_:_:)) and [`MusicTrackSetDestMIDIEndpoint`](https://developer.apple.com/documentation/audiotoolbox/musictracksetdestmidiendpoint(_:_:)) functions, described in `MusicTrack`.
    ///
    ///
    /// Create a new empty sequence
    ///
    /// A new music sequence will only have a tempo track (with a default tempo of 120 bpm),
    /// and the default type is beat based.
    ///
    /// When a sequence is to be played by a player, it can play to either an AUGraph, a MIDI Destination or a
    /// mixture/combination of both. See MusicSequenceSetAUGraph and MusicSequenceSetMIDIEndpoint for the generic
    /// destination assignments. Specific tracks can also be assigned nodes of a graph or a MIDI endpoint as targets
    /// for the events that they contain; see MusicTrackSetDestNode and MusicTrackSetDestMIDIEndpoint.
    ///
    ///
    /// Parameter `outSequence`: the new sequence
    ///
    /// # Safety
    ///
    /// `out_sequence` must be a valid pointer.
    pub fn NewMusicSequence(out_sequence: NonNull<MusicSequence>) -> OSStatus;
}

extern "C-unwind" {
    /// Disposes of a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to dispose of.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You cannot dispose of a music sequence while it is associated with a music player.
    ///
    ///
    /// Dispose the sequence
    ///
    /// A sequence cannot be disposed while a MusicPlayer has it.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    pub fn DisposeMusicSequence(in_sequence: MusicSequence) -> OSStatus;
}

extern "C-unwind" {
    /// Add a new, empty music track to a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to add the new music track to.
    ///
    /// - outTrack: On output, the new music track that was appended to the list of tracks for the music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Add a new (empty) track to the sequence
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `outTrack`: the new track (it is always appended to any existing tracks)
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_track` must be a valid pointer.
    pub fn MusicSequenceNewTrack(
        in_sequence: MusicSequence,
        out_track: NonNull<MusicTrack>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Removes a music track from a music sequence, and disposes of the track.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to remove the music track from.
    ///
    /// - inTrack: The music track to remove and dispose of.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Remove and dispose a track from a sequence
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inTrack`: the track to remove and dispose
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `in_track` must be a valid pointer.
    pub fn MusicSequenceDisposeTrack(in_sequence: MusicSequence, in_track: MusicTrack) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the number of music tracks owned by a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence whose track count you want.
    ///
    /// - outNumberOfTracks: On output, the number of music tracks in the music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The track count provided by this function excludes the tempo track.
    ///
    ///
    /// The number of tracks in a sequence.
    /// The track count and accessors exclude the tempo track (which is treated as a special case)
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `outNumberOfTracks`: the number of tracks
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_number_of_tracks` must be a valid pointer.
    pub fn MusicSequenceGetTrackCount(
        in_sequence: MusicSequence,
        out_number_of_tracks: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the music track at the specified track index.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to obtain the music track from.
    ///
    /// - inTrackIndex: The index for the music track you want to obtain. Music tracks are zero-indexed. Out of bound indexes result in an error.
    ///
    /// - outTrack: On output, the music track specified by the `inTrackIndex` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is for accessing only music tracks, not the tempo track.
    ///
    ///
    /// Get a track at the specified index
    ///
    /// Index is zero based. It will return kAudio_ParamError if index is not in the range: 0
    /// <
    /// TrackCount
    /// The track count and accessors exclude the tempo track (which is treated as a special case)
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inTrackIndex`: the index
    ///
    /// Parameter `outTrack`: the track at that index
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_track` must be a valid pointer.
    pub fn MusicSequenceGetIndTrack(
        in_sequence: MusicSequence,
        in_track_index: u32,
        out_track: NonNull<MusicTrack>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the index number for a specified music track.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to obtain the track index number from.
    ///
    /// - inTrack: The music track whose index you want to obtain. This function returns an error if the music track is not part of the music sequence specified in the `inSequence` parameter.
    ///
    /// - outTrackIndex: On output, the zero-based index of the music track that you provided in the `inTrack` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is for accessing only indexes for music tracks, not the tempo track.
    ///
    ///
    /// Get the index for a specific track
    ///
    /// Index is zero based. It will return an error if the track is not a member of the sequence.
    /// The track count and accessors exclude the tempo track (which is treated as a special case)
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `outTrackIndex`: the index of the track
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `in_track` must be a valid pointer.
    /// - `out_track_index` must be a valid pointer.
    pub fn MusicSequenceGetTrackIndex(
        in_sequence: MusicSequence,
        in_track: MusicTrack,
        out_track_index: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the tempo track for a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence whose tempo track you want to obtain.
    ///
    /// - outTrack: On output, the tempo track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each music sequence has a single tempo track. All tempo events are placed into this track, as well as some other events—such as the time signature from a MIDI file. The tempo track, once retrieved, can be edited and iterated over as can a music track. Most non-tempo events in a tempo track are ignored.
    ///
    ///
    /// Get the tempo track of the sequence
    ///
    /// Each sequence has a single tempo track. All tempo events are placed into this tempo track (as well
    /// as other appropriate events (time sig for instance from a MIDI file). The tempo track, once retrieved
    /// can be edited and iterated upon as any other track. Non-tempo events in a tempo track are ignored.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `outTrack`: the tempo track of the sequence
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_track` must be a valid pointer.
    pub fn MusicSequenceGetTempoTrack(
        in_sequence: MusicSequence,
        out_track: NonNull<MusicTrack>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Associates an audio processing graph with a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to associate with an audio processing graph.
    ///
    /// - inGraph: The audio processing graph to associate with the music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// After you call this function, the system directs a played music sequence’s output to the associated audio processing graph. By default, all music tracks in the sequence are directed to the first node in the graph that is an Instrument unit (of type `DLSMusicDevice`).
    ///
    ///
    /// Set the graph to be associated with the sequence
    ///
    /// A sequence can be associated with an AUGraph and this graph will be used to render the events as
    /// controlled by the sequence when it is played. By default, all of the tracks of a sequence will
    /// find the first AUNode that is an instance of an Apple MusicDevice audio unit (see MusicSequenceGetAUGraph).
    /// Specific nodes of the graph can be targeted for different tracks (see MusicTrackSetDestNode).  To render a
    /// multi-track GM MIDI sequence on iOS, create a custom graph with a MIDISynth audio unit as the MusicDevice.
    /// If inGraph is set to NULL, the sequence will reset to use the default graph.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inGraph`: the graph
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `in_graph` must be a valid pointer or null.
    #[cfg(feature = "AUGraph")]
    pub fn MusicSequenceSetAUGraph(in_sequence: MusicSequence, in_graph: AUGraph) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the audio processing graph associated with a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence whose associated audio processing graph you want to get.
    ///
    /// - outGraph: On output, the audio processing graph associated with the music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If no audio processing graph is already associated with the music sequence, this function creates a default graph. The default graph contains an Instrument unit (of type DLSMusicDevice) and a dynamic compressor unit (of type DynamicCompressor). In this case, all music tracks in the music sequence have their outputs directed to the Instrument unit.
    ///
    ///
    /// Gets the graph currently associated with a sequence
    ///
    /// By default if no graph is assigned to a sequence then the sequence will create a default graph.
    /// This default graph contains a MusicDevice and a DynamicsProcessor and all tracks will be targeted
    /// to the MusicDevice.  On macOS, this MusicDevice is an instance of a software synthesizer that is
    /// compatible with the GM and GS MIDI standards.  On iOS, it is an instance of a monotimbral software
    /// synthesizer designed to render events from a single MIDI channel.  To render multi-track GM MIDI
    /// sequences on iOS, create a custom graph with a MIDISynth audio unit as the MusicDevice.
    ///
    /// This call will thus either return the graph as set by the user, or this default graph.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `outGraph`: the graph
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_graph` must be a valid pointer.
    #[cfg(feature = "AUGraph")]
    pub fn MusicSequenceGetAUGraph(
        in_sequence: MusicSequence,
        out_graph: NonNull<AUGraph>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Associates a specified MIDI endpoint with all music tracks in a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want to associate with a MIDI endpoint.
    ///
    /// - inEndpoint: The MIDI endpoint to associate with the music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is a convenience function, equivalent to iterating through the music tracks in a music sequence and targeting each to the MIDI endpoint.
    ///
    ///
    /// Makes the target of all of the tracks in the sequence a MIDI endpoint
    ///
    /// This is a convenience function, and is equivalent to iterating through all of the tracks in a sequence
    /// and targeting each track to the MIDI endpoint
    ///
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inEndpoint`: the MIDI endpoint
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    #[cfg(feature = "objc2-core-midi")]
    pub fn MusicSequenceSetMIDIEndpoint(
        in_sequence: MusicSequence,
        in_endpoint: MIDIEndpointRef,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the sequence type for a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence whose sequence type you want to set.
    ///
    /// - inType: The type of sequence to assign to the music sequence. For the list of available sequence types, see [`MusicSequenceType`](https://developer.apple.com/documentation/audiotoolbox/musicsequencetype). The default sequence type is `kMusicSequenceType_Beats`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The sequence type can be set to `kMusicSequenceType_Beats` at any time. The sequence type can only be set to `kMusicSequenceType_Seconds` or `kMusicSequenceType_Samples` if there are no tempo events already in the sequence.
    ///
    /// The following considerations pertain to the various sequence types:
    ///
    /// - `kMusicSequenceType_Beats`—Tempo is specified as beats-per-minute. A music sequence of this type can contain any number of tempo events.
    ///
    /// - `kMusicSequenceType_Samples`—Tempo is specified as a sample rate, in terms of samples-per-second. If you set the tempo to 44,100 using a sequence of this type, then 44,100 beats corresponds to a duration of one second.
    ///
    /// - `kMusicSequenceType_Seconds`—The tempo should be set to 60; a beat is a second.
    ///
    /// After setting a music sequence to the `kMusicSequenceType_Samples` or `kMusicSequenceType_Seconds` type, add a single tempo event to specify the tempo.
    ///
    /// A meta event of interest for the `kMusicSequenceType_Seconds` sequence type is the SMPTE Offset meta event, which is stored in the tempo track. The sequence doesn’t do anything with this event.
    ///
    ///
    /// Set the sequence type (the default is beats)
    ///
    /// These two calls allow you to get and set a MusicSequence type; specifying
    /// kMusicSequenceType_Beats        = 'beat',
    /// kMusicSequenceType_Seconds        = 'secs',
    /// kMusicSequenceType_Samples        = 'samp'
    ///
    /// The sequence type can be set to beats at any time. The sequence type can only be set to
    /// seconds or samples if there are NO tempo events already in the sequence.
    ///
    /// For beats - it can have as many tempo events as you want
    /// For Samples and Seconds - you should add a single tempo event after setting the type
    /// Samples - the tempo is the desired sample rate - e.g. 44100 and each "beat" in the sequence will be
    /// interpreted as a sample count at that sample rate (so beat == 44100 is a second)
    /// Seconds - the tempo should be set to 60 - a beat is a second.
    ///
    /// Beats is the default (and is the behaviour on pre 10.5 systems)
    ///
    /// A meta event of interest for Seconds based MIDI files is the SMPTE Offset meta event - stored in the tempo track.
    /// The sequence doesn't do anything with this event (except store/write it)
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inType`: the sequence type
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    pub fn MusicSequenceSetSequenceType(
        in_sequence: MusicSequence,
        in_type: MusicSequenceType,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the sequence type for a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence whose sequence type you want to get.
    ///
    /// - outType: On output, the sequence type for the music sequence.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Get the sequence type
    ///
    /// See SetSequence for a full description
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `outType`: the type
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_type` must be a valid pointer.
    pub fn MusicSequenceGetSequenceType(
        in_sequence: MusicSequence,
        out_type: NonNull<MusicSequenceType>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Loads data into a music sequence from a URL reference.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to load the data into.
    ///
    /// - inFileRef: A `file://` URL pointing to a file that contains the data to load.
    ///
    /// - inFileTypeHint: Provides a hint to the system about the file type referenced by the `inFileRef` parameter.
    ///
    /// - inFlags: Flags that specify how the data should be parsed, and how it should be assigned to tracks. See [`MusicSequenceLoadFlags`](https://developer.apple.com/documentation/audiotoolbox/musicsequenceloadflags).
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Load the data contained within the referenced file to the sequence
    ///
    /// This function will parse the file referenced by the URL and add the events to the sequence.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inFileRef`: a file:// URL that references a file
    ///
    /// Parameter `inFileTypeHint`: provides a hint to the sequence on the file type being imported. Can be zero in many cases.
    ///
    /// Parameter `inFlags`: flags that can control how the data is parsed in the file and laid out in the tracks
    /// that will be created and added to the sequence in this operation
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn MusicSequenceFileLoad(
        in_sequence: MusicSequence,
        in_file_ref: &CFURL,
        in_file_type_hint: MusicSequenceFileTypeID,
        in_flags: MusicSequenceLoadFlags,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Load data into a music sequence from a data reference.
    ///
    /// Parameters:
    /// - inSequence: The music sequence to load the data into.
    ///
    /// - inData: The contents of a valid file loaded into a `CFData` object.
    ///
    /// - inFileTypeHint: Provides a hint to the system about the file type referenced by the `inFileRef` parameter.
    ///
    /// - inFlags: Flags that specify how the data should be parsed, and how it should be assigned to tracks. See [`MusicSequenceLoadFlags`](https://developer.apple.com/documentation/audiotoolbox/musicsequenceloadflags).
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The data to be loaded must conform to the file type indicated by the `inFileTypeHint` parameter.
    ///
    ///
    /// Load the data to the sequence
    ///
    /// This function will parse the data and add the events to the sequence. The data provided needs to
    /// be of a particular file type as specified by the fileTypeHint.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inData`: the contents of a valid file loaded into a CFData object
    ///
    /// Parameter `inFileTypeHint`: provides a hint to the sequence on the file type being imported. Can be zero in many cases.
    ///
    /// Parameter `inFlags`: flags that can control how the data is parsed in the file and laid out in the tracks
    /// that will be created and added to the sequence in this operation
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn MusicSequenceFileLoadData(
        in_sequence: MusicSequence,
        in_data: &CFData,
        in_file_type_hint: MusicSequenceFileTypeID,
        in_flags: MusicSequenceLoadFlags,
    ) -> OSStatus;
}

// TODO: pub fn MusicSequenceSetSMPTEResolution(fps: SignedByte,ticks: Byte,) -> i16;

// TODO: pub fn MusicSequenceGetSMPTEResolution(in_res: i16,fps: NonNull<SignedByte>,ticks: NonNull<Byte>,);

extern "C-unwind" {
    /// Creates a MIDI file from the events in a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want to create a MIDI file from.
    ///
    /// - inFileRef: The URL to the MIDI file to be created.
    ///
    /// - inFileType: The type of file to create.
    ///
    /// - inFlags: Flags that configure the file creation process.
    ///
    /// - inResolution: The resolution, which depends on the file type and the music sequence type.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function can be (and is most commonly) used to create a MIDI file from the events in a sequence. Only MIDI based events are used when creating the MIDI file. MIDI files are normally beat based, but can also have a SMPTE (or real-time rather than beat time) representation.
    ///
    /// The inResolution parameter specifies the relationship between “tick” and quarter note for saving to a standard MIDI file. Pass 0 to this parameter to use the default value; namely, the value that is currently set on the tempo track.
    ///
    /// The various sequence types determine the kinds of files that can be created, as follows:
    ///
    /// - Beats—When saving a MIDI file, it saves a beats (PPQ) based axis.
    ///
    /// - Seconds—When saving a MIDI file, it will save it as a SMPTE resolution - so you should specify this resolution when creating the MIDI file. If zero is specified, 25 fps and 40 ticks/frame is used (a time scale of a millisecond)
    ///
    /// - Samples—You cannot save to a MIDI file with this sequence type.
    ///
    /// The complete meaning of the 16-bit “division” field in a MIDI File’s MThd chunk. If it is positive, then a tick represents 1/D quarter notes.  If it negative, the following pertains:
    ///
    /// - Bits 14-8 are a signed 7-bit number representing the SMPTE format: 24, -25, -29 (drop), -30.
    ///
    /// - Bits 7-0 represents the number of ticks per SMPTE frame. Typical values are 4, 10, 80, 100. You can obtain millisecond resolution by specifying 25 frames/sec and 40 divisions/frame:
    ///
    /// ```objc
    ///   30 fps with 80 bits (ticks) per frame: 0xE250  ((char)0xE2 == -30)
    /// ```
    ///
    ///
    /// Create a file from a sequence
    ///
    /// This function can be (and is most commonly) used to create a MIDI file from the events in a sequence.
    /// Only MIDI based events are used when creating the MIDI file. MIDI files are normally beat based, but
    /// can also have a SMPTE (or real-time rather than beat time) representation.
    ///
    /// inResolution is relationship between "tick" and quarter note for saving to Standard MIDI File
    /// - pass in zero to use default - this will be the value that is currently set on the tempo track
    /// - see the comments for the set track property's time resolution
    ///
    /// The different Sequence types determine the kinds of files that can be created:
    ///
    /// Beats
    /// When saving a MIDI file, it saves a beats (PPQ) based axis
    ///
    /// Seconds
    /// When saving a MIDI file, it will save it as a SMPTE resolution - so you should specify this resolution
    /// when creating the MIDI file.
    /// If zero is specified, 25 fps and 40 ticks/frame is used (a time scale of a millisecond)
    ///
    /// Samples
    /// You cannot save to a MIDI file with this sequence type
    ///
    /// The complete meaning of the 16-bit "division" field in a MIDI File's MThd chunk.
    ///
    /// If it is positive, then a tick represents 1/D quarter notes.
    ///
    /// If it negative:
    ///
    /// bits 14-8 are a signed 7-bit number representing the SMPTE format:
    /// -24, -25, -29 (drop), -30
    /// bits 7-0 represents the number of ticks per SMPTE frame
    /// typical values: 4, 10, 80, 100
    ///
    /// You can obtain millisecond resolution by specifying 25 frames/sec and 40 divisions/frame.
    ///
    /// 30 fps with 80 bits (ticks) per frame: 0xE250  ((char)0xE2 == -30)
    ///
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inFileRef`: the location of the file to create
    ///
    /// Parameter `inFileType`: the type of file to create
    ///
    /// Parameter `inFlags`: flags to control the file creation
    ///
    /// Parameter `inResolution`: the resolution (depending on file type and sequence type)
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn MusicSequenceFileCreate(
        in_sequence: MusicSequence,
        in_file_ref: &CFURL,
        in_file_type: MusicSequenceFileTypeID,
        in_flags: MusicSequenceFileFlags,
        in_resolution: i16,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a data object containing the events from a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want to create a MIDI data object from.
    ///
    /// - inFileType: The type of file format for the data in the data object.
    ///
    /// - inFlags: Flags that configure the data object creation process.
    ///
    /// - inResolution: The resolution, which depends on the file type and the music sequence type.
    ///
    /// - outData: On output, the data object containing MIDI data in the specified format.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `CFData` object should be released by the caller.
    ///
    ///
    /// Create a data object from a sequence
    ///
    /// The same basic parameters apply to this as with the MusicSequenceFileCreate function. The difference
    /// being that that function will create a file on disk, whereas this one will create a CFData object
    /// that is a file in memory. The CFData object should be released by the caller.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inFileType`: the type of file to create
    ///
    /// Parameter `inFlags`: flags to control the file creation
    ///
    /// Parameter `inResolution`: the resolution (depending on file type and sequence type)
    ///
    /// Parameter `outData`: the resulting data object
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_data` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn MusicSequenceFileCreateData(
        in_sequence: MusicSequence,
        in_file_type: MusicSequenceFileTypeID,
        in_flags: MusicSequenceFileFlags,
        in_resolution: i16,
        out_data: NonNull<*const CFData>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Reverses the MIDI and tempo events in a music sequence, so the start becomes the end.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want to time-reverse.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Reverse in time all events in a sequence, including the tempo events
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    pub fn MusicSequenceReverse(in_sequence: MusicSequence) -> OSStatus;
}

extern "C-unwind" {
    /// Calculates the number of seconds that correspond to a number of beats.
    ///
    /// Parameters:
    /// - inSequence: The sequence that you want to get a count of seconds for.
    ///
    /// - inBeats: The number of beats that you want the corresponding number of seconds for.
    ///
    /// - outSeconds: On output, the number of seconds that corresponds to the number of beats in the `inBeats` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function makes use of the music sequence’s tempo track.
    ///
    ///
    /// Returns a seconds value that would correspond to the supplied beats
    ///
    /// Uses the sequence's tempo events
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inBeats`: the beats
    ///
    /// Parameter `outSeconds`: the seconds (time from 0 beat)
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_seconds` must be a valid pointer.
    pub fn MusicSequenceGetSecondsForBeats(
        in_sequence: MusicSequence,
        in_beats: MusicTimeStamp,
        out_seconds: NonNull<f64>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Calculates the number of beats that correspond to a number of seconds.
    ///
    /// Parameters:
    /// - inSequence: The sequence that you want to get a count of beats for.
    ///
    /// - inSeconds: The number of seconds that you want the corresponding number of beats for.
    ///
    /// - outBeats: On output, the number of beats that corresponds to the number of seconds in the `inSeconds` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function makes use of the music sequence’s tempo track.
    ///
    ///
    /// Returns a beat value that would correspond to the supplied seconds from zero.
    ///
    /// Uses the sequence's tempo events
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inSeconds`: the seconds
    ///
    /// Parameter `outBeats`: the corresponding beat
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_beats` must be a valid pointer.
    pub fn MusicSequenceGetBeatsForSeconds(
        in_sequence: MusicSequence,
        in_seconds: f64,
        out_beats: NonNull<MusicTimeStamp>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Registers a user callback function with a music sequence.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want to add a user callback function to.
    ///
    /// - inCallback: A reference to your callback function. Use `NULL` to remove a registered callback function.
    ///
    /// - inClientData: Your data that the music sequence provides back to your callback function when it is invoked.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The music sequence invokes your callback for each user event added to any music track owned by the sequence. If there is a callback registered, then UserEvents will be chased when MusicPlayerSetTime is called. In that case the inStartSliceBeat and inEndSliceBeat will both be the same value and will be the beat that the player is chasing to.
    ///
    /// Usually, where the sequence data is being scheduled for playback, the following applies:
    ///
    /// ```objc
    /// inStartSliceBeat <= inEventTime < inEndSliceBeat
    /// ```
    ///
    /// The only exception to this is if the track that owns the MusicEvent is looping. In this case the start beat will still be less than the end beat (so your callback can still determine that it is playing, and what beats are currently being scheduled), however, the inEventTime will be the original time-stamped time of the user event.
    ///
    ///
    /// Establish a user callback for a sequence
    ///
    /// This call is used to register (or remove if inCallback is NULL) a callback
    /// that the MusicSequence will call for ANY UserEvents that are added to any of the
    /// tracks of the sequence.
    ///
    /// If there is a callback registered, then UserEvents will be chased when
    /// MusicPlayerSetTime is called. In that case the inStartSliceBeat and inEndSliceBeat
    /// will both be the same value and will be the beat that the player is chasing too.
    ///
    /// In normal cases, where the sequence data is being scheduled for playback, the
    /// following will apply:
    /// inStartSliceBeat
    /// <
    /// = inEventTime
    /// <
    /// inEndSliceBeat
    ///
    /// The only exception to this is if the track that owns the MusicEvent is looping.
    /// In this case the start beat will still be less than the end beat (so your callback
    /// can still determine that it is playing, and what beats are currently being scheduled),
    /// however, the inEventTime will be the original time-stamped time of the user event.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inCallback`: the callback
    ///
    /// Parameter `inClientData`: client (user supplied) data provided back to the callback when it is called by the sequence
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_client_data` must be a valid pointer or null.
    pub fn MusicSequenceSetUserCallback(
        in_sequence: MusicSequence,
        in_callback: MusicSequenceUserCallback,
        in_client_data: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Formats a music sequence’s beat time to its bar-beat time.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want bar-beat time for.
    ///
    /// - inBeats: The beats to be represented as bar-beats.
    ///
    /// - inSubbeatDivisor: The denominator of the fractional number of beats.
    ///
    /// - outBarBeatTime: On output, the music sequence’s bar-beat time.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The sequence’s tempo track time signature events are used to calculate the bar-beat representation. If there are no Time Sig events added to the sequence 4/4 is assumed. A time signature event is a MIDI Meta Event as specified for MIDI files.
    ///
    /// Refer to `AudioToolbox/CAClock.h` for more information.
    ///
    ///
    /// Convenience function to format a sequence's beat time to its bar-beat time
    ///
    /// The sequence's tempo track Time Sig events are used to
    /// to calculate the bar-beat representation. If there are no Time Sig events added to the sequence
    /// 4/4 is assumed. A Time Sig event is a MIDI Meta Event as specified for MIDI files.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inBeats`: the beat which should be represented by the bar-beat
    ///
    /// Parameter `inSubbeatDivisor`: The denominator of the fractional number of beats.
    ///
    /// Parameter `outBarBeatTime`: the formatted bar/beat time
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_bar_beat_time` must be a valid pointer.
    pub fn MusicSequenceBeatsToBarBeatTime(
        in_sequence: MusicSequence,
        in_beats: MusicTimeStamp,
        in_subbeat_divisor: u32,
        out_bar_beat_time: NonNull<CABarBeatTime>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Formats a music sequence’s bar-beat time to its beat time.
    ///
    /// Parameters:
    /// - inSequence: The music sequence that you want the beat count for.
    ///
    /// - inBarBeatTime: The bar-beat time to be represented as beats.
    ///
    /// - outBeats: On output, the music sequence’s beat time.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The sequence’s tempo track time signature events are used to to calculate the bar-beat representation. If there are no Time Sig events added to the sequence 4/4 is assumed. A time signature event is a MIDI Meta Event as specified for MIDI files.
    ///
    /// Refer to `AudioToolbox/CAClock.h` for more information.
    ///
    ///
    /// Convenience function to format a bar-beat time to a sequence's beat time
    ///
    /// The sequence's tempo track Time Sig events are used to
    /// to calculate the bar-beat representation. If there are no Time Sig events added to the sequence
    /// 4/4 is assumed. A Time Sig event is a MIDI Meta Event as specified for MIDI files.
    ///
    /// Parameter `inSequence`: the sequence
    ///
    /// Parameter `inBarBeatTime`: the bar-beat time
    ///
    /// Parameter `outBeats`: the sequence's beat time for that bar-beat time
    ///
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `in_bar_beat_time` must be a valid pointer.
    /// - `out_beats` must be a valid pointer.
    pub fn MusicSequenceBarBeatTimeToBeats(
        in_sequence: MusicSequence,
        in_bar_beat_time: NonNull<CABarBeatTime>,
        out_beats: NonNull<MusicTimeStamp>,
    ) -> OSStatus;
}

/// Returns a dictionary containing music sequence information.
///
/// Parameters:
/// - inSequence: The music sequence that you want the information dictionary from.
///
///
/// ## Return Value
///
/// A dictionary object containing information about a music sequence.
///
///
///
/// ## Discussion
///
/// The dictionary can contain one or more of the kAFInfoDictionary_* keys specified in `AudioToolbox/AudioFile.h`. The caller should release the returned dictionary. If the call fails it will return `NULL`
///
///
/// Returns a dictionary containing meta-data derived from a sequence
///
/// The dictionary can contain one or more of the kAFInfoDictionary_*
/// keys specified in
/// <AudioToolbox
/// /AudioFile.h>
///
/// The caller should release the returned dictionary. If the call fails it will return NULL
///
///
/// Parameter `inSequence`: the sequence
///
/// Returns: a CFDictionary or NULL if the call fails.
///
/// # Safety
///
/// `in_sequence` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn MusicSequenceGetInfoDictionary(
    in_sequence: MusicSequence,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn MusicSequenceGetInfoDictionary(
            in_sequence: MusicSequence,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { MusicSequenceGetInfoDictionary(in_sequence) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

extern "C-unwind" {
    /// Gets the music sequence that the music track is a member of.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to know the music sequence for.
    ///
    /// - outSequence: On return, the music sequence that the music track is a member of.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Gets the sequence which the track is a member of
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `outSequence`: the track's sequence
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `out_sequence` must be a valid pointer.
    pub fn MusicTrackGetSequence(
        in_track: MusicTrack,
        out_sequence: NonNull<MusicSequence>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the music track’s event target to an audio unit node.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to set a target audio unit node for.
    ///
    /// - inNode: The node that you specifying as the target for music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The audio unit node that you specify must be a member of the audio processing graph that the music track’s sequence is using. When played, the track sends its events to that node.
    ///
    ///
    /// Sets the track's target to the specified AUNode
    ///
    /// The node must be a member of the graph that the track's sequence is using. When played, the track
    /// will send all of its events to that node.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inNode`: the new node
    ///
    /// # Safety
    ///
    /// `in_track` must be a valid pointer.
    #[cfg(feature = "AUGraph")]
    pub fn MusicTrackSetDestNode(in_track: MusicTrack, in_node: AUNode) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the music track’s event target to a MIDI endpoint.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to set a target MIDI endpoint for.
    ///
    /// - inEndpoint: The MIDI endpoint that you specifying as the target for music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// When played, the music track sends its events to the specified MIDI endpoint.
    ///
    ///
    /// Sets the track's target to the specified MIDI endpoint
    ///
    /// When played, the track will send all of its events to the specified MIDI Endpoint.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inEndpoint`: the new MIDI endpoint
    ///
    /// # Safety
    ///
    /// `in_track` must be a valid pointer.
    #[cfg(feature = "objc2-core-midi")]
    pub fn MusicTrackSetDestMIDIEndpoint(
        in_track: MusicTrack,
        in_endpoint: MIDIEndpointRef,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the audio unit node that is the event target for a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track for which you want to get the associated audio unit node.
    ///
    /// - outNode: On return, the audio unit node that is the event target of the music track. This function instead returns an error if the music track’s event target is not an audio unit node.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. If the music track’s event target is a MIDI endpoint, returns `kAudioToolboxErr_IllegalTrackDestination`.
    ///
    ///
    /// Gets the track's target if it is an AUNode
    ///
    /// Returns kAudioToolboxErr_IllegalTrackDestination if the track's target is a MIDIEndpointRef
    /// and NOT an AUNode
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `outNode`: the node target for the track
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `out_node` must be a valid pointer.
    #[cfg(feature = "AUGraph")]
    pub fn MusicTrackGetDestNode(in_track: MusicTrack, out_node: NonNull<AUNode>) -> OSStatus;
}

extern "C-unwind" {
    /// Gets the MIDI endpoint that is the event target for a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track for which you want to get the associated MIDI endpoint.
    ///
    /// - outEndpoint: On return, the MIDI endpoint that is the event target of the music track. This function instead returns an error if the music track’s event target is not a MIDI endpoint.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. If the music track’s event target is an audio unit node, returns `kAudioToolboxErr_IllegalTrackDestination`.
    ///
    ///
    /// Gets the track's target if it is a MIDI Endpoint
    ///
    /// Returns kAudioToolboxErr_IllegalTrackDestination if the track's target is an AUNode
    /// and NOT a MIDI Endpoint
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `outEndpoint`: the MIDI Endpoint target for the track
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `out_endpoint` must be a valid pointer.
    #[cfg(feature = "objc2-core-midi")]
    pub fn MusicTrackGetDestMIDIEndpoint(
        in_track: MusicTrack,
        out_endpoint: NonNull<MIDIEndpointRef>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets a music track property value.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to set a property value for.
    ///
    /// - inPropertyID: The identifier for the music track property that you want to set. See [Music Track Properties](https://developer.apple.com/documentation/audiotoolbox/1515456-music-track-properties) for possible values.
    ///
    /// - inData: The new property value.
    ///
    /// - inLength: The size of the new property value.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Music track property values are always accessed by reference.
    ///
    ///
    /// Sets the specified property value
    ///
    /// Property values are always get and set by reference
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inPropertyID`: the property ID
    ///
    /// Parameter `inData`: the new property value
    ///
    /// Parameter `inLength`: the size of the property value being set
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_data` must be a valid pointer.
    pub fn MusicTrackSetProperty(
        in_track: MusicTrack,
        in_property_id: u32,
        in_data: NonNull<c_void>,
        in_length: u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets a music track property value.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to get a property value from.
    ///
    /// - inPropertyID: The identifier for the music track property that you want to get. See [Music Track Properties](https://developer.apple.com/documentation/audiotoolbox/1515456-music-track-properties) for possible values.
    ///
    /// - outData: On output, the requested property value.
    ///
    /// - ioLength: On input, the available size for the retrieved property value. On output, the size of the valid property data that `outData` points to.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Music track property values are always accessed by reference. As of OS X v10.6, all such property values are fixed length.
    ///
    /// This function’s main purpose is to retrieve a music track property value, but you also use it to obtain the size of a variable-length property. Do this, prior to retrieving a variable-length property value, to ensure that you allocate enough memory in `outData` to hold the value.
    ///
    /// To obtain a property value’s size, call this function with the `outData` parameter set to `NULL`. On output, the `ioLength` parameter contains the property size.
    ///
    ///
    /// Gets the specified property value
    ///
    /// If outData is NULL, then the size of the data will be passed back in ioLength
    /// This allows the client to allocate a buffer of the correct size (useful for variable
    /// length properties -- currently all properties have fixed size)
    /// Property values are always get and set by reference
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inPropertyID`: the property ID
    ///
    /// Parameter `outData`: if not NULL, points to data of size ioLength
    ///
    /// Parameter `ioLength`: on input the available size of outData, on output the size of the valid data that outData
    /// will then point too.
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `out_data` must be a valid pointer.
    /// - `io_length` must be a valid pointer.
    pub fn MusicTrackGetProperty(
        in_track: MusicTrack,
        in_property_id: u32,
        out_data: NonNull<c_void>,
        io_length: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Shifts music track events forward or backward in time, in terms of beats.
    ///
    /// Parameters:
    /// - inTrack: The track whose events you want to move forward or backward in time.
    ///
    /// - inStartTime: The current start time, in beats, for the music track events you want to move.
    ///
    /// - inEndTime: The current end time, in beats, for the music track events you want to move.
    ///
    /// - inMoveTime: The number of beats to move the specified range of music track events. A positive value moves the events toward the end of the music track; a negative value moves the events toward the start.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `inStartTime` value must be less than the `inEndTime` value.
    ///
    ///
    /// Move events in a track
    ///
    /// Moves all of the events in the specified time range by the moveTime. MoveTime maybe negative to
    /// move events backwards (towards zero).
    ///
    /// All time ranges are [starttime
    /// <
    /// endtime]
    ///
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inStartTime`: the start time for the range of events
    ///
    /// Parameter `inEndTime`: the end time up to which will form the range of the events to move
    ///
    /// Parameter `inMoveTime`: amount of beats to move the selected events.
    ///
    /// # Safety
    ///
    /// `in_track` must be a valid pointer.
    pub fn MusicTrackMoveEvents(
        in_track: MusicTrack,
        in_start_time: MusicTimeStamp,
        in_end_time: MusicTimeStamp,
        in_move_time: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Removes a specified range of music track events.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to remove events from.
    ///
    /// - inStartTime: The start time, in beats, for the range of music track events that you want to remove.
    ///
    /// - inEndTime: The end time, in beats, for the range of music track events that you want to remove.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `inStartTime` value must be less than the `inEndTime` value.
    ///
    ///
    /// Removes all events within the specified range
    ///
    /// All time ranges are [starttime
    /// <
    /// endtime]
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inStartTime`: the start time for the range of events
    ///
    /// Parameter `inEndTime`: the end time up to which will form the range of the events to clear
    ///
    /// # Safety
    ///
    /// `in_track` must be a valid pointer.
    pub fn MusicTrackClear(
        in_track: MusicTrack,
        in_start_time: MusicTimeStamp,
        in_end_time: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Removes a specified range of music track events, and shifts later events toward the start of the track to fill in the gap.
    ///
    /// Parameters:
    /// - inTrack: The music track that you want to cut events from.
    ///
    /// - inStartTime: The start time, in beats, for the range of music track events that you want to cut.
    ///
    /// - inEndTime: The end time, in beats, for the range of music track events that you want to cut.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `inStartTime` value must be less than the `inEndTime` value.
    ///
    ///
    /// Removes all the events within the specified range
    ///
    /// Events that fall past the specified range will be moved back by the specified range time.
    ///
    /// All time ranges are [starttime
    /// <
    /// endtime]
    ///
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inStartTime`: the start time for the range of events
    ///
    /// Parameter `inEndTime`: the end time up to which will form the range of the events to cut out
    ///
    /// # Safety
    ///
    /// `in_track` must be a valid pointer.
    pub fn MusicTrackCut(
        in_track: MusicTrack,
        in_start_time: MusicTimeStamp,
        in_end_time: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Copies a range of events from one music track and inserts them into another music track.
    ///
    /// Parameters:
    /// - inSourceTrack: The music track that you want to copy events from.
    ///
    /// - inSourceStartTime: The start time, in beats, for the range of music track events that you want to copy from the source track.
    ///
    /// - inSourceEndTime: The end time, in beats, for the range of music track events that you want to copy from the source track.
    ///
    /// - inDestTrack: The music track that you want to add events to.
    ///
    /// - inDestInsertTime: The insertion point, in beats, in the destination music track for the copied events.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The events in the destination music track, starting at the insertion point, are pushed later in time (that is, away from the start of the track) to make room for the inserted events.
    ///
    /// The `inSourceStartTime` value must be less than the `inSourceEndTime` value.
    ///
    ///
    /// Copies events from one track and inserts them into another
    ///
    /// Copies all of the events with the specified time range of the source track. It then inserts
    /// those events into the destination track. All events at and after inDestInsertTime in inDestTrack
    /// are moved forward by the range's duration
    ///
    /// All time ranges are [starttime
    /// <
    /// endtime]
    ///
    ///
    /// Parameter `inSourceTrack`: the source track
    ///
    /// Parameter `inSourceStartTime`: the start time for the range of events
    ///
    /// Parameter `inSourceEndTime`: the end time up to which will form the range of the events to copy from the source track
    ///
    /// Parameter `inDestTrack`: the destination track to copy too
    ///
    /// Parameter `inDestInsertTime`: the time at which the copied events will be inserted.
    ///
    /// # Safety
    ///
    /// - `in_source_track` must be a valid pointer.
    /// - `in_dest_track` must be a valid pointer.
    pub fn MusicTrackCopyInsert(
        in_source_track: MusicTrack,
        in_source_start_time: MusicTimeStamp,
        in_source_end_time: MusicTimeStamp,
        in_dest_track: MusicTrack,
        in_dest_insert_time: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Copies a range of events from one music track and merges them into another music track.
    ///
    /// Parameters:
    /// - inSourceTrack: The music track that you want to copy events from.
    ///
    /// - inSourceStartTime: The start time, in beats, for the range of music track events that you want to copy from the source track.
    ///
    /// - inSourceEndTime: The end time, in beats, for the range of music track events that you want to copy from the source track.
    ///
    /// - inDestTrack: The music track that you want to add events to.
    ///
    /// - inDestInsertTime: The insertion point, in beats, in the destination music track for the copied events.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The events inserted into the destination music track are merged with existing events in that track. The events in the destination track that existed prior to calling this function remain in place.
    ///
    /// The `inSourceStartTime` value must be less than the `inSourceEndTime` value.
    ///
    ///
    /// Copies events from one track and merges them into another
    ///
    /// Copies all of the events with the specified time range of the source track. It then merges
    /// those events into the destination track starting at inDestInsertTime.
    ///
    /// All time ranges are [starttime
    /// <
    /// endtime]
    ///
    ///
    /// Parameter `inSourceTrack`: the source track
    ///
    /// Parameter `inSourceStartTime`: the start time for the range of events
    ///
    /// Parameter `inSourceEndTime`: the end time up to which will form the range of the events to copy from the source track
    ///
    /// Parameter `inDestTrack`: the destination track to copy too
    ///
    /// Parameter `inDestInsertTime`: the time at which the copied events will be merged.
    ///
    /// # Safety
    ///
    /// - `in_source_track` must be a valid pointer.
    /// - `in_dest_track` must be a valid pointer.
    pub fn MusicTrackMerge(
        in_source_track: MusicTrack,
        in_source_start_time: MusicTimeStamp,
        in_source_end_time: MusicTimeStamp,
        in_dest_track: MusicTrack,
        in_dest_insert_time: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `MIDINoteMessage` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inMessage: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a MIDINoteMessage event to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inMessage`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_message` must be a valid pointer.
    pub fn MusicTrackNewMIDINoteEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_message: NonNull<MIDINoteMessage>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `MIDIChannelMessage` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inMessage: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a MIDIChannelMessage event to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inMessage`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_message` must be a valid pointer.
    pub fn MusicTrackNewMIDIChannelEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_message: NonNull<MIDIChannelMessage>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `MIDIRawData` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inRawData: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a MIDIRawData event to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inRawData`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_raw_data` must be a valid pointer.
    pub fn MusicTrackNewMIDIRawDataEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_raw_data: NonNull<MIDIRawData>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `ExtendedNoteOnEvent` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inInfo: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a ExtendedNoteOnEvent to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inInfo`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_info` must be a valid pointer.
    #[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
    pub fn MusicTrackNewExtendedNoteEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_info: NonNull<ExtendedNoteOnEvent>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `ParameterEvent` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inInfo: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a ParameterEvent to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inInfo`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_info` must be a valid pointer.
    #[cfg(feature = "AUComponent")]
    pub fn MusicTrackNewParameterEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_info: NonNull<ParameterEvent>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds a tempo to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inBPM: The tempo, in beats per minute, to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a tempo event to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inBPM`: the event
    ///
    /// # Safety
    ///
    /// `in_track` must be a valid pointer.
    pub fn MusicTrackNewExtendedTempoEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_bpm: f64,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `MIDIMetaEvent` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inMetaEvent: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a MIDIMetaEvent to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inMetaEvent`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_meta_event` must be a valid pointer.
    pub fn MusicTrackNewMetaEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_meta_event: NonNull<MIDIMetaEvent>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `MusicEventUserData` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inUserData: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a MusicEventUserData event to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inUserData`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_user_data` must be a valid pointer.
    pub fn MusicTrackNewUserEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_user_data: NonNull<MusicEventUserData>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Adds an event of type `AUPresetEvent` to a music track.
    ///
    /// Parameters:
    /// - inTrack: The music track to add the event to.
    ///
    /// - inTimeStamp: The timestamp, in beats, at which to add the event. Must be greater than or equal to 0.
    ///
    /// - inPresetEvent: The event to add to the music track.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Adds a AUPresetEvent to a track
    ///
    /// The event is added at the specified time stamp. The time stamp should not be less than zero.
    ///
    /// Parameter `inTrack`: the track
    ///
    /// Parameter `inTimeStamp`: the time stamp
    ///
    /// Parameter `inPresetEvent`: the event
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_preset_event` must be a valid pointer.
    #[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
    pub fn MusicTrackNewAUPresetEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_preset_event: NonNull<AUPresetEvent>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a new music event iterator.
    ///
    /// Parameters:
    /// - inTrack: The music track to iterate over.
    ///
    /// - outIterator: On output, the newly created music event iterator.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A newly-created music event iterator points at the first event on the music track specified in the `inTrack` parameter.
    ///
    /// If you edit a music track after associating it with a music event iterator, you must discard iterator and create a new one. Perform the following steps after editing the track:
    ///
    /// 1. Obtain the current position using the [`MusicEventIteratorGetEventInfo`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorgeteventinfo(_:_:_:_:_:)) function, and save the position.
    ///
    /// 2. Dispose of the music event iterator.
    ///
    /// 3. Create a new iterator.
    ///
    /// 4. Seek to the desired position using the [`MusicEventIteratorSeek`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorseek(_:_:)) function.
    ///
    ///
    /// Creates an iterator to iterator over a track's events
    ///
    /// The iterator should be considered invalid if a track is edited. In that case you should create a new
    /// iterator and seek it to the desired position.
    ///
    ///
    /// Parameter `inTrack`: the track upon which to iterate
    ///
    /// Parameter `outIterator`: the new iterator
    ///
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `out_iterator` must be a valid pointer.
    pub fn NewMusicEventIterator(
        in_track: MusicTrack,
        out_iterator: NonNull<MusicEventIterator>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Disposes of a music event iterator.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator to dispose of.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Dispose an iterator
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// # Safety
    ///
    /// `in_iterator` must be a valid pointer.
    pub fn DisposeMusicEventIterator(in_iterator: MusicEventIterator) -> OSStatus;
}

extern "C-unwind" {
    /// Positions a music event iterator at a specified timestamp, in beats.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator that you want to position along a music track.
    ///
    /// - inTimeStamp: The new position for the music event iterator, in beats.
    ///
    /// If there is no music event at the specified time, on output the iterator points to the first event after that time.
    ///
    /// To position the iterator immediately beyond the final event of a music track, specify [`kMusicTimeStamp_EndOfTrack`](https://developer.apple.com/documentation/audiotoolbox/kmusictimestamp_endoftrack) for this parameter. You can then call the [`MusicEventIteratorPreviousEvent`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorpreviousevent(_:)) to backtrack to the final event of the music track.
    ///
    /// To position the iterator at the first event of a music track, specify a value of 0 for this parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Move the iterator to an event at the specified time
    ///
    /// If there is no event at the specified time, the iterator will point to the first event after
    /// that time.
    /// By specifying kMusicTimeStamp_EndOfTrack you will position the iterator to the end of track
    /// (which is pointing to the space just AFTER the last event). You can use MusicEventIteratorPreviousEvent
    /// to backup to the last event.
    /// By specifying 0, you will position the iterator at the first event
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `inTimeStamp`: the time stamp to seek too
    ///
    /// # Safety
    ///
    /// `in_iterator` must be a valid pointer.
    pub fn MusicEventIteratorSeek(
        in_iterator: MusicEventIterator,
        in_time_stamp: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Positions a music event iterator at the next event on a music track.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator to reposition.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this function to increment the position of a music event iterator forward through a music track’s events.
    ///
    /// If an iterator is at the final event of a track when you call this function, the iterator then moves beyond the final event. You can detect if the iterator is beyond the final event by calling the [`MusicEventIteratorHasCurrentEvent`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorhascurrentevent(_:_:)) function.
    ///
    /// The following code snippet illustrates how to use a music event iterator to proceed forward along a music track, from the start:
    ///
    /// ```objc
    /// // Create a new iterator, which automatically points at the first event
    /// // on the iterator's music track.
    ///  
    /// bool hasCurrentEvent;
    /// MusicEventIteratorHasCurrentEvent (myIterator, &hasCurrentEvent);
    /// while (hasCurrentEvent) {
    ///         // do work here
    ///     MusicEventIteratorNextEvent (myIterator);
    ///     MusicEventIteratorHasCurrentEvent (myIterator, &hasCurrentEvent);
    /// }
    /// ```
    ///
    ///
    /// Move the iterator to the next event
    ///
    /// If the iterator was at the last event, then it will move past the last event and will no longer point
    /// to an event. You can use check MusicEventIteratorHasCurrentEvent to see if there is an event at the
    /// iterator's current position. See also MusicEventIteratorHasNextEvent.
    ///
    /// Typically this call is used to move the iterator forwards through the track's events.
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// # Safety
    ///
    /// `in_iterator` must be a valid pointer.
    pub fn MusicEventIteratorNextEvent(in_iterator: MusicEventIterator) -> OSStatus;
}

extern "C-unwind" {
    /// Positions a music event iterator at the previous event on a music track.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator to reposition.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this function to decrement a music event iterator, moving it backward through a music track’s events.
    ///
    /// If an iterator is at the first event of a track when you call this function, the iterator position remains unchanged and this function returns an error.
    ///
    /// The following code snippet illustrates how to use a music event iterator to proceed backward along a music track, from the end:
    ///
    /// ```objc
    /// // Points iterator just beyond the final event on its music track
    /// MusicEventIteratorSeek (myIterator, kMusicTimeStamp_EndOfTrack);
    ///  
    /// bool hasPreviousEvent;
    /// MusicEventIteratorHasPreviousEvent (myIterator, &hasPreviousEvent);
    /// while (hasPreviousEvent) {
    ///     MusicEventIteratorPreviousEvent (myIterator);
    ///         // do work here
    ///     MusicEventIteratorHasPreviousEvent (myIterator, &hasPreviousEvent);
    /// }
    /// ```
    ///
    ///
    /// Move the iterator to the previous event
    ///
    /// If the iterator was at the first event, then it will leave the iterator unchanged and return an error.
    /// See also MusicEventIteratorHasPreviousEvent
    ///
    /// Typically this call is used to move the iterator backwards through the track's events.
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// # Safety
    ///
    /// `in_iterator` must be a valid pointer.
    pub fn MusicEventIteratorPreviousEvent(in_iterator: MusicEventIterator) -> OSStatus;
}

extern "C-unwind" {
    /// Gets information about the event at a music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose current event you want information about.
    ///
    /// - outTimeStamp: On output, the timestamp of the music event, in beats.
    ///
    /// - outEventType: On output, the type of music event. For possible event types, see [`MusicEventType`](https://developer.apple.com/documentation/audiotoolbox/musiceventtype).
    ///
    /// - outEventData: On output, a reference to the music event data. The type of data is specified by the `outEventType` parameter. Do not modify the referenced data directly; to change an event, use the [`MusicEventIteratorSetEventInfo`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorseteventinfo(_:_:_:)) function.
    ///
    /// - outEventDataSize: On output, the size, in bytes, of the music event data in the `outEventData` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Pass `NULL` for any output parameter whose information you do not need.
    ///
    ///
    /// Retrieves the event data at the iterator.
    ///
    /// Retrieves the event and other information from the iterator's current position.
    ///
    /// If you do not want specific information (eg, the time stamp) pass in NULL for that parameter.
    ///
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `outTimeStamp`: the time stamp of the event
    ///
    /// Parameter `outEventType`: one of kMusicEventType_XXX that indicates what kind of event type the iterator
    /// is currently pointing too
    ///
    /// Parameter `outEventData`: a reference to the event data. The type of data is described by the eventType. This data
    /// is read only and should not be edited in place.
    ///
    /// Parameter `outEventDataSize`: the size of the data referenced by outEventData
    ///
    /// # Safety
    ///
    /// - `in_iterator` must be a valid pointer.
    /// - `out_time_stamp` must be a valid pointer.
    /// - `out_event_type` must be a valid pointer.
    /// - `out_event_data` must be a valid pointer.
    /// - `out_event_data_size` must be a valid pointer.
    pub fn MusicEventIteratorGetEventInfo(
        in_iterator: MusicEventIterator,
        out_time_stamp: NonNull<MusicTimeStamp>,
        out_event_type: NonNull<MusicEventType>,
        out_event_data: NonNull<*const c_void>,
        out_event_data_size: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets information for the event at a music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose current event you want to set.
    ///
    /// - inEventType: The type of music event that you are specifying. For possible event types, see [`MusicEventType`](https://developer.apple.com/documentation/audiotoolbox/musiceventtype).
    ///
    /// - inEventData: The event data that you are specifying. The size and type of the data must be appropriate for the music event type you specify in the `inEventType` parameter.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this function to set the music event type and event data for the event that a music event iterator is positioned at. This function doesn’t allow you to change an event’s timestamp; to do that, call the [`MusicEventIteratorSetEventTime`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorseteventtime(_:_:)) function.
    ///
    ///
    /// Changes the type or value of an event
    ///
    /// Allows you to change either the event type, or the values of the event data, that the iterator is
    /// currently pointing too. You cannot change the event's time (to do that you should use
    /// MusicEventIteratorSetEventTime).
    ///
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `inEventType`: the new (or existing) type of the event you are changing
    ///
    /// Parameter `inEventData`: the new event data. The size and type of this event data must match the inEventType
    ///
    /// # Safety
    ///
    /// - `in_iterator` must be a valid pointer.
    /// - `in_event_data` must be a valid pointer.
    pub fn MusicEventIteratorSetEventInfo(
        in_iterator: MusicEventIterator,
        in_event_type: MusicEventType,
        in_event_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the timestamp for the event at a music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose current event you want to change the timestamp of.
    ///
    /// - inTimeStamp: The new timestamp for the event, in beats.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// After calling this function, the music event iterator remains positioned at the same event. However, because the event has been moved to a new location on the iterator’s music track, the iterator may no longer have a next or previous event. You can test this by calling [`MusicEventIteratorHasPreviousEvent`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorhaspreviousevent(_:_:)) and [`MusicEventIteratorHasNextEvent`](https://developer.apple.com/documentation/audiotoolbox/musiceventiteratorhasnextevent(_:_:)).
    ///
    ///
    /// Set a new time for an event
    ///
    /// The iterator will still be pointing to the same event, but as the event will have moved,
    /// it may or may not have a next or previous event now (depending of course on the time
    /// you moved it to).
    ///
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `inTimeStamp`: the new time stamp of the event
    ///
    /// # Safety
    ///
    /// `in_iterator` must be a valid pointer.
    pub fn MusicEventIteratorSetEventTime(
        in_iterator: MusicEventIterator,
        in_time_stamp: MusicTimeStamp,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Deletes the event at a music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose current event you want to delete.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// After calling this function, the music event iterator points to the event that follows the deleted event—if there is such an event. If the event you deleted was the final event, the iterator is then positioned immediately beyond the final event of the music track.
    ///
    ///
    /// Deletes the event pointed to by the iterator
    ///
    /// The iterator will reference the next event after the event has been deleted.
    ///
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// # Safety
    ///
    /// `in_iterator` must be a valid pointer.
    pub fn MusicEventIteratorDeleteEvent(in_iterator: MusicEventIterator) -> OSStatus;
}

extern "C-unwind" {
    /// Indicates whether or not a music track contains an event before the music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose state you want to know about.
    ///
    /// - outHasPrevEvent: On output, `true` (nonzero) if there is an event closer to the start of the music track than the music event iterator’s current position; `false` (zero) otherwise.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Does the track have an event previous to the event the iterator is pointing to?
    ///
    /// To use the iterator going backwards through a track:
    /// iter = New Iterator (points at first event)
    /// MusicEventIteratorSeek (iter, kMusicTimeStamp_EndOfTrack) // will point it past the last event
    /// bool hasPreviousEvent;
    /// MusicEventIteratorHasPreviousEvent (iter,
    /// &hasPreviousEvent
    /// )
    /// while (hasPreviousEvent) {
    /// MusicEventIteratorPreviousEvent (iter)
    /// //     do work... MusicEventIteratorGetEventInfo (iter, ...
    ///
    /// MusicEventIteratorHasPreviousEvent (iter,
    /// &hasPreviousEvent
    /// );
    /// }
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `outHasPrevEvent`: true if there is a previous event, false if not
    ///
    /// # Safety
    ///
    /// - `in_iterator` must be a valid pointer.
    /// - `out_has_prev_event` must be a valid pointer.
    pub fn MusicEventIteratorHasPreviousEvent(
        in_iterator: MusicEventIterator,
        out_has_prev_event: NonNull<Boolean>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Indicates whether or not a music track contains an event beyond the music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose state you want to know about.
    ///
    /// - outHasNextEvent: On output, `true` (nonzero) if there is an event closer to the end of the music track than the music event iterator’s current position; `false` (zero) otherwise.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Does the track have an event past the event the iterator is pointing too?
    ///
    /// To use the iterator going forwards through a track:
    /// iter = New Iterator (points at first event)
    /// bool hasCurrentEvent;
    /// MusicEventIteratorHasCurrentEvent(iter,
    /// &hasCurrentEvent
    /// );
    /// while (hasCurrentEvent) {
    /// // do work... MusicEventIteratorGetEventInfo (iter, ...
    ///
    /// MusicEventIteratorNextEvent (iter)
    /// MusicEventIteratorHasCurrentEvent(iter,
    /// &hasCurrentEvent
    /// );
    /// }
    ///
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `outHasNextEvent`: true if there is a next event, false if not
    ///
    /// # Safety
    ///
    /// - `in_iterator` must be a valid pointer.
    /// - `out_has_next_event` must be a valid pointer.
    pub fn MusicEventIteratorHasNextEvent(
        in_iterator: MusicEventIterator,
        out_has_next_event: NonNull<Boolean>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Indicates whether or not a music track contains an event at the music event iterator’s current position.
    ///
    /// Parameters:
    /// - inIterator: The music event iterator whose state you want to know about.
    ///
    /// - outHasCurEvent: On output, `true` (nonzero) if there is an event at the music event iterator’s current position; `false` (zero) otherwise.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    /// Is there an event at the iterator's current position?
    ///
    /// Parameter `inIterator`: the iterator
    ///
    /// Parameter `outHasCurEvent`: true if there is an event, false if not
    ///
    /// # Safety
    ///
    /// - `in_iterator` must be a valid pointer.
    /// - `out_has_cur_event` must be a valid pointer.
    pub fn MusicEventIteratorHasCurrentEvent(
        in_iterator: MusicEventIterator,
        out_has_cur_event: NonNull<Boolean>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `in_sequence` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "no longer supported"]
    pub fn MusicSequenceLoadSMFDataWithFlags(
        in_sequence: MusicSequence,
        in_data: &CFData,
        in_flags: MusicSequenceLoadFlags,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `in_sequence` must be a valid pointer.
    /// - `out_data` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "no longer supported"]
    pub fn MusicSequenceSaveSMFData(
        in_sequence: MusicSequence,
        out_data: NonNull<*const CFData>,
        in_resolution: u16,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `in_source_track` must be a valid pointer.
    /// - `out_new_track` must be a valid pointer.
    #[deprecated = "no longer supported"]
    pub fn NewMusicTrackFrom(
        in_source_track: MusicTrack,
        in_source_start_time: MusicTimeStamp,
        in_source_end_time: MusicTimeStamp,
        out_new_track: NonNull<MusicTrack>,
    ) -> OSStatus;
}

pub const kMusicEventType_ExtendedControl: c_uint = 2;

#[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct ExtendedControlEvent {
    pub groupID: MusicDeviceGroupID,
    pub controlID: AudioUnitParameterID,
    pub value: AudioUnitParameterValue,
}

#[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
unsafe impl Encode for ExtendedControlEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "ExtendedControlEvent",
        &[
            <MusicDeviceGroupID>::ENCODING,
            <AudioUnitParameterID>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
unsafe impl RefEncode for ExtendedControlEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `in_track` must be a valid pointer.
    /// - `in_info` must be a valid pointer.
    #[cfg(all(feature = "AUComponent", feature = "MusicDevice"))]
    #[deprecated = "no longer supported"]
    pub fn MusicTrackNewExtendedControlEvent(
        in_track: MusicTrack,
        in_time_stamp: MusicTimeStamp,
        in_info: NonNull<ExtendedControlEvent>,
    ) -> OSStatus;
}
