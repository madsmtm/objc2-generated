//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-midi")]
use objc2_core_midi::*;

use crate::*;

pub const kAUPresetVersionKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"version\0") };
pub const kAUPresetTypeKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"type\0") };
pub const kAUPresetSubtypeKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"subtype\0") };
pub const kAUPresetManufacturerKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"manufacturer\0") };
pub const kAUPresetDataKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"data\0") };
pub const kAUPresetNameKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAUPresetNumberKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"preset-number\0") };
pub const kAUPresetRenderQualityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"render-quality\0") };
pub const kAUPresetCPULoadKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"cpu-load\0") };
pub const kAUPresetElementNameKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"element-name\0") };
pub const kAUPresetExternalFileRefs: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"file-references\0") };
/// VST state from a VST “bank.”
pub const kAUPresetVSTDataKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"vstdata\0") };
/// VST state from a VST “preset.”
pub const kAUPresetVSTPresetKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"vstpreset\0") };
pub const kAUPresetMASDataKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"masdata\0") };
/// If present, distinguishes a global preset that is set on the global scope from a part-based preset that is set on the part scope. The value of this key is defined by the audio unit it applies to.
pub const kAUPresetPartKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"part\0") };
pub const kAudioUnitConfigurationInfo_HasCustomView: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HasCustomView\0") };
pub const kAudioUnitConfigurationInfo_ChannelConfigurations: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ChannelConfigurations\0") };
pub const kAudioUnitConfigurationInfo_InitialInputs: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"InitialInputs\0") };
pub const kAudioUnitConfigurationInfo_InitialOutputs: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"InitialOutputs\0") };
pub const kAudioUnitConfigurationInfo_IconURL: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IconURL\0") };
pub const kAudioUnitConfigurationInfo_BusCountWritable: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BusCountWritable\0") };
pub const kAudioUnitConfigurationInfo_SupportedChannelLayoutTags: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SupportedChannelLayoutTags\0") };
pub const kAudioUnitConfigurationInfo_MIDIProtocol: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MIDIProtocol\0") };
pub const kAudioUnitConfigurationInfo_MigrateFromPlugin: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MigrateFromPlugin\0") };
pub const kAudioUnitConfigurationInfo_AvailableArchitectures: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AvailableArchitectures\0") };
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Global: AudioUnitScope = 0;
/// The context for audio data coming into an audio unit.
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Input: AudioUnitScope = 1;
/// The context for audio data leaving an audio unit.
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Output: AudioUnitScope = 2;
/// In macOS, a context specific to the control scope of audio unit parameters.
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Group: AudioUnitScope = 3;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Part: AudioUnitScope = 4;
/// In macOS, a scope for changes to an individual musical note. The element identifier used with this scope is the unique note identifier returned from a started note (see the `MusicDeviceStartNote` function in `AudioUnit/MusicDevice.h`).
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Note: AudioUnitScope = 5;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_Layer: AudioUnitScope = 6;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitScope_LayerItem: AudioUnitScope = 7;

/// Describes the state of an audio unit.
///
/// ## Discussion
///
/// A read/write [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary) object valid on the audio unit global scope. A macOS audio unit that supports the part scope may, in addition, support presets on that scope that apply to individual parts.
///
/// When assigning a class information dictionary to an audio unit with the [`AudioUnitSetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitsetproperty(_:_:_:_:_:_:)) function, you own the reference to the dictionary and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
/// When obtaining a class information dictionary from an audio unit with the [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) function, you also own the reference to the dictionary and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ClassInfo: AudioUnitPropertyID = 0;
/// A write-only [`AudioUnitConnection`](https://developer.apple.com/documentation/audiotoolbox/audiounitconnection) data structure valid on the audio unit input scope.
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MakeConnection: AudioUnitPropertyID = 1;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SampleRate: AudioUnitPropertyID = 2;
/// A list of read-only parameter ID values valid on any audio unit scope.
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterList: AudioUnitPropertyID = 3;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterInfo: AudioUnitPropertyID = 4;
/// A read-only `Float64` value valid on the audio unit global scope.
///
/// ## Discussion
///
/// The proportion of time that an audio unit is devoting to audio rendering. The value ranges from 0.0 (the audio unit is spending no time rendering) through 1.0 (the audio unit is spending all of its time rendering).
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_CPULoad: AudioUnitPropertyID = 6;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_StreamFormat: AudioUnitPropertyID = 8;
/// A read/write `UInt32` value valid on any audio unit scope. The global audio unit scope always has an element count of 1.
///
/// ## Discussion
///
/// Most audio units implement this property as read-only, indicating that they use a fixed number of input and output buses. An audio unit implemented to support adding and removing buses implements this property as read/write.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ElementCount: AudioUnitPropertyID = 11;
/// A read-only `Float64` value valid on the audio unit global scope.
///
/// ## Discussion
///
/// The time, in seconds, that it takes an audio unit to move an audio sample from its input to its output.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_Latency: AudioUnitPropertyID = 12;
/// A read-only array of channel information structures valid on the audio unit global scope.
///
/// ## Discussion
///
/// The size of the array indicates the number of [`AUChannelInfo`](https://developer.apple.com/documentation/audiotoolbox/auchannelinfo) structures for an audio unit. Each structure describes the channel configuration for an audio input/output bus. For example, the values (2, 2) indicates a channel configuration of two input channels paired to two output channels on a bus.
///
/// A negative value for a field in an [`AUChannelInfo`](https://developer.apple.com/documentation/audiotoolbox/auchannelinfo) structure indicates that an input/output bus supports a variable number of channels, as follows:
///
/// - {–1, –1} indicates that a bus supports any number of input or output channels provided that the input and output channel counts match each other. This is the default configuration for effect units.
///
/// - {–1, –2} or {–2, –1} indicates that a bus supports any number of input and output channels; the channel counts on input and output can differ from each other.
///
/// - {–1, –3} indicates that a bus supports any number of input channels and up to three output channels.
///
/// A value of 0 for the `inChannels` field means that an audio unit does not have any audio input buses.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SupportedNumChannels: AudioUnitPropertyID = 13;
/// Specifies the maximum number of sample frames an audio unit is prepared to supply on one invocation of its [`AudioUnitRender`](https://developer.apple.com/documentation/audiotoolbox/audiounitrender(_:_:_:_:_:_:)) function.
///
/// ## Discussion
///
/// A read/write `UInt32` value valid on the audio unit global scope.
///
/// The default value of this property is 1,024, corresponding to about 23 ms at a 44.1 kHz sample rate. This default value is sufficient when a host app is using the default hardware buffer size and the device screen is not sleeping. When the device screen sleeps, the system saves power by reducing the frequency at which it requests sample frames. There is a corresponding increase in the number of sample frames requested of an audio unit, per render call.
///
/// The following table provides some common slice sizes:
///
/// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [] }], [Paragraph { inline_content: [Text { text: "Frame count" }] }], [Paragraph { inline_content: [Text { text: "Milliseconds at 44.1 kHz (approximate)" }] }]], [[Paragraph { inline_content: [Text { text: "Default" }] }], [Paragraph { inline_content: [Text { text: "1024" }] }], [Paragraph { inline_content: [Text { text: "23" }] }]], [[Paragraph { inline_content: [Text { text: "Screen sleep" }] }], [Paragraph { inline_content: [Text { text: "4096" }] }], [Paragraph { inline_content: [Text { text: "93" }] }]], [[Paragraph { inline_content: [Text { text: "Low latency" }] }], [Paragraph { inline_content: [Text { text: "256" }] }], [Paragraph { inline_content: [Text { text: "5" }] }]]], alignments: None, metadata: None })
/// You never need to set this property for I/O units because they are preconfigured to handle any slice size requested by the system. For all other audio units, you must set this property to a value of 4096 to handle screen sleep—unless audio input is running on the device. When audio input is running, the system maintains a slice size of 1024.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MaximumFramesPerSlice: AudioUnitPropertyID = 14;
/// An array of names for a named, indexed audio unit parameter. An indexed parameter is one whose unit type is [`kAudioUnitParameterUnit_Indexed`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterunit/indexed). The array’s strings can be used to build a menu for the parameter.
///
/// ## Discussion
///
/// A read-only [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) object whose elements are [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) objects, valid on any audio unit scope.
///
/// When obtaining a parameter string array from an audio unit with the [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) function, you own the reference to the array and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
/// Indexed parameters use whole-number index values; the size of this property’s array should be the same as the range between the parameter’s minimum and maximum values.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterValueStrings: AudioUnitPropertyID = 16;
/// A read/write `AudioChannelLayout` data structure valid on the audio unit input and output scopes.
///
/// ## Discussion
///
/// The channel order, within a given audio stream, for a specified audio unit element and scope. The number of channels in the layout must match the number of channels set for the scope-element. Each input and output bus in an audio unit can have one instance of this property.
///
/// Some audio units require this property. For example, the 3DMixer unit must implement this property on its output bus. If a host application attempts to clear the value of this property on a bus that requires a valid value, the audio unit will return a kAudioUnitErr_InvalidPropertyValue error.
///
/// Input and output buses can be in one of three states in regard to Audio channel layout:
///
/// 1. Implemented and set
///
/// 2. Implemented but not set
///
/// 3. Unimplemented
///
/// Requesting the value of this property when it is implemented but not set results in a [`kAudioUnitErr_PropertyNotInUse`](https://developer.apple.com/documentation/audiotoolbox/kaudiouniterr_propertynotinuse) error.
///
/// Use the `kAudioUnitProperty_AudioChannelLayout` property whenever channel layout is relevant.
///
/// For related information, refer to the descriptions for the `ScheduledAudioFileRegion` and [`AudioOutputUnitStartAtTimeParams`](https://developer.apple.com/documentation/audiotoolbox/audiooutputunitstartattimeparams) data structures.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_AudioChannelLayout: AudioUnitPropertyID = 19;
/// A read-only `Float64` value valid on the audio unit global scope.
///
/// ## Discussion
///
/// Indicates a time estimate, in seconds, between the last valid input being received by an audio unit and the audio unit’s output becoming silent. For example, a reverb unit’s tail time estimates the “decay” time. The tail time value is usually a conservative estimate that you can depend on.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_TailTime: AudioUnitPropertyID = 20;
/// A read/write `UInt32` value, representing a Boolean value, valid on the audio unit global scope.
///
/// ## Discussion
///
/// Indicates if an audio unit’s processing code is being bypassed (`1`) or not (0).
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_BypassEffect: AudioUnitPropertyID = 21;
/// A read-only `OSStatus` value valid on the audio unit global scope.
///
/// ## Discussion
///
/// This property is set if a call to the [`AudioUnitRender`](https://developer.apple.com/documentation/audiotoolbox/audiounitrender(_:_:_:_:_:_:)) function returns an error. To be notified of errors, register a callback function as a property listener using the [`AudioUnitAddPropertyListener`](https://developer.apple.com/documentation/audiotoolbox/audiounitaddpropertylistener(_:_:_:_:)) function.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_LastRenderError: AudioUnitPropertyID = 22;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SetRenderCallback: AudioUnitPropertyID = 23;
/// So-called _factory presets_ (as opposed to user-configured presets) are ones supplied with an audio unit by the manufacturer. You choose the active preset by setting the `kAudioUnitProperty_PresentPreset` property.
///
/// ## Discussion
///
/// A read-only [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray) array of [`AUPreset`](https://developer.apple.com/documentation/audiotoolbox/aupreset) structures.
///
/// When obtaining a factory preset array from an audio unit with the [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) function, you own the reference to the array and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_FactoryPresets: AudioUnitPropertyID = 24;
/// A read/write `UInt32` value valid on the audio unit global scope.
///
/// ## Discussion
///
/// A value in the range 0 through 127 that indicates an audio unit’s rendering quality. You should set this property to its maximum value unless doing so results in excessive CPU usage.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_RenderQuality: AudioUnitPropertyID = 26;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_HostCallbacks: AudioUnitPropertyID = 27;
/// A read/write `UInt32` value, representing a Boolean value, valid on the audio unit global scope.
///
/// ## Discussion
///
/// Indicates whether an audio unit can process input data directly within its input buffer (`1`) or not (0). You may want to disable in-place processing to allow your host application to manage the processing buffers.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_InPlaceProcessing: AudioUnitPropertyID = 29;
/// The name of the specified element.
///
/// ## Discussion
///
/// A read/write `CFStringRef` object valid on any audio unit scope.
///
/// When assigning an element name string to an audio unit with the [`AudioUnitSetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitsetproperty(_:_:_:_:_:_:)) function, you own the reference to the name and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
/// When obtaining an element name string from an audio unit with the [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) function, you also own the reference to the name and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ElementName: AudioUnitPropertyID = 30;
/// A read-only array on `AudioChannelLayoutTag` structures, valid on the audio unit input and output scopes.
///
/// ## Discussion
///
/// Used with GetProperty to ascertain what an audio unit understands about laying out of channel orders. This will typically return one or more of the specified layout tags.
///
/// When a specific set of layouts are returned, the client then uses the kAudioUnitProperty_AudioChannelLayout property (with one of those layout tags specified) to set the unit to use that layout. In this case the client (and the audio unit when reporting its AudioChannelLayout) is only expected to have set an AudioChannelLayout which only sets the layout tag as the valid field.
///
/// Some audio units may return the tag `kAudioChannelLayoutTag_UseChannelDescriptions`. This indicates a custom channel map.
///
/// In this case, the host then can look at supported number of channels on that scope (using the kAudioUnitProperty_SupportedNumChannels), and supply an AudioChannelLayout with the kAudioUnitProperty_AudioChannelLayout property to specify the layout, number of channels and location of each of those channels. This custom channel map MUST have a channel valence that is supported by the Audio Unit.
///
/// The UseChannelBitmap field is NOT used within the context of the AudioUnit.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SupportedChannelLayoutTags: AudioUnitPropertyID = 32;
/// The active factory preset for an audio unit.
///
/// ## Discussion
///
/// A read/write [`AUPreset`](https://developer.apple.com/documentation/audiotoolbox/aupreset) data structure valid on the audio unit global scope, The `presetName` field in the struct is of type [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) and follows Core Foundation memory semantics.
///
/// When setting the active factory preset on an audio unit with the [`AudioUnitSetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitsetproperty(_:_:_:_:_:_:)) function, you own the reference to the preset name and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
/// When obtaining the active factory preset from an audio unit with the [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) function, you also own the reference to the preset name and are responsible for later releasing it by calling the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_PresentPreset: AudioUnitPropertyID = 36;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_DependentParameters: AudioUnitPropertyID = 45;
/// A read/write AUInputSamplesInOutputCallbackStruct struct, valid on the audio unit global scope.
///
/// ## Discussion
///
/// An audio unit calls this callback at the end of its render call. The audio unit supplies the following information:
///
/// - outputTime - The timestamp passed in to the audio unit’s render call. This timestamp represents the time of the first output sample.
///
/// - inputSample - The sample number of the first input sample that is present in the output audio.
///
/// - numInputSamples - The number of input samples that were used and are present in the output audio.
///
/// This property allows a host application to determine which input samples correspond to a sample in the output buffer. It is useful only for audio units that do time-stretching, such as the macOS AUVaripseed and AUTimePitch units, where the relationship between input and output samples is non-trivial. For these units, the range of input samples that correspond to an output buffer typically differs from the range of input samples that were pulled for that render call. This difference arises because of internal buffering, processing latency, and other factors.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_InputSamplesInOutput: AudioUnitPropertyID = 49;
/// A read/write `UInt32` value valid on the audio unit input and output scopes, settable individually on each element.
///
/// ## Discussion
///
/// Default value is `true`, which means that the associated audio unit element creates a buffer for rendering into.
///
/// If true, the element will create a buffer for rendering into.
///
/// If false, the element will not create a buffer for rendering.
///
/// For example, if the audio unit is only ever going to have a connection as its input and never a callback, then it should not need to create a buffer (the API contract expects an audio unit to provide a buffer for callbacks, but no buffer for connections).
///
/// If the audio unit is always going to be pulled for audio with the client providing audio data buffers to the AudioUnitRender call, then it will never need to create an audio buffer on the output side.
///
/// So, this property can be used to control the default allocation strategy of an audio unit. If the audio unit needs a buffer, but one hasn’t been allocated, then an error will be thrown from that call to AudioUnitRender.
///
/// This property cannot be set on initialized audio units as it may end up reallocating memory.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ShouldAllocateBuffer: AudioUnitPropertyID = 51;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_FrequencyResponse: AudioUnitPropertyID = 52;
/// For parameters that have the [`kAudioUnitParameterFlag_PlotHistory`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameteroptions/flag_plothistory) flag set, getting this property fills out the [`AudioUnitParameterHistoryInfo`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterhistoryinfo) struct containing the recommended update rate and history duration.
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterHistoryInfo: AudioUnitPropertyID = 53;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_NickName: AudioUnitPropertyID = 54;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_OfflineRender: AudioUnitPropertyID = 37;
/// A shortened version of an audio unit parameter name, suitable for compact display situations.
///
/// ## Discussion
///
/// In your host application, you specify the desired length for the shortened version of the name by setting the `inDesiredLength` field in this property. For the full-length version of an audio unit parameter name, see the `kAudioUnitProperty_ParameterInfo` property.
///
/// Value is a read-only [`AudioUnitParameterNameInfo`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameternameinfo) data structure, valid on any audio unit scope.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterIDName: AudioUnitPropertyID = 34;
/// A read-only [`AudioUnitParameterStringFromValue`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterstringfromvalue) struct, valid on any audio unit scope.
///
/// ## Discussion
///
/// This property is used with parameters that are marked with the kAudioUnitParameterFlag_HasName parameter info flag. This indicates that some (or all) of the values represented by the parameter can and should be represented by a special display string.
///
/// This is NOT to be confused with kAudioUnitProperty_ParameterValueStrings. That property is used with parameters that are indexed and is typically used for instance to build a menu item of choices for one of several parameter values.
///
/// kAudioUnitProperty_ParameterStringFromValue can have a continuous range, and merely states to the host that if it is displaying those parameter’s values, they should request a name any time any value of the parameter is set when displaying that parameter.
///
/// For instance (a trivial example), a unit may present a gain parameter in a dB scale, and wish to display its minimum value as “negative infinity”. In this case, the audio unit will not return names for any parameter value greater than its minimum value - so the host will then just display the parameter value as is. For values less than or equal to the minimum value, the audio unit will return a string for “negative infinity” which the host can use to display appropriately.
///
/// A less trivial example might be a parameter that presents its values as seconds. However, in some situations this value should be better displayed in a SMPTE style of display.
///
/// ```objc
/// HH:MM:SS:FF
/// ```
///
/// In this case, the audio unit would return a name for any value of the parameter.
///
/// The GetProperty call is used in the same scope and element as the inParamID that is declared in the struct passed in to this property.
///
/// If the *inValue member is NULL, then the audio unit should take the current value of the specified parameter. If the *inValue member is NOT NULL, then the audio unit should return the name used for the specified value.
///
/// On exit, the outName may point to a CFStringRef (which if so must be released by the caller). If the parameter has no special name that should be applied to that parameter value, then outName will be NULL, and the host should display the parameter value as appropriate.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterStringFromValue: AudioUnitPropertyID = 33;
/// A read-only `AudioUnitParameterNameInfo` struct, valid on any audio unit scope.
///
/// ## Discussion
///
/// This works in a similar manner to the ParameterIDName property, except that the inID value is one of the clumpID’s that are returned with the audio unit’s ParameterInfo structure.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterClumpName: AudioUnitPropertyID = 35;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterValueFromString: AudioUnitPropertyID = 38;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ContextName: AudioUnitPropertyID = 25;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_PresentationLatency: AudioUnitPropertyID = 40;
/// A read/write CFDictionary object, valid on the audio unit global scope.
///
/// ## Discussion
///
/// If the audio unit implements this property then it is going to do different actions establishing its state from a document rather than from a user preset. Thus, a host app should use this property first (instead of kAudioUnitProperty_ClassInfo) when restoring the state of an audio unit when opening a document. If the audio unit returns an error (or doesn’t implement this property) then the host should use the same preset with the kAudioUnitProperty_ClassInfo.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ClassInfoFromDocument: AudioUnitPropertyID = 50;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_RequestViewController: AudioUnitPropertyID = 56;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParametersForOverview: AudioUnitPropertyID = 57;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SupportsMPE: AudioUnitPropertyID = 58;
/// The block that the system calls when the rendering context changes.
///
/// ## Discussion
///
/// If your Audio Unit creates auxilliary realtime rendering threads, set the value of this key to the [`AURenderContextObserver`](https://developer.apple.com/documentation/audiotoolbox/aurendercontextobserver) block you want the system to execute. The system executes your block when the rendering context changes.
///
/// <div class="warning">
///
/// ### Important
///  The block you provide is for system use only. Audio Unit hosts must not attempt to interact with the audio unit through this block.
///
///
///
/// </div>
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_RenderContextObserver: AudioUnitPropertyID = 60;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_LastRenderSampleTime: AudioUnitPropertyID = 61;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_LoadedOutOfProcess: AudioUnitPropertyID = 62;
/// A read-only `void *` value valid on the audio unit global scope.
///
/// ## Discussion
///
/// This property supports expedited interaction with an audio unit. To use it, call the [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) function with the `inID` parameter set to the selector constant that corresponds to the audio unit function you want to call quickly. On return, the `outData` parameter contains a function pointer for the selector.
///
/// For example, by calling [`AudioUnitGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audiounitgetproperty(_:_:_:_:_:_:)) with its `inID` parameter set to `kAudioUnitRenderSelect`, you obtain the function pointer for the [`AudioUnitRender`](https://developer.apple.com/documentation/audiotoolbox/audiounitrender(_:_:_:_:_:_:)) function. You can then invoke audio unit rendering without incurring the overhead of the component dispatch mechanism.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_FastDispatch: AudioUnitPropertyID = 5;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SetExternalBuffer: AudioUnitPropertyID = 15;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_GetUIComponentList: AudioUnitPropertyID = 18;
/// A read-only `AudioUnitCocoaViewInfo` data structure valid on the audio unit global scope.
///
/// ## Discussion
///
/// An audio unit’s custom Cocoa views. You can determine the number of views an audio unit provides by querying the size of this property. Typically, audio units provide just one view.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_CocoaUI: AudioUnitPropertyID = 31;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_IconLocation: AudioUnitPropertyID = 39;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_AUHostIdentifier: AudioUnitPropertyID = 46;
/// A read-only CFArray object valid on the audio unit global scope.
///
/// ## Discussion
///
/// The host will also need to determine how many MIDI output streams the audio unit can generate (and the name for each of these outputs). Each MIDI output is a complete MIDI data stream, such as embodied by a MIDIEndpointRef in CoreMIDI.
///
/// To do, the host uses this property and retrieves an array of CFStringRefs.
///
/// - the size of the array is the number of MIDI Outputs the audio unit supports
///
/// - each item in the array is the name for that output at that index
///
/// The host should release the array when it is finished with it.
///
/// Once the host has determined the audio unit supports this feature, it then instantiates a callback with the unit that the unit will call with MIDI data (see kAudioUnitProperty_MIDIOutputCallback).
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MIDIOutputCallbackInfo: AudioUnitPropertyID = 47;
/// A write-only AUMIDIOutputCallbackStruct struct, valid on the audio unit global scope.
///
/// ## Discussion
///
/// The host sets this property on the audio unit with the callback (and its user data) set appropriately.
///
/// Operational Parameters: In the render call, just as is the expected usage of the AUHostCallbacks, the audio unit can call the provided callback to provide MIDI data to the host that it will associate with the current AudioUnitRender call in process.
///
/// The audio unit in the callback provides the following:
///
/// - the user data provided by the host when the callback was established
///
/// - the AudioTimeStamp that was provided to the audio unit for this particular call of AudioUnitRender
///
/// - the output number to associate this MIDI data with
///
/// - a MIDI Packet List containing MIDI data. The time stamp values contained within the MIDIPackets in this list are **sample offsets*** from the AudioTimeStamp provided
///
/// This allows MIDI data to be time-stamped with a sample offset that is directly associated with the audio data it is generating in the current call to the AudioUnitRender function.
///
/// There is no implied or expected association between the number (or position) of an audio unit’s audio or MIDI outputs.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MIDIOutputCallback: AudioUnitPropertyID = 48;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MIDIOutputEventListCallback: AudioUnitPropertyID = 63;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_AudioUnitMIDIProtocol: AudioUnitPropertyID = 64;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_HostMIDIProtocol: AudioUnitPropertyID = 65;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MIDIOutputBufferSizeHint: AudioUnitPropertyID = 66;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_RemoteControlEventListener: AudioUnitPropertyID = 100;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_IsInterAppConnected: AudioUnitPropertyID = 101;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_PeerURL: AudioUnitPropertyID = 102;

/// An audio unit source-to-destination connection specification.
/// This structure contains the information needed to make a connection between a source
/// and destination audio unit.
///
/// The structure is set on the destination audio unit's input element
///
/// The audio unit that is the source for the connection
///
/// The source audio unit's output element to be used in the connection
///
/// The destination audio unit's input element to be used in the connection
#[cfg(all(feature = "AUComponent", feature = "AudioComponent"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitConnection {
    pub sourceAudioUnit: AudioUnit,
    pub sourceOutputNumber: u32,
    pub destInputNumber: u32,
}

#[cfg(all(feature = "AUComponent", feature = "AudioComponent"))]
unsafe impl Encode for AudioUnitConnection {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitConnection",
        &[<AudioUnit>::ENCODING, <u32>::ENCODING, <u32>::ENCODING],
    );
}

#[cfg(all(feature = "AUComponent", feature = "AudioComponent"))]
unsafe impl RefEncode for AudioUnitConnection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The audio input and output channel capabilities for an audio unit.
/// Define an audio unit's channel handling capabilities
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AUChannelInfo {
    pub inChannels: i16,
    pub outChannels: i16,
}

unsafe impl Encode for AUChannelInfo {
    const ENCODING: Encoding =
        Encoding::Struct("AUChannelInfo", &[<i16>::ENCODING, <i16>::ENCODING]);
}

unsafe impl RefEncode for AUChannelInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Allows an audio unit host application to tell an audio unit to use a specified buffer for its input callback.
/// Allow a host to tell an audio unit to use the provided memory for its input callback
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitExternalBuffer {
    pub buffer: NonNull<Byte>,
    pub size: u32,
}

unsafe impl Encode for AudioUnitExternalBuffer {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitExternalBuffer",
        &[<NonNull<Byte>>::ENCODING, <u32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioUnitExternalBuffer {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Used for registering an input callback function with an audio unit.
/// Used by a host when registering a callback with the audio unit to provide input
#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AURenderCallbackStruct {
    pub inputProc: AURenderCallback,
    pub inputProcRefCon: *mut c_void,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
unsafe impl Encode for AURenderCallbackStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "AURenderCallbackStruct",
        &[<AURenderCallback>::ENCODING, <*mut c_void>::ENCODING],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
unsafe impl RefEncode for AURenderCallbackStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Used to set factory presets for an audio unit.
/// Used to publish and set factory presets on an audio unit
///
/// If
/// <
/// 0, then preset is a user preset
/// If >= 0, then this field is used to select the factory preset
///
/// If a factory preset, the name of the specified factory preset
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUPreset {
    pub presetNumber: i32,
    pub presetName: *const CFString,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AUPreset {
    const ENCODING: Encoding =
        Encoding::Struct("AUPreset", &[<i32>::ENCODING, <*const CFString>::ENCODING]);
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AUPreset {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kRenderQuality_Max: c_uint = 127;
pub const kRenderQuality_High: c_uint = 96;
pub const kRenderQuality_Medium: c_uint = 64;
pub const kRenderQuality_Low: c_uint = 32;
pub const kRenderQuality_Min: c_uint = 0;

/// The maximum number of frequency response bin structures for the `AudioUnitProperty_FrequencyResponse` property.
pub const kNumberOfResponseFrequencies: c_uint = 1024;

/// An audio unit’s audio level at a particular frequency.
///
/// ## Overview
///
/// An array of AudioUnitFrequencyResponseBin are passed in to kAudioUnitProperty_FrequencyResponse with the mFrequency field filled in. The array is returned with the mMagnitude fields filled in. If fewer than kNumberOfResponseFrequencies are needed, then the first unused bin should be marked with a negative frequency.
///
///
/// Structure used to get the magnitude of the frequency response at a particular frequency via kAudioUnitProperty_FrequencyResponse.
///
/// An array of AudioUnitFrequencyResponseBin are passed in to kAudioUnitProperty_FrequencyResponse
/// with the mFrequency field filled in. The array is returned with the mMagnitude fields filled in.
/// If fewer than kNumberOfResponseFrequencies are needed, then the first unused bin should be marked with
/// a negative frequency.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitFrequencyResponseBin {
    pub mFrequency: f64,
    pub mMagnitude: f64,
}

unsafe impl Encode for AudioUnitFrequencyResponseBin {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitFrequencyResponseBin",
        &[<f64>::ENCODING, <f64>::ENCODING],
    );
}

unsafe impl RefEncode for AudioUnitFrequencyResponseBin {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// When called by the system, provides beat and tempo information to an audio unit from a host application.
///
/// Parameters:
/// - inHostUserData: Custom data that you provided when registering your callback with the audio unit.
///
/// - outCurrentBeat: On output, the current beat of the music that is playing.
///
/// - outCurrentTempo: On output, the current tempo of the music that is playing.
///
///
/// ## Discussion
///
/// If you named your callback function `MyHostCallback_GetBeatAndTempo`, you would declare it like this:
///
///
/// Retrieve information about the current beat and/or tempo
///
/// If the host app has set this callback, then the audio unit can use this to get the current
/// beat and tempo as they relate to the first sample in the render buffer. The audio unit can
/// call this callback only from within the audio unit render call (otherwise the host is unable
/// to provide information accurately to the audio unit as the information obtained is relate to
/// the current AudioUnitRender call). If the host cannot provide the requested information, it
/// will return kAudioUnitErr_CannotDoInCurrentContext.
///
/// The AudioUnit can provide NULL for any of the requested parameters (except for
/// inHostUserData) if it is not interested in that particular piece of information
///
///
/// Parameter `inHostUserData`: Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///
/// Parameter `outCurrentBeat`: The current beat, where 0 is the first beat. Tempo is defined as the number of whole-number (integer) beat values (as indicated by the outCurrentBeat field) per minute.
///
/// Parameter `outCurrentTempo`: The current tempo
pub type HostCallback_GetBeatAndTempo =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut f64, *mut f64) -> OSStatus>;

/// When called by the system, provides musical timing information to an audio unit from a host application.
///
/// Parameters:
/// - inHostUserData: Custom data that you provided when registering your callback with the audio unit.
///
/// - outDeltaSampleOffsetToNextBeat: On output, the number of samples until the next beat.
///
/// - outTimeSig_Numerator: On output, the numerator for a musical time signature.
///
/// - outTimeSig_Denominator: On output, the denominator for a musical time signature.
///
/// - outCurrentMeasureDownBeat:
///
///
/// ## Discussion
///
/// If you named your callback function `MyHostCallback_GetMusicalTimeLocation`, you would declare it like this:
///
///
/// Retrieve information about the musical time state of the host
///
/// If the host app has set this callback, then the audio unit can use this to obtain
/// information about the state of musical time in the host. The audio unit can call this
/// callback only from within the audio unit render call (otherwise the host is unable to
/// provide information accurately to the audio unit as the information obtained is relate to
/// the current AudioUnitRender call). If the host cannot provide the requested information, it
/// will return kAudioUnitErr_CannotDoInCurrentContext.
///
/// The AudioUnit can provide NULL for any of the requested parameters (except for
/// inHostUserData) if it is not interested in that particular piece of information
///
///
/// Parameter `inHostUserData`: Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///
/// Parameter `outDeltaSampleOffsetToNextBeat`: The number of samples until the next whole beat from the start sample of the current rendering buffer
///
/// Parameter `outTimeSig_Numerator`: The Numerator of the current time signature
///
/// Parameter `outTimeSig_Denominator`: The Denominator of the current time signature (4 is a quarter note, etc)
///
/// Parameter `outCurrentMeasureDownBeat`: The beat that corresponds to the downbeat (first beat) of the current measure that is being rendered
pub type HostCallback_GetMusicalTimeLocation = Option<
    unsafe extern "C-unwind" fn(*mut c_void, *mut u32, *mut f32, *mut u32, *mut f64) -> OSStatus,
>;

/// When called by the system, provides audio transport state and timeline information to an audio unit from a host application.
///
/// Parameters:
/// - inHostUserData: Custom data that you provided when registering your callback with the audio unit.
///
/// - outIsPlaying: On output, `TRUE` if audio is playing, or `FALSE` otherwise.
///
/// - outTransportStateChanged: On output, `TRUE` if the transport state changed since the last time the callback was invoked, or `FALSE` otherwise.
///
/// - outCurrentSampleInTimeLine: On output, the sample number, indexed from zero from the beginning of the timeline.
///
/// - outIsCycling: On output, `TRUE` if cycling, or `FALSE` otherwise.
///
/// - outCycleStartBeat:
///
/// - outCycleEndBeat:
///
///
/// ## Discussion
///
/// If you named your callback function `MyHostCallback_GetTransportState`, you would declare it like this:
///
///
/// Retrieve information about the time line's (or transport) state of the host.
///
/// If the host app has set this callback, then the audio unit can use this to obtain
/// information about the transport state of the host's time line. The audio unit can call this
/// callback only from within the audio unit render call (otherwise the host is unable to
/// provide information accurately to the audio unit as the information obtained is relate to
/// the current AudioUnitRender call. If the host cannot provide the requested information, it
/// will return kAudioUnitErr_CannotDoInCurrentContext.
///
/// The AudioUnit can provide NULL for any of the requested parameters (except for
/// inHostUserData) if it is not interested in that particular piece of information
///
///
/// Parameter `inHostUserData`: Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///
/// Parameter `outIsPlaying`: Returns true if the host's transport is currently playing, false if stopped
///
/// Parameter `outTransportStateChanged`: Returns true if there was a change to the state of, or discontinuities in, the host's transport (generally since the callback was last called). Can indicate such state changes as start/top, time moves (jump from one time line to another).
///
/// Parameter `outCurrentSampleInTimeLine`: Returns the current sample count in the time line of the host's transport time.
///
/// Parameter `outIsCycling`: Returns true if the host's transport is currently cycling or looping
///
/// Parameter `outCycleStartBeat`: If cycling is true, the start beat of the cycle or loop point in the host's transport
///
/// Parameter `outCycleEndBeat`: If cycling is true, the end beat of the cycle or loop point in the host's transport
pub type HostCallback_GetTransportState = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        *mut Boolean,
        *mut Boolean,
        *mut f64,
        *mut Boolean,
        *mut f64,
        *mut f64,
    ) -> OSStatus,
>;

/// Retrieve information about the time line's (or transport) state of the host.
///
/// If the host app has set this callback, then the audio unit can use this to obtain
/// information about the transport state of the host's time line. The audio unit can call this
/// callback only from within the audio unit render call (otherwise the host is unable to
/// provide information accurately to the audio unit as the information obtained is relate to
/// the current AudioUnitRender call. If the host cannot provide the requested information, it
/// will return kAudioUnitErr_CannotDoInCurrentContext.
///
/// The AudioUnit can provide NULL for any of the requested parameters (except for
/// inHostUserData) if it is not interested in that particular piece of information
///
///
/// Parameter `inHostUserData`: Must be provided by the audio unit when it makes this call. It is the client data provided by the host when it set the HostCallbacks property
///
/// Parameter `outIsPlaying`: Returns true if the host's transport is currently playing, false if stopped
///
/// Parameter `outIsRecording`: Returns true if the host is currently record-enabled, otherwise false.
///
/// Parameter `outTransportStateChanged`: Returns true if there was a change to the state of, or discontinuities in, the host's transport (generally since the callback was last called). Can indicate such state changes as start/top, time moves (jump from one time line to another).
///
/// Parameter `outCurrentSampleInTimeLine`: Returns the current sample count in the time line of the host's transport time.
///
/// Parameter `outIsCycling`: Returns true if the host's transport is currently cycling or looping
///
/// Parameter `outCycleStartBeat`: If cycling is true, the start beat of the cycle or loop point in the host's transport
///
/// Parameter `outCycleEndBeat`: If cycling is true, the end beat of the cycle or loop point in the host's transport
pub type HostCallback_GetTransportState2 = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        *mut Boolean,
        *mut Boolean,
        *mut Boolean,
        *mut f64,
        *mut Boolean,
        *mut f64,
        *mut f64,
    ) -> OSStatus,
>;

/// The time- and transport-related callback functions for an audio unit.
/// Contains the various callbacks for an audio unit to call
///
/// Any callback can be NULL.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct HostCallbackInfo {
    pub hostUserData: *mut c_void,
    pub beatAndTempoProc: HostCallback_GetBeatAndTempo,
    pub musicalTimeLocationProc: HostCallback_GetMusicalTimeLocation,
    pub transportStateProc: HostCallback_GetTransportState,
    pub transportStateProc2: HostCallback_GetTransportState2,
}

unsafe impl Encode for HostCallbackInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "HostCallbackInfo",
        &[
            <*mut c_void>::ENCODING,
            <HostCallback_GetBeatAndTempo>::ENCODING,
            <HostCallback_GetMusicalTimeLocation>::ENCODING,
            <HostCallback_GetTransportState>::ENCODING,
            <HostCallback_GetTransportState2>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for HostCallbackInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An audio unit parameter whose value can change in response to a change in its parent metaparameter.
/// Used to represent a dependent parameter that can change as a result of its parent meta-parameter
/// changing
#[cfg(feature = "AUComponent")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AUDependentParameter {
    pub mScope: AudioUnitScope,
    pub mParameterID: AudioUnitParameterID,
}

#[cfg(feature = "AUComponent")]
unsafe impl Encode for AUDependentParameter {
    const ENCODING: Encoding = Encoding::Struct(
        "AUDependentParameter",
        &[<AudioUnitScope>::ENCODING, <AudioUnitParameterID>::ENCODING],
    );
}

#[cfg(feature = "AUComponent")]
unsafe impl RefEncode for AUDependentParameter {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The name and number of custom Cocoa views for an audio unit.
/// The location and class name of one or more view factory objects an Audio Unit publishes
///
/// Contains the location of the bundle which the host app can then use to locate the bundle
///
/// Contains the names of the classes that implements the required protocol (AUCocoaUIBase). This class is a view factory that creates the NSView object that is the AudioUnit view.
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitCocoaViewInfo {
    pub mCocoaAUViewBundleLocation: NonNull<CFURL>,
    pub mCocoaAUViewClass: [NonNull<CFString>; 1],
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AudioUnitCocoaViewInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitCocoaViewInfo",
        &[
            <NonNull<CFURL>>::ENCODING,
            <[NonNull<CFString>; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AudioUnitCocoaViewInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The name and version of an audio unit’s host application.
/// Used to describe the name and version of the audio unit's host
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUHostVersionIdentifier {
    pub hostName: NonNull<CFString>,
    pub hostVersion: u32,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AUHostVersionIdentifier {
    const ENCODING: Encoding = Encoding::Struct(
        "AUHostVersionIdentifier",
        &[<NonNull<CFString>>::ENCODING, <u32>::ENCODING],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AUHostVersionIdentifier {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// When called by a host application, gets MIDI data from an audio unit.
///
/// Parameters:
/// - userData: Custom data.
///
/// - timeStamp:
///
/// - midiOutNum:
///
/// - pktlist:
///
///
/// ## Discussion
///
/// If you named your callback function `MyAUMIDIOutputCallback`, you would declare it like this:
///
///
#[cfg(all(feature = "objc2-core-audio-types", feature = "objc2-core-midi"))]
pub type AUMIDIOutputCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        NonNull<AudioTimeStamp>,
        u32,
        NonNull<MIDIPacketList>,
    ) -> OSStatus,
>;

/// The callback function and custom data for an audio unit that provides MIDI output.
/// Set by host application to provide the callback and user data for an audio
/// unit that provides MIDI output
#[cfg(all(feature = "objc2-core-audio-types", feature = "objc2-core-midi"))]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUMIDIOutputCallbackStruct {
    pub midiOutputCallback: AUMIDIOutputCallback,
    pub userData: *mut c_void,
}

#[cfg(all(feature = "objc2-core-audio-types", feature = "objc2-core-midi"))]
unsafe impl Encode for AUMIDIOutputCallbackStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "AUMIDIOutputCallbackStruct",
        &[<AUMIDIOutputCallback>::ENCODING, <*mut c_void>::ENCODING],
    );
}

#[cfg(all(feature = "objc2-core-audio-types", feature = "objc2-core-midi"))]
unsafe impl RefEncode for AUMIDIOutputCallbackStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The callback function and custom data for providing input-to-output sample mapping for an audio unit.
/// Used by a host when registering a callback with an audio unit, to provide
/// input-to-output samples mapping
#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUInputSamplesInOutputCallbackStruct {
    pub inputToOutputCallback: AUInputSamplesInOutputCallback,
    pub userData: *mut c_void,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
unsafe impl Encode for AUInputSamplesInOutputCallbackStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "AUInputSamplesInOutputCallbackStruct",
        &[
            <AUInputSamplesInOutputCallback>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
unsafe impl RefEncode for AUInputSamplesInOutputCallbackStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The suggested update rate and history duration for parameters which have the [`kAudioUnitParameterFlag_PlotHistory`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameteroptions/flag_plothistory) flag set.
///
/// ## Overview
///
/// The structure is filled out by getting the value of the `kAudioUnitProperty_ParameterHistoryInfo` property.
///
///
/// This structure contains the suggested update rate and history duration for parameters which have the kAudioUnitParameterFlag_PlotHistory flag set.
/// The structure is filled out by getting kAudioUnitProperty_ParameterHistoryInfo.
///
/// This is the number of times per second that it is suggested that the host get the value of this parameter.
///
/// This is the duration in seconds of history that should be plotted.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitParameterHistoryInfo {
    pub updatesPerSecond: f32,
    pub historyDurationInSeconds: f32,
}

unsafe impl Encode for AudioUnitParameterHistoryInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterHistoryInfo",
        &[<f32>::ENCODING, <f32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioUnitParameterHistoryInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Expresses time as a sample count.
///
/// ## Discussion
///
/// Sample times are normally positive, but hosts can propagate HAL sample times through audio units, and HAL sample times can be small negative numbers.
///
///
/// Expresses time as a sample count.
///
/// Sample times are normally positive, but hosts can propagate HAL sample times through audio
/// units, and HAL sample times can be small negative numbers.
pub type AUEventSampleTime = i64;

/// The unit-of-measure for an audio unit parameter.
///
/// ## Overview
///
/// The various units of measure for audio unit parameters are described in `Audio Unit Parameter Units of Measure`.
///
///
/// untyped value generally between 0.0 and 1.0
///
/// takes an integer value (good for menu selections)
///
/// 0.0 means FALSE, non-zero means TRUE
///
/// usually from 0 -> 100, sometimes -50 -> +50
///
/// absolute or relative time
///
/// one sample frame equals (1.0/sampleRate) seconds
///
/// -180 to 180 degrees
///
/// rate multiplier, for playback speed, etc. (e.g. 2.0 == twice as fast)
///
/// absolute frequency/pitch in cycles/second
///
/// unit of relative pitch
///
/// useful for coarse detuning
///
/// absolute pitch as defined in the MIDI spec (exact freq may depend on tuning table)
///
/// a generic MIDI controller value from 0 -> 127
///
/// logarithmic relative gain
///
/// linear relative gain
///
/// -180 to 180 degrees, similar to phase but more general (good for 3D coord system)
///
/// 0 -> 100, crossfade mix two sources according to sqrt(x) and sqrt(1.0 - x)
///
/// 0.0 -> 1.0, pow(x, 3.0) -> linear gain to simulate a reasonable mixer channel fader response
///
/// standard left to right mixer pan
///
/// distance measured in meters
///
/// absolute frequency measurement :
/// if f is freq in hertz then absoluteCents = 1200 * log2(f / 440) + 6900
///
/// octaves in relative pitch where a value of 1 is equal to 1200 cents
///
/// beats per minute, ie tempo
///
/// time relative to tempo, i.e., 1.0 at 120 BPM would equal 1/2 a second
///
/// parameter is expressed in milliseconds
///
/// for compression, expansion ratio, etc.
///
/// this is the parameter unit type for parameters that present a custom unit name
///
/// a generic MIDI 2.0 controller value with 32-bit range
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioUnitParameterUnit(pub u32);
impl AudioUnitParameterUnit {
    /// A generic unit of measure.
    ///
    /// ## Discussion
    ///
    /// Expected but not required to range between 0.0 and 1.0.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Generic")]
    pub const Generic: Self = Self(0);
    /// An indexed unit of measure.
    ///
    /// ## Discussion
    ///
    /// Indicates a particular menu item in a list of menu items, typically using whole-number values starting at 1.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Indexed")]
    pub const Indexed: Self = Self(1);
    /// A Boolean-like unit of measure.
    ///
    /// ## Discussion
    ///
    /// A value of 0.0 means `FALSE` and a nonzero value means `TRUE`.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Boolean")]
    pub const Boolean: Self = Self(2);
    /// A percentage unit of measure.
    ///
    /// ## Discussion
    ///
    /// Most audio unit parameters of this type range from 0 (for 0%) through 100 (for 100%). Some range from from –50 to +50.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Percent")]
    pub const Percent: Self = Self(3);
    /// A whole-seconds unit of measure, indicating either absolute or relative time.
    #[doc(alias = "kAudioUnitParameterUnit_Seconds")]
    pub const Seconds: Self = Self(4);
    /// A sample-frame-count unit of measure.
    ///
    /// ## Discussion
    ///
    /// The duration of a sample frame, for fixed frame-rate audio formats, is equal to 1.0/`kAudioUnitProperty_SampleRate` seconds.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_SampleFrames")]
    pub const SampleFrames: Self = Self(5);
    /// An angular degree unit of measure.
    ///
    /// ## Discussion
    ///
    /// Typical range is –180 through +180 and is intended to represent the phase difference between two signals. See also the [`kAudioUnitParameterUnit_Degrees`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterunit/degrees) property.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Phase")]
    pub const Phase: Self = Self(6);
    /// A multiplication factor unit of measure.
    ///
    /// ## Discussion
    ///
    /// A multiplication factor, most often used for playback speed. A value of  2.0, for example, means twice as fast. May also be used for other purposes where a multiplication factor is appropriate.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Rate")]
    pub const Rate: Self = Self(7);
    /// A hertz unit of measure.
    ///
    /// ## Discussion
    ///
    /// Absolute frequency or pitch in cycles per second.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Hertz")]
    pub const Hertz: Self = Self(8);
    /// A logarithmic unit of measure for a musical interval between two notes.
    ///
    /// ## Discussion
    ///
    /// Relative musical pitch in cents, where 1,200 cents are equal to one octave. 100 cents are equal to one semitone. See also the [`kAudioUnitParameterUnit_AbsoluteCents`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterunit/absolutecents) property.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Cents")]
    pub const Cents: Self = Self(9);
    /// A relative unit of measure for a musical interval between two notes.
    ///
    /// ## Discussion
    ///
    /// One octave has 12 semitones equal in size. Each semitone is equivalent to 100 cents. This parameter unit is useful for coarse tuning or detuning.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_RelativeSemiTones")]
    pub const RelativeSemiTones: Self = Self(10);
    /// A whole-number unit of measure corresponding to audio frequency.
    ///
    /// ## Discussion
    ///
    /// Absolute pitch as defined in the MIDI specification. A standard piano keyboard ranges from MIDI note number 21 (for the A0 note) to 108 (for the C8 note), with MIDI note 60 corresponding to middle C (C4). The frequency for a given MIDI note number may depend on a tuning table.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_MIDINoteNumber")]
    pub const MIDINoteNumber: Self = Self(11);
    /// A whole-number unit of measure corresponding to standard MIDI control numbers.
    ///
    /// ## Discussion
    ///
    /// Range is from 0 through 127.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_MIDIController")]
    pub const MIDIController: Self = Self(12);
    /// A logarithmic unit of measure representing the ratio between two audio levels.
    ///
    /// ## Discussion
    ///
    /// Typically used as a relative measure of audio gain.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Decibels")]
    pub const Decibels: Self = Self(13);
    /// A linear unit of measure representing the difference between two audio levels.
    ///
    /// ## Discussion
    ///
    /// Typically used as a relative measure of audio gain.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_LinearGain")]
    pub const LinearGain: Self = Self(14);
    /// An angular degree unit of measure.
    ///
    /// ## Discussion
    ///
    /// Typical range is from –180° through +180° and is intended as a general representation of geometric position, such as for audio sources in a three-dimensional coordinate system. See also the [`kAudioUnitParameterUnit_Phase`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterunit/phase) property.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Degrees")]
    pub const Degrees: Self = Self(15);
    /// An audio power unit of measure.
    ///
    /// ## Discussion
    ///
    /// Recommended range is from 0 through 100, representing a crossfade mix of two sources according to `sqrt (x)` and `sqrt (1.0 - x)`.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_EqualPowerCrossfade")]
    pub const EqualPowerCrossfade: Self = Self(16);
    /// An audio power unit of measure.
    ///
    /// ## Discussion
    ///
    /// Recommended range is from 0.0 through 1.0. Use `pow (x, 3.0)` to simulate a reasonable linear mixer channel fader response.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_MixerFaderCurve1")]
    pub const MixerFaderCurve1: Self = Self(17);
    /// An audio position unit of measure.
    ///
    /// ## Discussion
    ///
    /// For standard left-to-right audio panning.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Pan")]
    pub const Pan: Self = Self(18);
    /// A distance unit of measure, corresponding to meters.
    #[doc(alias = "kAudioUnitParameterUnit_Meters")]
    pub const Meters: Self = Self(19);
    /// An absolute unit of measure for the musical pitch of a note.
    ///
    /// ## Discussion
    ///
    /// Absolute musical pitch in cents. 1,200 cents are equal to one octave. If `f` is a frequency in hertz, then `absoluteCents = 1200 * log2 (f/440) + 6900`. See also the [`kAudioUnitParameterUnit_Cents`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterunit/cents) property.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_AbsoluteCents")]
    pub const AbsoluteCents: Self = Self(20);
    /// A relative unit of measure for the musical interval between two notes.
    ///
    /// ## Discussion
    ///
    /// Octaves in relative pitch, where a value of 1 is equal to an interval of `1200` cents.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Octaves")]
    pub const Octaves: Self = Self(21);
    /// A whole-number unit of measure for musical tempo, representing beats per minute.
    #[doc(alias = "kAudioUnitParameterUnit_BPM")]
    pub const BPM: Self = Self(22);
    /// A time unit of measure in musical beats.
    ///
    /// ## Discussion
    ///
    /// 1.0 beats at 120 BPM (beats per minute) equals a duration of 1/2 second.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Beats")]
    pub const Beats: Self = Self(23);
    /// A time unit of measure representing milliseconds.
    #[doc(alias = "kAudioUnitParameterUnit_Milliseconds")]
    pub const Milliseconds: Self = Self(24);
    /// A unitless ratio unit of measure.
    ///
    /// ## Discussion
    ///
    /// Useful for representing an amount of compression or expansion, for example.
    ///
    ///
    #[doc(alias = "kAudioUnitParameterUnit_Ratio")]
    pub const Ratio: Self = Self(25);
    /// A custom unit of measure.
    #[doc(alias = "kAudioUnitParameterUnit_CustomUnit")]
    pub const CustomUnit: Self = Self(26);
    #[doc(alias = "kAudioUnitParameterUnit_MIDI2Controller")]
    pub const MIDI2Controller: Self = Self(27);
}

unsafe impl Encode for AudioUnitParameterUnit {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioUnitParameterUnit {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Value options for audio unit parameters.
///
/// ## Overview
///
/// These constants are relevant only in macOS, and not in iOS.
///
/// Audio unit parameter flags, for use in the [`AudioUnitParameterInfo`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterinfo) data structure , serve as a dictionary-like set of information about an audio unit parameter. Parameter flag bit position 19 is reserved.
///
///
/// Bit positions 18, 17, and 16 are set aside for display scales. Bit 19 is reserved.
///
///
///
///
///
///
///
///
///
///
///
///
///
/// This flag provides a hint to a host that this parameter should be controlled through the
/// highest resolution if the host has limitations on the control resolution of parameter
/// values. Generally this means that controlling this parameter with a single MIDI Control
/// message (i.e. 128 values) is too course a grain for that parameter, and a finer control
/// resolution should be used if possible. If this flag is not set, then a host can assume that
/// a 7-bit control quantization is acceptable. Ideally, parameters should be controlled in the
/// fullest resolution that they are published with.
///
/// Changing the parameter in real-time will cause a glitch or otherwise undesirable effect.
///
/// If set, the parameter can be ramped.
///
/// If set, the parameter is obscure (hint to UI to only display in expert mode).
///
/// In the original ParameterInfo a C string only was specified. With MacOS 10.2 and later, the
/// last four bytes of this string are reserved for a CFStringRef, which gives the ability to
/// used Unicode encoding, necessary for providing a name in languages using non-ASCII
/// characters. If this flag bit is set, the CFStringRef is valid.
///
/// If set, changing this parameter may change any number of others in the AudioUnit.
///
/// If set, changing this parameter may change others in the same element as the current
/// parameter.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioUnitParameterOptions(pub u32);
bitflags::bitflags! {
    impl AudioUnitParameterOptions: u32 {
/// If an audio unit can generate parameter names dynamically, it should set this flag.
///
/// ## Discussion
///
/// Audio unit hosting applications should check for this flag being set. If it is, the host should release the audio unit parameter name when it is done using it.
///
/// If this flag is not set, the host application can assume that the audio unit will release its parameter names.
///
///
        #[doc(alias = "kAudioUnitParameterFlag_CFNameRelease")]
        const Flag_CFNameRelease = 1<<4;
        #[doc(alias = "kAudioUnitParameterFlag_OmitFromPresets")]
        const Flag_OmitFromPresets = 1<<13;
/// If set, getting the `kAudioUnitProperty_ParameterHistoryInfo` property fills out the [`AudioUnitParameterHistoryInfo`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameterhistoryinfo) struct containing the recommended update rate and history duration.
        #[doc(alias = "kAudioUnitParameterFlag_PlotHistory")]
        const Flag_PlotHistory = 1<<14;
        #[doc(alias = "kAudioUnitParameterFlag_MeterReadOnly")]
        const Flag_MeterReadOnly = 1<<15;
        #[doc(alias = "kAudioUnitParameterFlag_DisplayMask")]
        const Flag_DisplayMask = (7<<16)|(1<<22);
        #[doc(alias = "kAudioUnitParameterFlag_DisplaySquareRoot")]
        const Flag_DisplaySquareRoot = 1<<16;
        #[doc(alias = "kAudioUnitParameterFlag_DisplaySquared")]
        const Flag_DisplaySquared = 2<<16;
        #[doc(alias = "kAudioUnitParameterFlag_DisplayCubed")]
        const Flag_DisplayCubed = 3<<16;
        #[doc(alias = "kAudioUnitParameterFlag_DisplayCubeRoot")]
        const Flag_DisplayCubeRoot = 4<<16;
        #[doc(alias = "kAudioUnitParameterFlag_DisplayExponential")]
        const Flag_DisplayExponential = 5<<16;
        #[doc(alias = "kAudioUnitParameterFlag_HasClump")]
        const Flag_HasClump = 1<<20;
        #[doc(alias = "kAudioUnitParameterFlag_ValuesHaveStrings")]
        const Flag_ValuesHaveStrings = 1<<21;
        #[doc(alias = "kAudioUnitParameterFlag_DisplayLogarithmic")]
        const Flag_DisplayLogarithmic = 1<<22;
        #[doc(alias = "kAudioUnitParameterFlag_IsHighResolution")]
        const Flag_IsHighResolution = 1<<23;
        #[doc(alias = "kAudioUnitParameterFlag_NonRealTime")]
        const Flag_NonRealTime = 1<<24;
        #[doc(alias = "kAudioUnitParameterFlag_CanRamp")]
        const Flag_CanRamp = 1<<25;
        #[doc(alias = "kAudioUnitParameterFlag_ExpertMode")]
        const Flag_ExpertMode = 1<<26;
        #[doc(alias = "kAudioUnitParameterFlag_HasCFNameString")]
        const Flag_HasCFNameString = 1<<27;
        #[doc(alias = "kAudioUnitParameterFlag_IsGlobalMeta")]
        const Flag_IsGlobalMeta = 1<<28;
        #[doc(alias = "kAudioUnitParameterFlag_IsElementMeta")]
        const Flag_IsElementMeta = 1<<29;
        #[doc(alias = "kAudioUnitParameterFlag_IsReadable")]
        const Flag_IsReadable = 1<<30;
        #[doc(alias = "kAudioUnitParameterFlag_IsWritable")]
        const Flag_IsWritable = 1<<31;
    }
}

unsafe impl Encode for AudioUnitParameterOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioUnitParameterOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// UNUSED - set to zero - UTF8 encoded C string (originally).
///
/// Only valid if the unit field equals kAudioUnitParameterUnit_CustomUnit, in
/// which case, unitName must contain a valid CFStringRef. As with cfNameString,
/// if (flags
/// &
/// kAudioUnitParameterFlag_CFNameRelease) is non-zero, the
/// AudioUnit must return a +1 reference to this string, and the host must
/// release it.
///
/// Only valid if kAudioUnitParameterFlag_HasClump is set.
///
/// Only valid if kAudioUnitParameterFlag_HasCFNameString is set.
///
/// If the "unit" field contains a value not in the enum above, then assume
/// kAudioUnitParameterUnit_Generic
///
/// The parameter's minimum value.
///
/// The parameter's maximum value.
///
/// The parameter's default value.
///
/// Due to some vagaries about the ways in which Parameter's CFNames have been
/// described, it was necessary to add a flag:
/// kAudioUnitParameterFlag_CFNameRelease. In normal usage a parameter name is
/// essentially a static object, but sometimes an audio unit will generate
/// parameter names dynamically.. As these are expected to be CFStrings, in that
/// case the host should release those names when it is finished with them, but
/// there was no way to communicate this distinction in behavior. Thus, if an
/// audio unit will (or could) generate a name dynamically, it should set this
/// flag in the parameter's info. The host should check for this flag, and if
/// present, release the parameter name when it is finished with it.
#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitParameterInfo {
    pub name: [c_char; 52],
    pub unitName: *const CFString,
    pub clumpID: u32,
    pub cfNameString: *const CFString,
    pub unit: AudioUnitParameterUnit,
    pub minValue: AudioUnitParameterValue,
    pub maxValue: AudioUnitParameterValue,
    pub defaultValue: AudioUnitParameterValue,
    pub flags: AudioUnitParameterOptions,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl Encode for AudioUnitParameterInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterInfo",
        &[
            <[c_char; 52]>::ENCODING,
            <*const CFString>::ENCODING,
            <u32>::ENCODING,
            <*const CFString>::ENCODING,
            <AudioUnitParameterUnit>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
            <AudioUnitParameterOptions>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl RefEncode for AudioUnitParameterInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Reserved for system use. Use clump ID values other than `0`.
pub const kAudioUnitClumpID_System: c_uint = 0;

// TODO: pub fn GetAudioUnitParameterDisplayType(flags: AudioUnitParameterOptions,) -> AudioUnitParameterOptions;

// TODO: pub fn SetAudioUnitParameterDisplayType(flags: AudioUnitParameterOptions,display_type: AudioUnitParameterOptions,) -> AudioUnitParameterOptions;

pub const kAudioUnitParameterName_Full: c_int = -1;

/// A short version of the name for an audio unit parameter.
///
/// ## Discussion
///
/// This data structure is used as a value for the [`kAudioUnitProperty_ParameterClumpName`](https://developer.apple.com/documentation/audiotoolbox/kaudiounitproperty_parameterclumpname) and [`kAudioUnitProperty_ParameterIDName`](https://developer.apple.com/documentation/audiotoolbox/kaudiounitproperty_parameteridname) audio unit properties.
///
///
/// Used to provide shorter names for a specified parameter
#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitParameterNameInfo {
    pub inID: AudioUnitParameterID,
    pub inDesiredLength: i32,
    pub outName: *const CFString,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl Encode for AudioUnitParameterNameInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterNameInfo",
        &[
            <AudioUnitParameterID>::ENCODING,
            <i32>::ENCODING,
            <*const CFString>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl RefEncode for AudioUnitParameterNameInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type definition for a data type that defines the short version of the name for an audio unit parameter.
///
/// ## Discussion
///
/// `AudioUnitParameterIDName` is a `typedef` for [`AudioUnitParameterNameInfo`](https://developer.apple.com/documentation/audiotoolbox/audiounitparameternameinfo).
///
///
#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
pub type AudioUnitParameterIDName = AudioUnitParameterNameInfo;

/// A string representation of a parameter’s value.
/// Provide a string representation of a parameter's value
#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitParameterStringFromValue {
    pub inParamID: AudioUnitParameterID,
    pub inValue: NonNull<AudioUnitParameterValue>,
    pub outString: *const CFString,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl Encode for AudioUnitParameterStringFromValue {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterStringFromValue",
        &[
            <AudioUnitParameterID>::ENCODING,
            <NonNull<AudioUnitParameterValue>>::ENCODING,
            <*const CFString>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl RefEncode for AudioUnitParameterStringFromValue {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A parameter’s value based on a string representation of the value.
/// Provide the parameter's value for a given string representation of it
#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitParameterValueFromString {
    pub inParamID: AudioUnitParameterID,
    pub inString: NonNull<CFString>,
    pub outValue: AudioUnitParameterValue,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl Encode for AudioUnitParameterValueFromString {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterValueFromString",
        &[
            <AudioUnitParameterID>::ENCODING,
            <NonNull<CFString>>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl RefEncode for AudioUnitParameterValueFromString {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// In inter-app audio, messages to control the host's transport state.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AudioUnitRemoteControlEvent(pub u32);
impl AudioUnitRemoteControlEvent {
    #[doc(alias = "kAudioUnitRemoteControlEvent_TogglePlayPause")]
    pub const TogglePlayPause: Self = Self(1);
    #[doc(alias = "kAudioUnitRemoteControlEvent_ToggleRecord")]
    pub const ToggleRecord: Self = Self(2);
    #[doc(alias = "kAudioUnitRemoteControlEvent_Rewind")]
    pub const Rewind: Self = Self(3);
}

unsafe impl Encode for AudioUnitRemoteControlEvent {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioUnitRemoteControlEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Block called to receive a remote control event.
#[cfg(feature = "block2")]
pub type AudioUnitRemoteControlEventListener =
    *mut block2::DynBlock<dyn Fn(AudioUnitRemoteControlEvent)>;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_AllParameterMIDIMappings: AudioUnitPropertyID = 41;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_AddParameterMIDIMapping: AudioUnitPropertyID = 42;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_RemoveParameterMIDIMapping: AudioUnitPropertyID = 43;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_HotMapParameterMIDIMapping: AudioUnitPropertyID = 44;

/// General defined values to customize the behavior of parameter-to-MIDI mappings
///
///
///
/// If this flag is set and the value of the mStatus field is a MIDI channel message, then
/// the MIDI channel number in the status byte is ignored; the mapping is from the specified
/// MIDI message on any channel.
///
///
///
/// If this flag is set and the value of the mStatus field is a Note On, Note Off, or
/// Polyphonic Pressure message, the message's note number is ignored. The mapping is from
/// any note number.
///
///
///
/// Set this flag if the MIDI control should map only to a sub-range of the parameter's value.
/// Then specify that range in the mSubRangeMin and mSubRangeMax member fields.
///
///
///
/// Intended for Boolean typed parameters. When this property is set, it means that the
/// parameter's value should be toggled when the mapped MIDI message is received. For example,
/// if the parameter's value is currently TRUE, when the mapped MIDI message is received
/// the value changes to FALSE.
///
///
///
/// This property is useful when mapping a parameter to a MIDI Controller. When set, it
/// indicates that the parameter can assume only two values: on or off. For this reason, a
/// parameter associated with this property is typically Boolean. For example, if this
/// property is set for a parameter mapped to a sustain pedal MIDI controller, controller
/// values from 0 to 64 result in the parameter switched to its "off" state; controller
/// values from 65 to 127 result in the parameter switched to its "on" state.
///
/// This property works in connection with the kAUParameterMIDIMapping_Bipolar_On property.
/// The value of the kAUParameterMIDIMapping_Bipolar_On property
///
///
///
/// Determines whether the  "on" state of a parameter is mapped to the "on" or "off" state
/// of the associated MIDI controller. Only valid  if the  kAUParameterMIDIMapping_Bipolar
/// property is set.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUParameterMIDIMappingFlags(pub u32);
bitflags::bitflags! {
    impl AUParameterMIDIMappingFlags: u32 {
        #[doc(alias = "kAUParameterMIDIMapping_AnyChannelFlag")]
        const AnyChannelFlag = 1<<0;
        #[doc(alias = "kAUParameterMIDIMapping_AnyNoteFlag")]
        const AnyNoteFlag = 1<<1;
        #[doc(alias = "kAUParameterMIDIMapping_SubRange")]
        const SubRange = 1<<2;
        #[doc(alias = "kAUParameterMIDIMapping_Toggle")]
        const Toggle = 1<<3;
        #[doc(alias = "kAUParameterMIDIMapping_Bipolar")]
        const Bipolar = 1<<4;
        #[doc(alias = "kAUParameterMIDIMapping_Bipolar_On")]
        const Bipolar_On = 1<<5;
    }
}

unsafe impl Encode for AUParameterMIDIMappingFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUParameterMIDIMappingFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Represents a mapping between a MIDI message and an audio unit's parameter.
///
/// The reserved fields in this structure are for future use. In the current implementation,
/// they help align the structure to 64 bit size. Do not use the names of these fields in a
/// host application. They are subject to change.
#[cfg(feature = "AUComponent")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AUParameterMIDIMapping {
    pub mScope: AudioUnitScope,
    pub mElement: AudioUnitElement,
    pub mParameterID: AudioUnitParameterID,
    pub mFlags: AUParameterMIDIMappingFlags,
    pub mSubRangeMin: AudioUnitParameterValue,
    pub mSubRangeMax: AudioUnitParameterValue,
    pub mStatus: u8,
    pub mData1: u8,
    pub reserved1: u8,
    pub reserved2: u8,
    pub reserved3: u32,
}

#[cfg(feature = "AUComponent")]
unsafe impl Encode for AUParameterMIDIMapping {
    const ENCODING: Encoding = Encoding::Struct(
        "AUParameterMIDIMapping",
        &[
            <AudioUnitScope>::ENCODING,
            <AudioUnitElement>::ENCODING,
            <AudioUnitParameterID>::ENCODING,
            <AUParameterMIDIMappingFlags>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "AUComponent")]
unsafe impl RefEncode for AUParameterMIDIMapping {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_MIDIXMLNames: AudioUnitPropertyID = 1006;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_PartGroup: AudioUnitPropertyID = 1010;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_DualSchedulingMode: AudioUnitPropertyID = 1013;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_SupportsStartStopNote: AudioUnitPropertyID = 1014;

pub const kMusicDeviceSampleFrameMask_SampleOffset: c_uint = 0xFFFFFF;
pub const kMusicDeviceSampleFrameMask_IsScheduled: c_uint = 0x01000000;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitOfflineProperty_InputSize: AudioUnitPropertyID = 3020;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitOfflineProperty_OutputSize: AudioUnitPropertyID = 3021;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitOfflineProperty_StartOffset: AudioUnitPropertyID = 3022;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitOfflineProperty_PreflightRequirements: AudioUnitPropertyID = 3023;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitOfflineProperty_PreflightName: AudioUnitPropertyID = 3024;

pub const kOfflinePreflight_NotRequired: c_uint = 0;
pub const kOfflinePreflight_Optional: c_uint = 1;
pub const kOfflinePreflight_Required: c_uint = 2;

#[cfg(feature = "AUComponent")]
#[deprecated = "no longer supported"]
pub const kAudioUnitProperty_DistanceAttenuationData: AudioUnitPropertyID = 3600;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitMigrateProperty_FromPlugin: AudioUnitPropertyID = 4000;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitMigrateProperty_OldAutomation: AudioUnitPropertyID = 4001;

pub const kOtherPluginFormat_Undefined: u32 = 0;
pub const kOtherPluginFormat_kMAS: u32 = 1;
pub const kOtherPluginFormat_kVST: u32 = 2;
pub const kOtherPluginFormat_AU: u32 = 3;

/// One of the OtherPluginFormat values
///
///
/// struct AudioClassDescription {
/// OSType mType;
/// OSType mSubType;
/// OSType mManufacturer;
/// };
/// is defined in
/// <CoreAudioTypes
/// /CoreAudioTypes.h>
///
/// mType specifies a generic, plug-in format defined descriptor
/// mSubType is usually left to the manufacturer to use at their discretion
/// mManufacturer is a registered code to identify all plugins from the same manufacturer
#[cfg(feature = "objc2-core-audio-types")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitOtherPluginDesc {
    pub format: u32,
    pub plugin: AudioClassDescription,
}

#[cfg(feature = "objc2-core-audio-types")]
unsafe impl Encode for AudioUnitOtherPluginDesc {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitOtherPluginDesc",
        &[<u32>::ENCODING, <AudioClassDescription>::ENCODING],
    );
}

#[cfg(feature = "objc2-core-audio-types")]
unsafe impl RefEncode for AudioUnitOtherPluginDesc {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Used to translate another plug-in's parameter values to  audio unit parameter
/// values
#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitParameterValueTranslation {
    pub otherDesc: AudioUnitOtherPluginDesc,
    pub otherParamID: u32,
    pub otherValue: f32,
    pub auParamID: AudioUnitParameterID,
    pub auValue: AudioUnitParameterValue,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
unsafe impl Encode for AudioUnitParameterValueTranslation {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterValueTranslation",
        &[
            <AudioUnitOtherPluginDesc>::ENCODING,
            <u32>::ENCODING,
            <f32>::ENCODING,
            <AudioUnitParameterID>::ENCODING,
            <AudioUnitParameterValue>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-audio-types"))]
unsafe impl RefEncode for AudioUnitParameterValueTranslation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// AU-MAS specific structs for the data contained in the "masdata" key of an audio
/// unit preset dictionary
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitPresetMAS_SettingData {
    pub isStockSetting: u32,
    pub settingID: u32,
    pub dataLen: u32,
    pub data: [u8; 1],
}

unsafe impl Encode for AudioUnitPresetMAS_SettingData {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitPresetMAS_SettingData",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u8; 1]>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AudioUnitPresetMAS_SettingData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// See MAS documentation
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitPresetMAS_Settings {
    pub manufacturerID: u32,
    pub effectID: u32,
    pub variantID: u32,
    pub settingsVersion: u32,
    pub numberOfSettings: u32,
    pub settings: [AudioUnitPresetMAS_SettingData; 1],
}

unsafe impl Encode for AudioUnitPresetMAS_Settings {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitPresetMAS_Settings",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[AudioUnitPresetMAS_SettingData; 1]>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AudioUnitPresetMAS_Settings {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SampleRateConverterComplexity: AudioUnitPropertyID = 3014;

/// Basic sample rate conversion using linear interpolation. Fast, but lower quality.
pub const kAudioUnitSampleRateConverterComplexity_Linear: u32 = 0x6c696e65;
pub const kAudioUnitSampleRateConverterComplexity_Normal: u32 = 0x6e6f726d;
/// Mastering quality sample rate conversion. More computationally expensive.
pub const kAudioUnitSampleRateConverterComplexity_Mastering: u32 = 0x62617473;

/// A read/write audio device ID object, of type `AudioDeviceID`, valid on the audio unit global scope.
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_CurrentDevice: AudioUnitPropertyID = 2000;
/// Indicates whether an audio unit is running (`TRUE`) or not (`FALSE`).
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_IsRunning: AudioUnitPropertyID = 2001;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_ChannelMap: AudioUnitPropertyID = 2002;
/// Specifies whether audio I/O is enabled for an I/O unit bus-scope combination.
///
/// ## Discussion
///
/// An I/O unit’s bus 0 connects to output hardware, such as for playback through a speaker. Output is enabled by default. To disable output, the bus 0 output scope must be disabled, as follows:
///
/// ```objc
/// UInt32 enableOutput        = 0;    // to disable output
/// AudioUnitElement outputBus = 0;
///  
/// AudioUnitSetProperty (
///     io_unit_instance,
///     kAudioOutputUnitProperty_EnableIO,
///     kAudioUnitScope_Output,
///     outputBus,
///     &enableOutput,
///     sizeof (enableOutput)
/// );
/// ```
///
/// An I/O unit’s bus 1 connects to input hardware, such as for recording from a microphone. Input is disabled by default. To enable input, the bus 1 input scope must be enabled, as follows:
///
/// ```objc
/// UInt32 enableInput        = 1;    // to enable input
/// AudioUnitElement inputBus = 1;
///  
/// AudioUnitSetProperty (
///     io_unit_instance,
///     kAudioOutputUnitProperty_EnableIO,
///     kAudioUnitScope_Input,
///     inputBus,
///     &enableInput,
///     sizeof (enableInput)
/// );
/// ```
///
/// A read/write `UInt32` value valid on the input and output scopes.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_EnableIO: AudioUnitPropertyID = 2003;
/// A write-only `AudioOutputUnitStartAtTimeParams` data structure valid on the audio unit global scope. When this property is set on an output unit, it will cause the next Start request (but no subsequent Starts) to use the AudioDeviceStartAtTime function, using the specified timestamp, passing false for `inRequestedStartTimeIsInput`.
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_StartTime: AudioUnitPropertyID = 2004;
/// A read/write `AURenderCallbackStruct` data structure valid on the audio unit global scope. When an output unit has been enabled for input operation, this callback can be used to provide a single callback to the host application from the input I/O proc, in order to notify the host that input is available and may be obtained by calling the `AudioUnitRender` function.
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_SetInputCallback: AudioUnitPropertyID = 2005;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_HasIO: AudioUnitPropertyID = 2006;
/// A read/write `UInt32` value valid on the audio unit global scope.
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_StartTimestampsAtZero: AudioUnitPropertyID = 2007;
/// The workgroup associated with the audio device underlying this Audio Unit.
///
/// ## Discussion
///
/// The value of this key is an [`os_workgroup_t`](https://developer.apple.com/documentation/os/os_workgroup_t) object.
///
/// Workgroups allow multiple threads to coordinate their activities for realtime operations. For Audio Units, this coordination occurs between the Audio Unit and other processes, such as the audio server and host app. The system uses the workgroup to observe the threads’ CPU usage and dynamically balance the competing considerations of power consumption and real-time rendering capacity.
///
/// This version 2 property is bridged to the version 3 [`osWorkgroup`](https://developer.apple.com/documentation/audiotoolbox/auaudiounit/osworkgroup) property of [`AUAudioUnit`](https://developer.apple.com/documentation/audiotoolbox/auaudiounit).
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_OSWorkgroup: AudioUnitPropertyID = 2015;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_IntendedSpatialExperience: AudioUnitPropertyID = 2016;

#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_MIDICallbacks: AudioUnitPropertyID = 2010;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_HostReceivesRemoteControlEvents: AudioUnitPropertyID = 2011;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_RemoteControlToHost: AudioUnitPropertyID = 2012;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_HostTransportState: AudioUnitPropertyID = 2013;
#[cfg(feature = "AUComponent")]
pub const kAudioOutputUnitProperty_NodeComponentDescription: AudioUnitPropertyID = 2014;

/// For inter-app audio, callbacks for receiving MIDI messages.
///
/// The supplied callback functions are called from the realtime rendering thread, before each
/// render cycle, to provide any incoming MIDI messages.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioOutputUnitMIDICallbacks {
    pub userData: *mut c_void,
    pub MIDIEventProc: unsafe extern "C-unwind" fn(*mut c_void, u32, u32, u32, u32),
    pub MIDISysExProc: unsafe extern "C-unwind" fn(*mut c_void, NonNull<u8>, u32),
}

unsafe impl Encode for AudioOutputUnitMIDICallbacks {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioOutputUnitMIDICallbacks",
        &[
            <*mut c_void>::ENCODING,
            <unsafe extern "C-unwind" fn(*mut c_void, u32, u32, u32, u32)>::ENCODING,
            <unsafe extern "C-unwind" fn(*mut c_void, NonNull<u8>, u32)>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AudioOutputUnitMIDICallbacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A timestamp for scheduled starting of an I/O audio unit.
#[cfg(feature = "objc2-core-audio-types")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioOutputUnitStartAtTimeParams {
    pub mTimestamp: AudioTimeStamp,
    pub mFlags: u32,
}

#[cfg(feature = "objc2-core-audio-types")]
unsafe impl Encode for AudioOutputUnitStartAtTimeParams {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioOutputUnitStartAtTimeParams",
        &[<AudioTimeStamp>::ENCODING, <u32>::ENCODING],
    );
}

#[cfg(feature = "objc2-core-audio-types")]
unsafe impl RefEncode for AudioOutputUnitStartAtTimeParams {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A property that bypasses all processing for microphone uplink done by the voice processing unit.
#[cfg(feature = "AUComponent")]
pub const kAUVoiceIOProperty_BypassVoiceProcessing: AudioUnitPropertyID = 2100;
/// A property to enable automatic gain control on the processed microphone uplink.
#[cfg(feature = "AUComponent")]
pub const kAUVoiceIOProperty_VoiceProcessingEnableAGC: AudioUnitPropertyID = 2101;
/// A property to mute the output of the processed microphone uplink.
#[cfg(feature = "AUComponent")]
pub const kAUVoiceIOProperty_MuteOutput: AudioUnitPropertyID = 2104;

/// Constants that indicate the state of muted speech.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUVoiceIOSpeechActivityEvent(pub u32);
impl AUVoiceIOSpeechActivityEvent {
    /// A state that indicates speech started.
    #[doc(alias = "kAUVoiceIOSpeechActivityHasStarted")]
    pub const HasStarted: Self = Self(0);
    /// A state that indicates speech ended.
    #[doc(alias = "kAUVoiceIOSpeechActivityHasEnded")]
    pub const HasEnded: Self = Self(1);
}

unsafe impl Encode for AUVoiceIOSpeechActivityEvent {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUVoiceIOSpeechActivityEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A block that the system calls to indicate speech activity while the user has the microphone muted.
///
/// Parameters:
/// - event: An event that indicates whether muted speech started or ended.
///
/// Block called to receive speech activity event while the client is muted.
#[cfg(feature = "block2")]
pub type AUVoiceIOMutedSpeechActivityEventListener =
    *mut block2::DynBlock<dyn Fn(AUVoiceIOSpeechActivityEvent)>;

/// A property to register a listener that the system calls when it detects speech while the user has the microphone muted.
///
/// ## Discussion
///
/// To use this API, your app must implement mute using the [`kAUVoiceIOProperty_MuteOutput`](https://developer.apple.com/documentation/audiotoolbox/kauvoiceioproperty_muteoutput) property.
///
///
#[cfg(feature = "AUComponent")]
pub const kAUVoiceIOProperty_MutedSpeechActivityEventListener: AudioUnitPropertyID = 2106;

/// The ducking level to apply to other non-voice audio.
/// Ducking level applied to other (i.e. non-voice) audio by AUVoiceIO.
///
/// DuckingLevelDefault = Default ducking level to other audio for typical voice chat.
/// DuckingLevelMin = minimum ducking to other audio.
/// DuckingLevelMid = medium ducking to other audio.
/// DuckingLevelMax = maximum ducking to other audio.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUVoiceIOOtherAudioDuckingLevel(pub u32);
impl AUVoiceIOOtherAudioDuckingLevel {
    /// The default ducking level of other non-voice audio in a typical voice chat.
    #[doc(alias = "kAUVoiceIOOtherAudioDuckingLevelDefault")]
    pub const Default: Self = Self(0);
    /// The minimum ducking level of other non-voice audio.
    #[doc(alias = "kAUVoiceIOOtherAudioDuckingLevelMin")]
    pub const Min: Self = Self(10);
    /// A medium ducking level of other non-voice audio.
    #[doc(alias = "kAUVoiceIOOtherAudioDuckingLevelMid")]
    pub const Mid: Self = Self(20);
    /// The maximum ducking level of other non-voice audio.
    #[doc(alias = "kAUVoiceIOOtherAudioDuckingLevelMax")]
    pub const Max: Self = Self(30);
}

unsafe impl Encode for AUVoiceIOOtherAudioDuckingLevel {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUVoiceIOOtherAudioDuckingLevel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure that you use to configure ducking of other non-voice audio in a voice chat.
///
/// ## Overview
///
/// Use this structure to specify whether to enable advanced ducking and set the ducking level of other non-voice audio in a voice chat. Advanced ducking ducks other non-voice audio based on the presence of voice activity from local and remote chat participants. Setting a higher level of ducking could increase the clarity of voice chat.
///
/// If you don’t set this value, the default ducking configuration disables advanced ducking and sets the ducking level to [`kAUVoiceIOOtherAudioDuckingLevelDefault`](https://developer.apple.com/documentation/audiotoolbox/auvoiceiootheraudioduckinglevel/default).
///
///
/// The configuration of ducking other (i.e. non-voice) audio
///
///
/// Enables advanced ducking which ducks other audio based on the presence of voice activity from local and/or remote chat participants.
///
/// Ducking level of other audio
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AUVoiceIOOtherAudioDuckingConfiguration {
    pub mEnableAdvancedDucking: Boolean,
    pub mDuckingLevel: AUVoiceIOOtherAudioDuckingLevel,
}

unsafe impl Encode for AUVoiceIOOtherAudioDuckingConfiguration {
    const ENCODING: Encoding = Encoding::Struct(
        "AUVoiceIOOtherAudioDuckingConfiguration",
        &[
            <Boolean>::ENCODING,
            <AUVoiceIOOtherAudioDuckingLevel>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AUVoiceIOOtherAudioDuckingConfiguration {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAUVoiceIOProperty_OtherAudioDuckingConfiguration: AudioUnitPropertyID = 2108;

#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAUVoiceIOProperty_VoiceProcessingQuality: AudioUnitPropertyID = 2103;

#[cfg(feature = "AUComponent")]
pub const kAUNBandEQProperty_NumberOfBands: AudioUnitPropertyID = 2200;
#[cfg(feature = "AUComponent")]
pub const kAUNBandEQProperty_MaxNumberOfBands: AudioUnitPropertyID = 2201;
#[cfg(feature = "AUComponent")]
pub const kAUNBandEQProperty_BiquadCoefficients: AudioUnitPropertyID = 2203;

/// An error that indicates that the audio unit encountered an unexpected number of input channels during initialization.
pub const kAUVoiceIOErr_UnexpectedNumberOfInputChannels: OSStatus = -66784;

/// Specifies whether metering is enabled or disabled for a particular scope-element combination.
///
/// ## Discussion
///
/// A read/write `UInt32` value valid on the input and output scopes.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MeteringMode: AudioUnitPropertyID = 3007;
/// Describes the internal state of a matrix mixer.
///
/// ## Discussion
///
/// Calculate the size required for this property’s value as follows:
///
/// ```objc
/// (input channel count + 1) * (output channel count + 1)
/// ```
///
/// Obtain the channel counts using the `kAudioUnitProperty_MatrixDimensions` property.
///
/// For example, consider a matrix mixer that has 2 input channels and 2 output channels. The value of this property then requires a 3 x 3 array of `Float32` values. You can retrieve specific pieces of information for this example matrix mixer’s state as follows:
///
/// - Global volume is stored at `volumes[2][2]`
///
/// - Input volumes are stored in the last column: first input channel at `volumes[0][2]`; second input channel at `volumes[1][2]`
///
/// - Output volumes are stored in the last row: first output channel at `volumes [2][0]`; second output channel at `volumes[2][1]`
///
/// - Cross-point volumes are stored at their expected locations(`volumes[0][1]`, etc)
///
/// A read-only two-dimensional array of `Float32` values valid on the audio unit global scope.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MatrixLevels: AudioUnitPropertyID = 3006;
/// Indicates the total number of channels for input and output of a given matrix mixer.
///
/// ## Discussion
///
/// A read-only `2 * UInt32` value valid on the audio unit global scope.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MatrixDimensions: AudioUnitPropertyID = 3009;
/// Indicates audio clipping that has occurred since this property was last accessed.
///
/// ## Discussion
///
/// A read-only [`AudioUnitMeterClipping`](https://developer.apple.com/documentation/audiotoolbox/audiounitmeterclipping) data structure valid on the audio unit global scope.
///
///
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MeterClipping: AudioUnitPropertyID = 3011;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_InputAnchorTimeStamp: AudioUnitPropertyID = 3016;

/// Audio clipping that has occurred in a mixer unit.
///
/// ## Overview
///
/// This data structure is used by the `kAudioUnitProperty_MeterClipping` property.
///
///
/// The maximum value seen on the channel since the last time the property was retrieved.
///
/// TRUE if there was an infinite value on this channel.
///
/// TRUE if there was a floating point Not-A-Number value on this channel.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitMeterClipping {
    pub peakValueSinceLastCall: f32,
    pub sawInfinity: Boolean,
    pub sawNotANumber: Boolean,
}

unsafe impl Encode for AudioUnitMeterClipping {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitMeterClipping",
        &[<f32>::ENCODING, <Boolean>::ENCODING, <Boolean>::ENCODING],
    );
}

unsafe impl RefEncode for AudioUnitMeterClipping {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ReverbRoomType: AudioUnitPropertyID = 10;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_UsesInternalReverb: AudioUnitPropertyID = 1005;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatializationAlgorithm: AudioUnitPropertyID = 3000;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerRenderingFlags: AudioUnitPropertyID = 3003;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerSourceMode: AudioUnitPropertyID = 3005;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerDistanceParams: AudioUnitPropertyID = 3010;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerAttenuationCurve: AudioUnitPropertyID = 3013;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerOutputType: AudioUnitPropertyID = 3100;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerPointSourceInHeadMode: AudioUnitPropertyID = 3103;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerEnableHeadTracking: AudioUnitPropertyID = 3111;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerPersonalizedHRTFMode: AudioUnitPropertyID = 3113;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpatialMixerAnyInputIsUsingPersonalizedHRTF: AudioUnitPropertyID =
    3116;

/// Use kSpatializationAlgorithm_UseOutputType with appropriate kAudioUnitProperty_SpatialMixerOutputType
/// for highest-quality spatial rendering across different hardware.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUSpatializationAlgorithm(pub u32);
impl AUSpatializationAlgorithm {
    #[doc(alias = "kSpatializationAlgorithm_EqualPowerPanning")]
    pub const SpatializationAlgorithm_EqualPowerPanning: Self = Self(0);
    #[doc(alias = "kSpatializationAlgorithm_SphericalHead")]
    pub const SpatializationAlgorithm_SphericalHead: Self = Self(1);
    #[doc(alias = "kSpatializationAlgorithm_HRTF")]
    pub const SpatializationAlgorithm_HRTF: Self = Self(2);
    #[doc(alias = "kSpatializationAlgorithm_SoundField")]
    pub const SpatializationAlgorithm_SoundField: Self = Self(3);
    #[doc(alias = "kSpatializationAlgorithm_VectorBasedPanning")]
    pub const SpatializationAlgorithm_VectorBasedPanning: Self = Self(4);
    #[doc(alias = "kSpatializationAlgorithm_StereoPassThrough")]
    pub const SpatializationAlgorithm_StereoPassThrough: Self = Self(5);
    #[doc(alias = "kSpatializationAlgorithm_HRTFHQ")]
    pub const SpatializationAlgorithm_HRTFHQ: Self = Self(6);
    #[doc(alias = "kSpatializationAlgorithm_UseOutputType")]
    pub const SpatializationAlgorithm_UseOutputType: Self = Self(7);
}

unsafe impl Encode for AUSpatializationAlgorithm {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatializationAlgorithm {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Mono input is spatialized using kAudioUnitProperty_SpatializationAlgorithm.
/// Any input with more than one channel is passed through without spatialization. This is
/// the default mode and corresponds to legacy behavior. The rendering is equivalent to
/// kSpatialMixerSourceMode_PointSource for mono input and
/// kSpatialMixerSourceMode_Bypass for input with more than one channel.
///
///
///
/// No spatial rendering. If input and output AudioChannelLayouts are equivalent, all
/// input channels are copied to corresponding output channels. If the input and
/// output AudioChannelLayouts differ, mixing is done according to the
/// kAudioFormatProperty_MatrixMixMap property of the layouts. No occlusion, obstruction,
/// or reverb is applied in this mode.
///
///
///
/// All channels of the input signal are rendered as a single source except if rendering
/// in-head with kSpatialMixerPointSourceInHeadMode_Bypass.
///
///
///
/// The input channels are spatialized around the listener as far-field sources.
/// The relative directions of the individual channels are specified by the
/// AudioChannelLayout of the bus. The rotation of the whole bed in the global space is
/// controlled by azimuth and elevation parameters.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUSpatialMixerSourceMode(pub u32);
impl AUSpatialMixerSourceMode {
    #[doc(alias = "kSpatialMixerSourceMode_SpatializeIfMono")]
    pub const SpatialMixerSourceMode_SpatializeIfMono: Self = Self(0);
    #[doc(alias = "kSpatialMixerSourceMode_Bypass")]
    pub const SpatialMixerSourceMode_Bypass: Self = Self(1);
    #[doc(alias = "kSpatialMixerSourceMode_PointSource")]
    pub const SpatialMixerSourceMode_PointSource: Self = Self(2);
    #[doc(alias = "kSpatialMixerSourceMode_AmbienceBed")]
    pub const SpatialMixerSourceMode_AmbienceBed: Self = Self(3);
}

unsafe impl Encode for AUSpatialMixerSourceMode {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatialMixerSourceMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Used to specify room type (as identified by a factory preset number) on Apple audio
/// units that use internal reverb.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUReverbRoomType(pub u32);
impl AUReverbRoomType {
    #[doc(alias = "kReverbRoomType_SmallRoom")]
    pub const ReverbRoomType_SmallRoom: Self = Self(0);
    #[doc(alias = "kReverbRoomType_MediumRoom")]
    pub const ReverbRoomType_MediumRoom: Self = Self(1);
    #[doc(alias = "kReverbRoomType_LargeRoom")]
    pub const ReverbRoomType_LargeRoom: Self = Self(2);
    #[doc(alias = "kReverbRoomType_MediumHall")]
    pub const ReverbRoomType_MediumHall: Self = Self(3);
    #[doc(alias = "kReverbRoomType_LargeHall")]
    pub const ReverbRoomType_LargeHall: Self = Self(4);
    #[doc(alias = "kReverbRoomType_Plate")]
    pub const ReverbRoomType_Plate: Self = Self(5);
    #[doc(alias = "kReverbRoomType_MediumChamber")]
    pub const ReverbRoomType_MediumChamber: Self = Self(6);
    #[doc(alias = "kReverbRoomType_LargeChamber")]
    pub const ReverbRoomType_LargeChamber: Self = Self(7);
    #[doc(alias = "kReverbRoomType_Cathedral")]
    pub const ReverbRoomType_Cathedral: Self = Self(8);
    #[doc(alias = "kReverbRoomType_LargeRoom2")]
    pub const ReverbRoomType_LargeRoom2: Self = Self(9);
    #[doc(alias = "kReverbRoomType_MediumHall2")]
    pub const ReverbRoomType_MediumHall2: Self = Self(10);
    #[doc(alias = "kReverbRoomType_MediumHall3")]
    pub const ReverbRoomType_MediumHall3: Self = Self(11);
    #[doc(alias = "kReverbRoomType_LargeHall2")]
    pub const ReverbRoomType_LargeHall2: Self = Self(12);
}

unsafe impl Encode for AUReverbRoomType {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUReverbRoomType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUSpatialMixerAttenuationCurve(pub u32);
impl AUSpatialMixerAttenuationCurve {
    #[doc(alias = "kSpatialMixerAttenuationCurve_Power")]
    pub const SpatialMixerAttenuationCurve_Power: Self = Self(0);
    #[doc(alias = "kSpatialMixerAttenuationCurve_Exponential")]
    pub const SpatialMixerAttenuationCurve_Exponential: Self = Self(1);
    #[doc(alias = "kSpatialMixerAttenuationCurve_Inverse")]
    pub const SpatialMixerAttenuationCurve_Inverse: Self = Self(2);
    #[doc(alias = "kSpatialMixerAttenuationCurve_Linear")]
    pub const SpatialMixerAttenuationCurve_Linear: Self = Self(3);
}

unsafe impl Encode for AUSpatialMixerAttenuationCurve {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatialMixerAttenuationCurve {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct MixerDistanceParams {
    pub mReferenceDistance: f32,
    pub mMaxDistance: f32,
    pub mMaxAttenuation: f32,
}

unsafe impl Encode for MixerDistanceParams {
    const ENCODING: Encoding = Encoding::Struct(
        "MixerDistanceParams",
        &[<f32>::ENCODING, <f32>::ENCODING, <f32>::ENCODING],
    );
}

unsafe impl RefEncode for MixerDistanceParams {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUSpatialMixerRenderingFlags(pub u32);
bitflags::bitflags! {
    impl AUSpatialMixerRenderingFlags: u32 {
        #[doc(alias = "kSpatialMixerRenderingFlags_InterAuralDelay")]
        const SpatialMixerRenderingFlags_InterAuralDelay = 1<<0;
        #[doc(alias = "kSpatialMixerRenderingFlags_DistanceAttenuation")]
        const SpatialMixerRenderingFlags_DistanceAttenuation = 1<<2;
    }
}

unsafe impl Encode for AUSpatialMixerRenderingFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatialMixerRenderingFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Use generic head-related transfer function (HRTF).
///
///
///
/// Use personalized head-related transfer function (HRTF), if available.
///
///
///
/// Follow system preferences to choose between personalized vs generic
/// head-related transfer function (HRTF).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUSpatialMixerPersonalizedHRTFMode(pub u32);
impl AUSpatialMixerPersonalizedHRTFMode {
    #[doc(alias = "kSpatialMixerPersonalizedHRTFMode_Off")]
    pub const SpatialMixerPersonalizedHRTFMode_Off: Self = Self(0);
    #[doc(alias = "kSpatialMixerPersonalizedHRTFMode_On")]
    pub const SpatialMixerPersonalizedHRTFMode_On: Self = Self(1);
    #[doc(alias = "kSpatialMixerPersonalizedHRTFMode_Auto")]
    pub const SpatialMixerPersonalizedHRTFMode_Auto: Self = Self(2);
}

unsafe impl Encode for AUSpatialMixerPersonalizedHRTFMode {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatialMixerPersonalizedHRTFMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Render for headphones.
///
///
///
/// Render for built-in speakers. The spatialization is optimized for current hardware and
/// will not be suitable for playback on other hardware. On iOS devices, the rendering may
/// be specific to device orientation. Non-realtime rendering may not provide intended results
/// if the orientation changes between rendering the audio and playing it back.
///
///
///
/// Render for external speakers based on the mixer's output channel layout.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AUSpatialMixerOutputType(pub u32);
impl AUSpatialMixerOutputType {
    #[doc(alias = "kSpatialMixerOutputType_Headphones")]
    pub const SpatialMixerOutputType_Headphones: Self = Self(1);
    #[doc(alias = "kSpatialMixerOutputType_BuiltInSpeakers")]
    pub const SpatialMixerOutputType_BuiltInSpeakers: Self = Self(2);
    #[doc(alias = "kSpatialMixerOutputType_ExternalSpeakers")]
    pub const SpatialMixerOutputType_ExternalSpeakers: Self = Self(3);
}

unsafe impl Encode for AUSpatialMixerOutputType {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatialMixerOutputType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This setting only affects spatialization when using kSpatializationAlgorithm_UseOutputType
/// with kSpatialMixerSourceMode_PointSource.
///
///
///
/// A point source remains a single mono source inside the listener's head regardless
/// of the channels it consists of.
///
///
///
/// A point source splits into bypass inside the listener's head. This enables transitions
/// between traditional, non-spatialized rendering and spatialized sources outside the
/// listener's head.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUSpatialMixerPointSourceInHeadMode(pub u32);
impl AUSpatialMixerPointSourceInHeadMode {
    #[doc(alias = "kSpatialMixerPointSourceInHeadMode_Mono")]
    pub const SpatialMixerPointSourceInHeadMode_Mono: Self = Self(0);
    #[doc(alias = "kSpatialMixerPointSourceInHeadMode_Bypass")]
    pub const SpatialMixerPointSourceInHeadMode_Bypass: Self = Self(1);
}

unsafe impl Encode for AUSpatialMixerPointSourceInHeadMode {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUSpatialMixerPointSourceInHeadMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAUAudioMixProperty_SpatialAudioMixMetadata: AudioUnitPropertyID = 5000;
#[cfg(feature = "AUComponent")]
pub const kAUAudioMixProperty_EnableSpatialization: AudioUnitPropertyID = 5001;

#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAudioUnitProperty_3DMixerDistanceParams: AudioUnitPropertyID = 3010;
#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAudioUnitProperty_3DMixerAttenuationCurve: AudioUnitPropertyID = 3013;
#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAudioUnitProperty_DopplerShift: AudioUnitPropertyID = 3002;
#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAudioUnitProperty_3DMixerRenderingFlags: AudioUnitPropertyID = 3003;
#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAudioUnitProperty_3DMixerDistanceAtten: AudioUnitPropertyID = 3004;
#[cfg(feature = "AUComponent")]
#[deprecated]
pub const kAudioUnitProperty_ReverbPreset: AudioUnitPropertyID = 3012;

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AU3DMixerRenderingFlags(pub u32);
bitflags::bitflags! {
    impl AU3DMixerRenderingFlags: u32 {
        const k3DMixerRenderingFlags_InterAuralDelay = 1<<0;
        const k3DMixerRenderingFlags_DopplerShift = 1<<1;
        const k3DMixerRenderingFlags_DistanceAttenuation = 1<<2;
        const k3DMixerRenderingFlags_DistanceFilter = 1<<3;
        const k3DMixerRenderingFlags_DistanceDiffusion = 1<<4;
        const k3DMixerRenderingFlags_LinearDistanceAttenuation = 1<<5;
        const k3DMixerRenderingFlags_ConstantReverbBlend = 1<<6;
    }
}

unsafe impl Encode for AU3DMixerRenderingFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AU3DMixerRenderingFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AU3DMixerAttenuationCurve(pub u32);
impl AU3DMixerAttenuationCurve {
    /// An equal-power-based attenuation curve.
    pub const k3DMixerAttenuationCurve_Power: Self = Self(0);
    /// An exponential attenuation curve.
    pub const k3DMixerAttenuationCurve_Exponential: Self = Self(1);
    /// An inverse attenuation curve.
    pub const k3DMixerAttenuationCurve_Inverse: Self = Self(2);
    /// A linear attenuation curve.
    pub const k3DMixerAttenuationCurve_Linear: Self = Self(3);
}

unsafe impl Encode for AU3DMixerAttenuationCurve {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AU3DMixerAttenuationCurve {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduleAudioSlice: AudioUnitPropertyID = 3300;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduleStartTimeStamp: AudioUnitPropertyID = 3301;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_CurrentPlayTime: AudioUnitPropertyID = 3302;

/// bits in ScheduledAudioSlice.mFlags
///
///
/// Set if the unit is done with this slice
///
/// Set if any portion of the buffer has been played
///
/// Set if any portion of the buffer was not played because it was scheduled late
///
/// specifies that the buffer should loop indefinitely
///
/// specifies that the buffer should interrupt any previously scheduled buffer
/// (by default, buffers following a playing buffer are not played until the
/// playing buffer has completed).
///
/// specifies that the buffer should interrupt any previously scheduled buffer,
/// but only at a loop point in that buffer.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AUScheduledAudioSliceFlags(pub u32);
bitflags::bitflags! {
    impl AUScheduledAudioSliceFlags: u32 {
        #[doc(alias = "kScheduledAudioSliceFlag_Complete")]
        const ScheduledAudioSliceFlag_Complete = 0x01;
        #[doc(alias = "kScheduledAudioSliceFlag_BeganToRender")]
        const ScheduledAudioSliceFlag_BeganToRender = 0x02;
        #[doc(alias = "kScheduledAudioSliceFlag_BeganToRenderLate")]
        const ScheduledAudioSliceFlag_BeganToRenderLate = 0x04;
        #[doc(alias = "kScheduledAudioSliceFlag_Loop")]
        const ScheduledAudioSliceFlag_Loop = 0x08;
        #[doc(alias = "kScheduledAudioSliceFlag_Interrupt")]
        const ScheduledAudioSliceFlag_Interrupt = 0x10;
        #[doc(alias = "kScheduledAudioSliceFlag_InterruptAtLoop")]
        const ScheduledAudioSliceFlag_InterruptAtLoop = 0x20;
    }
}

unsafe impl Encode for AUScheduledAudioSliceFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AUScheduledAudioSliceFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduledFileIDs: AudioUnitPropertyID = 3310;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduledFileRegion: AudioUnitPropertyID = 3311;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduledFilePrime: AudioUnitPropertyID = 3312;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduledFileBufferSizeFrames: AudioUnitPropertyID = 3313;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ScheduledFileNumberBuffers: AudioUnitPropertyID = 3314;

#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_UsesInternalReverb: AudioUnitPropertyID =
    kAudioUnitProperty_UsesInternalReverb;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_SoundBankData: AudioUnitPropertyID = 1008;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_StreamFromDisk: AudioUnitPropertyID = 1011;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_SoundBankFSRef: AudioUnitPropertyID = 1012;

#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_InstrumentName: AudioUnitPropertyID = 1001;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_InstrumentNumber: AudioUnitPropertyID = 1004;

#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_InstrumentCount: AudioUnitPropertyID = 1000;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_BankName: AudioUnitPropertyID = 1007;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_SoundBankURL: AudioUnitPropertyID = 1100;

#[cfg(feature = "AUComponent")]
pub const kAUMIDISynthProperty_EnablePreload: AudioUnitPropertyID = 4119;

#[cfg(feature = "AUComponent")]
pub const kAUSamplerProperty_LoadInstrument: AudioUnitPropertyID = 4102;
#[cfg(feature = "AUComponent")]
pub const kAUSamplerProperty_LoadAudioFiles: AudioUnitPropertyID = 4101;

#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUSamplerInstrumentData {
    pub fileURL: NonNull<CFURL>,
    pub instrumentType: u8,
    pub bankMSB: u8,
    pub bankLSB: u8,
    pub presetID: u8,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AUSamplerInstrumentData {
    const ENCODING: Encoding = Encoding::Struct(
        "AUSamplerInstrumentData",
        &[
            <NonNull<CFURL>>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AUSamplerInstrumentData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kInstrumentType_DLSPreset: c_uint = 1;
pub const kInstrumentType_SF2Preset: c_uint = kInstrumentType_DLSPreset;
pub const kInstrumentType_AUPreset: c_uint = 2;
pub const kInstrumentType_Audiofile: c_uint = 3;
pub const kInstrumentType_EXS24: c_uint = 4;

pub const kAUSampler_DefaultPercussionBankMSB: c_uint = 0x78;
pub const kAUSampler_DefaultMelodicBankMSB: c_uint = 0x79;
pub const kAUSampler_DefaultBankLSB: c_uint = 0x00;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_DeferredRendererPullSize: AudioUnitPropertyID = 3320;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_DeferredRendererExtraLatency: AudioUnitPropertyID = 3321;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_DeferredRendererWaitFrames: AudioUnitPropertyID = 3322;

#[cfg(feature = "AUComponent")]
pub const kAUNetReceiveProperty_Hostname: AudioUnitPropertyID = 3511;
#[cfg(feature = "AUComponent")]
pub const kAUNetReceiveProperty_Password: AudioUnitPropertyID = 3512;

#[cfg(feature = "AUComponent")]
pub const kAUNetSendProperty_PortNum: AudioUnitPropertyID = 3513;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendProperty_TransmissionFormat: AudioUnitPropertyID = 3514;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendProperty_TransmissionFormatIndex: AudioUnitPropertyID = 3515;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendProperty_ServiceName: AudioUnitPropertyID = 3516;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendProperty_Disconnect: AudioUnitPropertyID = 3517;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendProperty_Password: AudioUnitPropertyID = 3518;

#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_PCMFloat32: AudioUnitPropertyID = 0;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_PCMInt24: AudioUnitPropertyID = 1;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_PCMInt16: AudioUnitPropertyID = 2;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_Lossless24: AudioUnitPropertyID = 3;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_Lossless16: AudioUnitPropertyID = 4;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_ULaw: AudioUnitPropertyID = 5;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_IMA4: AudioUnitPropertyID = 6;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_128kbpspc: AudioUnitPropertyID = 7;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_96kbpspc: AudioUnitPropertyID = 8;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_80kbpspc: AudioUnitPropertyID = 9;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_64kbpspc: AudioUnitPropertyID = 10;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_48kbpspc: AudioUnitPropertyID = 11;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_40kbpspc: AudioUnitPropertyID = 12;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_32kbpspc: AudioUnitPropertyID = 13;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_LD_64kbpspc: AudioUnitPropertyID = 14;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_LD_48kbpspc: AudioUnitPropertyID = 15;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_LD_40kbpspc: AudioUnitPropertyID = 16;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendPresetFormat_AAC_LD_32kbpspc: AudioUnitPropertyID = 17;
#[cfg(feature = "AUComponent")]
pub const kAUNetSendNumPresetFormats: AudioUnitPropertyID = 18;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AUNumVersion {
    pub nonRelRev: u8,
    pub stage: u8,
    pub minorAndBugRev: u8,
    pub majorRev: u8,
}

unsafe impl Encode for AUNumVersion {
    const ENCODING: Encoding = Encoding::Struct(
        "AUNumVersion",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AUNumVersion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Used to describe the name and version of the audio unit's host
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUHostIdentifier {
    pub hostName: NonNull<CFString>,
    pub hostVersion: AUNumVersion,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AUHostIdentifier {
    const ENCODING: Encoding = Encoding::Struct(
        "AUHostIdentifier",
        &[<NonNull<CFString>>::ENCODING, <AUNumVersion>::ENCODING],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AUHostIdentifier {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioUnitParameterFlag_Global: c_uint = 1 << 0;
pub const kAudioUnitParameterFlag_Input: c_uint = 1 << 1;
pub const kAudioUnitParameterFlag_Output: c_uint = 1 << 2;
pub const kAudioUnitParameterFlag_Group: c_uint = 1 << 3;

pub const kAudioUnitParameterFlag_HasName: u32 =
    AudioUnitParameterOptions::Flag_ValuesHaveStrings.0;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SRCAlgorithm: AudioUnitPropertyID = 9;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_MIDIControlMapping: AudioUnitPropertyID = 17;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_CurrentPreset: AudioUnitPropertyID = 28;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_ParameterValueName: AudioUnitPropertyID =
    kAudioUnitProperty_ParameterStringFromValue;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_BusCount: AudioUnitPropertyID = kAudioUnitProperty_ElementCount;
#[cfg(feature = "AUComponent")]
pub const kAudioOfflineUnitProperty_InputSize: AudioUnitPropertyID =
    kAudioUnitOfflineProperty_InputSize;
#[cfg(feature = "AUComponent")]
pub const kAudioOfflineUnitProperty_OutputSize: AudioUnitPropertyID =
    kAudioUnitOfflineProperty_OutputSize;

pub const kAudioUnitSRCAlgorithm_Polyphase: u32 = 0x706f6c79;
pub const kAudioUnitSRCAlgorithm_MediumQuality: u32 = 0x63737263;

#[cfg(feature = "AUComponent")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioUnitMIDIControlMapping {
    pub midiNRPN: u16,
    pub midiControl: u8,
    pub scope: u8,
    pub element: AudioUnitElement,
    pub parameter: AudioUnitParameterID,
}

#[cfg(feature = "AUComponent")]
unsafe impl Encode for AudioUnitMIDIControlMapping {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitMIDIControlMapping",
        &[
            <u16>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <AudioUnitElement>::ENCODING,
            <AudioUnitParameterID>::ENCODING,
        ],
    );
}

#[cfg(feature = "AUComponent")]
unsafe impl RefEncode for AudioUnitMIDIControlMapping {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioUnitParameterValueName {
    pub inParamID: AudioUnitParameterID,
    pub inValue: NonNull<f32>,
    pub outName: NonNull<CFString>,
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl Encode for AudioUnitParameterValueName {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioUnitParameterValueName",
        &[
            <AudioUnitParameterID>::ENCODING,
            <NonNull<f32>>::ENCODING,
            <NonNull<CFString>>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "AUComponent", feature = "objc2-core-foundation"))]
unsafe impl RefEncode for AudioUnitParameterValueName {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_GroupOutputBus: AudioUnitPropertyID = 1002;
#[cfg(feature = "AUComponent")]
pub const kMusicDeviceProperty_SoundBankFSSpec: AudioUnitPropertyID = 1003;
#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_PannerMode: AudioUnitPropertyID = 3008;

#[cfg(feature = "AUComponent")]
pub const kAudioUnitProperty_SpeakerConfiguration: AudioUnitPropertyID = 3001;

pub const kSpeakerConfiguration_HeadPhones: c_uint = 0;
pub const kSpeakerConfiguration_Stereo: c_uint = 1;
pub const kSpeakerConfiguration_Quad: c_uint = 2;
pub const kSpeakerConfiguration_5_0: c_uint = 3;
pub const kSpeakerConfiguration_5_1: c_uint = kSpeakerConfiguration_5_0;

#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AUSamplerBankPresetData {
    pub bankURL: NonNull<CFURL>,
    pub bankMSB: u8,
    pub bankLSB: u8,
    pub presetID: u8,
    pub reserved: u8,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AUSamplerBankPresetData {
    const ENCODING: Encoding = Encoding::Struct(
        "AUSamplerBankPresetData",
        &[
            <NonNull<CFURL>>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AUSamplerBankPresetData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "AUComponent")]
pub const kAUSamplerProperty_LoadPresetFromBank: AudioUnitPropertyID = 4100;
#[cfg(feature = "AUComponent")]
pub const kAUSamplerProperty_BankAndPreset: AudioUnitPropertyID =
    kAUSamplerProperty_LoadPresetFromBank;
