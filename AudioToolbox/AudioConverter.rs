//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;

use crate::*;

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueAudioConverter {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaqueAudioConverter {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("OpaqueAudioConverter", &[]));
}

/// A reference to an audio converter object.
/// A reference to an AudioConverter object.
pub type AudioConverterRef = *mut OpaqueAudioConverter;

/// An audio converter property identifier.
pub type AudioConverterPropertyID = u32;

/// A `UInt32` value that indicates the size, in bytes, of the smallest buffer of input data that can be supplied via the audio converter input callback or as the input to the [`AudioConverterConvertBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterconvertbuffer(_:_:_:_:_:)) function.
pub const kAudioConverterPropertyMinimumInputBufferSize: AudioConverterPropertyID = 0x6d696273;
/// A `UInt32` value that indicates the size, in bytes, of the smallest buffer of output data that can be supplied to AudioConverterFillComplexBuffer or as the output to AudioConverterConvertBuffer
pub const kAudioConverterPropertyMinimumOutputBufferSize: AudioConverterPropertyID = 0x6d6f6273;
/// A `UInt32` value that indicates the size, in bytes, of the largest single packet of data in the input format. This is mostly useful for variable bit rate compressed data (decoders).
pub const kAudioConverterPropertyMaximumInputPacketSize: AudioConverterPropertyID = 0x78697073;
/// A `UInt32` value that indicates the size, in bytes, of the largest single packet of data in the output format. This is mostly useful for variable bit rate compressed data (encoders).
pub const kAudioConverterPropertyMaximumOutputPacketSize: AudioConverterPropertyID = 0x786f7073;
/// A `UInt32` value that on input holds a size, in bytes, that is desired for the output data. On output, it holds the size, in bytes, of the input buffer required to generate that much output data. Note that some converters cannot do this calculation.
pub const kAudioConverterPropertyCalculateInputBufferSize: AudioConverterPropertyID = 0x63696273;
/// A `UInt32` value that on input holds a size, in bytes, that is desired for the input data. On output, it holds the size, in bytes, of the output buffer required to hold the output data to be generated. Some converters cannot do this calculation.
pub const kAudioConverterPropertyCalculateOutputBufferSize: AudioConverterPropertyID = 0x636f6273;
/// The value of this property varies from format to format and is considered private to the format. It is treated as a buffer of untyped data.
pub const kAudioConverterPropertyInputCodecParameters: AudioConverterPropertyID = 0x69636470;
/// The value of this property varies from format to format and is considered private to the format. It is treated as a buffer of untyped data.
pub const kAudioConverterPropertyOutputCodecParameters: AudioConverterPropertyID = 0x6f636470;
/// The sample rate conversion algorithm.
///
/// ## Discussion
///
/// The sample rate conversion algorithm, specified using a constant from [Sample Rate Conversion Complexity Identifiers](https://developer.apple.com/documentation/audiotoolbox/1559923-sample-rate-conversion-complexit).
///
///
pub const kAudioConverterSampleRateConverterComplexity: AudioConverterPropertyID = 0x73726361;
/// The rendering quality of the sample rate converter.
///
/// ## Discussion
///
/// The rendering quality of the sample rate converter, specified using a constant from [Sample Rate Conversion Quality Identifiers](https://developer.apple.com/documentation/audiotoolbox/1559924-sample-rate-conversion-quality-i). See also [`kAudioConverterSampleRateConverterComplexity`](https://developer.apple.com/documentation/audiotoolbox/kaudioconvertersamplerateconvertercomplexity).
///
///
pub const kAudioConverterSampleRateConverterQuality: AudioConverterPropertyID = 0x73726371;
/// A `Float64` value equal to `0.0`.
pub const kAudioConverterSampleRateConverterInitialPhase: AudioConverterPropertyID = 0x73726370;
/// The rendering quality of a codec. A `UInt32` value.
pub const kAudioConverterCodecQuality: AudioConverterPropertyID = 0x63647175;
/// The priming method, usually for sample-rate conversion.
///
/// ## Discussion
///
/// See [`AudioConverterPrimeInfo`](https://developer.apple.com/documentation/audiotoolbox/audioconverterprimeinfo) and [Converter Priming Constants](https://developer.apple.com/documentation/audiotoolbox/1559927-converter-priming-constants).
///
///
pub const kAudioConverterPrimeMethod: AudioConverterPropertyID = 0x70726d6d;
/// An [`AudioConverterPrimeInfo`](https://developer.apple.com/documentation/audiotoolbox/audioconverterprimeinfo) structure.
pub const kAudioConverterPrimeInfo: AudioConverterPropertyID = 0x7072696d;
/// An array of `SInt32` values that specify an input-to-output channel mapping.
///
/// ## Discussion
///
/// The size of the array is the number of output channels. Each element specifies, using a 0-based index, which input channel’s data is routed to that output channel. A value of `-1` indicates that no input channel is to be routed to that output channel.
///
/// The default behavior is as follows. Given that `In` = the number of input channels and `Out` = the number of output channels. When `In` > `Out`, the first `Out` inputs are routed to the first `Out` outputs, and the remaining inputs are discarded.  When `Out` > `In`, the first `In` inputs are routed to the first `Out` outputs, and the remaining outputs are zeroed.
///
///
pub const kAudioConverterChannelMap: AudioConverterPropertyID = 0x63686d70;
/// A `void*` value that points to memory set up by the caller. This property is required by some audio data formats in order to decompress the input data.
pub const kAudioConverterDecompressionMagicCookie: AudioConverterPropertyID = 0x646d6763;
/// A `void*` value that points to memory set up by the caller. This property is returned by the converter so that your application may store it along with the output data. This property can then be passed back to the converter for decompression at a later time.
pub const kAudioConverterCompressionMagicCookie: AudioConverterPropertyID = 0x636d6763;
/// A `UInt32` value containing the number of bits per second to aim for when encoding data. Some decoders also allow you to query this property to discover the bit rate.
pub const kAudioConverterEncodeBitRate: AudioConverterPropertyID = 0x62726174;
/// A `Float64` value that specifies an output sample rate.
///
/// ## Discussion
///
/// For encoding audio converters a) with a specified output sample rate of `0` and b) that are capable of performing sample rate conversion on the input data, this property provides a way to set output sample rate.
///
///
pub const kAudioConverterEncodeAdjustableSampleRate: AudioConverterPropertyID = 0x616a7372;
/// An `AudioChannelLayout` structure that specifies an audio converter’s input channel layout.
pub const kAudioConverterInputChannelLayout: AudioConverterPropertyID = 0x69636c20;
/// An `AudioChannelLayout` structure that specifies an audio converter’s output channel layout.
pub const kAudioConverterOutputChannelLayout: AudioConverterPropertyID = 0x6f636c20;
/// An array of `AudioValueRange` structures that describes applicable bit rates based on current settings.
pub const kAudioConverterApplicableEncodeBitRates: AudioConverterPropertyID = 0x61656272;
/// An array of `AudioValueRange` structures that describes the available bit rates based on the input format. You can determine the available bit rates using Audio Format Services.
pub const kAudioConverterAvailableEncodeBitRates: AudioConverterPropertyID = 0x76656272;
/// An array of `AudioValueRange` structures that describes applicable sample rates based on current settings.
pub const kAudioConverterApplicableEncodeSampleRates: AudioConverterPropertyID = 0x61657372;
/// An array of `AudioValueRange` structures that describes the available sample rates based on the input format. You can determine the available sample rates using Audio Format Services.
pub const kAudioConverterAvailableEncodeSampleRates: AudioConverterPropertyID = 0x76657372;
/// An array of `AudioChannelLayoutTag` values for the format and number of channels specified in the encoder’s input format.
pub const kAudioConverterAvailableEncodeChannelLayoutTags: AudioConverterPropertyID = 0x6165636c;
/// The current, completely specified output `AudioStreamBasicDescription` structure.
pub const kAudioConverterCurrentOutputStreamDescription: AudioConverterPropertyID = 0x61636f64;
/// The current, completely specified input `AudioStreamBasicDescription` structure.
pub const kAudioConverterCurrentInputStreamDescription: AudioConverterPropertyID = 0x61636964;
/// An array (of type `CFArray`) of property settings for converters.
pub const kAudioConverterPropertySettings: AudioConverterPropertyID = 0x61637073;
/// A `UInt32` value that designates the source bit depth to preserve.
///
/// ## Discussion
///
/// This is a hint used by some encoders, such as the Apple lossless encoder. The converter usually tries to preserve as many bits as possible. A lossless encoder does poorly if more bits are supplied than are desired in the output.
///
///
pub const kAudioConverterPropertyBitDepthHint: AudioConverterPropertyID = 0x61636264;
/// An array of `AudioFormatListItem` structures that describes the set of data formats produced by the encoder end of an audio converter.
///
/// ## Discussion
///
/// If the `ioPropertyDataSize` parameter of the [`AudioConverterGetProperty`](https://developer.apple.com/documentation/audiotoolbox/audioconvertergetproperty(_:_:_:_:)) function indicates that the size of the data in the `outPropertyData` parameter is `sizeof (AudioFormatListItem)`, then only the best format is returned. This property may be used, for example, to discover all the data formats produced by the AAC High Efficiency version 2 encoder (specified by the `kAudioFormatMPEG4AAC_HE_V2` constant).
///
///
pub const kAudioConverterPropertyFormatList: AudioConverterPropertyID = 0x666c7374;
pub const kAudioConverterPropertyPerformDownmix: AudioConverterPropertyID = 0x646d6978;
pub const kAudioConverterPropertyChannelMixMap: AudioConverterPropertyID = 0x6d6d6170;

pub const kAudioConverterPropertyDithering: AudioConverterPropertyID = 0x64697468;
pub const kAudioConverterPropertyDitherBitDepth: AudioConverterPropertyID = 0x64626974;

pub const kDitherAlgorithm_TPDF: u32 = 1;
pub const kDitherAlgorithm_NoiseShaping: u32 = 2;

/// Specifies maximum sample-rate conversion quality.
pub const kAudioConverterQuality_Max: u32 = 0x7F;
/// Specifies high sample rate conversion quality.
pub const kAudioConverterQuality_High: u32 = 0x60;
/// Specifies medium sample rate conversion quality.
pub const kAudioConverterQuality_Medium: u32 = 0x40;
/// Specifies low sample rate conversion quality.
pub const kAudioConverterQuality_Low: u32 = 0x20;
/// Specifies minimum sample rate conversion quality.
pub const kAudioConverterQuality_Min: u32 = 0;

/// Specifies linear interpolation for sample rate conversion. This provides the lowest quality and is, computationally, the least expensive option.
pub const kAudioConverterSampleRateConverterComplexity_Linear: u32 = 0x6c696e65;
/// Specifies the normal-complexity sample rate conversion algorithm. This is the default value.
pub const kAudioConverterSampleRateConverterComplexity_Normal: u32 = 0x6e6f726d;
/// Specifies a mastering-quality sample rate conversion algorithm. This provides the highest quality and is, computationally, the most expensive option.
pub const kAudioConverterSampleRateConverterComplexity_Mastering: u32 = 0x62617473;
pub const kAudioConverterSampleRateConverterComplexity_MinimumPhase: u32 = 0x6d696e70;

/// Prime with `leading` + `trailing` input frames.
pub const kConverterPrimeMethod_Pre: u32 = 0;
/// Prime with `trailing` frames only, for zero latency. Leading frames are assumed to be silence.
pub const kConverterPrimeMethod_Normal: u32 = 1;
/// Acts in “latency” mode. Leading and trailing frames are both assumed to be silence.
pub const kConverterPrimeMethod_None: u32 = 2;

/// Specifies priming information for an audio converter.
///
/// ## Overview
///
/// Some audio data format conversions, particularly those involving sample-rate conversion, yield higher quality output when leading or trailing frames are available to the converter. The appropriate number of these so-called _priming frames_ depends on the input audio data format.
///
/// You specify leading or trailing frames in the `leadingFrames` and `trailingFrames` fields of an `AudioConverterPrimeInfo` structure. You then configure your audio converter by calling the [`AudioConverterSetProperty`](https://developer.apple.com/documentation/audiotoolbox/audioconvertersetproperty(_:_:_:_:)) function for the [`kAudioConverterPrimeInfo`](https://developer.apple.com/documentation/audiotoolbox/kaudioconverterprimeinfo) property, specifying this structure as the property value. You also indicate to the converter which priming option to use by setting the [`kAudioConverterPrimeMethod`](https://developer.apple.com/documentation/audiotoolbox/kaudioconverterprimemethod) property.
///
/// When you configure an audio converter by specifying leading or trailing frames, you alter the behavior of the [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) function. The very first call to that function, or the first call after calling [`AudioConverterReset`](https://developer.apple.com/documentation/audiotoolbox/audioconverterreset(_:)), results in a request for additional input frames when the converter object invokes your [`AudioConverterComplexInputDataProc`](https://developer.apple.com/documentation/audiotoolbox/audioconvertercomplexinputdataproc) callback. The number of priming frames requested depends on the priming option you specify, as shown in below.
///
/// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Priming option" }] }], [Paragraph { inline_content: [Text { text: "Number of priming frames (approximate)" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kConverterPrimeMethod_Pre" }] }], [Paragraph { inline_content: [CodeVoice { code: "leadingFrames" }, Text { text: " + " }, CodeVoice { code: "trailingFrames" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kConverterPrimeMethod_Normal" }] }], [Paragraph { inline_content: [CodeVoice { code: "trailingFrames" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kConverterPrimeMethod_None" }] }], [Paragraph { inline_content: [CodeVoice { code: "0" }] }]]], alignments: None, metadata: None })
/// The default priming option is that specified by the `kConverterPrimeMethod_Normal` constant. This option requires no preseeking of the input stream. It generates `trailingFrames` of latency at output.
///
/// The `kConverterPrimeMethod_Pre` priming option results in a first invocation of your callback that asks for approximately `leadingFrames` + `trailingFrames` priming frames. Latency at output will correspond, approximately, to this duration.
///
/// The `kConverterPrimeMethod_None` priming constant is especially useful in real-time applications that process live input. This option minimizes output latency, but is appropriate only for formats that do not require priming frames.
///
/// In a digital audio workstation, the `kConverterPrimeMethod_Pre` option may be preferable for real-time applications. This is because your application may be able to provide priming frames by preloading them from disk or memory, avoiding latency while still supporting audio formats that require priming.
///
///
/// Specifies priming information.
///
/// When using AudioConverterFillComplexBuffer() (either a single call or a series of calls), some
/// conversions, particularly involving sample-rate conversion, ideally require a certain
/// number of input frames previous to the normal start input frame and beyond the end of
/// the last expected input frame in order to yield high-quality results.
///
/// These are expressed in the leadingFrames and trailingFrames members of the structure.
///
/// The very first call to AudioConverterFillComplexBuffer(), or first call after
/// AudioConverterReset(), will request additional input frames beyond those normally
/// expected in the input proc callback to fulfill this first AudioConverterFillComplexBuffer()
/// request. The number of additional frames requested, depending on the prime method, will
/// be approximately:
///
/// Prime method                  | Additional frames
/// ------------------------------|----------------------
/// kConverterPrimeMethod_Pre     | leadingFrames + trailingFrames
/// kConverterPrimeMethod_Normal  | trailingFrames
/// kConverterPrimeMethod_None    | 0
///
/// Thus, in effect, the first input proc callback(s) may provide not only the leading
/// frames, but also may "read ahead" by an additional number of trailing frames depending
/// on the prime method.
///
/// kConverterPrimeMethod_None is useful in a real-time application processing live input,
/// in which case trailingFrames (relative to input sample rate) of through latency will be
/// seen at the beginning of the output of the AudioConverter.  In other real-time
/// applications such as DAW systems, it may be possible to provide these initial extra
/// audio frames since they are stored on disk or in memory somewhere and
/// kConverterPrimeMethod_Pre may be preferable.  The default method is
/// kConverterPrimeMethod_Normal, which requires no pre-seeking of the input stream and
/// generates no latency at the output.
///
///
/// Specifies the number of leading (previous) input frames, relative to the normal/desired
/// start input frame, required by the converter to perform a high quality conversion. If
/// using kConverterPrimeMethod_Pre, the client should "pre-seek" the input stream provided
/// through the input proc by leadingFrames. If no frames are available previous to the
/// desired input start frame (because, for example, the desired start frame is at the very
/// beginning of available audio), then provide "leadingFrames" worth of initial zero frames
/// in the input proc.  Do not "pre-seek" in the default case of
/// kConverterPrimeMethod_Normal or when using kConverterPrimeMethod_None.
///
///
/// Specifies the number of trailing input frames (past the normal/expected end input frame)
/// required by the converter to perform a high quality conversion.  The client should be
/// prepared to provide this number of additional input frames except when using
/// kConverterPrimeMethod_None. If no more frames of input are available in the input stream
/// (because, for example, the desired end frame is at the end of an audio file), then zero
/// (silent) trailing frames will be synthesized for the client.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioConverterPrimeInfo {
    pub leadingFrames: u32,
    pub trailingFrames: u32,
}

unsafe impl Encode for AudioConverterPrimeInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioConverterPrimeInfo",
        &[<u32>::ENCODING, <u32>::ENCODING],
    );
}

unsafe impl RefEncode for AudioConverterPrimeInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This is an option for AudioConverterNewWithOptions which removes unnecessary
/// buffering, both for input and internally to the converter, saving memory
/// at the cost of reduced format support and usage restrictions:
///
/// - Input and output formats must be constant bit-rate, non-zero bytes per packet
/// (e.g. linear PCM, a-law, etc.) with the same sample rate and frames per packet.
/// - AudioConverterFillBuffer cannot be used.
/// - AudioConverterFillComplexBuffer cannot be used.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioConverterOptions(pub u32);
bitflags::bitflags! {
    impl AudioConverterOptions: u32 {
        #[doc(alias = "kAudioConverterOption_Unbuffered")]
        const Unbuffered = 1<<16;
    }
}

unsafe impl Encode for AudioConverterOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for AudioConverterOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioConverterErr_FormatNotSupported: OSStatus = 0x666d743f;
pub const kAudioConverterErr_OperationNotSupported: OSStatus = 0x6F703F3F;
pub const kAudioConverterErr_PropertyNotSupported: OSStatus = 0x70726f70;
pub const kAudioConverterErr_InvalidInputSize: OSStatus = 0x696e737a;
/// The byte size is not an integer multiple of the frame size.
pub const kAudioConverterErr_InvalidOutputSize: OSStatus = 0x6f74737a;
pub const kAudioConverterErr_UnspecifiedError: OSStatus = 0x77686174;
pub const kAudioConverterErr_BadPropertySizeError: OSStatus = 0x2173697a;
pub const kAudioConverterErr_RequiresPacketDescriptionsError: OSStatus = 0x21706b64;
pub const kAudioConverterErr_InputSampleRateOutOfRange: OSStatus = 0x21697372;
pub const kAudioConverterErr_OutputSampleRateOutOfRange: OSStatus = 0x216f7372;

extern "C-unwind" {
    /// Optimizes the subsequent creation of audio converters by the current process.
    ///
    /// This function performs its work asynchronously.  The optional completion block,
    /// if provided, is executed once preparation is complete.
    /// Although a best effort is made to ensure future audio converters will be created quickly,
    /// there are no guarantees.
    ///
    ///
    /// Parameter `inFlags`: Reserved for future use.  Pass 0.
    ///
    /// Parameter `ioReserved`: Reserved for future use.  Pass NULL.
    ///
    /// Parameter `inCompletionBlock`: Optional block to execute once preparation is complete.  May be NULL.
    /// The block is given the OSStatus result of the preparation.
    ///
    /// # Safety
    ///
    /// `io_reserved` must be a valid pointer or null.
    #[cfg(feature = "block2")]
    pub fn AudioConverterPrepare(
        in_flags: u32,
        io_reserved: *mut c_void,
        in_completion_block: Option<&block2::DynBlock<dyn Fn(OSStatus)>>,
    );
}

extern "C-unwind" {
    /// Creates a new audio converter object based on specified audio formats.
    ///
    /// Parameters:
    /// - inSourceFormat: The format of the source audio to be converted.
    ///
    /// - inDestinationFormat: The destination format to which the audio is to be converted.
    ///
    /// - outAudioConverter: On return, a new audio converter object.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For a pair of linear PCM formats, the following conversions are supported:
    ///
    /// - Addition and removal of channels, when the input and output format `mChannelsPerFrame` fields do not match. Channels may also be reordered and removed using the `kAudioConverterChannelMap` property.
    ///
    /// - Sample rate conversion.
    ///
    /// - Interleaving and deinterleaving, when the input and output format `(mFormatFlags & kAudioFormatFlagIsNonInterleaved)` values do not match.
    ///
    /// - Conversion between any pair of the following formats:
    ///
    /// - 8-bit integer, signed or unsigned.
    ///
    /// - 16-, 24-, or 32-bit integer, big- or little-endian. Other integral bit depths, if high-aligned and nonpacked, are also supported
    ///
    /// - 32- and 64-bit floating point, big- or little-endian.
    ///
    /// Encoding and decoding between linear PCM and compressed formats is supported. Functions in Audio Format Services (`AudioToolbox/AudioFormat.h`) return information about the formats supported on a system. When using a codec, you can use any supported PCM format. The converter object performs any necessary additional conversion between your PCM format and the one created or consumed by the codec.
    ///
    ///
    /// Create a new AudioConverter.
    ///
    ///
    /// Parameter `inSourceFormat`: The format of the source audio to be converted.
    ///
    /// Parameter `inDestinationFormat`: The destination format to which the audio is to be converted.
    ///
    /// Parameter `outAudioConverter`: On successful return, points to a new AudioConverter instance.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// For a pair of linear PCM formats, the following conversions
    /// are supported:
    ///
    /// <ul>
    /// <li>
    /// addition and removal of channels, when the stream descriptions'
    /// mChannelsPerFrame does not match. Channels may also be reordered and removed
    /// using the kAudioConverterChannelMap property.
    /// </li>
    /// <li>
    /// sample rate conversion
    /// </li>
    /// <li>
    /// interleaving/deinterleaving, when the stream descriptions' (mFormatFlags
    /// &
    /// kAudioFormatFlagIsNonInterleaved) does not match.
    /// </li>
    /// <li>
    /// conversion between any pair of the following formats:
    /// </li>
    /// <ul>
    /// <li>
    /// 8 bit integer, signed or unsigned
    /// </li>
    /// <li>
    /// 16, 24, or 32-bit integer, big- or little-endian. Other integral
    /// bit depths, if high-aligned and non-packed, are also supported
    /// </li>
    /// <li>
    /// 32 and 64-bit float, big- or little-endian.
    /// </li>
    /// </ul>
    /// </ul>
    ///
    /// Also, encoding and decoding between linear PCM and compressed formats is
    /// supported. Functions in AudioToolbox/AudioFormat.h return information about the
    /// supported formats. When using a codec, you can use any supported PCM format (as
    /// above); the converter will perform any necessary additional conversion between
    /// your PCM format and the one created or consumed by the codec.
    ///
    /// Note that AudioConverter may change the formats to correct any
    /// inconsistent or erroneous values.  The actual formats expected and used
    /// by the newly created AudioConverter can be obtained by getting the
    /// properties `kAudioConverterCurrentInputStreamDescription` and
    /// `kAudioConverterCurrentOutputStreamDescription` from it.
    ///
    /// # Safety
    ///
    /// - `in_source_format` must be a valid pointer.
    /// - `in_destination_format` must be a valid pointer.
    /// - `out_audio_converter` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterNew(
        in_source_format: NonNull<AudioStreamBasicDescription>,
        in_destination_format: NonNull<AudioStreamBasicDescription>,
        out_audio_converter: NonNull<AudioConverterRef>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a new audio converter object using a specified codec.
    ///
    /// Parameters:
    /// - inSourceFormat: The format of the source audio to be converted.
    ///
    /// - inDestinationFormat: The destination format to which the audio is to be converted.
    ///
    /// - inNumberClassDescriptions: The number of class descriptions supplied in the `inClassDescriptions` parameter.
    ///
    /// - inClassDescriptions: A list of `AudioClassDescription` objects that specify the codec to use.
    ///
    /// - outAudioConverter: On return, a new audio converter object.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is identical to [`AudioConverterNew`](https://developer.apple.com/documentation/audiotoolbox/audioconverternew(_:_:_:)) function, except that your application may explicitly choose which codec to instantiate if there is more than one choice.
    ///
    ///
    /// Create a new AudioConverter using specific codecs.
    ///
    ///
    /// Parameter `inSourceFormat`: The format of the source audio to be converted.
    ///
    /// Parameter `inDestinationFormat`: The destination format to which the audio is to be converted.
    ///
    /// Parameter `inNumberClassDescriptions`: The number of class descriptions.
    ///
    /// Parameter `inClassDescriptions`: AudioClassDescriptions specifiying the codec to instantiate.
    ///
    /// Parameter `outAudioConverter`: On successful return, points to a new AudioConverter instance.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// This function is identical to AudioConverterNew(), except that the client may
    /// explicitly choose which codec to instantiate if there is more than one choice.
    ///
    /// # Safety
    ///
    /// - `in_source_format` must be a valid pointer.
    /// - `in_destination_format` must be a valid pointer.
    /// - `in_class_descriptions` must be a valid pointer.
    /// - `out_audio_converter` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterNewSpecific(
        in_source_format: NonNull<AudioStreamBasicDescription>,
        in_destination_format: NonNull<AudioStreamBasicDescription>,
        in_number_class_descriptions: u32,
        in_class_descriptions: NonNull<AudioClassDescription>,
        out_audio_converter: NonNull<AudioConverterRef>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Create a new AudioConverter with one or more options enabled.
    ///
    ///
    /// Parameter `inSourceFormat`: The format of the source audio to be converted.
    ///
    /// Parameter `inDestinationFormat`: The destination format to which the audio is to be converted.
    ///
    /// Parameter `inOptions`: Flags selecting one or more optional configurations for the AudioConverter.
    ///
    /// Parameter `outAudioConverter`: On successful return, points to a new AudioConverter instance.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// This is an alternative to AudioConverterNew which supports enabling
    /// one or more optional configurations for the new AudioConverter.
    ///
    /// # Safety
    ///
    /// - `in_source_format` must be a valid pointer.
    /// - `in_destination_format` must be a valid pointer.
    /// - `out_audio_converter` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterNewWithOptions(
        in_source_format: NonNull<AudioStreamBasicDescription>,
        in_destination_format: NonNull<AudioStreamBasicDescription>,
        in_options: AudioConverterOptions,
        out_audio_converter: NonNull<AudioConverterRef>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Disposes of an audio converter object.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter object to dispose of.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    ///
    /// Destroy an AudioConverter.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to dispose.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// # Safety
    ///
    /// `in_audio_converter` must be a valid pointer.
    pub fn AudioConverterDispose(in_audio_converter: AudioConverterRef) -> OSStatus;
}

extern "C-unwind" {
    /// Resets an audio converter object, clearing and flushing its buffers.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter object to reset.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Call this function after a discontinuity in the source audio stream being provided to the converter.
    ///
    ///
    /// Reset an AudioConverter
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to reset.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// Should be called whenever there is a discontinuity in the source audio stream
    /// being provided to the converter. This will flush any internal buffers in the
    /// converter.
    ///
    /// # Safety
    ///
    /// `in_audio_converter` must be a valid pointer.
    pub fn AudioConverterReset(in_audio_converter: AudioConverterRef) -> OSStatus;
}

extern "C-unwind" {
    /// Gets information about an audio converter property.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to get property information from.
    ///
    /// - inPropertyID: The property you want information about.
    ///
    /// - outSize: On output, the size of the property value in bytes. Can be `NULL` on output.
    ///
    /// - outWritable: On output, a Boolean value indicating whether the property value is writable (`true`) or not (`false`). Can be `NULL` on output.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    /// Returns information about an AudioConverter property.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to query.
    ///
    /// Parameter `inPropertyID`: The property to query.
    ///
    /// Parameter `outSize`: If non-null, on exit, the maximum size of the property value in bytes.
    ///
    /// Parameter `outWritable`: If non-null, on exit, indicates whether the property value is writable.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `out_size` must be a valid pointer or null.
    /// - `out_writable` must be a valid pointer or null.
    pub fn AudioConverterGetPropertyInfo(
        in_audio_converter: AudioConverterRef,
        in_property_id: AudioConverterPropertyID,
        out_size: *mut u32,
        out_writable: *mut Boolean,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Gets an audio converter property value.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to get a property value from.
    ///
    /// - inPropertyID: The property whose value you want.
    ///
    /// - ioPropertyDataSize: On input, the size of the memory pointed to by the `outPropertyData` parameter. On output, the size of the property value.
    ///
    /// - outPropertyData: On output, the property value you wanted to get.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Some Core Audio property values are C types and others are Core Foundation objects.
    ///
    /// If you call this function to retrieve a value that is a Core Foundation object, then this function—despite the use of “Get” in its name—duplicates the object. You are responsible for releasing the object, as described in [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029) in [Memory Management Programming Guide for Core Foundation](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/CFMemoryMgmt.html#//apple_ref/doc/uid/10000127i).
    ///
    ///
    /// Returns an AudioConverter property value.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to query.
    ///
    /// Parameter `inPropertyID`: The property to fetch.
    ///
    /// Parameter `ioPropertyDataSize`: On entry, the size of the memory pointed to by outPropertyData. On
    /// successful exit, the size of the property value.
    ///
    /// Parameter `outPropertyData`: On exit, the property value.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `io_property_data_size` must be a valid pointer.
    /// - `out_property_data` must be a valid pointer.
    pub fn AudioConverterGetProperty(
        in_audio_converter: AudioConverterRef,
        in_property_id: AudioConverterPropertyID,
        io_property_data_size: NonNull<u32>,
        out_property_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Sets the value of an audio converter object property.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to set a property value on.
    ///
    /// - inPropertyID: The property whose value you want to set.
    ///
    /// - inPropertyDataSize: The size, in bytes, of the property value.
    ///
    /// - inPropertyData: The value you want to apply to the specified property.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can employ the property mechanism, for example, to split a monaural input to both channels of a stereo output. You would do this as follows:
    ///
    /// ```objc
    ///  SInt32 channelMap[2] = {0, 0}; // array size should match the number of output channels
    ///  AudioConverterSetProperty (
    ///     theConverter,
    ///     kAudioConverterChannelMap,
    ///     sizeof(channelMap),
    ///     channelMap
    /// );
    /// ```
    ///
    ///
    /// Sets an AudioConverter property value.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to modify.
    ///
    /// Parameter `inPropertyID`: The property to set.
    ///
    /// Parameter `inPropertyDataSize`: The size in bytes of the property value.
    ///
    /// Parameter `inPropertyData`: Points to the new property value.
    ///
    /// Returns: An OSStatus result code.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_property_data` must be a valid pointer.
    pub fn AudioConverterSetProperty(
        in_audio_converter: AudioConverterRef,
        in_property_id: AudioConverterPropertyID,
        in_property_data_size: u32,
        in_property_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Converts audio data from one linear PCM format to another.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to use for format conversion.
    ///
    /// - inInputDataSize: The size, in bytes, of the audio data input buffer.
    ///
    /// - inInputData: The audio data to convert.
    ///
    /// - ioOutputDataSize: On input, the size, in bytes, of the buffer available for the converted data. On output, the number of bytes written to the output buffer (pointed to by the `outOutputData` parameter).
    ///
    /// - outOutputData: On output, the converted audio data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is for the special case of converting from one linear PCM format to another. This function cannot perform sample rate conversions and cannot be used for conversion to or from most compressed formats. To perform these types of conversion, use [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) instead.
    ///
    ///
    /// Converts data from an input buffer to an output buffer.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to use.
    ///
    /// Parameter `inInputDataSize`: The size of the buffer inInputData.
    ///
    /// Parameter `inInputData`: The input audio data buffer.
    ///
    /// Parameter `ioOutputDataSize`: On entry, the size of the buffer outOutputData. On exit, the number of bytes
    /// written to outOutputData.
    ///
    /// Parameter `outOutputData`: The output data buffer.
    ///
    /// Returns: Produces a buffer of output data from an AudioConverter, using the supplied
    /// input buffer.
    ///
    /// WARNING: this function will fail for any conversion where there is a
    /// variable relationship between the input and output data buffer sizes. This
    /// includes sample rate conversions and most compressed formats. In these cases,
    /// use AudioConverterFillComplexBuffer. Generally this function is only appropriate for
    /// PCM-to-PCM conversions where there is no sample rate conversion.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_input_data` must be a valid pointer.
    /// - `io_output_data_size` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    pub fn AudioConverterConvertBuffer(
        in_audio_converter: AudioConverterRef,
        in_input_data_size: u32,
        in_input_data: NonNull<c_void>,
        io_output_data_size: NonNull<u32>,
        out_output_data: NonNull<c_void>,
    ) -> OSStatus;
}

/// Supplies input data to the [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) function.
///
/// Parameters:
/// - inAudioConverter: The audio converter object that invoked this callback to obtain new data to convert.
///
/// - ioNumberDataPackets: On input, the minimum number of packets of input audio data the converter needs for its current conversion cycle. On output, the number of packets of audio data provided for conversion, or `0` if there is no more data to convert.
///
/// - ioData: On output, point the fields of the `AudioBufferList` structure, passed by this parameter, to the audio data you are providing to be converted.
///
/// - outDataPacketDescription: If not `NULL` on input,  the audio converter expects this callback to provide an array of `AudioStreamPacketDescription` structures on output, one for each packet of audio data you are providing in the `ioData` parameter.
///
/// - inUserData: On input, the custom application data you provided to the [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) function.
///
///
/// ## Discussion
///
/// If you named your callback function `MyAudioConverterComplexInputDataProc`, you would declare it like this:
///
/// ### Discussion
///
/// This callback supplies input audio data to the [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) function.
///
/// The audio converter object requests a minimum number of packets in the `ioNumberDataPackets` parameter. Your callback may provide one or more packets. If the number you provide is less than the minimum requested, the converter will invoke your callback again in the near future.
///
/// You write your callback to manipulate the fields of the `AudioBufferList` structure, in the `ioData` parameter, to point to one or more buffers of audio data. You use a single buffer for interleaved PCM data, or multiple buffers for non-interleaved PCM data. Your callback is responsible for not freeing or altering the buffer(s) until invoked again.
///
/// If your callback returns an error, it must return zero packets of data. Upon receiving zero packets, the `AudioConverterFillComplexBuffer` function delivers any pending output, stops producing further output, and returns the error code. You can use this mechanism when an input callback has temporarily run out of data but has not yet reached the end of the input audio stream.
///
///
/// Callback function for supplying input data to AudioConverterFillComplexBuffer.
///
///
/// Parameter `inAudioConverter`: The AudioConverter requesting input.
///
/// Parameter `ioNumberDataPackets`: On entry, the minimum number of packets of input audio data the converter
/// would like in order to fulfill its current FillBuffer request. On exit, the
/// number of packets of audio data actually being provided for input, or 0 if
/// there is no more input.
///
/// Parameter `ioData`: This points to an audio buffer list to be filled in by the callback to refer to the
/// buffer(s) provided by the callback.
/// On exit, the members of ioData should be set to point to the audio data
/// being provided for input.
///
/// Parameter `outDataPacketDescription`: If non-null, on exit, the callback is expected to fill this in with
/// an AudioStreamPacketDescription for each packet of input data being provided.
///
/// Parameter `inUserData`: The inInputDataProcUserData parameter passed to AudioConverterFillComplexBuffer().
///
/// Returns: An OSStatus result code.
///
/// This callback function supplies input to AudioConverterFillComplexBuffer.
///
/// The AudioConverter requests a minimum number of packets (*ioNumberDataPackets).
/// The callback may return one or more packets. If this is less than the minimum,
/// the callback will simply be called again in the near future. Note that ioNumberDataPackets counts
/// packets in terms of the converter's input format (not its output format).
/// Also note that the callback must provide a whole number of packets.
///
/// The callback may be asked to provide multiple input packets in a single call, even for compressed
/// formats.  The callback must update the number of packets pointed to by ioNumberDataPackets
/// to indicate the number of packets actually being provided, and if the packets require packet
/// descriptions, these must be filled into the array pointed to by outDataPacketDescription, one
/// packet description per packet.
///
/// The callback is given an audio buffer list pointed to by ioData.  This buffer list may refer to
/// existing buffers owned and allocated by the audio converter, in which case the callback may
/// use them and copy input audio data into them.  However, the buffer list may also be empty
/// (mDataByteSize == 0 and/or mData == NULL), in which case the callback must provide its own
/// buffers.  The callback manipulates the members of ioData to point to one or more buffers
/// of audio data (multiple buffers are used with non-interleaved PCM data). The
/// callback is responsible for not freeing or altering this buffer until it is called again.
///
/// For input data that varies from one packet to another in either size (bytes per packet)
/// or duration (frames per packet), such as when decoding compressed audio, the callback
/// should expect outDataPacketDescription to be non-null and point to array of packet descriptions,
/// which the callback must fill in, one for every packet provided by the callback.  Each packet must
/// have a valid packet description, regardless of whether or not these descriptions are different
/// from each other.  Packet descriptions are required even if there is only one packet.
///
/// If the callback returns an error, it must return zero packets of data.
/// AudioConverterFillComplexBuffer will stop producing output and return whatever
/// output has already been produced to its caller, along with the error code. This
/// mechanism can be used when an input proc has temporarily run out of data, but
/// has not yet reached end of stream.
#[cfg(feature = "objc2-core-audio-types")]
pub type AudioConverterComplexInputDataProc = Option<
    unsafe extern "C-unwind" fn(
        AudioConverterRef,
        NonNull<u32>,
        NonNull<AudioBufferList>,
        *mut *mut AudioStreamPacketDescription,
        *mut c_void,
    ) -> OSStatus,
>;

///
/// ## Discussion
///
/// Realtime-safe variant of AudioConverterComplexInputDataProc.
///
/// See the discussions of AudioConverterComplexInputDataProc and AudioConverterFillComplexBuffer.
///
///
/// Realtime-safe variant of AudioConverterComplexInputDataProc.
///
/// See the discussions of AudioConverterComplexInputDataProc and AudioConverterFillComplexBuffer.
#[cfg(feature = "objc2-core-audio-types")]
pub type AudioConverterComplexInputDataProcRealtimeSafe = Option<
    unsafe extern "C-unwind" fn(
        AudioConverterRef,
        NonNull<u32>,
        NonNull<AudioBufferList>,
        *mut *mut AudioStreamPacketDescription,
        *mut c_void,
    ) -> OSStatus,
>;

extern "C-unwind" {
    /// Converts audio data supplied by a callback function, supporting non-interleaved and packetized formats.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to use for format conversion.
    ///
    /// - inInputDataProc: A callback function that supplies audio data to convert. This callback is invoked repeatedly as the converter is ready for new input data.
    ///
    /// - inInputDataProcUserData: Custom data for use by your application when receiving a callback invocation.
    ///
    /// - ioOutputDataPacketSize: On input, the size of the output buffer (in the `outOutputData` parameter), expressed in number packets in the audio converter’s output format. On output, the number of packets of converted data that were written to the output buffer.
    ///
    /// - outOutputData: On output, the converted audio data.
    ///
    /// - outPacketDescription: On input, must point to a block of memory capable of holding the number of packet descriptions specified in the `ioOutputDataPacketSize` parameter. (See _Audio Format Services Reference_ for functions that let you determine whether an audio format uses packet descriptions). If not `NULL` on output and if the audio converter’s output format uses packet descriptions, then this parameter contains an array of packet descriptions.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this function for all audio data format conversions except for the special case of converting from one linear PCM format to another with no sample rate conversion.
    ///
    ///
    /// Converts data supplied by an input callback function, supporting non-interleaved
    /// and packetized formats.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to use.
    ///
    /// Parameter `inInputDataProc`: A callback function which supplies the input data.
    ///
    /// Parameter `inInputDataProcUserData`: A value for the use of the callback function.
    ///
    /// Parameter `ioOutputDataPacketSize`: On entry, the capacity of outOutputData expressed in packets in the
    /// converter's output format. On exit, the number of packets of converted
    /// data that were written to outOutputData.
    ///
    /// Parameter `outOutputData`: The converted output data is written to this buffer. On entry, the buffers'
    /// mDataByteSize fields (which must all be the same) reflect buffer capacity.
    /// On exit, mDataByteSize is set to the number of bytes written.
    ///
    /// Parameter `outPacketDescription`: If non-null, and the converter's output uses packet descriptions, then
    /// packet descriptions are written to this array. It must point to a memory
    /// block capable of holding *ioOutputDataPacketSize packet descriptions.
    /// (See AudioFormat.h for ways to determine whether an audio format
    /// uses packet descriptions).
    ///
    /// Returns: An OSStatus result code.
    ///
    /// Produces a buffer list of output data from an AudioConverter. The supplied input
    /// callback function is called whenever necessary.
    ///
    /// If the output format uses packet descriptions, such as most compressed formats where packets
    /// vary in size or duration, the caller is expected to provide a buffer for holding packet descriptions,
    /// pointed to by outPacketDescription.  The array must have the capacity to hold a packet description
    /// for each output packet that may be written.  A packet description array is expected even if only
    /// a single output packet is to be written.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_input_data_proc` must be implemented correctly.
    /// - `in_input_data_proc_user_data` must be a valid pointer or null.
    /// - `io_output_data_packet_size` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    /// - `out_packet_description` must be a valid pointer or null.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterFillComplexBuffer(
        in_audio_converter: AudioConverterRef,
        in_input_data_proc: AudioConverterComplexInputDataProc,
        in_input_data_proc_user_data: *mut c_void,
        io_output_data_packet_size: NonNull<u32>,
        out_output_data: NonNull<AudioBufferList>,
        out_packet_description: *mut AudioStreamPacketDescription,
    ) -> OSStatus;
}

extern "C-unwind" {
    ///
    /// ## Discussion
    ///
    /// Identical to AudioConverterFillComplexBuffer, with the addition of a realtime-safety guarantee.
    ///
    /// Conversions involving only PCM formats – interleaving, deinterleaving, channel count changes, sample rate conversions – are realtime-safe. Such conversions may use this API in order to obtain compiler checks involving the `CA_REALTIME_API` attributes.
    ///
    /// At runtime, this function returns `kAudioConverterErr_OperationNotSupported` if the conversion requires non-realtime-safe functionality.
    ///
    ///
    /// Identical to AudioConverterFillComplexBuffer, with the addition of a realtime-safety
    /// guarantee.
    ///
    /// Conversions involving only PCM formats -- interleaving, deinterleaving, channel count changes,
    /// sample rate conversions -- are realtime-safe. Such conversions may use this API in order to
    /// obtain compiler checks involving the `CA_REALTIME_API` attributes.
    ///
    /// At runtime, this function returns `kAudioConverterErr_OperationNotSupported` if the conversion
    /// requires non-realtime-safe functionality.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_input_data_proc` must be implemented correctly.
    /// - `in_input_data_proc_user_data` must be a valid pointer or null.
    /// - `io_output_data_packet_size` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    /// - `out_packet_description` must be a valid pointer or null.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterFillComplexBufferRealtimeSafe(
        in_audio_converter: AudioConverterRef,
        in_input_data_proc: AudioConverterComplexInputDataProcRealtimeSafe,
        in_input_data_proc_user_data: *mut c_void,
        io_output_data_packet_size: NonNull<u32>,
        out_output_data: NonNull<AudioBufferList>,
        out_packet_description: *mut AudioStreamPacketDescription,
    ) -> OSStatus;
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to use for format conversion.
    ///
    /// - inInputDataProc: A callback function that supplies audio data to convert. This callback is invoked repeatedly as the converter is ready for new input data.
    ///
    /// - inInputDataProcUserData: Custom data for use by your application when receiving a callback invocation.
    ///
    /// - ioOutputDataPacketSize: On input, the size of the output buffer (in the `outOutputData` parameter), expressed in number packets in the audio converter’s output format.  On output, the number of packets of converted data that were written to the output buffer.
    ///
    /// - outOutputData: The converted output data is written to this buffer. On entry, the buffers’ `mDataByteSize` fields (which must all be the same) reflect buffer capacity.  On exit, `mDataByteSize` is set to the number of bytes written.
    ///
    /// - outPacketDescriptions: If not `NULL`, and if the audio converter’s output format uses packet descriptions, this must point to a block of memory capable of holding the number of packet descriptions specified in the `ioOutputDataPacketSize` parameter.  (See _Audio Format Services Reference_ for functions that let you determine whether an audio format uses packet descriptions). If not `NULL` on output and if the audio converter’s output format uses packet descriptions, then this parameter contains an array of packet descriptions.
    ///
    /// - outPacketDependencies: Should point to a memory block capable of holding the number of packet dependency description structures specified in the `ioOutputDataPacketSize` parameter.  Must not be `NULL`.  This array will be filled out only by encoders that produce a format which has a non-zero value for `kAudioFormatProperty_FormatEmploysDependentPackets`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Converts audio data supplied by a callback function, supporting non-interleaved and packetized formats, and also supporting packet dependency descriptions.
    ///
    /// For output formats that use packet dependency descriptions, this must be used instead of AudioConverterFillComplexBuffer, which will return an error for such formats.
    ///
    ///
    /// Converts audio data supplied by a callback function, supporting non-interleaved and
    /// packetized formats, and also supporting packet dependency descriptions.
    ///
    /// For output formats that use packet dependency descriptions, this must be used instead of
    /// AudioConverterFillComplexBuffer, which will return an error for such formats.
    ///
    /// Parameter `inAudioConverter`: The audio converter to use for format conversion.
    ///
    /// Parameter `inInputDataProc`: A callback function that supplies audio data to convert.
    /// This callback is invoked repeatedly as the converter is ready for
    /// new input data.
    ///
    /// Parameter `inInputDataProcUserData`: Custom data for use by your application when receiving a
    /// callback invocation.
    ///
    /// Parameter `ioOutputDataPacketSize`: On input, the size of the output buffer (in the `outOutputData`
    /// parameter), expressed in number packets in the audio converter’s
    /// output format.  On output, the number of packets of converted data
    /// that were written to the output buffer.
    ///
    /// Parameter `outOutputData`: The converted output data is written to this buffer. On entry, the
    /// buffers' `mDataByteSize` fields (which must all be the same) reflect
    /// buffer capacity.  On exit, `mDataByteSize` is set to the number of
    /// bytes written.
    ///
    /// Parameter `outPacketDescriptions`: If not `NULL`, and if the audio converter's output format uses packet
    /// descriptions, this must point to a block of memory capable of holding
    /// the number of packet descriptions specified in the `ioOutputDataPacketSize`
    /// parameter.  (See _Audio Format Services Reference_ for functions that
    /// let you determine whether an audio format uses packet descriptions).
    /// If not `NULL` on output and if the audio converter's output format
    /// uses packet descriptions, then this parameter contains an array of
    /// packet descriptions.
    ///
    /// Parameter `outPacketDependencies`: Should point to a memory block capable of holding the number of
    /// packet dependency description structures specified in the
    /// `ioOutputDataPacketSize` parameter.  Must not be `NULL`.  This array
    /// will be filled out only by encoders that produce a format which has a
    /// non-zero value for `kAudioFormatProperty_FormatEmploysDependentPackets`.
    ///
    /// Returns: A result code.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_input_data_proc` must be implemented correctly.
    /// - `in_input_data_proc_user_data` must be a valid pointer or null.
    /// - `io_output_data_packet_size` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    /// - `out_packet_descriptions` must be a valid pointer or null.
    /// - `out_packet_dependencies` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterFillComplexBufferWithPacketDependencies(
        in_audio_converter: AudioConverterRef,
        in_input_data_proc: AudioConverterComplexInputDataProc,
        in_input_data_proc_user_data: *mut c_void,
        io_output_data_packet_size: NonNull<u32>,
        out_output_data: NonNull<AudioBufferList>,
        out_packet_descriptions: *mut AudioStreamPacketDescription,
        out_packet_dependencies: NonNull<AudioStreamPacketDependencyDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Converts audio data from one linear PCM format to another, where both use the same sample rate.
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to use for the format conversion.
    ///
    /// - inNumberPCMFrames: The number of linear PCM frames to convert.
    ///
    /// - inInputData: The source audio buffer list.
    ///
    /// - outOutputData: The destination audio buffer list.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is appropriate for linear PCM-to-linear PCM audio data format conversion where there is no sample rate conversion.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This function fails for conversions where there is a variation between the input and output data buffer sizes. This includes sample rate conversions and conversions involving most compressed formats. In these cases, instead use the [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) function.
    ///
    ///
    ///
    /// </div>
    ///
    /// Converts PCM data from an input buffer list to an output buffer list.
    ///
    ///
    /// Parameter `inAudioConverter`: The AudioConverter to use.
    ///
    /// Parameter `inNumberPCMFrames`: The number of PCM frames to convert.
    ///
    /// Parameter `inInputData`: The source audio buffer list.
    ///
    /// Parameter `outOutputData`: The converted output data is written to this buffer list.
    ///
    /// Returns: An OSStatus result code.
    ///
    ///
    /// Warning: This function will fail for any conversion where there is a
    /// variable relationship between the input and output data buffer sizes. This
    /// includes sample rate conversions and most compressed formats. In these cases,
    /// use AudioConverterFillComplexBuffer. Generally this function is only appropriate for
    /// PCM-to-PCM conversions where there is no sample rate conversion.
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_input_data` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioConverterConvertComplexBuffer(
        in_audio_converter: AudioConverterRef,
        in_number_pcm_frames: u32,
        in_input_data: NonNull<AudioBufferList>,
        out_output_data: NonNull<AudioBufferList>,
    ) -> OSStatus;
}

/// Deprecated. The audio converter input callback may be passed any number of packets of data. If fewer are packets are returned than required, then the input proc is called again. If more packets are passed than required, they remain in the client’s buffer and are consumed as needed.
pub const kAudioConverterPropertyMaximumInputBufferSize: AudioConverterPropertyID = 0x78696273;
/// A value that indicates the sample rate conversion algorithm.
///
/// ## Discussion
///
/// This value is deprecated. Use [`kAudioConverterSampleRateConverterComplexity`](https://developer.apple.com/documentation/audiotoolbox/kaudioconvertersamplerateconvertercomplexity) instead.
///
///
pub const kAudioConverterSampleRateConverterAlgorithm: AudioConverterPropertyID = 0x73726369;

/// Deprecated. Use [`AudioConverterFillComplexBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) instead.
///
/// ## Discussion
///
/// If you named your callback function `MyAudioConverterInputDataProc`, you would declare it like this:
///
/// ### Discussion
///
/// This deprecated callback supplies input data to the [`AudioConverterFillBuffer`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillbuffer) function. Use [`AudioConverterComplexInputDataProc`](https://developer.apple.com/documentation/audiotoolbox/audioconvertercomplexinputdataproc) instead.
///
///
/// Callback function for supplying input data to AudioConverterFillBuffer.
///
///
/// Parameter `inAudioConverter`: The AudioConverter requesting input.
///
/// Parameter `ioDataSize`: On entry, the minimum number of bytes of audio data the converter
/// would like in order to fulfill its current FillBuffer request.
/// On exit, the number of bytes of audio data actually being provided
/// for input, or 0 if there is no more input.
///
/// Parameter `outData`: On exit, *outData should point to the audio data being provided
/// for input.
///
/// Parameter `inUserData`: The inInputDataProcUserData parameter passed to AudioConverterFillBuffer().
///
/// Returns: An OSStatus result code.
///
/// This callback function supplies input to AudioConverterFillBuffer.
///
/// The AudioConverter requests a minimum amount of data (*ioDataSize). The callback
/// may return any amount of data. If it is less than than the minimum, the callback
/// will simply be called again in the near future.
///
/// The callback supplies a pointer to a buffer of audio data. The callback is
/// responsible for not freeing or altering this buffer until it is called again.
///
/// If the callback returns an error, it must return zero bytes of data.
/// AudioConverterFillBuffer will stop producing output and return whatever output
/// has already been produced to its caller, along with the error code. This
/// mechanism can be used when an input proc has temporarily run out of data, but
/// has not yet reached end of stream.
pub type AudioConverterInputDataProc = Option<
    unsafe extern "C-unwind" fn(
        AudioConverterRef,
        NonNull<u32>,
        NonNull<NonNull<c_void>>,
        *mut c_void,
    ) -> OSStatus,
>;

extern "C-unwind" {
    ///
    /// Parameters:
    /// - inAudioConverter: The audio converter to use for format conversion.
    ///
    /// - inInputDataProc: A callback function that supplies audio data to convert. This callback is invoked repeatedly as the converter is ready for new input data.
    ///
    /// - inInputDataProcUserData: Custom data for use by your application when receiving a callback invocation.
    ///
    /// - ioOutputDataSize: On input, the size, in bytes, of the buffer available for the converted data. On output, the number of bytes written to the output buffer (pointed to by the `outOutputData` parameter).
    ///
    /// - outOutputData: On output, the converted audio data.
    ///
    ///
    /// ## Return Value
    ///
    /// A  result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Converts audio data supplied by a callback function.
    ///
    /// ### Special Considerations
    ///
    /// This function is deprecated. Use the [`AudioConverterFillComplexBuffer(_:_:_:_:_:_:)`](https://developer.apple.com/documentation/audiotoolbox/audioconverterfillcomplexbuffer(_:_:_:_:_:_:)) function instead.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `in_audio_converter` must be a valid pointer.
    /// - `in_input_data_proc` must be implemented correctly.
    /// - `in_input_data_proc_user_data` must be a valid pointer or null.
    /// - `io_output_data_size` must be a valid pointer.
    /// - `out_output_data` must be a valid pointer.
    #[deprecated = "no longer supported"]
    pub fn AudioConverterFillBuffer(
        in_audio_converter: AudioConverterRef,
        in_input_data_proc: AudioConverterInputDataProc,
        in_input_data_proc_user_data: *mut c_void,
        io_output_data_size: NonNull<u32>,
        out_output_data: NonNull<c_void>,
    ) -> OSStatus;
}
