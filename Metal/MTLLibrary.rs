//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A convenience type alias for an autoreleased pipeline reflection instance.
#[cfg(feature = "MTLRenderPipeline")]
pub type MTLAutoreleasedRenderPipelineReflection = MTLRenderPipelineReflection;

/// A convenience type alias for an autoreleased compute pipeline reflection object.
#[cfg(feature = "MTLComputePipeline")]
pub type MTLAutoreleasedComputePipelineReflection = MTLComputePipelineReflection;

/// A completion handler signature a method calls when it finishes creating a Metal library.
///
/// Parameters:
/// - library: An [`MTLLibrary`](https://developer.apple.com/documentation/metal/mtllibrary) instance if the method successfully compiles the library without any errors; otherwise `nil`.
///
/// - error: An error instance if the compiler generates any warnings or errors; otherwise `nil`.
///
///
/// ## Discussion
///
/// Both `library` and `error` can be non-`nil` if the compiler successfully generates a library with warnings.
///
///
#[cfg(feature = "block2")]
pub type MTLNewLibraryCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut ProtocolObject<dyn MTLLibrary>, *mut NSError)>;

/// A completion handler signature a method calls when it finishes creating a render pipeline.
///
/// Parameters:
/// - renderPipelineState: An [`MTLRenderPipelineState`](https://developer.apple.com/documentation/metal/mtlrenderpipelinestate) instance if the method completes successfully; otherwise `nil`.
///
/// - error: If an error occurs, an error information instance; otherwise `nil`.
///
#[cfg(all(
    feature = "MTLAllocation",
    feature = "MTLRenderPipeline",
    feature = "block2"
))]
pub type MTLNewRenderPipelineStateCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut ProtocolObject<dyn MTLRenderPipelineState>, *mut NSError)>;

/// A completion handler signature a method calls when it finishes creating a render pipeline and reflection information.
///
/// Parameters:
/// - renderPipelineState: An [`MTLRenderPipelineState`](https://developer.apple.com/documentation/metal/mtlrenderpipelinestate) instance if the method successfully compiles the library without any errors; otherwise `nil`.
///
/// - reflection: An [`MTLRenderPipelineReflection`](https://developer.apple.com/documentation/metal/mtlrenderpipelinereflection) instance if the method completes successfully; otherwise `nil`.
///
/// - error: If an error occurs, an error information instance; otherwise `nil`.
///
#[cfg(all(
    feature = "MTLAllocation",
    feature = "MTLRenderPipeline",
    feature = "block2"
))]
pub type MTLNewRenderPipelineStateWithReflectionCompletionHandler = *mut block2::DynBlock<
    dyn Fn(
        *mut ProtocolObject<dyn MTLRenderPipelineState>,
        *mut MTLRenderPipelineReflection,
        *mut NSError,
    ),
>;

/// A completion handler signature a method calls when it finishes creating a compute pipeline.
///
/// Parameters:
/// - computePipelineState: An [`MTLComputePipelineState`](https://developer.apple.com/documentation/metal/mtlcomputepipelinestate) instance if the method completes successfully; otherwise `nil`.
///
/// - error: On return, if an error occurs, a pointer to an error information instance; otherwise `nil`.
///
#[cfg(all(
    feature = "MTLAllocation",
    feature = "MTLComputePipeline",
    feature = "block2"
))]
pub type MTLNewComputePipelineStateCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut ProtocolObject<dyn MTLComputePipelineState>, *mut NSError)>;

/// A completion handler signature a method calls when it finishes creating a compute pipeline and reflection information.
///
/// Parameters:
/// - computePipelineState: An [`MTLComputePipelineState`](https://developer.apple.com/documentation/metal/mtlcomputepipelinestate) instance if the method completes successfully; otherwise `nil`.
///
/// - reflection: An [`MTLComputePipelineReflection`](https://developer.apple.com/documentation/metal/mtlcomputepipelinereflection) instance if the method completes successfully; otherwise `nil`.
///
/// - error: On return, if an error occurs, a pointer to an error information instance; otherwise `nil`.
///
#[cfg(all(
    feature = "MTLAllocation",
    feature = "MTLComputePipeline",
    feature = "block2"
))]
pub type MTLNewComputePipelineStateWithReflectionCompletionHandler = *mut block2::DynBlock<
    dyn Fn(
        *mut ProtocolObject<dyn MTLComputePipelineState>,
        *mut MTLComputePipelineReflection,
        *mut NSError,
    ),
>;

#[cfg(all(feature = "MTLDynamicLibrary", feature = "block2"))]
pub type MTLNewDynamicLibraryCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut ProtocolObject<dyn MTLDynamicLibrary>, *mut NSError)>;

/// A convenience type alias for an autoreleased argument instance.
#[deprecated = "Use MTLBinding and cast to specific Binding (MTLTextureBinding, MTLBufferBinding, .etc) instead"]
#[cfg(feature = "MTLArgument")]
pub type MTLAutoreleasedArgument = MTLArgument;

/// Types of tessellation patches that can be inputs of a post-tessellation vertex function.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLPatchType(pub NSUInteger);
impl MTLPatchType {
    /// An option that indicates that this isn’t a post-tessellation vertex function.
    #[doc(alias = "MTLPatchTypeNone")]
    pub const None: Self = Self(0);
    /// A triangle patch.
    ///
    /// ## Discussion
    ///
    /// Metal uses this value if the shader is a post-tessellation vertex function with the `[[patch(triangle)]]` attribute.
    ///
    ///
    #[doc(alias = "MTLPatchTypeTriangle")]
    pub const Triangle: Self = Self(1);
    /// A quad patch.
    ///
    /// ## Discussion
    ///
    /// Metal uses this value if the shader is a post-tessellation vertex function with the `[[patch(quad)]]` attribute.
    ///
    ///
    #[doc(alias = "MTLPatchTypeQuad")]
    pub const Quad: Self = Self(2);
}

unsafe impl Encode for MTLPatchType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLPatchType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An instance that represents an attribute of a vertex function.
    ///
    /// ## Overview
    ///
    /// An [`MTLVertexAttribute`](https://developer.apple.com/documentation/metal/mtlvertexattribute) instance represents an attribute for per-vertex input in a vertex function. You use vertex attribute instances to inspect the inputs of a vertex function by examining the [`vertexAttributes`](https://developer.apple.com/documentation/metal/mtlfunction/vertexattributes) property of the corresponding [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) instance.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLVertexAttribute;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLVertexAttribute {}
);

impl MTLVertexAttribute {
    extern_methods!(
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Retained<NSString>;

        #[unsafe(method(attributeIndex))]
        #[unsafe(method_family = none)]
        pub fn attributeIndex(&self) -> NSUInteger;

        #[cfg(feature = "MTLDataType")]
        #[unsafe(method(attributeType))]
        #[unsafe(method_family = none)]
        pub fn attributeType(&self) -> MTLDataType;

        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub fn isActive(&self) -> bool;

        #[unsafe(method(isPatchData))]
        #[unsafe(method_family = none)]
        pub fn isPatchData(&self) -> bool;

        #[unsafe(method(isPatchControlPointData))]
        #[unsafe(method_family = none)]
        pub fn isPatchControlPointData(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLVertexAttribute {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLVertexAttribute {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// An object that describes an attribute defined in the stage-in argument for a shader.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLAttribute;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLAttribute {}
);

impl MTLAttribute {
    extern_methods!(
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Retained<NSString>;

        #[unsafe(method(attributeIndex))]
        #[unsafe(method_family = none)]
        pub fn attributeIndex(&self) -> NSUInteger;

        #[cfg(feature = "MTLDataType")]
        #[unsafe(method(attributeType))]
        #[unsafe(method_family = none)]
        pub fn attributeType(&self) -> MTLDataType;

        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub fn isActive(&self) -> bool;

        #[unsafe(method(isPatchData))]
        #[unsafe(method_family = none)]
        pub fn isPatchData(&self) -> bool;

        #[unsafe(method(isPatchControlPointData))]
        #[unsafe(method_family = none)]
        pub fn isPatchControlPointData(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLAttribute {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLAttribute {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// The type of a top-level Metal Shading Language (MSL) function.
/// An identifier for a top-level Metal function.
///
/// Each location in the API where a program is used requires a function written for that specific usage.
///
///
/// A vertex shader, usable for a MTLRenderPipelineState.
///
///
/// A fragment shader, usable for a MTLRenderPipelineState.
///
///
/// A compute kernel, usable to create a MTLComputePipelineState.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLFunctionType(pub NSUInteger);
impl MTLFunctionType {
    /// A vertex function you can use in a render pipeline state object.
    #[doc(alias = "MTLFunctionTypeVertex")]
    pub const Vertex: Self = Self(1);
    /// A fragment function you can use in a render pipeline state object.
    #[doc(alias = "MTLFunctionTypeFragment")]
    pub const Fragment: Self = Self(2);
    /// A kernel you can use in a compute pipeline state object.
    #[doc(alias = "MTLFunctionTypeKernel")]
    pub const Kernel: Self = Self(3);
    /// A function you can use in a visible function table.
    #[doc(alias = "MTLFunctionTypeVisible")]
    pub const Visible: Self = Self(5);
    /// A function you can use in an intersection function table.
    #[doc(alias = "MTLFunctionTypeIntersection")]
    pub const Intersection: Self = Self(6);
    #[doc(alias = "MTLFunctionTypeMesh")]
    pub const Mesh: Self = Self(7);
    #[doc(alias = "MTLFunctionTypeObject")]
    pub const Object: Self = Self(8);
}

unsafe impl Encode for MTLFunctionType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLFunctionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A constant that specializes the behavior of a shader.
    ///
    /// ## Overview
    ///
    /// Don’t create an [`MTLFunctionConstant`](https://developer.apple.com/documentation/metal/mtlfunctionconstant) instance directly. Instead, the list of function constants for a function by querying the `functionConstants` property of an [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) instance.
    ///
    /// An [`MTLFunctionConstant`](https://developer.apple.com/documentation/metal/mtlfunctionconstant) instance should only be obtained from a nonspecialized function created with the [`newFunctionWithName:`](https://developer.apple.com/documentation/metal/mtllibrary/makefunction(name:)) method. You only need an [`MTLFunctionConstant`](https://developer.apple.com/documentation/metal/mtlfunctionconstant) instance if you don’t have sufficient information to create an [`MTLFunctionConstantValues`](https://developer.apple.com/documentation/metal/mtlfunctionconstantvalues) instance used to create a specialized function with the [`newFunctionWithName:constantValues:error:`](https://developer.apple.com/documentation/metal/mtllibrary/makefunction(name:constantvalues:)) or [`newFunctionWithName:constantValues:completionHandler:`](https://developer.apple.com/documentation/metal/mtllibrary/makefunction(name:constantvalues:completionhandler:)) method.
    ///
    ///
    /// describe an uberShader constant used by the function
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLFunctionConstant;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLFunctionConstant {}
);

impl MTLFunctionConstant {
    extern_methods!(
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Retained<NSString>;

        #[cfg(feature = "MTLDataType")]
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub fn r#type(&self) -> MTLDataType;

        #[unsafe(method(index))]
        #[unsafe(method_family = none)]
        pub fn index(&self) -> NSUInteger;

        #[unsafe(method(required))]
        #[unsafe(method_family = none)]
        pub fn required(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLFunctionConstant {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLFunctionConstant {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// A interface that represents a public shader function in a Metal library.
    ///
    /// ## Overview
    ///
    /// Use [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) instances to specify which shaders a Metal pipeline calls when the GPU executes commands that specify that pipeline. For more information on creating pipeline states, see [`MTLRenderPipelineDescriptor`](https://developer.apple.com/documentation/metal/mtlrenderpipelinedescriptor) and [`MTLComputePipelineDescriptor`](https://developer.apple.com/documentation/metal/mtlcomputepipelinedescriptor).
    ///
    /// An [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) instance is a _specialized_ function if the shader contains function constants, otherwise it is a _nonspecialized_ function.
    ///
    /// Don’t use standard allocation and initialization techniques to create an [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) instance. Instead, use the function creation methods provided by the [`MTLLibrary`](https://developer.apple.com/documentation/metal/mtllibrary) protocol. To create a nonspecialized function, call the [`newFunctionWithName:`](https://developer.apple.com/documentation/metal/mtllibrary/makefunction(name:)) method.
    ///
    /// To create a specialized function, call one of these [`MTLLibrary`](https://developer.apple.com/documentation/metal/mtllibrary) methods:
    ///
    /// - [`newFunctionWithName:constantValues:completionHandler:`](https://developer.apple.com/documentation/metal/mtllibrary/makefunction(name:constantvalues:completionhandler:))
    ///
    /// - [`newFunctionWithName:constantValues:error:`](https://developer.apple.com/documentation/metal/mtllibrary/makefunction(name:constantvalues:))
    ///
    /// [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) instances can use a significant amount of memory; release any strong references to them after you finish creating pipeline instances.
    ///
    ///
    /// A handle to intermediate code used as inputs for either a MTLComputePipelineState or a MTLRenderPipelineState.
    ///
    /// MTLFunction is a single vertex shader, fragment shader, or compute function.  A Function can only be used with the device that it was created against.
    pub unsafe trait MTLFunction: NSObjectProtocol + Send + Sync {
        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);

        #[cfg(feature = "MTLDevice")]
        /// The device this resource was created against.  This resource can only be used with this device.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// The overall kind of entry point: compute, vertex, or fragment.
        #[unsafe(method(functionType))]
        #[unsafe(method_family = none)]
        fn functionType(&self) -> MTLFunctionType;

        /// Returns the patch type. MTLPatchTypeNone if it is not a post tessellation vertex shader.
        #[unsafe(method(patchType))]
        #[unsafe(method_family = none)]
        fn patchType(&self) -> MTLPatchType;

        /// Returns the number of patch control points if it was specified in the shader. Returns -1 if it
        /// was not specified.
        #[unsafe(method(patchControlPointCount))]
        #[unsafe(method_family = none)]
        fn patchControlPointCount(&self) -> NSInteger;

        #[unsafe(method(vertexAttributes))]
        #[unsafe(method_family = none)]
        fn vertexAttributes(&self) -> Option<Retained<NSArray<MTLVertexAttribute>>>;

        /// Returns an array describing the attributes
        #[unsafe(method(stageInputAttributes))]
        #[unsafe(method_family = none)]
        fn stageInputAttributes(&self) -> Option<Retained<NSArray<MTLAttribute>>>;

        /// The name of the function in the shading language.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        fn name(&self) -> Retained<NSString>;

        /// A dictionary containing information about all function contents, keyed by the constant names.
        #[unsafe(method(functionConstantsDictionary))]
        #[unsafe(method_family = none)]
        fn functionConstantsDictionary(
            &self,
        ) -> Retained<NSDictionary<NSString, MTLFunctionConstant>>;

        #[cfg(feature = "MTLArgumentEncoder")]
        /// Creates an argument encoder which will encode arguments matching the layout of the argument buffer at the given bind point index.
        ///
        /// # Safety
        ///
        /// `bufferIndex` might not be bounds-checked.
        #[unsafe(method(newArgumentEncoderWithBufferIndex:))]
        #[unsafe(method_family = new)]
        unsafe fn newArgumentEncoderWithBufferIndex(
            &self,
            buffer_index: NSUInteger,
        ) -> Retained<ProtocolObject<dyn MTLArgumentEncoder>>;

        #[cfg(all(feature = "MTLArgument", feature = "MTLArgumentEncoder"))]
        /// Creates an argument encoder which will encode arguments matching the layout of the argument buffer at the given bind point index.
        ///
        /// # Safety
        ///
        /// `bufferIndex` might not be bounds-checked.
        #[deprecated = "Use MTLDevice's newArgumentEncoderWithBufferBinding: instead"]
        #[unsafe(method(newArgumentEncoderWithBufferIndex:reflection:))]
        #[unsafe(method_family = new)]
        unsafe fn newArgumentEncoderWithBufferIndex_reflection(
            &self,
            buffer_index: NSUInteger,
            reflection: Option<&mut Option<Retained<MTLAutoreleasedArgument>>>,
        ) -> Retained<ProtocolObject<dyn MTLArgumentEncoder>>;

        #[cfg(feature = "MTLFunctionDescriptor")]
        /// The options this function was created with.
        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        fn options(&self) -> MTLFunctionOptions;
    }
);

/// Metal shading language versions.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLLanguageVersion(pub NSUInteger);
impl MTLLanguageVersion {
    /// Version 1.0 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion1_0")]
    #[deprecated = "Use a newer language standard"]
    pub const Version1_0: Self = Self(1 << 16);
    /// Version 1.1 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion1_1")]
    pub const Version1_1: Self = Self((1 << 16) + 1);
    /// Version 1.2 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion1_2")]
    pub const Version1_2: Self = Self((1 << 16) + 2);
    /// Version 2.0 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion2_0")]
    pub const Version2_0: Self = Self(2 << 16);
    /// Version 2.1 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion2_1")]
    pub const Version2_1: Self = Self((2 << 16) + 1);
    /// Version 2.2 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion2_2")]
    pub const Version2_2: Self = Self((2 << 16) + 2);
    /// Version 2.3 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion2_3")]
    pub const Version2_3: Self = Self((2 << 16) + 3);
    /// Version 2.4 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion2_4")]
    pub const Version2_4: Self = Self((2 << 16) + 4);
    /// Version 3.0 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion3_0")]
    pub const Version3_0: Self = Self((3 << 16) + 0);
    /// Version 3.1 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion3_1")]
    pub const Version3_1: Self = Self((3 << 16) + 1);
    /// Version 3.2 of the Metal shading language.
    #[doc(alias = "MTLLanguageVersion3_2")]
    pub const Version3_2: Self = Self((3 << 16) + 2);
    #[doc(alias = "MTLLanguageVersion4_0")]
    pub const Version4_0: Self = Self((4 << 16) + 0);
}

unsafe impl Encode for MTLLanguageVersion {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLLanguageVersion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A set of options for Metal library types.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLLibraryType(pub NSInteger);
impl MTLLibraryType {
    /// A library that can create pipeline state objects.
    #[doc(alias = "MTLLibraryTypeExecutable")]
    pub const Executable: Self = Self(0);
    /// A library that you can dynamically link to from other libraries.
    #[doc(alias = "MTLLibraryTypeDynamic")]
    pub const Dynamic: Self = Self(1);
}

unsafe impl Encode for MTLLibraryType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLLibraryType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The optimization options for the Metal compiler.
/// Optimization level for the Metal compiler.
///
///
/// Optimize for program performance.
///
///
/// Like default, with extra optimizations to reduce code size.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLLibraryOptimizationLevel(pub NSInteger);
impl MTLLibraryOptimizationLevel {
    /// An optimization option for the Metal compiler that prioritizes runtime performance.
    #[doc(alias = "MTLLibraryOptimizationLevelDefault")]
    pub const Default: Self = Self(0);
    /// An optimization option for the Metal compiler that prioritizes minimizing the size of its output binaries, which may also reduce compile time.
    ///
    /// ## Discussion
    ///
    /// This option is similar to [`MTLLibraryOptimizationLevelDefault`](https://developer.apple.com/documentation/metal/mtllibraryoptimizationlevel/default), but adds optimizations that prioritize minimizing a shader’s executable size, which may also reduce compile time.
    ///
    ///
    #[doc(alias = "MTLLibraryOptimizationLevelSize")]
    pub const Size: Self = Self(1);
}

unsafe impl Encode for MTLLibraryOptimizationLevel {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLLibraryOptimizationLevel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLCompileSymbolVisibility(pub NSInteger);
impl MTLCompileSymbolVisibility {
    #[doc(alias = "MTLCompileSymbolVisibilityDefault")]
    pub const Default: Self = Self(0);
    #[doc(alias = "MTLCompileSymbolVisibilityHidden")]
    pub const Hidden: Self = Self(1);
}

unsafe impl Encode for MTLCompileSymbolVisibility {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLCompileSymbolVisibility {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An indication of whether the compiler can perform optimizations for floating-point arithmetic that may violate the IEEE 754 standard.
/// An enum to indicate if the compiler can perform optimizations for floating-point arithmetic that may violate the IEEE 754 standard
///
///
/// Disables unsafe floating-point optimizations
///
///
/// Allows aggressive, unsafe floating-point optimizations but preserves infs and nans
///
///
/// Allows aggressive, unsafe floating-point optimizations
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLMathMode(pub NSInteger);
impl MTLMathMode {
    /// An indicator of the mode the compiler uses to disable unsafe floating-point optimizations by preventing the compiler from making any transformations that could affect the results.
    #[doc(alias = "MTLMathModeSafe")]
    pub const Safe: Self = Self(0);
    /// An indicator of the mode the compiler uses to make aggressive, potentially lossy assumptions about floating-point math, while honoring Inf/NaN.
    ///
    /// ## Discussion
    ///
    /// This is the default for Apple silicon devices.
    ///
    ///
    #[doc(alias = "MTLMathModeRelaxed")]
    pub const Relaxed: Self = Self(1);
    /// An indicator of the mode the compiler uses to make aggressive, potentially lossy assumptions about floating-point math.
    ///
    /// ## Discussion
    ///
    /// This is the default for Intel and AMD devices.
    ///
    ///
    #[doc(alias = "MTLMathModeFast")]
    pub const Fast: Self = Self(2);
}

unsafe impl Encode for MTLMathMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLMathMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Indicates which FP32 math functions Metal uses.
/// An enum to indicate the default math functions for single precision floating-point
///
///
/// Sets the default math functions for single precision floating-point to the corresponding functions in `metal::fast` namespace
///
///
/// Sets the default math functions for single precision floating-point to the corresponding functions in 'metal::precise' namespace
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLMathFloatingPointFunctions(pub NSInteger);
impl MTLMathFloatingPointFunctions {
    /// An indication that Metal uses the fast version of the 32b floating-point math functions.
    ///
    /// ## Discussion
    ///
    /// This is the default behavior.
    ///
    ///
    #[doc(alias = "MTLMathFloatingPointFunctionsFast")]
    pub const Fast: Self = Self(0);
    /// An indication that Metal uses the precise version of the 32b floating-point math functions.
    #[doc(alias = "MTLMathFloatingPointFunctionsPrecise")]
    pub const Precise: Self = Self(1);
}

unsafe impl Encode for MTLMathFloatingPointFunctions {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLMathFloatingPointFunctions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Compilation settings for a Metal shader library.
    ///
    /// ## Overview
    ///
    /// You can configure the Metal compiler’s options by setting any or all of an [`MTLCompileOptions`](https://developer.apple.com/documentation/metal/mtlcompileoptions) instance’s properties, including the following:
    ///
    /// - Target previous OS releases by assigning the [`languageVersion`](https://developer.apple.com/documentation/metal/mtlcompileoptions/languageversion) property to an [`MTLLanguageVersion`](https://developer.apple.com/documentation/metal/mtllanguageversion) case.
    ///
    /// - Set preprocessor macros for the Metal compiler by assigning a dictionary to the [`preprocessorMacros`](https://developer.apple.com/documentation/metal/mtlcompileoptions/preprocessormacros) property.
    ///
    /// - Choose what the Metal compiler’s optimizer prioritizes by setting the [`optimizationLevel`](https://developer.apple.com/documentation/metal/mtlcompileoptions/optimizationlevel) property to an [`MTLLibraryOptimizationLevel`](https://developer.apple.com/documentation/metal/mtllibraryoptimizationlevel) case.
    ///
    /// - Allow the compiler to optimize for floating-point arithmetic that may violate the IEEE 754 standard by setting [`mathMode`](https://developer.apple.com/documentation/metal/mtlcompileoptions/mathmode) to [`MTLMathModeFast`](https://developer.apple.com/documentation/metal/mtlmathmode/fast).
    ///
    /// You can compile a library with your compile options instance by calling an [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) instance’s [`newLibraryWithSource:options:error:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(source:options:)) or [`newLibraryWithSource:options:completionHandler:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(source:options:completionhandler:)) method.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLCompileOptions;
);

extern_conformance!(
    unsafe impl NSCopying for MTLCompileOptions {}
);

unsafe impl CopyingHelper for MTLCompileOptions {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLCompileOptions {}
);

impl MTLCompileOptions {
    extern_methods!(
        /// List of preprocessor macros to consider to when compiling this program. Specified as key value pairs, using a NSDictionary. The keys must be NSString objects and values can be either NSString or NSNumber objects.
        ///
        /// The default value is nil.
        #[unsafe(method(preprocessorMacros))]
        #[unsafe(method_family = none)]
        pub fn preprocessorMacros(&self) -> Option<Retained<NSDictionary<NSString, NSObject>>>;

        /// Setter for [`preprocessorMacros`][Self::preprocessorMacros].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `preprocessor_macros` generic should be of the correct type.
        #[unsafe(method(setPreprocessorMacros:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreprocessorMacros(
            &self,
            preprocessor_macros: Option<&NSDictionary<NSString, NSObject>>,
        );

        /// If YES, enables the compiler to perform optimizations for floating-point arithmetic that may violate the IEEE 754 standard. It also enables the high precision variant of math functions for single precision floating-point scalar and vector types. fastMathEnabled defaults to YES.
        #[deprecated = "Use mathMode instead"]
        #[unsafe(method(fastMathEnabled))]
        #[unsafe(method_family = none)]
        pub fn fastMathEnabled(&self) -> bool;

        /// Setter for [`fastMathEnabled`][Self::fastMathEnabled].
        #[deprecated = "Use mathMode instead"]
        #[unsafe(method(setFastMathEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setFastMathEnabled(&self, fast_math_enabled: bool);

        /// Sets the floating-point arithmetic optimizations. Default depends on the language standard version.
        #[unsafe(method(mathMode))]
        #[unsafe(method_family = none)]
        pub fn mathMode(&self) -> MTLMathMode;

        /// Setter for [`mathMode`][Self::mathMode].
        #[unsafe(method(setMathMode:))]
        #[unsafe(method_family = none)]
        pub fn setMathMode(&self, math_mode: MTLMathMode);

        /// Sets the default math functions for single precision floating-point. Default is `MTLMathFloatingPointFunctionsFast`.
        #[unsafe(method(mathFloatingPointFunctions))]
        #[unsafe(method_family = none)]
        pub fn mathFloatingPointFunctions(&self) -> MTLMathFloatingPointFunctions;

        /// Setter for [`mathFloatingPointFunctions`][Self::mathFloatingPointFunctions].
        #[unsafe(method(setMathFloatingPointFunctions:))]
        #[unsafe(method_family = none)]
        pub fn setMathFloatingPointFunctions(
            &self,
            math_floating_point_functions: MTLMathFloatingPointFunctions,
        );

        /// set the metal language version used to interpret the source.
        #[unsafe(method(languageVersion))]
        #[unsafe(method_family = none)]
        pub fn languageVersion(&self) -> MTLLanguageVersion;

        /// Setter for [`languageVersion`][Self::languageVersion].
        #[unsafe(method(setLanguageVersion:))]
        #[unsafe(method_family = none)]
        pub fn setLanguageVersion(&self, language_version: MTLLanguageVersion);

        /// Which type the library should be compiled as. The default value is MTLLibraryTypeExecutable.
        ///
        /// MTLLibraryTypeExecutable is suitable to build a library of "kernel", "vertex" and "fragment" qualified functions.
        /// MTLLibraryType is suitable when the compilation result will instead be used to instantiate a MTLDynamicLibrary.
        /// MTLDynamicLibrary contains no qualified functions, but it's unqualified functions and variables can be used as an external dependency for compiling other libraries.
        #[unsafe(method(libraryType))]
        #[unsafe(method_family = none)]
        pub fn libraryType(&self) -> MTLLibraryType;

        /// Setter for [`libraryType`][Self::libraryType].
        #[unsafe(method(setLibraryType:))]
        #[unsafe(method_family = none)]
        pub fn setLibraryType(&self, library_type: MTLLibraryType);

        /// The install name of this dynamic library.
        ///
        /// The install name is used when a pipeline state is created that depends, directly or indirectly, on a dynamic library.
        /// The installName is embedded into any other MTLLibrary that links against the compilation result.
        /// This property should be set such that the dynamic library can be found in the file system at the time a pipeline state is created.
        /// Specify one of:
        /// - an absolute path to a file from which the dynamic library can be loaded, or
        /// - a path relative to
        /// @
        /// executable_path, where
        /// @
        /// executable_path is substituted with the directory name from which the MTLLibrary containing the MTLFunction entrypoint used to create the pipeline state is loaded, or
        /// - a path relative to
        /// @
        /// loader_path, where
        /// @
        /// loader_path is substituted with the directory name from which the MTLLibrary with the reference to this installName embedded is loaded.
        /// The first is appropriate for MTLDynamicLibrary written to the file-system using its serializeToURL:error: method on the current device.
        /// The others are appropriate when the MTLDynamicLibrary is installed as part of a bundle or app, where the absolute path is not known.
        /// This property is ignored when the type property is not set to MTLLibraryTypeDynamic.
        /// This propery should not be null if the property type is set to MTLLibraryTypeDynamic: the compilation will fail in that scenario.
        #[unsafe(method(installName))]
        #[unsafe(method_family = none)]
        pub fn installName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`installName`][Self::installName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInstallName:))]
        #[unsafe(method_family = none)]
        pub fn setInstallName(&self, install_name: Option<&NSString>);

        #[cfg(feature = "MTLDynamicLibrary")]
        /// A set of MTLDynamicLibrary instances to link against.
        /// The installName of the provided MTLDynamicLibrary is embedded into the compilation result.
        /// When a function from the resulting MTLLibrary is used (either as an MTLFunction, or as an to create a pipeline state, the embedded install names are used to automatically load the MTLDynamicLibrary instances.
        /// This property can be null if no libraries should be automatically loaded, either because the MTLLibrary has no external dependencies, or because you will use preloadedLibraries to specify the libraries to use at pipeline creation time.
        #[unsafe(method(libraries))]
        #[unsafe(method_family = none)]
        pub fn libraries(&self)
            -> Option<Retained<NSArray<ProtocolObject<dyn MTLDynamicLibrary>>>>;

        #[cfg(feature = "MTLDynamicLibrary")]
        /// Setter for [`libraries`][Self::libraries].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLibraries:))]
        #[unsafe(method_family = none)]
        pub fn setLibraries(
            &self,
            libraries: Option<&NSArray<ProtocolObject<dyn MTLDynamicLibrary>>>,
        );

        /// If YES,  set the compiler to compile shaders to preserve invariance.  The default is false.
        #[unsafe(method(preserveInvariance))]
        #[unsafe(method_family = none)]
        pub fn preserveInvariance(&self) -> bool;

        /// Setter for [`preserveInvariance`][Self::preserveInvariance].
        #[unsafe(method(setPreserveInvariance:))]
        #[unsafe(method_family = none)]
        pub fn setPreserveInvariance(&self, preserve_invariance: bool);

        /// Sets the compiler optimization level.
        #[unsafe(method(optimizationLevel))]
        #[unsafe(method_family = none)]
        pub fn optimizationLevel(&self) -> MTLLibraryOptimizationLevel;

        /// Setter for [`optimizationLevel`][Self::optimizationLevel].
        #[unsafe(method(setOptimizationLevel:))]
        #[unsafe(method_family = none)]
        pub fn setOptimizationLevel(&self, optimization_level: MTLLibraryOptimizationLevel);

        /// Adds a compiler command to force the default visibility of symbols to be hidden
        #[unsafe(method(compileSymbolVisibility))]
        #[unsafe(method_family = none)]
        pub fn compileSymbolVisibility(&self) -> MTLCompileSymbolVisibility;

        /// Setter for [`compileSymbolVisibility`][Self::compileSymbolVisibility].
        #[unsafe(method(setCompileSymbolVisibility:))]
        #[unsafe(method_family = none)]
        pub fn setCompileSymbolVisibility(
            &self,
            compile_symbol_visibility: MTLCompileSymbolVisibility,
        );

        /// Adds a compiler command to allow the reference of undefined symbols
        #[unsafe(method(allowReferencingUndefinedSymbols))]
        #[unsafe(method_family = none)]
        pub fn allowReferencingUndefinedSymbols(&self) -> bool;

        /// Setter for [`allowReferencingUndefinedSymbols`][Self::allowReferencingUndefinedSymbols].
        #[unsafe(method(setAllowReferencingUndefinedSymbols:))]
        #[unsafe(method_family = none)]
        pub fn setAllowReferencingUndefinedSymbols(
            &self,
            allow_referencing_undefined_symbols: bool,
        );

        /// Adds a compiler command to specify the total threads per threadgroup
        #[unsafe(method(maxTotalThreadsPerThreadgroup))]
        #[unsafe(method_family = none)]
        pub fn maxTotalThreadsPerThreadgroup(&self) -> NSUInteger;

        /// Setter for [`maxTotalThreadsPerThreadgroup`][Self::maxTotalThreadsPerThreadgroup].
        #[unsafe(method(setMaxTotalThreadsPerThreadgroup:))]
        #[unsafe(method_family = none)]
        pub fn setMaxTotalThreadsPerThreadgroup(
            &self,
            max_total_threads_per_threadgroup: NSUInteger,
        );

        #[cfg(feature = "MTLTypes")]
        /// Sets the required threads-per-threadgroup during dispatches. The `threadsPerThreadgroup` argument of any dispatch must match this value if it is set.
        /// Optional, unless the pipeline is going to use CooperativeTensors in which case this must be set.
        /// Setting this to a size of 0 in every dimension disables this property
        #[unsafe(method(requiredThreadsPerThreadgroup))]
        #[unsafe(method_family = none)]
        pub fn requiredThreadsPerThreadgroup(&self) -> MTLSize;

        #[cfg(feature = "MTLTypes")]
        /// Setter for [`requiredThreadsPerThreadgroup`][Self::requiredThreadsPerThreadgroup].
        #[unsafe(method(setRequiredThreadsPerThreadgroup:))]
        #[unsafe(method_family = none)]
        pub fn setRequiredThreadsPerThreadgroup(&self, required_threads_per_threadgroup: MTLSize);

        /// If YES,  set the compiler to enable any logging in the shader. The default is false.
        #[unsafe(method(enableLogging))]
        #[unsafe(method_family = none)]
        pub fn enableLogging(&self) -> bool;

        /// Setter for [`enableLogging`][Self::enableLogging].
        #[unsafe(method(setEnableLogging:))]
        #[unsafe(method_family = none)]
        pub fn setEnableLogging(&self, enable_logging: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLCompileOptions {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLCompileOptions {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// Represents a reflection object containing information about a function in a Metal library.
    /// Represents a reflection object containing information about a function in a Metal library.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLFunctionReflection;
);

unsafe impl Send for MTLFunctionReflection {}

unsafe impl Sync for MTLFunctionReflection {}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLFunctionReflection {}
);

impl MTLFunctionReflection {
    extern_methods!(
        #[cfg(feature = "MTLArgument")]
        /// Provides a list of inputs and outputs of the function.
        #[unsafe(method(bindings))]
        #[unsafe(method_family = none)]
        pub fn bindings(&self) -> Retained<NSArray<ProtocolObject<dyn MTLBinding>>>;

        /// The string passed to the user annotation attribute for this function. Null if no user annotation is present for this function.
        #[unsafe(method(userAnnotation))]
        #[unsafe(method_family = none)]
        pub fn userAnnotation(&self) -> Option<Retained<NSString>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLFunctionReflection {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLFunctionReflection {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// The error domain for Metal libraries.
    /// NSErrors raised when creating a library.
    pub static MTLLibraryErrorDomain: &'static NSErrorDomain;
}

/// Error codes for Metal library errors.
/// NSErrors raised when creating a library.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLLibraryError(pub NSUInteger);
impl MTLLibraryError {
    /// Metal couldn’t support the requested action.
    ///
    /// ## Discussion
    ///
    /// For example, the requested library file has improper formatting, or the requested library is not accessible.
    ///
    ///
    #[doc(alias = "MTLLibraryErrorUnsupported")]
    pub const Unsupported: Self = Self(1);
    /// The action caused an internal error.
    #[doc(alias = "MTLLibraryErrorInternal")]
    pub const Internal: Self = Self(2);
    /// The library or function failed to compile.
    #[doc(alias = "MTLLibraryErrorCompileFailure")]
    pub const CompileFailure: Self = Self(3);
    /// The library or function compiled successfully but generated warnings.
    #[doc(alias = "MTLLibraryErrorCompileWarning")]
    pub const CompileWarning: Self = Self(4);
    /// Metal couldn’t find the specified Metal function.
    #[doc(alias = "MTLLibraryErrorFunctionNotFound")]
    pub const FunctionNotFound: Self = Self(5);
    /// Metal couldn’t find the Metal source file.
    #[doc(alias = "MTLLibraryErrorFileNotFound")]
    pub const FileNotFound: Self = Self(6);
}

unsafe impl Encode for MTLLibraryError {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLLibraryError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A collection of Metal shader functions.
    ///
    /// ## Overview
    ///
    /// An [`MTLLibrary`](https://developer.apple.com/documentation/metal/mtllibrary) instance contains Metal shading language source code compiled during an app’s build process or at runtime from a text string.
    ///
    /// Don’t implement this protocol yourself; instead, use the library creation methods provided by the [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) protocol. To create an [`MTLLibrary`](https://developer.apple.com/documentation/metal/mtllibrary) from a precompiled Metal library binary, call one of these [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) methods:
    ///
    /// - [`newDefaultLibrary`](https://developer.apple.com/documentation/metal/mtldevice/makedefaultlibrary())
    ///
    /// - [`newLibraryWithFile:error:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(filepath:))
    ///
    /// - [`newLibraryWithData:error:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(data:))
    ///
    /// To create an [`MTLLibrary`](https://developer.apple.com/documentation/metal/mtllibrary) by compiling source code at runtime, call one of these [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) methods:
    ///
    /// - [`newLibraryWithSource:options:completionHandler:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(source:options:completionhandler:))
    ///
    /// - [`newLibraryWithSource:options:error:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(source:options:))
    ///
    ///
    pub unsafe trait MTLLibrary: NSObjectProtocol + Send + Sync {
        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);

        #[cfg(feature = "MTLDevice")]
        /// The device this resource was created against.  This resource can only be used with this device.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// Returns a pointer to a function object, return nil if the function is not found in the library.
        #[unsafe(method(newFunctionWithName:))]
        #[unsafe(method_family = new)]
        fn newFunctionWithName(
            &self,
            function_name: &NSString,
        ) -> Option<Retained<ProtocolObject<dyn MTLFunction>>>;

        #[cfg(feature = "MTLFunctionConstantValues")]
        /// Returns a pointer to a function object obtained by applying the constant values to the named function.
        ///
        /// This method will call the compiler. Use newFunctionWithName:constantValues:completionHandler: to
        /// avoid waiting on the compiler.
        #[unsafe(method(newFunctionWithName:constantValues:error:_))]
        #[unsafe(method_family = new)]
        fn newFunctionWithName_constantValues_error(
            &self,
            name: &NSString,
            constant_values: &MTLFunctionConstantValues,
        ) -> Result<Retained<ProtocolObject<dyn MTLFunction>>, Retained<NSError>>;

        #[cfg(all(feature = "MTLFunctionConstantValues", feature = "block2"))]
        /// Returns a pointer to a function object obtained by applying the constant values to the named function.
        ///
        /// This method is asynchronous since it is will call the compiler.
        #[unsafe(method(newFunctionWithName:constantValues:completionHandler:))]
        #[unsafe(method_family = none)]
        fn newFunctionWithName_constantValues_completionHandler(
            &self,
            name: &NSString,
            constant_values: &MTLFunctionConstantValues,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut ProtocolObject<dyn MTLFunction>, *mut NSError),
            >,
        );

        /// Retrieves reflection information for a function in the library.
        ///
        /// - Parameters:
        /// - functionName: The name of a GPU function in the library.
        /// The name needs to match one of the elements in the string array of library's ``functionNames`` property.
        ///
        /// - Returns: An `MTLFunctionReflection` instance when the method succeeds; otherwise `nil`.
        ///
        /// The reflection instance contains metadata information about a specific GPU function,
        /// which can include:
        /// * Function parameters
        /// * Return types
        /// * Bindings
        /// * Annotations from a developer, if available
        ///
        /// - Note: The Metal compiler generates the function's reflection information
        /// when you or Xcode build the library.
        ///
        /// The method only returns reflection information if all of the following conditions apply:
        /// * The library has a function with a name that matches `functionName`.
        /// * The deployment target is macOS 13.0 or later, or iOS 16.0 or later, or visionOS 2.0 or later.
        #[unsafe(method(reflectionForFunctionWithName:))]
        #[unsafe(method_family = none)]
        fn reflectionForFunctionWithName(
            &self,
            function_name: &NSString,
        ) -> Option<Retained<MTLFunctionReflection>>;

        #[cfg(all(feature = "MTLFunctionDescriptor", feature = "block2"))]
        /// Create a new MTLFunction object asynchronously.
        #[unsafe(method(newFunctionWithDescriptor:completionHandler:))]
        #[unsafe(method_family = none)]
        fn newFunctionWithDescriptor_completionHandler(
            &self,
            descriptor: &MTLFunctionDescriptor,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut ProtocolObject<dyn MTLFunction>, *mut NSError),
            >,
        );

        #[cfg(feature = "MTLFunctionDescriptor")]
        /// Create  a new MTLFunction object synchronously.
        #[unsafe(method(newFunctionWithDescriptor:error:_))]
        #[unsafe(method_family = new)]
        fn newFunctionWithDescriptor_error(
            &self,
            descriptor: &MTLFunctionDescriptor,
        ) -> Result<Retained<ProtocolObject<dyn MTLFunction>>, Retained<NSError>>;

        #[cfg(all(feature = "MTLFunctionDescriptor", feature = "block2"))]
        /// Create a new MTLFunction object asynchronously.
        #[unsafe(method(newIntersectionFunctionWithDescriptor:completionHandler:))]
        #[unsafe(method_family = none)]
        fn newIntersectionFunctionWithDescriptor_completionHandler(
            &self,
            descriptor: &MTLIntersectionFunctionDescriptor,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut ProtocolObject<dyn MTLFunction>, *mut NSError),
            >,
        );

        #[cfg(feature = "MTLFunctionDescriptor")]
        /// Create  a new MTLFunction object synchronously.
        #[unsafe(method(newIntersectionFunctionWithDescriptor:error:_))]
        #[unsafe(method_family = new)]
        fn newIntersectionFunctionWithDescriptor_error(
            &self,
            descriptor: &MTLIntersectionFunctionDescriptor,
        ) -> Result<Retained<ProtocolObject<dyn MTLFunction>>, Retained<NSError>>;

        /// The array contains NSString objects, with the name of each function in library.
        #[unsafe(method(functionNames))]
        #[unsafe(method_family = none)]
        fn functionNames(&self) -> Retained<NSArray<NSString>>;

        /// The library type provided when this MTLLibrary was created.
        /// Libraries with MTLLibraryTypeExecutable can be used to obtain MTLFunction from.
        /// Libraries with MTLLibraryTypeDynamic can be used to resolve external references in other MTLLibrary from.
        ///
        /// See: MTLCompileOptions
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        fn r#type(&self) -> MTLLibraryType;

        /// The installName provided when this MTLLibrary was created.
        ///
        /// Always nil if the type of the library is not MTLLibraryTypeDynamic.
        ///
        /// See: MTLCompileOptions
        #[unsafe(method(installName))]
        #[unsafe(method_family = none)]
        fn installName(&self) -> Option<Retained<NSString>>;
    }
);
