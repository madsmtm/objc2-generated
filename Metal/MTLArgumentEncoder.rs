//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/metal/mtlattributestridestatic?language=objc)
pub static MTLAttributeStrideStatic: NSUInteger = NSUIntegerMax as _;

extern_protocol!(
    /// MTLArgumentEncoder encodes buffer, texture, sampler, and constant data into a buffer.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtlargumentencoder?language=objc)
    pub unsafe trait MTLArgumentEncoder: NSObjectProtocol {
        #[cfg(feature = "MTLDevice")]
        /// The device this argument encoder was created against.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn set_label(&self, label: Option<&NSString>);

        /// The number of bytes required to store the encoded resource bindings.
        #[unsafe(method(encodedLength))]
        #[unsafe(method_family = none)]
        fn encoded_length(&self) -> NSUInteger;

        /// The alignment in bytes required to store the encoded resource bindings.
        #[unsafe(method(alignment))]
        #[unsafe(method_family = none)]
        fn alignment(&self) -> NSUInteger;

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// Sets the destination buffer and offset at which the arguments will be encoded.
        ///
        /// # Safety
        ///
        /// - `argument_buffer` may need to be synchronized.
        /// - `argument_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `argument_buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        #[unsafe(method(setArgumentBuffer:offset:))]
        #[unsafe(method_family = none)]
        unsafe fn set_argument_buffer_offset(
            &self,
            argument_buffer: Option<&ProtocolObject<dyn MTLBuffer>>,
            offset: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// Sets the destination buffer, starting offset and specific array element arguments will be encoded into. arrayElement represents
        /// the desired element of IAB array targetted by encoding
        ///
        /// # Safety
        ///
        /// - `argument_buffer` may need to be synchronized.
        /// - `argument_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `argument_buffer` contents should be of the correct type.
        /// - `startOffset` might not be bounds-checked.
        #[unsafe(method(setArgumentBuffer:startOffset:arrayElement:))]
        #[unsafe(method_family = none)]
        unsafe fn set_argument_buffer_start_offset_array_element(
            &self,
            argument_buffer: Option<&ProtocolObject<dyn MTLBuffer>>,
            start_offset: NSUInteger,
            array_element: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// Set a buffer at the given bind point index.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        /// - `offset` might not be bounds-checked.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setBuffer:offset:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_buffer_offset_at_index(
            &self,
            buffer: Option<&ProtocolObject<dyn MTLBuffer>>,
            offset: NSUInteger,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLBuffer",
            feature = "MTLResource"
        ))]
        /// Set an array of buffers at the given bind point index range.
        ///
        /// # Safety
        ///
        /// - `buffers` must be a valid pointer.
        /// - `offsets` might not be bounds-checked.
        /// - `offsets` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setBuffers:offsets:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_buffers_offsets_with_range(
            &self,
            buffers: NonNull<*const ProtocolObject<dyn MTLBuffer>>,
            offsets: NonNull<NSUInteger>,
            range: NSRange,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLResource",
            feature = "MTLTexture"
        ))]
        /// Set a texture at the given bind point index.
        ///
        /// # Safety
        ///
        /// - `texture` may need to be synchronized.
        /// - `texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setTexture:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_texture_at_index(
            &self,
            texture: Option<&ProtocolObject<dyn MTLTexture>>,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLResource",
            feature = "MTLTexture"
        ))]
        /// Set an array of textures at the given bind point index range.
        ///
        /// # Safety
        ///
        /// - `textures` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setTextures:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_textures_with_range(
            &self,
            textures: NonNull<*const ProtocolObject<dyn MTLTexture>>,
            range: NSRange,
        );

        #[cfg(feature = "MTLSampler")]
        /// Set a sampler at the given bind point index.
        ///
        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(setSamplerState:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_sampler_state_at_index(
            &self,
            sampler: Option<&ProtocolObject<dyn MTLSamplerState>>,
            index: NSUInteger,
        );

        #[cfg(feature = "MTLSampler")]
        /// Set an array of samplers at the given bind point index range.
        ///
        /// # Safety
        ///
        /// - `samplers` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setSamplerStates:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_sampler_states_with_range(
            &self,
            samplers: NonNull<*const ProtocolObject<dyn MTLSamplerState>>,
            range: NSRange,
        );

        /// Returns a pointer to the constant data at the given bind point index.
        ///
        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(constantDataAtIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn constant_data_at_index(&self, index: NSUInteger) -> NonNull<c_void>;

        #[cfg(all(feature = "MTLAllocation", feature = "MTLRenderPipeline"))]
        /// Sets a render pipeline state at a given bind point index
        ///
        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(setRenderPipelineState:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_render_pipeline_state_at_index(
            &self,
            pipeline: Option<&ProtocolObject<dyn MTLRenderPipelineState>>,
            index: NSUInteger,
        );

        #[cfg(all(feature = "MTLAllocation", feature = "MTLRenderPipeline"))]
        /// Set an array of render pipeline states at a given bind point index range
        ///
        /// # Safety
        ///
        /// - `pipelines` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setRenderPipelineStates:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_render_pipeline_states_with_range(
            &self,
            pipelines: NonNull<*const ProtocolObject<dyn MTLRenderPipelineState>>,
            range: NSRange,
        );

        #[cfg(all(feature = "MTLAllocation", feature = "MTLComputePipeline"))]
        /// Sets a compute pipeline state at a given bind point index
        ///
        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(setComputePipelineState:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_compute_pipeline_state_at_index(
            &self,
            pipeline: Option<&ProtocolObject<dyn MTLComputePipelineState>>,
            index: NSUInteger,
        );

        #[cfg(all(feature = "MTLAllocation", feature = "MTLComputePipeline"))]
        /// Set an array of compute pipeline states at a given bind point index range
        ///
        /// # Safety
        ///
        /// - `pipelines` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setComputePipelineStates:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_compute_pipeline_states_with_range(
            &self,
            pipelines: NonNull<*const ProtocolObject<dyn MTLComputePipelineState>>,
            range: NSRange,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLIndirectCommandBuffer",
            feature = "MTLResource"
        ))]
        /// Sets an indirect command buffer at a given bind point index
        ///
        /// # Safety
        ///
        /// - `indirect_command_buffer` may need to be synchronized.
        /// - `indirect_command_buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setIndirectCommandBuffer:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_indirect_command_buffer_at_index(
            &self,
            indirect_command_buffer: Option<&ProtocolObject<dyn MTLIndirectCommandBuffer>>,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLIndirectCommandBuffer",
            feature = "MTLResource"
        ))]
        /// Set an array of indirect command buffers at the given bind point index range.
        ///
        /// # Safety
        ///
        /// - `buffers` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setIndirectCommandBuffers:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_indirect_command_buffers_with_range(
            &self,
            buffers: NonNull<*const ProtocolObject<dyn MTLIndirectCommandBuffer>>,
            range: NSRange,
        );

        #[cfg(all(
            feature = "MTLAccelerationStructure",
            feature = "MTLAllocation",
            feature = "MTLResource"
        ))]
        /// # Safety
        ///
        /// - `acceleration_structure` may need to be synchronized.
        /// - `acceleration_structure` may be unretained, you must ensure it is kept alive while in use.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setAccelerationStructure:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_acceleration_structure_at_index(
            &self,
            acceleration_structure: Option<&ProtocolObject<dyn MTLAccelerationStructure>>,
            index: NSUInteger,
        );

        /// Returns a pointer to a new MTLArgumentEncoder that can be used to encode the an argument buffer
        /// in the buffer associated with a given index.
        /// Returns nil if the resource at the given index is not an argument buffer.
        ///
        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(newArgumentEncoderForBufferAtIndex:))]
        #[unsafe(method_family = new)]
        unsafe fn new_argument_encoder_for_buffer_at_index(
            &self,
            index: NSUInteger,
        ) -> Option<Retained<ProtocolObject<dyn MTLArgumentEncoder>>>;

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLResource",
            feature = "MTLVisibleFunctionTable"
        ))]
        /// Set a visible function table at the given buffer index
        ///
        /// # Safety
        ///
        /// - `visible_function_table` may need to be synchronized.
        /// - `visible_function_table` may be unretained, you must ensure it is kept alive while in use.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setVisibleFunctionTable:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_visible_function_table_at_index(
            &self,
            visible_function_table: Option<&ProtocolObject<dyn MTLVisibleFunctionTable>>,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLResource",
            feature = "MTLVisibleFunctionTable"
        ))]
        /// Set visible function tables at the given buffer index range
        ///
        /// # Safety
        ///
        /// - `visible_function_tables` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setVisibleFunctionTables:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_visible_function_tables_with_range(
            &self,
            visible_function_tables: NonNull<*const ProtocolObject<dyn MTLVisibleFunctionTable>>,
            range: NSRange,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLIntersectionFunctionTable",
            feature = "MTLResource"
        ))]
        /// Set an intersection function table at the given buffer index
        ///
        /// # Safety
        ///
        /// - `intersection_function_table` may need to be synchronized.
        /// - `intersection_function_table` may be unretained, you must ensure it is kept alive while in use.
        /// - `index` might not be bounds-checked.
        #[unsafe(method(setIntersectionFunctionTable:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_intersection_function_table_at_index(
            &self,
            intersection_function_table: Option<&ProtocolObject<dyn MTLIntersectionFunctionTable>>,
            index: NSUInteger,
        );

        #[cfg(all(
            feature = "MTLAllocation",
            feature = "MTLIntersectionFunctionTable",
            feature = "MTLResource"
        ))]
        /// Set intersection function tables at the given buffer index range
        ///
        /// # Safety
        ///
        /// - `intersection_function_tables` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setIntersectionFunctionTables:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_intersection_function_tables_with_range(
            &self,
            intersection_function_tables: NonNull<
                *const ProtocolObject<dyn MTLIntersectionFunctionTable>,
            >,
            range: NSRange,
        );

        #[cfg(feature = "MTLDepthStencil")]
        /// Sets a depth stencil state at a given bind point index
        ///
        /// # Safety
        ///
        /// `index` might not be bounds-checked.
        #[unsafe(method(setDepthStencilState:atIndex:))]
        #[unsafe(method_family = none)]
        unsafe fn set_depth_stencil_state_at_index(
            &self,
            depth_stencil_state: Option<&ProtocolObject<dyn MTLDepthStencilState>>,
            index: NSUInteger,
        );

        #[cfg(feature = "MTLDepthStencil")]
        /// Sets an array of depth stencil states at a given buffer index range
        ///
        /// # Safety
        ///
        /// - `depth_stencil_states` must be a valid pointer.
        /// - `range` might not be bounds-checked.
        #[unsafe(method(setDepthStencilStates:withRange:))]
        #[unsafe(method_family = none)]
        unsafe fn set_depth_stencil_states_with_range(
            &self,
            depth_stencil_states: NonNull<*const ProtocolObject<dyn MTLDepthStencilState>>,
            range: NSRange,
        );
    }
);
