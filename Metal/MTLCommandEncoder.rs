//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Options that describe how a graphics or compute function uses an argument buffer’s resource.
///
/// ## Overview
///
/// You can combine multiple [`MTLResourceUsage`](https://developer.apple.com/documentation/metal/mtlresourceusage) values with a bitwise OR (`|`) if the resource serves multiple purposes over its lifetime. You can enable options for certain resources that indicate whether the Metal driver needs to convert the resource to another format, such as whether it needs to decompress a color render target.
///
///
/// Describes how a resource will be used by a shader through an argument buffer
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLResourceUsage(pub NSUInteger);
bitflags::bitflags! {
    impl MTLResourceUsage: NSUInteger {
/// An option that enables reading from the resource.
        #[doc(alias = "MTLResourceUsageRead")]
        const Read = 1<<0;
/// An option that enables writing to the resource.
        #[doc(alias = "MTLResourceUsageWrite")]
        const Write = 1<<1;
/// An option that enables sampling from the resource.
///
/// ## Discussion
///
/// Specify this option only if the resource is a texture.
///
///
        #[doc(alias = "MTLResourceUsageSample")]
#[deprecated]
        const Sample = 1<<2;
    }
}

unsafe impl Encode for MTLResourceUsage {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLResourceUsage {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes the types of resources that a barrier operates on.
/// Describes the types of resources that the a barrier operates on
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLBarrierScope(pub NSUInteger);
bitflags::bitflags! {
    impl MTLBarrierScope: NSUInteger {
/// The barrier affects any buffer objects.
        #[doc(alias = "MTLBarrierScopeBuffers")]
        const Buffers = 1<<0;
/// The barrier affects textures.
        #[doc(alias = "MTLBarrierScopeTextures")]
        const Textures = 1<<1;
/// The barrier affects any render targets.
        #[doc(alias = "MTLBarrierScopeRenderTargets")]
        const RenderTargets = 1<<2;
    }
}

unsafe impl Encode for MTLBarrierScope {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLBarrierScope {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes stages of GPU work.
///
/// ## Overview
///
/// All commands you encoder into command buffers relate to one or more shader stages, for example, a compute dispatch command from a compute command encoder relates to stage [`MTLStageDispatch`](https://developer.apple.com/documentation/metal/mtlstages/dispatch).
///
/// Use these stages to issue barriers between shader stages to ensure Metal correctly synchronizes GPU commands.
///
///
/// Describes stages of GPU work.
///
/// All commands you encoder into command buffers relate to one or more shader stages,
/// for example, a compute dispatch command from a compute command encoder relates to
/// stage ``MTLStageDispatch``.
///
/// Use these stages to issue barriers between shader stages to ensure Metal correctly
/// synchronizes GPU commands.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLStages(pub NSUInteger);
bitflags::bitflags! {
    impl MTLStages: NSUInteger {
/// Represents all vertex shader stage work in a render pass.
/// Represents all vertex shader stage work in a render pass.
        #[doc(alias = "MTLStageVertex")]
        const Vertex = 1<<0;
/// Represents all fragment shader stage work in a render pass.
/// Represents all fragment shader stage work in a render pass.
        #[doc(alias = "MTLStageFragment")]
        const Fragment = 1<<1;
/// Represents all tile shading stage work in a render pass.
/// Represents all tile shading stage work in a render pass.
        #[doc(alias = "MTLStageTile")]
        const Tile = 1<<2;
/// Represents all object shader stage work in a render pass.
/// Represents all object shader stage work in a render pass.
        #[doc(alias = "MTLStageObject")]
        const Object = 1<<3;
/// Represents all mesh shader stage work work in a render pass.
/// Represents all mesh shader stage work work in a render pass.
        #[doc(alias = "MTLStageMesh")]
        const Mesh = 1<<4;
/// Represents all sparse and placement sparse resource mapping updates.
/// Represents all sparse and placement sparse resource mapping updates.
        #[doc(alias = "MTLStageResourceState")]
        const ResourceState = 1<<26;
/// Represents all compute dispatches in a compute pass.
/// Represents all compute dispatches in a compute pass.
        #[doc(alias = "MTLStageDispatch")]
        const Dispatch = 1<<27;
/// Represents all blit operations in a pass.
/// Represents all blit operations in a pass.
        #[doc(alias = "MTLStageBlit")]
        const Blit = 1<<28;
/// Represents all acceleration structure operations.
/// Represents all acceleration structure operations.
        #[doc(alias = "MTLStageAccelerationStructure")]
        const AccelerationStructure = 1<<29;
/// Represents all machine learning network dispatch operations.
/// Represents all machine learning network dispatch operations.
        #[doc(alias = "MTLStageMachineLearning")]
        const MachineLearning = 1<<30;
/// Convenience mask representing all stages of GPU work.
/// Convenience mask representing all stages of GPU work.
        #[doc(alias = "MTLStageAll")]
        const All = NSIntegerMax as _;
    }
}

unsafe impl Encode for MTLStages {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLStages {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// An encoder that writes GPU commands into a command buffer.
    ///
    /// ## Overview
    ///
    /// Don’t implement this protocol yourself; instead you call methods on an [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) instance to create command encoders. Command encoder instances are lightweight instances that you re-create every time you need to send commands to the GPU.
    ///
    /// There are many different kinds of command encoders, each providing a different set of commands that can be encoded into the buffer. A command encoder implements the [`MTLCommandEncoder`](https://developer.apple.com/documentation/metal/mtlcommandencoder) protocol and an additional protocol specific to the kind of encoder being created.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Protocol" }] }], [Paragraph { inline_content: [Text { text: "Task" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.metal/documentation/Metal/MTLRenderCommandEncoder", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Graphics rendering" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.metal/documentation/Metal/MTLComputeCommandEncoder", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Computation" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.metal/documentation/Metal/MTLBlitCommandEncoder", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Memory management" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.metal/documentation/Metal/MTLParallelRenderCommandEncoder", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Multiple graphics rendering tasks encoded in parallel." }] }]]], alignments: None, metadata: None })
    /// While a command encoder is active, it has the exclusive right to append commands to its command buffer. Once you finish encoding commands, call the [`endEncoding`](https://developer.apple.com/documentation/metal/mtlcommandencoder/endencoding()) method to finish encoding the commands. To write further commands into the same command buffer, create a new command encoder.
    ///
    /// You can call the [`insertDebugSignpost:`](https://developer.apple.com/documentation/metal/mtlcommandencoder/insertdebugsignpost(_:)), [`pushDebugGroup:`](https://developer.apple.com/documentation/metal/mtlcommandencoder/pushdebuggroup(_:)), and [`popDebugGroup`](https://developer.apple.com/documentation/metal/mtlcommandencoder/popdebuggroup()) methods to put debug strings into the command buffer and to push or pop string labels used to identify groups of encoded commands. These methods don’t change the rendering or compute behavior of your app; the Xcode debugger uses them to organize your app’s rendering commands in a format that may provide insight into how your app works.
    ///
    ///
    /// MTLCommandEncoder is the common interface for objects that write commands into MTLCommandBuffers.
    pub unsafe trait MTLCommandEncoder: NSObjectProtocol {
        #[cfg(feature = "MTLDevice")]
        /// The device this resource was created against.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);

        /// Declare that all command generation from this encoder is complete, and detach from the MTLCommandBuffer.
        #[unsafe(method(endEncoding))]
        #[unsafe(method_family = none)]
        fn endEncoding(&self);

        /// Encodes a consumer barrier on work you commit to the same command queue.
        ///
        /// Encode a barrier that guarantees that any subsequent work you encode in the current command encoder that corresponds
        /// to the `beforeStages` stages doesn't proceed until Metal completes all work prior to the current command encoder
        /// corresponding to the `afterQueueStages` stages, completes.
        ///
        /// Metal can reorder the exact point where it applies the barrier, so use this method for synchronizing between different passes.
        ///
        /// If you need to synchronize work within a pass that you encode with an instance of a subclass of ``MTLCommandEncoder``,
        /// use memory barriers instead. For subclasses of ``MTL4CommandEncoder``, use encoder barriers.
        ///
        /// You can specify `afterQueueStages` and `beforeStages` that contain ``MTLStages`` unrelated to the current command
        /// encoder.
        ///
        /// - Parameters:
        /// - afterQueueStages: ``MTLStages`` mask that represents the stages of work to wait for.
        /// This argument applies to work corresponding to these stages you
        /// encode in prior command encoders, and not for the current encoder.
        /// - beforeStages:     ``MTLStages`` mask that represents the stages of work that wait.
        /// This argument applies to work you encode in the current command encoder.
        #[unsafe(method(barrierAfterQueueStages:beforeStages:))]
        #[unsafe(method_family = none)]
        fn barrierAfterQueueStages_beforeStages(
            &self,
            after_queue_stages: MTLStages,
            before_stages: MTLStages,
        );

        /// Inserts a debug string into the command buffer.  This does not change any API behavior, but can be useful when debugging.
        #[unsafe(method(insertDebugSignpost:))]
        #[unsafe(method_family = none)]
        fn insertDebugSignpost(&self, string: &NSString);

        /// Push a new named string onto a stack of string labels.
        #[unsafe(method(pushDebugGroup:))]
        #[unsafe(method_family = none)]
        fn pushDebugGroup(&self, string: &NSString);

        /// Pop the latest named string off of the stack.
        #[unsafe(method(popDebugGroup))]
        #[unsafe(method_family = none)]
        fn popDebugGroup(&self);
    }
);
