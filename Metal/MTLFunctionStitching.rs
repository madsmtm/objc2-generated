//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A bitfield of options to create a stitched library
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLStitchedLibraryOptions(pub NSUInteger);
bitflags::bitflags! {
    impl MTLStitchedLibraryOptions: NSUInteger {
        #[doc(alias = "MTLStitchedLibraryOptionNone")]
        const None = 0;
/// Library creation fails (i.e nil is returned) if:
/// - A lookup binary archive has been specified
/// - The library has not been found in the archive
        #[doc(alias = "MTLStitchedLibraryOptionFailOnBinaryArchiveMiss")]
        const FailOnBinaryArchiveMiss = 1<<0;
/// stores and tracks this library in a Metal Pipelines Script
/// This flag is optional and only supported in the context of binary archives.
///
/// This flag is required for inspecting and consuming binary archives with stitched libraries via the metal-source tool. It is not required for recompilation, nor for storing stitched libraries in binary archives. Set this flag only if you intend to use metal-source on a serialized binary archive.
        #[doc(alias = "MTLStitchedLibraryOptionStoreLibraryInMetalPipelinesScript")]
        const StoreLibraryInMetalPipelinesScript = 1<<1;
    }
}

unsafe impl Encode for MTLStitchedLibraryOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLStitchedLibraryOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A protocol to identify types that customize how the Metal compiler stitches a function together.
    /// An attribute to be applied to the produced stitched function.
    pub unsafe trait MTLFunctionStitchingAttribute: NSObjectProtocol {}
);

extern_class!(
    /// An attribute to specify that Metal needs to inline all of the function calls when generating the stitched function.
    ///
    /// ## Overview
    ///
    /// To inline functions in a call graph, instantiate an instance of this class and assign it as an attribute on the [`MTLFunctionStitchingGraph`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph).
    ///
    ///
    /// Applies the `__attribute__((always_inline))` attribute to the produced stitched function.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLFunctionStitchingAttributeAlwaysInline;
);

extern_conformance!(
    unsafe impl MTLFunctionStitchingAttribute for MTLFunctionStitchingAttributeAlwaysInline {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLFunctionStitchingAttributeAlwaysInline {}
);

impl MTLFunctionStitchingAttributeAlwaysInline {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl MTLFunctionStitchingAttributeAlwaysInline {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLFunctionStitchingAttributeAlwaysInline {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// A protocol to identify call graph nodes.
    /// A node used in a graph for stitching.
    pub unsafe trait MTLFunctionStitchingNode: NSObjectProtocol + NSCopying {}
);

extern_class!(
    /// A call graph node that describes an input to the call graph.
    ///
    /// ## Overview
    ///
    /// An input node contains data from one of the stitched function’s parameters. The output data type of an input node has the same type as the matching parameter.
    ///
    ///
    /// An indexed input node of the produced stitched function.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLFunctionStitchingInputNode;
);

extern_conformance!(
    unsafe impl MTLFunctionStitchingNode for MTLFunctionStitchingInputNode {}
);

extern_conformance!(
    unsafe impl NSCopying for MTLFunctionStitchingInputNode {}
);

unsafe impl CopyingHelper for MTLFunctionStitchingInputNode {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLFunctionStitchingInputNode {}
);

impl MTLFunctionStitchingInputNode {
    extern_methods!(
        #[unsafe(method(argumentIndex))]
        #[unsafe(method_family = none)]
        pub fn argumentIndex(&self) -> NSUInteger;

        /// Setter for [`argumentIndex`][Self::argumentIndex].
        ///
        /// # Safety
        ///
        /// This might not be bounds-checked.
        #[unsafe(method(setArgumentIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setArgumentIndex(&self, argument_index: NSUInteger);

        /// # Safety
        ///
        /// This might not be bounds-checked.
        #[unsafe(method(initWithArgumentIndex:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithArgumentIndex(
            this: Allocated<Self>,
            argument: NSUInteger,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLFunctionStitchingInputNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLFunctionStitchingInputNode {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A call graph node that describes a function call and its inputs.
    ///
    /// ## Overview
    ///
    /// When the Metal device object evaluates the function graph to compile the stitched function, it evaluates the nodes stored in the [`arguments`](https://developer.apple.com/documentation/metal/mtlfunctionstitchingfunctionnode/arguments) property that it hasn’t already evaluated, and then calls the function specified by [`name`](https://developer.apple.com/documentation/metal/mtlfunctionstitchingfunctionnode/name) to generate the node’s output.
    ///
    /// If the function has side effects on the input data, use the [`controlDependencies`](https://developer.apple.com/documentation/metal/mtlfunctionstitchingfunctionnode/controldependencies) property on other nodes to specify whether the Metal device object must evaluate this node first.
    ///
    ///
    /// A function node that calls the specified function with arguments and ordering determined by data and control dependencies.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLFunctionStitchingFunctionNode;
);

extern_conformance!(
    unsafe impl MTLFunctionStitchingNode for MTLFunctionStitchingFunctionNode {}
);

extern_conformance!(
    unsafe impl NSCopying for MTLFunctionStitchingFunctionNode {}
);

unsafe impl CopyingHelper for MTLFunctionStitchingFunctionNode {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLFunctionStitchingFunctionNode {}
);

impl MTLFunctionStitchingFunctionNode {
    extern_methods!(
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Retained<NSString>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub fn setName(&self, name: &NSString);

        #[unsafe(method(arguments))]
        #[unsafe(method_family = none)]
        pub fn arguments(&self) -> Retained<NSArray<ProtocolObject<dyn MTLFunctionStitchingNode>>>;

        /// Setter for [`arguments`][Self::arguments].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setArguments:))]
        #[unsafe(method_family = none)]
        pub fn setArguments(
            &self,
            arguments: &NSArray<ProtocolObject<dyn MTLFunctionStitchingNode>>,
        );

        #[unsafe(method(controlDependencies))]
        #[unsafe(method_family = none)]
        pub fn controlDependencies(&self) -> Retained<NSArray<MTLFunctionStitchingFunctionNode>>;

        /// Setter for [`controlDependencies`][Self::controlDependencies].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setControlDependencies:))]
        #[unsafe(method_family = none)]
        pub fn setControlDependencies(
            &self,
            control_dependencies: &NSArray<MTLFunctionStitchingFunctionNode>,
        );

        #[unsafe(method(initWithName:arguments:controlDependencies:))]
        #[unsafe(method_family = init)]
        pub fn initWithName_arguments_controlDependencies(
            this: Allocated<Self>,
            name: &NSString,
            arguments: &NSArray<ProtocolObject<dyn MTLFunctionStitchingNode>>,
            control_dependencies: &NSArray<MTLFunctionStitchingFunctionNode>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLFunctionStitchingFunctionNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLFunctionStitchingFunctionNode {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A description of a new stitched function.
    ///
    /// ## Overview
    ///
    /// An [`MTLFunctionStitchingGraph`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph) instance describes the function graph for a stitched function. A _stitched function_ is a visible function you create by composing other Metal shader functions together in a function graph. A function stitching graph contains nodes for the function’s arguments and any functions it calls in the implementation. Data flows from the arguments to the end of the graph until the stitched function evaluates all of the graph’s nodes.
    ///
    /// The graph in the figure below constructs a new function that adds numbers from two source arrays, storing the result in a third array. The function’s parameters are pointers to the source and destination arrays, and an index for performing the array lookup. The graph uses three separate MSL functions to construct the stitched function: a function to look up a value from an array, a function that adds two numbers together, and a function that stores a value to an array.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/f123f8a3ffeb3749a42fabbe146c4239/media-3842304~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/76256ecf7b056395a2c570d8dc8b2570/media-3842304%402x.png 2x" />
    ///     <img alt="A function graph with four columns. The first column shows the function’s arguments, which consist of two source arrays, an index, and a destination array. The second column shows two function calls to look up numbers in the source arrays in the first column. The third column shows a function call to add the numbers, and the final column calls a function to store the sum to the destination array in the first column." src="https://docs-assets.developer.apple.com/published/f123f8a3ffeb3749a42fabbe146c4239/media-3842304~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// Create an [`MTLFunctionStitchingGraph`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph) instance for each stitched function you want to create. Configure its properties to describe the new function and the nodes that define its behavior, as described below. To create a new library with these stitched functions, see [`MTLStitchedLibraryDescriptor`](https://developer.apple.com/documentation/metal/mtlstitchedlibrarydescriptor).
    ///
    /// ### Configuring a function stitching graph
    ///
    /// To create a valid stitched function, the function stitching graph and shader code must meet some requirements:
    ///
    /// - Implement the MSL functions that you use to create the new function, adding the `stitchable` attribute to each. Stitchable functions are visible functions that you can also use in a function graph. Stitchable functions may require the compiler to do additional work or emit larger instance code, so mark functions as stitchable only when necessary.
    ///
    /// - Declare the stitched function’s name and signature in a header file to include in any shader code that calls the new function. Alternatively, you can add the function to a function table with a matching type and pass the function table as an argument.
    ///
    /// - Create an [`MTLFunctionStitchingInputNode`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinginputnode) node for each of the function’s arguments, specifying which parameter each node references. The output type of each input node is the type of that parameter in your function signature.
    ///
    /// - Create an [`MTLFunctionStitchingFunctionNode`](https://developer.apple.com/documentation/metal/mtlfunctionstitchingfunctionnode) for each function the implementation calls. A function node’s output type is the return type of the MSL function.
    ///
    /// - Make sure the output types of each node match the types of the node they pass to. For example, if a function takes a `float` parameter, the node that provides that data must output a `float` value. If you don’t match the types correctly, Metal doesn’t define the behavior of the resulting function.
    ///
    /// - Create an array from the node instances and assign it to the [`nodes`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph/nodes) property.
    ///
    /// - If the function produces an output, create another node and assign it to the [`outputNode`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph/outputnode) property. The output type of this node must match the function’s return type. Don’t include this node in the array of nodes you assign to the [`nodes`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph/nodes) property.
    ///
    /// The MSL code below implements the functions in the example graph above, as well as the function’s signature:
    ///
    /// ```metal
    /// [[stitchable]] float add(float a, float b)
    /// {
    ///     return a + b;
    /// }
    ///
    /// [[stitchable]] float lookup(const constant float *a, uint index)
    /// {
    ///     return a[index];
    /// }
    ///
    /// [[stitchable]] float store(float value, device float *a, uint index)
    /// {
    ///     a[index] = value;
    /// }
    ///
    /// // The output function declaration.
    /// [[visible]] void add_arrays(constant float *a, constant float *b, device float*c, uint tid);
    /// ```
    ///
    /// The following code creates the graph above:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Load the functions from the library.", "let functions = [", "    library.makeFunction(name: \"add\"),", "    library.makeFunction(name: \"lookup\"),", "    library.makeFunction(name: \"store\")", "]", "", "// Create nodes for the input parameters.", "let srcA = MTLFunctionStitchingInputNode.init(argumentIndex: 0)", "let srcB = MTLFunctionStitchingInputNode.init(argumentIndex: 1)", "let dest = MTLFunctionStitchingInputNode.init(argumentIndex: 2)", "let index = MTLFunctionStitchingInputNode.init(argumentIndex: 3)", "", "// Create nodes for the functions.", "let lookup_a = MTLFunctionStitchingFunctionNode.init(name: \"read\", arguments: [srcA, index], controlDependencies: [])", "let lookup_b = MTLFunctionStitchingFunctionNode.init(name: \"read\", arguments: [srcB, index], controlDependencies: [])", "let sum = MTLFunctionStitchingFunctionNode.init(name: \"add\", arguments: [lookup_a, lookup_b], controlDependencies: [])", "let store = MTLFunctionStitchingFunctionNode.init(name: \"store\", arguments: [sum, dest, index], controlDependencies: [])", "", "// Create the stitching graph.", "let graph = MTLFunctionStitchingGraph.init(functionName: \"add_arrays\", nodes: [lookup_a, lookup_b, sum, store], outputNode: nil, attributes: [])"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objective-c"), code: ["// Load the functions from the library.", "NSArray *functions = @[", "    [library newFunctionWithName:@\"add\"],", "    [library newFunctionWithName:@\"lookup\"],", "    [library newFunctionWithName:@\"store\"],", "];", "", "// Create nodes for the input parameters.", "MTLFunctionStitchingInputNode *srcA = [[MTLFunctionStitchingInputNode alloc] initWithArgumentIndex:0];", "MTLFunctionStitchingInputNode *srcB = [[MTLFunctionStitchingInputNode alloc] initWithArgumentIndex:1];", "MTLFunctionStitchingInputNode *dest = [[MTLFunctionStitchingInputNode alloc] initWithArgumentIndex:2];", "MTLFunctionStitchingInputNode *index = [[MTLFunctionStitchingInputNode alloc] initWithArgumentIndex:3];", "", "// Create nodes for the functions.", "MTLFunctionStitchingFunctionNode *lookup_a =", "    [[MTLFunctionStitchingFunctionNode alloc] initWithName:@\"read\" arguments:@[srcA, index] controlDependencies:@[]];", "MTLFunctionStitchingFunctionNode *lookup_b =", "    [[MTLFunctionStitchingFunctionNode alloc] initWithName:@\"read\" arguments:@[srcB, index] controlDependencies:@[]];", "MTLFunctionStitchingFunctionNode *sum =", "    [[MTLFunctionStitchingFunctionNode alloc] initWithName:@\"add\" arguments:@[lookup_a, lookup_b] controlDependencies:@[]];", "MTLFunctionStitchingFunctionNode *store =", "    [[MTLFunctionStitchingFunctionNode alloc] initWithName:@\"store\" arguments:@[sum, dest, index] controlDependencies:@[]];", "", "// Create the stitching graph.", "MTLFunctionStitchingGraph *graph =", "    [[MTLFunctionStitchingGraph alloc] initWithFunctionName:@\"add_arrays\" nodes:@[lookup_a, lookup_b, sum, store]", "                                                 outputNode:nil attributes:@[]];"], metadata: None }] }] })
    ///
    /// A function graph that describes a directed acyclic graph.
    ///
    /// The return value of the output node will be used as the return value for the final stitched graph.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLFunctionStitchingGraph;
);

extern_conformance!(
    unsafe impl NSCopying for MTLFunctionStitchingGraph {}
);

unsafe impl CopyingHelper for MTLFunctionStitchingGraph {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLFunctionStitchingGraph {}
);

impl MTLFunctionStitchingGraph {
    extern_methods!(
        #[unsafe(method(functionName))]
        #[unsafe(method_family = none)]
        pub fn functionName(&self) -> Retained<NSString>;

        /// Setter for [`functionName`][Self::functionName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFunctionName:))]
        #[unsafe(method_family = none)]
        pub fn setFunctionName(&self, function_name: &NSString);

        #[unsafe(method(nodes))]
        #[unsafe(method_family = none)]
        pub fn nodes(&self) -> Retained<NSArray<MTLFunctionStitchingFunctionNode>>;

        /// Setter for [`nodes`][Self::nodes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setNodes:))]
        #[unsafe(method_family = none)]
        pub fn setNodes(&self, nodes: &NSArray<MTLFunctionStitchingFunctionNode>);

        #[unsafe(method(outputNode))]
        #[unsafe(method_family = none)]
        pub fn outputNode(&self) -> Option<Retained<MTLFunctionStitchingFunctionNode>>;

        /// Setter for [`outputNode`][Self::outputNode].
        #[unsafe(method(setOutputNode:))]
        #[unsafe(method_family = none)]
        pub fn setOutputNode(&self, output_node: Option<&MTLFunctionStitchingFunctionNode>);

        #[unsafe(method(attributes))]
        #[unsafe(method_family = none)]
        pub fn attributes(
            &self,
        ) -> Retained<NSArray<ProtocolObject<dyn MTLFunctionStitchingAttribute>>>;

        /// Setter for [`attributes`][Self::attributes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAttributes:))]
        #[unsafe(method_family = none)]
        pub fn setAttributes(
            &self,
            attributes: &NSArray<ProtocolObject<dyn MTLFunctionStitchingAttribute>>,
        );

        #[unsafe(method(initWithFunctionName:nodes:outputNode:attributes:))]
        #[unsafe(method_family = init)]
        pub fn initWithFunctionName_nodes_outputNode_attributes(
            this: Allocated<Self>,
            function_name: &NSString,
            nodes: &NSArray<MTLFunctionStitchingFunctionNode>,
            output_node: Option<&MTLFunctionStitchingFunctionNode>,
            attributes: &NSArray<ProtocolObject<dyn MTLFunctionStitchingAttribute>>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLFunctionStitchingGraph {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLFunctionStitchingGraph {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A description of a new library of procedurally generated functions.
    ///
    /// ## Overview
    ///
    /// An [`MTLStitchedLibraryDescriptor`](https://developer.apple.com/documentation/metal/mtlstitchedlibrarydescriptor) describes a library of new stitched functions. A _stitched function_ is a visible function you create by composing other Metal shader functions together in a function graph.
    ///
    /// Configure a stitched library descriptor by assigning an array of one or more [`MTLFunctionStitchingGraph`](https://developer.apple.com/documentation/metal/mtlfunctionstitchinggraph) instances, each describing a stitched function, to the [`functionGraphs`](https://developer.apple.com/documentation/metal/mtlstitchedlibrarydescriptor/functiongraphs) property. Then assign an [`MTLFunction`](https://developer.apple.com/documentation/metal/mtlfunction) array that includes all the functions the graphs depend on to the [`functions`](https://developer.apple.com/documentation/metal/mtlstitchedlibrarydescriptor/functions) property.
    ///
    /// Create a stitched library from the descriptor by passing it to the [`newLibraryWithStitchedDescriptor:error:`](https://developer.apple.com/documentation/metal/mtldevice/makelibrary(stitcheddescriptor:)) method of an [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice). You can change the descriptor to create other libraries without affecting any existing ones.
    ///
    ///
    /// A container for the graphs and functions needed to create the stitched functions described by the graphs.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLStitchedLibraryDescriptor;
);

extern_conformance!(
    unsafe impl NSCopying for MTLStitchedLibraryDescriptor {}
);

unsafe impl CopyingHelper for MTLStitchedLibraryDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLStitchedLibraryDescriptor {}
);

impl MTLStitchedLibraryDescriptor {
    extern_methods!(
        #[unsafe(method(functionGraphs))]
        #[unsafe(method_family = none)]
        pub fn functionGraphs(&self) -> Retained<NSArray<MTLFunctionStitchingGraph>>;

        /// Setter for [`functionGraphs`][Self::functionGraphs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFunctionGraphs:))]
        #[unsafe(method_family = none)]
        pub fn setFunctionGraphs(&self, function_graphs: &NSArray<MTLFunctionStitchingGraph>);

        #[cfg(feature = "MTLLibrary")]
        #[unsafe(method(functions))]
        #[unsafe(method_family = none)]
        pub fn functions(&self) -> Retained<NSArray<ProtocolObject<dyn MTLFunction>>>;

        #[cfg(feature = "MTLLibrary")]
        /// Setter for [`functions`][Self::functions].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// - `functions` generic must be safe to call.
        /// - `functions` generic must have the correct argument and return types.
        #[unsafe(method(setFunctions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFunctions(&self, functions: &NSArray<ProtocolObject<dyn MTLFunction>>);

        #[cfg(feature = "MTLBinaryArchive")]
        /// The array of archives to be searched.
        ///
        /// Binary archives to be searched for precompiled stitched libraries during the compilation of this library.
        #[unsafe(method(binaryArchives))]
        #[unsafe(method_family = none)]
        pub fn binaryArchives(&self) -> Retained<NSArray<ProtocolObject<dyn MTLBinaryArchive>>>;

        #[cfg(feature = "MTLBinaryArchive")]
        /// Setter for [`binaryArchives`][Self::binaryArchives].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBinaryArchives:))]
        #[unsafe(method_family = none)]
        pub fn setBinaryArchives(
            &self,
            binary_archives: &NSArray<ProtocolObject<dyn MTLBinaryArchive>>,
        );

        /// The options to use for this new MTLLibrary.
        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        pub fn options(&self) -> MTLStitchedLibraryOptions;

        /// Setter for [`options`][Self::options].
        #[unsafe(method(setOptions:))]
        #[unsafe(method_family = none)]
        pub fn setOptions(&self, options: MTLStitchedLibraryOptions);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLStitchedLibraryDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLStitchedLibraryDescriptor {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
