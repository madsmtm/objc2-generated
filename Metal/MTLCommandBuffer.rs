//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// The discrete states for a command buffer that represent its life cycle stages.
/// MTLCommandBufferStatus reports the current stage in the lifetime of MTLCommandBuffer, as it proceeds to enqueued, committed, scheduled, and completed.
///
///
/// The command buffer has not been enqueued yet.
///
///
/// This command buffer is enqueued, but not committed.
///
///
/// Commited to its command queue, but not yet scheduled for execution.
///
///
/// All dependencies have been resolved and the command buffer has been scheduled for execution.
///
///
/// The command buffer has finished executing successfully: any blocks set with -addCompletedHandler: may now be called.
///
///
/// Execution of the command buffer was aborted due to an error during execution.  Check -error for more information.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLCommandBufferStatus(pub NSUInteger);
impl MTLCommandBufferStatus {
    /// A command buffer’s initial state, which indicates its command queue isn’t reserving a place for it.
    ///
    /// ## Discussion
    ///
    /// See the [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) protocol’s [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property for more information.
    ///
    ///
    #[doc(alias = "MTLCommandBufferStatusNotEnqueued")]
    pub const NotEnqueued: Self = Self(0);
    /// A command buffer’s second state, which indicates its command queue is reserving a place for it.
    ///
    /// ## Discussion
    ///
    /// See the [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) protocol’s [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property for more information.
    ///
    ///
    #[doc(alias = "MTLCommandBufferStatusEnqueued")]
    pub const Enqueued: Self = Self(1);
    /// A command buffer’s third state, which indicates the command queue is preparing to schedule the command buffer by resolving its dependencies.
    ///
    /// ## Discussion
    ///
    /// See the [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) protocol’s [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property for more information.
    ///
    ///
    #[doc(alias = "MTLCommandBufferStatusCommitted")]
    pub const Committed: Self = Self(2);
    /// A command buffer’s fourth state, which indicates the command buffer has its resources ready and is waiting for the GPU to run its commands.
    ///
    /// ## Discussion
    ///
    /// See the [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) protocol’s [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property for more information.
    ///
    ///
    #[doc(alias = "MTLCommandBufferStatusScheduled")]
    pub const Scheduled: Self = Self(3);
    /// A command buffer’s successful, final state, which indicates the GPU finished running the command buffer’s commands without any problems.
    ///
    /// ## Discussion
    ///
    /// See the [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) protocol’s [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property for more information.
    ///
    ///
    #[doc(alias = "MTLCommandBufferStatusCompleted")]
    pub const Completed: Self = Self(4);
    /// A command buffer’s unsuccessful, final state, which indicates the GPU stopped running the buffer’s commands because of a runtime issue.
    ///
    /// ## Discussion
    ///
    /// See the [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) protocol’s [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property for more information. When a command buffer’s status is equal to [`MTLCommandBufferStatusError`](https://developer.apple.com/documentation/metal/mtlcommandbufferstatus/error), check its [`error`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/error) property for more details about the issue. See [Command buffer debugging](https://developer.apple.com/documentation/metal/command-buffer-debugging) for more methods properties that can help you identify the issue.
    ///
    ///
    #[doc(alias = "MTLCommandBufferStatusError")]
    pub const Error: Self = Self(5);
}

unsafe impl Encode for MTLCommandBufferStatus {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandBufferStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain for Metal command buffer errors.
    /// An error domain for NSError objects produced by MTLCommandBuffer
    pub static MTLCommandBufferErrorDomain: &'static NSErrorDomain;
}

/// Error codes that indicate why a GPU is unable to finish running a command buffer.
/// Error codes that can be found in MTLCommandBuffer.error
///
///
/// An internal error that doesn't fit into the other categories. The actual low level error code is encoded in the local description.
///
///
/// Execution of this command buffer took too long, execution of this command was interrupted and aborted.
///
///
/// Execution of this command buffer generated an unserviceable GPU page fault. This can caused by buffer read write attribute mismatch or out of boundary access.
///
///
/// Access to this device has been revoked because this client has been responsible for too many timeouts or hangs.
///
///
/// This process does not have access to use this device.
///
///
/// Insufficient memory was available to execute this command buffer.
///
///
/// The command buffer referenced an invalid resource.  This is most commonly caused when the caller deletes a resource before executing a command buffer that refers to it.
///
///
/// One or more internal resources limits reached that prevent using memoryless render pass attachments. See error string for more detail.
///
///
/// The device was physically removed before the command could finish execution
///
///
/// Execution of the command buffer was stopped due to Stack Overflow Exception. [MTLComputePipelineDescriptor maxCallStackDepth] setting needs to be checked.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLCommandBufferError(pub NSUInteger);
impl MTLCommandBufferError {
    /// An error code that represents the absence of any problems.
    #[doc(alias = "MTLCommandBufferErrorNone")]
    pub const None: Self = Self(0);
    /// An error code that indicates the Metal framework has an internal problem.
    ///
    /// ## Discussion
    ///
    /// The local description contains the underlying error code. You can report the scenario that generated this error code with [Feedback Assistant](https://feedbackassistant.apple.com).
    ///
    ///
    #[doc(alias = "MTLCommandBufferErrorInternal")]
    pub const Internal: Self = Self(1);
    /// An error code that indicates the system interrupted and terminated the command buffer because it took more time to execute than the system allows.
    #[doc(alias = "MTLCommandBufferErrorTimeout")]
    pub const Timeout: Self = Self(2);
    /// An error code that indicates the command buffer generated a page fault the GPU can’t service.
    ///
    /// ## Discussion
    ///
    /// The underlying cause may be a buffer read/write attribute mismatch or an out-of-boundary access.
    ///
    ///
    #[doc(alias = "MTLCommandBufferErrorPageFault")]
    pub const PageFault: Self = Self(3);
    /// A former error code that indicates the system has revoked the Metal device’s access because it’s responsible for too many timeouts or hangs.
    #[doc(alias = "MTLCommandBufferErrorBlacklisted")]
    #[deprecated]
    pub const Blacklisted: Self = Self(4);
    /// An error code that indicates the system has revoked the Metal device’s access because it’s responsible for too many timeouts or hangs.
    #[doc(alias = "MTLCommandBufferErrorAccessRevoked")]
    pub const AccessRevoked: Self = Self(4);
    /// An error code that indicates a process doesn’t have access to a GPU device.
    #[doc(alias = "MTLCommandBufferErrorNotPermitted")]
    pub const NotPermitted: Self = Self(7);
    /// An error code that indicates the GPU device doesn’t have sufficient memory to execute a command buffer.
    #[doc(alias = "MTLCommandBufferErrorOutOfMemory")]
    pub const OutOfMemory: Self = Self(8);
    /// An error code that indicates the command buffer has an invalid reference to resource.
    ///
    /// ## Discussion
    ///
    /// Typically, apps trigger this error by deleting a resource and then running a command buffer that refers to it.
    ///
    ///
    #[doc(alias = "MTLCommandBufferErrorInvalidResource")]
    pub const InvalidResource: Self = Self(9);
    /// An error code that indicates the GPU ran out of one or more of its internal resources that support memoryless render pass attachments.
    ///
    /// ## Discussion
    ///
    /// See the error string for more details.
    ///
    ///
    #[doc(alias = "MTLCommandBufferErrorMemoryless")]
    pub const Memoryless: Self = Self(10);
    /// An error code that indicates a person physically removed the GPU device before the command buffer finished running.
    #[doc(alias = "MTLCommandBufferErrorDeviceRemoved")]
    pub const DeviceRemoved: Self = Self(11);
    /// An error code that indicates the GPU terminated the command buffer because a kernel function of tile shader used too many stack frames.
    ///
    /// ## Discussion
    ///
    /// You can set the largest number of stack frames your pipelines by configuring these properties:
    ///
    /// - [`MTLComputePipelineDescriptor`](https://developer.apple.com/documentation/metal/mtlcomputepipelinedescriptor)`.`[`maxCallStackDepth`](https://developer.apple.com/documentation/metal/mtlcomputepipelinedescriptor/maxcallstackdepth) for kernel functions
    ///
    /// - [`MTLTileRenderPipelineDescriptor`](https://developer.apple.com/documentation/metal/mtltilerenderpipelinedescriptor)`.`[`maxCallStackDepth`](https://developer.apple.com/documentation/metal/mtltilerenderpipelinedescriptor/maxcallstackdepth) for tile shaders
    ///
    ///
    #[doc(alias = "MTLCommandBufferErrorStackOverflow")]
    pub const StackOverflow: Self = Self(12);
}

unsafe impl Encode for MTLCommandBufferError {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandBufferError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A key to a command buffer error’s user information dictionary that retrieves additional information about a GPU’s runtime error.
    ///
    /// ## Discussion
    ///
    /// You can retrieve an [`MTLCommandBufferEncoderInfo`](https://developer.apple.com/documentation/metal/mtlcommandbufferencoderinfo) instance from the [`userInfo`](https://developer.apple.com/documentation/foundation/nserror/userinfo) dictionary of a command buffer’s [`error`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/error) property.
    ///
    ///
    /// Key in the userInfo for MTLCommandBufferError NSErrors. Value is an NSArray of MTLCommandBufferEncoderInfo objects in recorded order if an appropriate MTLCommandBufferErrorOption was set, otherwise the key will not exist in the userInfo dictionary.
    pub static MTLCommandBufferEncoderInfoErrorKey: &'static NSErrorUserInfoKey;
}

/// Options for reporting errors from a command buffer.
/// Options for controlling the error reporting for Metal command buffer objects.
///
///
/// No special error reporting.
///
///
/// Provide the execution status of the individual encoders within the command buffer. In the event of a command buffer error, populate the `userInfo` dictionary of the command buffer's NSError parameter, see MTLCommandBufferEncoderInfoErrorKey and MTLCommandBufferEncoderInfo. Note that enabling this error reporting option may increase CPU, GPU, and/or memory overhead on some platforms; testing for impact is suggested.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLCommandBufferErrorOption(pub NSUInteger);
bitflags::bitflags! {
    impl MTLCommandBufferErrorOption: NSUInteger {
/// An option that clears a command buffer’s error options.
        #[doc(alias = "MTLCommandBufferErrorOptionNone")]
        const None = 0;
/// An option that instructs a command buffer to save additional details about a GPU runtime error.
///
/// ## Discussion
///
/// You can set this option to a command buffer descriptor’s [`errorOptions`](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor/erroroptions) property.
///
/// <div class="warning">
///
/// ### Note
///  Enabling this option can slightly reduce your app’s CPU runtime performance.
///
///
///
/// </div>
///
        #[doc(alias = "MTLCommandBufferErrorOptionEncoderExecutionStatus")]
        const EncoderExecutionStatus = 1<<0;
    }
}

unsafe impl Encode for MTLCommandBufferErrorOption {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandBufferErrorOption {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Possible error conditions for the command encoder’s commands.
/// The error states for a Metal command encoder after command buffer execution.
///
///
/// The state of the commands associated with the encoder is unknown (the error information was likely not requested).
///
///
/// The commands associated with the encoder were completed.
///
///
/// The commands associated with the encoder were affected by an error, which may or may not have been caused by the commands themselves, and failed to execute in full.
///
///
/// The commands associated with the encoder never started execution.
///
///
/// The commands associated with the encoder caused an error.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLCommandEncoderErrorState(pub NSInteger);
impl MTLCommandEncoderErrorState {
    /// An error state that indicates the command buffer doesn’t know the state of its commands on the GPU.
    #[doc(alias = "MTLCommandEncoderErrorStateUnknown")]
    pub const Unknown: Self = Self(0);
    /// A state that indicates the GPU successfully executed the commands without any errors.
    #[doc(alias = "MTLCommandEncoderErrorStateCompleted")]
    pub const Completed: Self = Self(1);
    /// An error state that indicates the GPU failed to fully execute the commands because of an error.
    ///
    /// ## Discussion
    ///
    /// The commands in the command buffer may or may not be responsible for the error.
    ///
    ///
    #[doc(alias = "MTLCommandEncoderErrorStateAffected")]
    pub const Affected: Self = Self(2);
    /// An error state that indicates the GPU didn’t execute the commands.
    #[doc(alias = "MTLCommandEncoderErrorStatePending")]
    pub const Pending: Self = Self(3);
    /// An error state that indicates the commands in the command buffer are the cause of an error.
    #[doc(alias = "MTLCommandEncoderErrorStateFaulted")]
    pub const Faulted: Self = Self(4);
}

unsafe impl Encode for MTLCommandEncoderErrorState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLCommandEncoderErrorState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A configuration that customizes the behavior for a new command buffer.
    ///
    /// ## Overview
    ///
    /// Create a command buffer with a custom configuration by creating an [`MTLCommandBufferDescriptor`](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor) instance and passing it to an [`MTLCommandQueue`](https://developer.apple.com/documentation/metal/mtlcommandqueue) instance’s [`commandBufferWithDescriptor:`](https://developer.apple.com/documentation/metal/mtlcommandqueue/makecommandbuffer(descriptor:)) method. You can configure whether the command buffer retains references to resources that its commands refer to with the [`retainedReferences`](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor/retainedreferences) property. The command buffer can save extra error information, which is useful during development, by setting its [`errorOptions`](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor/erroroptions) property to [`MTLCommandBufferErrorOptionEncoderExecutionStatus`](https://developer.apple.com/documentation/metal/mtlcommandbuffererroroption/encoderexecutionstatus).
    ///
    ///
    /// An object that you use to configure new Metal command buffer objects.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLCommandBufferDescriptor;
);

extern_conformance!(
    unsafe impl NSCopying for MTLCommandBufferDescriptor {}
);

unsafe impl CopyingHelper for MTLCommandBufferDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLCommandBufferDescriptor {}
);

impl MTLCommandBufferDescriptor {
    extern_methods!(
        /// If YES, the created command buffer holds strong references to objects needed for it to execute. If NO, the created command buffer does not hold strong references to objects needed for it to execute.
        #[unsafe(method(retainedReferences))]
        #[unsafe(method_family = none)]
        pub fn retainedReferences(&self) -> bool;

        /// Setter for [`retainedReferences`][Self::retainedReferences].
        #[unsafe(method(setRetainedReferences:))]
        #[unsafe(method_family = none)]
        pub fn setRetainedReferences(&self, retained_references: bool);

        /// A set of options to influence the error reporting of the created command buffer. See MTLCommandBufferErrorOption.
        #[unsafe(method(errorOptions))]
        #[unsafe(method_family = none)]
        pub fn errorOptions(&self) -> MTLCommandBufferErrorOption;

        /// Setter for [`errorOptions`][Self::errorOptions].
        #[unsafe(method(setErrorOptions:))]
        #[unsafe(method_family = none)]
        pub fn setErrorOptions(&self, error_options: MTLCommandBufferErrorOption);

        #[cfg(feature = "MTLLogState")]
        /// Contains information related to shader logging.
        #[unsafe(method(logState))]
        #[unsafe(method_family = none)]
        pub fn logState(&self) -> Option<Retained<ProtocolObject<dyn MTLLogState>>>;

        #[cfg(feature = "MTLLogState")]
        /// Setter for [`logState`][Self::logState].
        #[unsafe(method(setLogState:))]
        #[unsafe(method_family = none)]
        pub fn setLogState(&self, log_state: Option<&ProtocolObject<dyn MTLLogState>>);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLCommandBufferDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLCommandBufferDescriptor {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// A container that provides additional information about a runtime failure a GPU encounters as it runs the commands in a command buffer.
    ///
    /// ## Overview
    ///
    /// To create a command buffer that generates additional information (when a GPU encounters an error running it), configure an [`MTLCommandBufferDescriptor`](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor) instance’s [`errorOptions`](https://developer.apple.com/documentation/metal/mtlcommandbufferdescriptor/erroroptions) property. For information about how to retrieve the information from an [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) instance, see its [`error`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/error) property.
    ///
    ///
    /// Provides execution status information for a Metal command encoder.
    pub unsafe trait MTLCommandBufferEncoderInfo: NSObjectProtocol {
        /// The debug label given to the associated Metal command encoder at command buffer submission.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Retained<NSString>;

        /// The debug signposts inserted into the associated Metal command encoder.
        #[unsafe(method(debugSignposts))]
        #[unsafe(method_family = none)]
        fn debugSignposts(&self) -> Retained<NSArray<NSString>>;

        /// The error state of the associated Metal command encoder.
        #[unsafe(method(errorState))]
        #[unsafe(method_family = none)]
        fn errorState(&self) -> MTLCommandEncoderErrorState;
    }
);

/// A completion handler signature a GPU device calls when it finishes scheduling a command buffer, or when the GPU finishes running it.
///
/// Parameters:
/// - commandBuffer: The [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) instance that’s invoking the completion handler.
///
///
/// ## Discussion
///
/// The [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) type uses this signature in its methods that register your completion handlers, including [`addScheduledHandler:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/addscheduledhandler(_:)) and [`addCompletedHandler:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/addcompletedhandler(_:)).
///
///
#[cfg(feature = "block2")]
pub type MTLCommandBufferHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn MTLCommandBuffer>>)>;

/// The type of dispatch method to use when calling encoded functions.
/// MTLDispatchType Describes how a command encoder will execute dispatched work.
///
///
/// Command encoder dispatches are executed in dispatched order.
///
///
/// Command encoder dispatches are executed in parallel with each other.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLDispatchType(pub NSUInteger);
impl MTLDispatchType {
    /// Sets a command encoder to dispatch encoded commands serially during your pass.
    #[doc(alias = "MTLDispatchTypeSerial")]
    pub const Serial: Self = Self(0);
    /// Sets a command encoder to dispatch encoded commands concurrently during your pass.
    ///
    /// ## Discussion
    ///
    /// If you encode multiple commands that access a single resource, you’re responsible for synchronizing the accesses to that resource. For more information, see [Resource synchronization](https://developer.apple.com/documentation/metal/resource-synchronization).
    ///
    ///
    #[doc(alias = "MTLDispatchTypeConcurrent")]
    pub const Concurrent: Self = Self(1);
}

unsafe impl Encode for MTLDispatchType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLDispatchType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A container that stores a sequence of GPU commands that you encode into it.
    ///
    /// ## Overview
    ///
    /// A command buffer represents a chunk of work for the GPU that stores the commands you encode to it, as well as any resources those commands need. You primarily use a command buffer to:
    ///
    /// - Create command encoders and call their methods to add commands to the buffer
    ///
    /// - Optionally reserve a place for the command buffer in its command queue by _enqueuing_ the command buffer, even before you encode any commands into it
    ///
    /// - Submit, or commit_,_ the contents of the command buffer to the command queue that creates it to run on the GPU device the queue represents
    ///
    /// Create a command encoder from an [`MTLCommandQueue`](https://developer.apple.com/documentation/metal/mtlcommandqueue) instance by calling its [`commandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandqueue/makecommandbuffer()) method. Typically, you create one or more command queues when your app launches and then keep them throughout your app’s lifetime.
    ///
    /// To add commands to an [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) instance, create an encoder from one of its factory methods, including:
    ///
    /// - An [`MTLRenderCommandEncoder`](https://developer.apple.com/documentation/metal/mtlrendercommandencoder) instance by calling [`renderCommandEncoderWithDescriptor:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/makerendercommandencoder(descriptor:))
    ///
    /// - An [`MTLComputeCommandEncoder`](https://developer.apple.com/documentation/metal/mtlcomputecommandencoder) instance by calling [`computeCommandEncoderWithDispatchType:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/makecomputecommandencoder(dispatchtype:))
    ///
    /// - An [`MTLBlitCommandEncoder`](https://developer.apple.com/documentation/metal/mtlblitcommandencoder) instance by calling [`blitCommandEncoder`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/makeblitcommandencoder()) or [`blitCommandEncoderWithDescriptor:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/makeblitcommandencoder(descriptor:))
    ///
    /// - An [`MTLParallelRenderCommandEncoder`](https://developer.apple.com/documentation/metal/mtlparallelrendercommandencoder) instance by calling [`parallelRenderCommandEncoderWithDescriptor:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/makeparallelrendercommandencoder(descriptor:))
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  All encoders inherit additional methods from the [`MTLCommandEncoder`](https://developer.apple.com/documentation/metal/mtlcommandencoder).
    ///
    ///
    ///
    /// </div>
    /// You can use only a single encoder at a time to add commands to a command buffer. To start using a different command encoder, first signal that you’re done with the current encoder by calling its [`endEncoding`](https://developer.apple.com/documentation/metal/mtlcommandencoder/endencoding()) method. Then create another command encoder from the command buffer and continue adding commands to the buffer with the new encoder.
    ///
    /// Repeat the process until you finish encoding commands to the command buffer and are ready to run the buffer’s contents on the GPU. Then submit the command buffer to the command queue that you used to create it by calling the command buffer’s [`commit`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/commit()) method. After an app commits a command buffer, you check its [`status`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/status) property or block a thread by calling its [`waitUntilScheduled`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/waituntilscheduled()) or [`waitUntilCompleted`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/waituntilcompleted()) methods.
    ///
    /// You also have the option to reserve a place for the command buffer in its command queue by calling the command buffer’s [`enqueue`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/enqueue()) method. You can call this method exactly once at any time before you commit the buffer to the queue. If you don’t enqueue a command buffer, it implicitly enqueues itself when you commit it. Each command queue ensures the order that you enqueue its command buffers is the same order the queue schedules them to run on the GPU.
    ///
    /// <div class="warning">
    ///
    /// ### Tip
    ///  Establish an order of execution for multiple command buffers you encode in parallel by first calling their [`enqueue`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/enqueue()) methods in that order.
    ///
    ///
    ///
    /// </div>
    /// For example, a multithreaded app might set the GPU’s execution order for a sequence of related subtasks by:
    ///
    /// 1. Creating a command buffer for each subtask
    ///
    /// 2. Enqueuing the command buffers in the proper order on a single thread
    ///
    /// 3. Encoding commands to each buffer on a separate thread and then committing it
    ///
    ///
    /// A serial list of commands for the device to execute.
    pub unsafe trait MTLCommandBuffer: NSObjectProtocol {
        #[cfg(feature = "MTLDevice")]
        /// The device this resource was created against.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        #[cfg(feature = "MTLCommandQueue")]
        /// The command queue this command buffer was created from.
        #[unsafe(method(commandQueue))]
        #[unsafe(method_family = none)]
        fn commandQueue(&self) -> Retained<ProtocolObject<dyn MTLCommandQueue>>;

        /// If YES, this command buffer holds strong references to objects needed to execute this command buffer.
        #[unsafe(method(retainedReferences))]
        #[unsafe(method_family = none)]
        fn retainedReferences(&self) -> bool;

        /// The set of options configuring the error reporting of the created command buffer.
        #[unsafe(method(errorOptions))]
        #[unsafe(method_family = none)]
        fn errorOptions(&self) -> MTLCommandBufferErrorOption;

        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(kernelStartTime))]
        #[unsafe(method_family = none)]
        fn kernelStartTime(&self) -> CFTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(kernelEndTime))]
        #[unsafe(method_family = none)]
        fn kernelEndTime(&self) -> CFTimeInterval;

        #[cfg(feature = "MTLFunctionLog")]
        /// Logs generated by the command buffer during execution of the GPU commands. Valid after GPU execution is completed
        #[unsafe(method(logs))]
        #[unsafe(method_family = none)]
        fn logs(&self) -> Retained<ProtocolObject<dyn MTLLogContainer>>;

        #[cfg(feature = "objc2-core-foundation")]
        /// The host time in seconds that GPU starts executing this command buffer. Returns zero if it has not started. This usually can be called in command buffer completion handler.
        #[unsafe(method(GPUStartTime))]
        #[unsafe(method_family = none)]
        fn GPUStartTime(&self) -> CFTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        /// The host time in seconds that GPU finishes executing this command buffer. Returns zero if CPU has not received completion notification. This usually can be called in command buffer completion handler.
        #[unsafe(method(GPUEndTime))]
        #[unsafe(method_family = none)]
        fn GPUEndTime(&self) -> CFTimeInterval;

        /// Append this command buffer to the end of its MTLCommandQueue.
        #[unsafe(method(enqueue))]
        #[unsafe(method_family = none)]
        fn enqueue(&self);

        /// Commit a command buffer so it can be executed as soon as possible.
        #[unsafe(method(commit))]
        #[unsafe(method_family = none)]
        fn commit(&self);

        #[cfg(feature = "block2")]
        /// Adds a block to be called when this command buffer has been scheduled for execution.
        ///
        /// # Safety
        ///
        /// `block` must be a valid pointer.
        #[unsafe(method(addScheduledHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn addScheduledHandler(&self, block: MTLCommandBufferHandler);

        #[cfg(feature = "MTLDrawable")]
        /// Add a drawable present that will be invoked when this command buffer has been scheduled for execution.
        ///
        /// The submission thread will be lock stepped with present call been serviced by window server
        #[unsafe(method(presentDrawable:))]
        #[unsafe(method_family = none)]
        fn presentDrawable(&self, drawable: &ProtocolObject<dyn MTLDrawable>);

        #[cfg(all(feature = "MTLDrawable", feature = "objc2-core-foundation"))]
        /// Add a drawable present for a specific host time that will be invoked when this command buffer has been scheduled for execution.
        ///
        /// The submission thread will be lock stepped with present call been serviced by window server
        #[unsafe(method(presentDrawable:atTime:))]
        #[unsafe(method_family = none)]
        fn presentDrawable_atTime(
            &self,
            drawable: &ProtocolObject<dyn MTLDrawable>,
            presentation_time: CFTimeInterval,
        );

        #[cfg(all(feature = "MTLDrawable", feature = "objc2-core-foundation"))]
        /// Add a drawable present for a specific host time that allows previous frame to be on screen for at least duration time.
        ///
        /// Parameter `drawable`: The drawable to be presented
        ///
        /// Parameter `duration`: The minimum time that previous frame should be displayed. The time is double preceision floating point in the unit of seconds.
        ///
        /// The difference of this API versus presentDrawable:atTime is that this API defers calculation of the presentation time until the previous frame's actual presentation time is known, thus to be able to maintain a more consistent and stable frame time. This also provides an easy way to set frame rate.
        /// The submission thread will be lock stepped with present call been serviced by window server
        #[unsafe(method(presentDrawable:afterMinimumDuration:))]
        #[unsafe(method_family = none)]
        fn presentDrawable_afterMinimumDuration(
            &self,
            drawable: &ProtocolObject<dyn MTLDrawable>,
            duration: CFTimeInterval,
        );

        /// Synchronously wait for this command buffer to be scheduled.
        #[unsafe(method(waitUntilScheduled))]
        #[unsafe(method_family = none)]
        fn waitUntilScheduled(&self);

        #[cfg(feature = "block2")]
        /// Add a block to be called when this command buffer has completed execution.
        ///
        /// # Safety
        ///
        /// `block` must be a valid pointer.
        #[unsafe(method(addCompletedHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn addCompletedHandler(&self, block: MTLCommandBufferHandler);

        /// Synchronously wait for this command buffer to complete.
        #[unsafe(method(waitUntilCompleted))]
        #[unsafe(method_family = none)]
        fn waitUntilCompleted(&self);

        /// status reports the current stage in the lifetime of MTLCommandBuffer, as it proceeds to enqueued, committed, scheduled, and completed.
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        fn status(&self) -> MTLCommandBufferStatus;

        /// If an error occurred during execution, the NSError may contain more details about the problem.
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        fn error(&self) -> Option<Retained<NSError>>;

        #[cfg(all(feature = "MTLBlitCommandEncoder", feature = "MTLCommandEncoder"))]
        /// returns a blit command encoder to encode into this command buffer.
        #[unsafe(method(blitCommandEncoder))]
        #[unsafe(method_family = none)]
        fn blitCommandEncoder(&self)
            -> Option<Retained<ProtocolObject<dyn MTLBlitCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLRenderCommandEncoder",
            feature = "MTLRenderPass"
        ))]
        /// returns a render command endcoder to encode into this command buffer.
        #[unsafe(method(renderCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn renderCommandEncoderWithDescriptor(
            &self,
            render_pass_descriptor: &MTLRenderPassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLRenderCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLComputeCommandEncoder",
            feature = "MTLComputePass"
        ))]
        /// returns a compute command endcoder to encode into this command buffer.
        #[unsafe(method(computeCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn computeCommandEncoderWithDescriptor(
            &self,
            compute_pass_descriptor: &MTLComputePassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLComputeCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLBlitCommandEncoder",
            feature = "MTLBlitPass",
            feature = "MTLCommandEncoder"
        ))]
        /// returns a blit command endcoder to encode into this command buffer.
        #[unsafe(method(blitCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn blitCommandEncoderWithDescriptor(
            &self,
            blit_pass_descriptor: &MTLBlitPassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLBlitCommandEncoder>>>;

        #[cfg(all(feature = "MTLCommandEncoder", feature = "MTLComputeCommandEncoder"))]
        /// returns a compute command encoder to encode into this command buffer.
        #[unsafe(method(computeCommandEncoder))]
        #[unsafe(method_family = none)]
        fn computeCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLComputeCommandEncoder>>>;

        #[cfg(all(feature = "MTLCommandEncoder", feature = "MTLComputeCommandEncoder"))]
        /// returns a compute command encoder to encode into this command buffer. Optionally allow this command encoder to execute dispatches concurrently.
        ///
        /// On devices that do not support concurrent command encoders, this call is equivalent to computeCommandEncoder
        #[unsafe(method(computeCommandEncoderWithDispatchType:))]
        #[unsafe(method_family = none)]
        fn computeCommandEncoderWithDispatchType(
            &self,
            dispatch_type: MTLDispatchType,
        ) -> Option<Retained<ProtocolObject<dyn MTLComputeCommandEncoder>>>;

        #[cfg(feature = "MTLEvent")]
        /// Encodes a command that pauses execution of this command buffer until the specified event reaches a given value.
        ///
        /// This method may only be called if there is no current command encoder on the receiver.
        #[unsafe(method(encodeWaitForEvent:value:))]
        #[unsafe(method_family = none)]
        fn encodeWaitForEvent_value(&self, event: &ProtocolObject<dyn MTLEvent>, value: u64);

        #[cfg(feature = "MTLEvent")]
        /// Encodes a command that signals an event with a given value.
        ///
        /// This method may only be called if there is no current command encoder on the receiver.
        #[unsafe(method(encodeSignalEvent:value:))]
        #[unsafe(method_family = none)]
        fn encodeSignalEvent_value(&self, event: &ProtocolObject<dyn MTLEvent>, value: u64);

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLParallelRenderCommandEncoder",
            feature = "MTLRenderPass"
        ))]
        /// returns a parallel render pass encoder to encode into this command buffer.
        #[unsafe(method(parallelRenderCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn parallelRenderCommandEncoderWithDescriptor(
            &self,
            render_pass_descriptor: &MTLRenderPassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLParallelRenderCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLResourceStateCommandEncoder"
        ))]
        #[unsafe(method(resourceStateCommandEncoder))]
        #[unsafe(method_family = none)]
        fn resourceStateCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLResourceStateCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLCommandEncoder",
            feature = "MTLResourceStateCommandEncoder",
            feature = "MTLResourceStatePass"
        ))]
        #[unsafe(method(resourceStateCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn resourceStateCommandEncoderWithDescriptor(
            &self,
            resource_state_pass_descriptor: &MTLResourceStatePassDescriptor,
        ) -> Option<Retained<ProtocolObject<dyn MTLResourceStateCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLAccelerationStructureCommandEncoder",
            feature = "MTLCommandEncoder"
        ))]
        #[unsafe(method(accelerationStructureCommandEncoder))]
        #[unsafe(method_family = none)]
        fn accelerationStructureCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLAccelerationStructureCommandEncoder>>>;

        #[cfg(all(
            feature = "MTLAccelerationStructureCommandEncoder",
            feature = "MTLCommandEncoder"
        ))]
        #[unsafe(method(accelerationStructureCommandEncoderWithDescriptor:))]
        #[unsafe(method_family = none)]
        fn accelerationStructureCommandEncoderWithDescriptor(
            &self,
            descriptor: &MTLAccelerationStructurePassDescriptor,
        ) -> Retained<ProtocolObject<dyn MTLAccelerationStructureCommandEncoder>>;

        /// Push a new named string onto a stack of string labels.
        #[unsafe(method(pushDebugGroup:))]
        #[unsafe(method_family = none)]
        fn pushDebugGroup(&self, string: &NSString);

        /// Pop the latest named string off of the stack.
        #[unsafe(method(popDebugGroup))]
        #[unsafe(method_family = none)]
        fn popDebugGroup(&self);

        #[cfg(feature = "MTLResidencySet")]
        /// Marks the residency set as part of the current command buffer execution. This ensures that the residency set is resident during execution of the command buffer.
        #[unsafe(method(useResidencySet:))]
        #[unsafe(method_family = none)]
        fn useResidencySet(&self, residency_set: &ProtocolObject<dyn MTLResidencySet>);

        #[cfg(feature = "MTLResidencySet")]
        /// Marks the residency sets as part of the current command buffer execution. This ensures that the residency sets are resident during execution of the command buffer.
        ///
        /// # Safety
        ///
        /// - `residency_sets` must be a valid pointer.
        /// - `count` might not be bounds-checked.
        #[unsafe(method(useResidencySets:count:))]
        #[unsafe(method_family = none)]
        unsafe fn useResidencySets_count(
            &self,
            residency_sets: NonNull<NonNull<ProtocolObject<dyn MTLResidencySet>>>,
            count: NSUInteger,
        );
    }
);
