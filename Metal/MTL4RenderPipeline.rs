//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Enumerates possible behaviors of how a pipeline maps its logical outputs to its color attachments.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4logicaltophysicalcolorattachmentmappingstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTL4LogicalToPhysicalColorAttachmentMappingState(pub NSInteger);
impl MTL4LogicalToPhysicalColorAttachmentMappingState {
    /// Treats the logical color attachment descriptor array for render and tile render pipelines to match the physical one.
    ///
    /// This is the default behavior, which produces an identity mapping.
    #[doc(alias = "MTL4LogicalToPhysicalColorAttachmentMappingStateIdentity")]
    pub const Identity: Self = Self(0);
    /// Deduces the color attachment mapping by inheriting it from the color attachment map of the current encoder.
    ///
    /// Use this setting to indicate Metal should inherit the mapping from the ``colorAttachmentMap`` property of the current
    /// ``MTL4RenderCommandEncoder`` or ``MTLRenderCommandEncoder`` in use at draw time.
    #[doc(alias = "MTL4LogicalToPhysicalColorAttachmentMappingStateInherited")]
    pub const Inherited: Self = Self(1);
}

unsafe impl Encode for MTL4LogicalToPhysicalColorAttachmentMappingState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTL4LogicalToPhysicalColorAttachmentMappingState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4renderpipelinecolorattachmentdescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTL4RenderPipelineColorAttachmentDescriptor;
);

extern_conformance!(
    unsafe impl NSCopying for MTL4RenderPipelineColorAttachmentDescriptor {}
);

unsafe impl CopyingHelper for MTL4RenderPipelineColorAttachmentDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTL4RenderPipelineColorAttachmentDescriptor {}
);

impl MTL4RenderPipelineColorAttachmentDescriptor {
    extern_methods!(
        #[cfg(feature = "MTLPixelFormat")]
        /// Configures the pixel format.
        ///
        /// This property defaults to ``MTLPixelFormatInvalid``.
        #[unsafe(method(pixelFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn pixelFormat(&self) -> MTLPixelFormat;

        #[cfg(feature = "MTLPixelFormat")]
        /// Setter for [`pixelFormat`][Self::pixelFormat].
        #[unsafe(method(setPixelFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPixelFormat(&self, pixel_format: MTLPixelFormat);

        #[cfg(feature = "MTL4PipelineState")]
        /// Enables blending.
        ///
        /// This property's default value is
        /// <doc
        /// ://com.apple.documentation/documentation/swift/false>.
        #[unsafe(method(blendingState))]
        #[unsafe(method_family = none)]
        pub unsafe fn blendingState(&self) -> MTL4BlendState;

        #[cfg(feature = "MTL4PipelineState")]
        /// Setter for [`blendingState`][Self::blendingState].
        #[unsafe(method(setBlendingState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBlendingState(&self, blending_state: MTL4BlendState);

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the source RGB blend factor.
        ///
        /// This property defaults to ``MTLBlendFactorOne``.
        #[unsafe(method(sourceRGBBlendFactor))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceRGBBlendFactor(&self) -> MTLBlendFactor;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`sourceRGBBlendFactor`][Self::sourceRGBBlendFactor].
        #[unsafe(method(setSourceRGBBlendFactor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSourceRGBBlendFactor(&self, source_rgb_blend_factor: MTLBlendFactor);

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the destination RGB blend factor.
        ///
        /// This property defaults to ``MTLBlendFactorZero``.
        #[unsafe(method(destinationRGBBlendFactor))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationRGBBlendFactor(&self) -> MTLBlendFactor;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`destinationRGBBlendFactor`][Self::destinationRGBBlendFactor].
        #[unsafe(method(setDestinationRGBBlendFactor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDestinationRGBBlendFactor(
            &self,
            destination_rgb_blend_factor: MTLBlendFactor,
        );

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the RGB blend operation.
        ///
        /// This property defaults to ``MTLBlendOperationAdd``.
        #[unsafe(method(rgbBlendOperation))]
        #[unsafe(method_family = none)]
        pub unsafe fn rgbBlendOperation(&self) -> MTLBlendOperation;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`rgbBlendOperation`][Self::rgbBlendOperation].
        #[unsafe(method(setRgbBlendOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRgbBlendOperation(&self, rgb_blend_operation: MTLBlendOperation);

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the source-alpha blend factor.
        ///
        /// This property defaults to ``MTLBlendFactorOne``.
        #[unsafe(method(sourceAlphaBlendFactor))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAlphaBlendFactor(&self) -> MTLBlendFactor;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`sourceAlphaBlendFactor`][Self::sourceAlphaBlendFactor].
        #[unsafe(method(setSourceAlphaBlendFactor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSourceAlphaBlendFactor(&self, source_alpha_blend_factor: MTLBlendFactor);

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the destination-alpha blend factor.
        ///
        /// This property defaults to ``MTLBlendFactorZero``.
        #[unsafe(method(destinationAlphaBlendFactor))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationAlphaBlendFactor(&self) -> MTLBlendFactor;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`destinationAlphaBlendFactor`][Self::destinationAlphaBlendFactor].
        #[unsafe(method(setDestinationAlphaBlendFactor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDestinationAlphaBlendFactor(
            &self,
            destination_alpha_blend_factor: MTLBlendFactor,
        );

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the alpha blending operation.
        ///
        /// This property defaults to ``MTLBlendOperationAdd``.
        #[unsafe(method(alphaBlendOperation))]
        #[unsafe(method_family = none)]
        pub unsafe fn alphaBlendOperation(&self) -> MTLBlendOperation;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`alphaBlendOperation`][Self::alphaBlendOperation].
        #[unsafe(method(setAlphaBlendOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAlphaBlendOperation(&self, alpha_blend_operation: MTLBlendOperation);

        #[cfg(feature = "MTLRenderPipeline")]
        /// Configures the color write mask.
        ///
        /// This property defaults to ``MTLColorWriteMaskAll``.
        #[unsafe(method(writeMask))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeMask(&self) -> MTLColorWriteMask;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`writeMask`][Self::writeMask].
        #[unsafe(method(setWriteMask:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWriteMask(&self, write_mask: MTLColorWriteMask);

        /// Resets this descriptor to its default state.
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTL4RenderPipelineColorAttachmentDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An array of color attachment descriptions for a render pipeline.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4renderpipelinecolorattachmentdescriptorarray?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTL4RenderPipelineColorAttachmentDescriptorArray;
);

extern_conformance!(
    unsafe impl NSCopying for MTL4RenderPipelineColorAttachmentDescriptorArray {}
);

unsafe impl CopyingHelper for MTL4RenderPipelineColorAttachmentDescriptorArray {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTL4RenderPipelineColorAttachmentDescriptorArray {}
);

impl MTL4RenderPipelineColorAttachmentDescriptorArray {
    extern_methods!(
        /// Accesses a color attachment at a specific index.
        ///
        /// - Parameter attachmentIndex: Index of the attachment to access.
        #[unsafe(method(objectAtIndexedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndexedSubscript(
            &self,
            attachment_index: NSUInteger,
        ) -> Retained<MTL4RenderPipelineColorAttachmentDescriptor>;

        /// Sets an attachment at an index.
        ///
        /// This function offers 'copy' semantics.
        ///
        /// You can safely set the color attachment at any legal index to nil. This has the effect of resetting that attachment
        /// descriptor's state to its default values.
        ///
        /// - Parameters:
        /// - attachment: the descriptor of the attachment to set.
        /// - attachmentIndex: the index of the attachment within the array.
        #[unsafe(method(setObject:atIndexedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObject_atIndexedSubscript(
            &self,
            attachment: Option<&MTL4RenderPipelineColorAttachmentDescriptor>,
            attachment_index: NSUInteger,
        );

        /// Resets the elements of the descriptor array
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTL4RenderPipelineColorAttachmentDescriptorArray {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Allows you to easily specify color attachment remapping from logical to physical indices.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtllogicaltophysicalcolorattachmentmap?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLLogicalToPhysicalColorAttachmentMap;
);

extern_conformance!(
    unsafe impl NSCopying for MTLLogicalToPhysicalColorAttachmentMap {}
);

unsafe impl CopyingHelper for MTLLogicalToPhysicalColorAttachmentMap {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLLogicalToPhysicalColorAttachmentMap {}
);

impl MTLLogicalToPhysicalColorAttachmentMap {
    extern_methods!(
        /// Maps a physical color attachment index to a logical index.
        ///
        /// - Parameters:
        /// - physicalIndex: index of the color attachment's physical mapping.
        /// - logicalIndex: index of the color attachment's logical mapping.
        #[unsafe(method(setPhysicalIndex:forLogicalIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPhysicalIndex_forLogicalIndex(
            &self,
            physical_index: NSUInteger,
            logical_index: NSUInteger,
        );

        /// Queries the physical color attachment index corresponding to a logical index.
        #[unsafe(method(getPhysicalIndexForLogicalIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPhysicalIndexForLogicalIndex(
            &self,
            logical_index: NSUInteger,
        ) -> NSUInteger;

        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLLogicalToPhysicalColorAttachmentMap {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Allows you to specify additional binary functions to link to each stage of a render pipeline.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4renderpipelinebinaryfunctionsdescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTL4RenderPipelineBinaryFunctionsDescriptor;
);

extern_conformance!(
    unsafe impl NSCopying for MTL4RenderPipelineBinaryFunctionsDescriptor {}
);

unsafe impl CopyingHelper for MTL4RenderPipelineBinaryFunctionsDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTL4RenderPipelineBinaryFunctionsDescriptor {}
);

impl MTL4RenderPipelineBinaryFunctionsDescriptor {
    extern_methods!(
        #[cfg(feature = "MTL4BinaryFunction")]
        /// Provides an array of binary functions representing additional binary vertex shader functions.
        #[unsafe(method(vertexAdditionalBinaryFunctions))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexAdditionalBinaryFunctions(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn MTL4BinaryFunction>>>>;

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Setter for [`vertexAdditionalBinaryFunctions`][Self::vertexAdditionalBinaryFunctions].
        #[unsafe(method(setVertexAdditionalBinaryFunctions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexAdditionalBinaryFunctions(
            &self,
            vertex_additional_binary_functions: Option<
                &NSArray<ProtocolObject<dyn MTL4BinaryFunction>>,
            >,
        );

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Provides an array of binary functions representing additional binary fragment shader functions.
        #[unsafe(method(fragmentAdditionalBinaryFunctions))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentAdditionalBinaryFunctions(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn MTL4BinaryFunction>>>>;

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Setter for [`fragmentAdditionalBinaryFunctions`][Self::fragmentAdditionalBinaryFunctions].
        #[unsafe(method(setFragmentAdditionalBinaryFunctions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFragmentAdditionalBinaryFunctions(
            &self,
            fragment_additional_binary_functions: Option<
                &NSArray<ProtocolObject<dyn MTL4BinaryFunction>>,
            >,
        );

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Provides an array of binary functions representing additional binary tile shader functions.
        #[unsafe(method(tileAdditionalBinaryFunctions))]
        #[unsafe(method_family = none)]
        pub unsafe fn tileAdditionalBinaryFunctions(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn MTL4BinaryFunction>>>>;

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Setter for [`tileAdditionalBinaryFunctions`][Self::tileAdditionalBinaryFunctions].
        #[unsafe(method(setTileAdditionalBinaryFunctions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTileAdditionalBinaryFunctions(
            &self,
            tile_additional_binary_functions: Option<
                &NSArray<ProtocolObject<dyn MTL4BinaryFunction>>,
            >,
        );

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Provides an array of binary functions representing additional binary object shader functions.
        #[unsafe(method(objectAdditionalBinaryFunctions))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAdditionalBinaryFunctions(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn MTL4BinaryFunction>>>>;

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Setter for [`objectAdditionalBinaryFunctions`][Self::objectAdditionalBinaryFunctions].
        #[unsafe(method(setObjectAdditionalBinaryFunctions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObjectAdditionalBinaryFunctions(
            &self,
            object_additional_binary_functions: Option<
                &NSArray<ProtocolObject<dyn MTL4BinaryFunction>>,
            >,
        );

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Provides an array of binary functions representing additional binary mesh shader functions.
        #[unsafe(method(meshAdditionalBinaryFunctions))]
        #[unsafe(method_family = none)]
        pub unsafe fn meshAdditionalBinaryFunctions(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn MTL4BinaryFunction>>>>;

        #[cfg(feature = "MTL4BinaryFunction")]
        /// Setter for [`meshAdditionalBinaryFunctions`][Self::meshAdditionalBinaryFunctions].
        #[unsafe(method(setMeshAdditionalBinaryFunctions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMeshAdditionalBinaryFunctions(
            &self,
            mesh_additional_binary_functions: Option<
                &NSArray<ProtocolObject<dyn MTL4BinaryFunction>>,
            >,
        );

        /// Resets this descriptor to its default state.
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl MTL4RenderPipelineBinaryFunctionsDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Groups together properties to create a render pipeline state object.
    ///
    /// Compared to ``MTLRenderPipelineDescriptor``, this interface doesn't offer a mechanism to hint to Metal mutability of
    /// vertex and fragment buffers. Additionally, using this descriptor, you don't specify binary archives.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4renderpipelinedescriptor?language=objc)
    #[unsafe(super(MTL4PipelineDescriptor, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MTL4PipelineState")]
    pub struct MTL4RenderPipelineDescriptor;
);

#[cfg(feature = "MTL4PipelineState")]
extern_conformance!(
    unsafe impl NSCopying for MTL4RenderPipelineDescriptor {}
);

#[cfg(feature = "MTL4PipelineState")]
unsafe impl CopyingHelper for MTL4RenderPipelineDescriptor {
    type Result = Self;
}

#[cfg(feature = "MTL4PipelineState")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MTL4RenderPipelineDescriptor {}
);

#[cfg(feature = "MTL4PipelineState")]
impl MTL4RenderPipelineDescriptor {
    extern_methods!(
        #[cfg(feature = "MTL4FunctionDescriptor")]
        /// Assigns the shader function that this pipeline executes for each vertex.
        #[unsafe(method(vertexFunctionDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexFunctionDescriptor(&self) -> Option<Retained<MTL4FunctionDescriptor>>;

        #[cfg(feature = "MTL4FunctionDescriptor")]
        /// Setter for [`vertexFunctionDescriptor`][Self::vertexFunctionDescriptor].
        #[unsafe(method(setVertexFunctionDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexFunctionDescriptor(
            &self,
            vertex_function_descriptor: Option<&MTL4FunctionDescriptor>,
        );

        #[cfg(feature = "MTL4FunctionDescriptor")]
        /// Assigns the shader function that this pipeline executes for each fragment.
        ///
        /// When you don't specify a fragment function, you need to disable rasterization by setting property
        /// ``rasterizationEnabled`` to false.
        #[unsafe(method(fragmentFunctionDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentFunctionDescriptor(&self)
            -> Option<Retained<MTL4FunctionDescriptor>>;

        #[cfg(feature = "MTL4FunctionDescriptor")]
        /// Setter for [`fragmentFunctionDescriptor`][Self::fragmentFunctionDescriptor].
        #[unsafe(method(setFragmentFunctionDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFragmentFunctionDescriptor(
            &self,
            fragment_function_descriptor: Option<&MTL4FunctionDescriptor>,
        );

        #[cfg(feature = "MTLVertexDescriptor")]
        /// Configures an optional vertex descriptor for the vertex input.
        ///
        /// A vertex descriptor specifies the layout of your vertex data, allowing your vertex shaders to access the content
        /// in your vertex arrays via the `[[stage_in]]` attribute in Metal Shading Language.
        #[unsafe(method(vertexDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexDescriptor(&self) -> Option<Retained<MTLVertexDescriptor>>;

        #[cfg(feature = "MTLVertexDescriptor")]
        /// Setter for [`vertexDescriptor`][Self::vertexDescriptor].
        #[unsafe(method(setVertexDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexDescriptor(&self, vertex_descriptor: Option<&MTLVertexDescriptor>);

        /// Controls the number of samples this pipeline applies for each fragment.
        #[unsafe(method(rasterSampleCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn rasterSampleCount(&self) -> NSUInteger;

        /// Setter for [`rasterSampleCount`][Self::rasterSampleCount].
        #[unsafe(method(setRasterSampleCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRasterSampleCount(&self, raster_sample_count: NSUInteger);

        /// Indicates whether to read and use the alpha channel fragment output of color attachments to compute a sample coverage mask.
        #[unsafe(method(alphaToCoverageState))]
        #[unsafe(method_family = none)]
        pub unsafe fn alphaToCoverageState(&self) -> MTL4AlphaToCoverageState;

        /// Setter for [`alphaToCoverageState`][Self::alphaToCoverageState].
        #[unsafe(method(setAlphaToCoverageState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAlphaToCoverageState(
            &self,
            alpha_to_coverage_state: MTL4AlphaToCoverageState,
        );

        /// Indicates whether the pipeline forces alpha channel values of color attachments to the largest representable value.
        #[unsafe(method(alphaToOneState))]
        #[unsafe(method_family = none)]
        pub unsafe fn alphaToOneState(&self) -> MTL4AlphaToOneState;

        /// Setter for [`alphaToOneState`][Self::alphaToOneState].
        #[unsafe(method(setAlphaToOneState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAlphaToOneState(&self, alpha_to_one_state: MTL4AlphaToOneState);

        /// Determines whether the pipeline rasterizes primitives.
        ///
        /// By default, this value is
        /// <doc
        /// ://com.apple.documentation/documentation/swift/true>, specifying that this pipeline
        /// rasterizes primitives. Set this property to
        /// <doc
        /// ://com.apple.documentation/documentation/swift/false> when you
        /// don't provide a fragment shader function via function ``fragmentFunctionDescriptor``.
        #[unsafe(method(isRasterizationEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRasterizationEnabled(&self) -> bool;

        /// Setter for [`isRasterizationEnabled`][Self::isRasterizationEnabled].
        #[unsafe(method(setRasterizationEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRasterizationEnabled(&self, rasterization_enabled: bool);

        /// Determines the maximum value that can you can pass as the pipeline's amplification count.
        ///
        /// This property controls the maximum count you pass to ``MTL4RenderCommandEncoder/setVertexAmplificationCount:viewMappings:``
        /// when using vertex amplification with this pipeline.
        #[unsafe(method(maxVertexAmplificationCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxVertexAmplificationCount(&self) -> NSUInteger;

        /// Setter for [`maxVertexAmplificationCount`][Self::maxVertexAmplificationCount].
        #[unsafe(method(setMaxVertexAmplificationCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaxVertexAmplificationCount(
            &self,
            max_vertex_amplification_count: NSUInteger,
        );

        /// Accesses an array containing descriptions of the color attachments this pipeline writes to.
        #[unsafe(method(colorAttachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorAttachments(
            &self,
        ) -> Retained<MTL4RenderPipelineColorAttachmentDescriptorArray>;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Assigns type of primitive topology this pipeline renders.
        #[unsafe(method(inputPrimitiveTopology))]
        #[unsafe(method_family = none)]
        pub unsafe fn inputPrimitiveTopology(&self) -> MTLPrimitiveTopologyClass;

        #[cfg(feature = "MTLRenderPipeline")]
        /// Setter for [`inputPrimitiveTopology`][Self::inputPrimitiveTopology].
        #[unsafe(method(setInputPrimitiveTopology:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInputPrimitiveTopology(
            &self,
            input_primitive_topology: MTLPrimitiveTopologyClass,
        );

        #[cfg(feature = "MTL4LinkingDescriptor")]
        /// Provides static linking information for the vertex stage of the render pipeline.
        ///
        /// Use this property to link extra shader functions to the vertex stage of the render pipeline.
        #[unsafe(method(vertexStaticLinkingDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexStaticLinkingDescriptor(&self)
            -> Retained<MTL4StaticLinkingDescriptor>;

        #[cfg(feature = "MTL4LinkingDescriptor")]
        /// Setter for [`vertexStaticLinkingDescriptor`][Self::vertexStaticLinkingDescriptor].
        #[unsafe(method(setVertexStaticLinkingDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexStaticLinkingDescriptor(
            &self,
            vertex_static_linking_descriptor: Option<&MTL4StaticLinkingDescriptor>,
        );

        #[cfg(feature = "MTL4LinkingDescriptor")]
        /// Provides static linking information for the fragment stage of the render pipeline.
        ///
        /// Use this property to link extra shader functions to the fragment stage of the render pipeline.
        #[unsafe(method(fragmentStaticLinkingDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentStaticLinkingDescriptor(
            &self,
        ) -> Retained<MTL4StaticLinkingDescriptor>;

        #[cfg(feature = "MTL4LinkingDescriptor")]
        /// Setter for [`fragmentStaticLinkingDescriptor`][Self::fragmentStaticLinkingDescriptor].
        #[unsafe(method(setFragmentStaticLinkingDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFragmentStaticLinkingDescriptor(
            &self,
            fragment_static_linking_descriptor: Option<&MTL4StaticLinkingDescriptor>,
        );

        /// Indicates whether you can use the render pipeline to create new pipelines by
        /// adding binary functions to the vertex shader function’s callable functions list.
        #[unsafe(method(supportVertexBinaryLinking))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportVertexBinaryLinking(&self) -> bool;

        /// Setter for [`supportVertexBinaryLinking`][Self::supportVertexBinaryLinking].
        #[unsafe(method(setSupportVertexBinaryLinking:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportVertexBinaryLinking(&self, support_vertex_binary_linking: bool);

        /// Indicates whether you can use the pipeline to create new pipelines by
        /// adding binary functions to the fragment shader function’s callable functions list.
        #[unsafe(method(supportFragmentBinaryLinking))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportFragmentBinaryLinking(&self) -> bool;

        /// Setter for [`supportFragmentBinaryLinking`][Self::supportFragmentBinaryLinking].
        #[unsafe(method(setSupportFragmentBinaryLinking:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportFragmentBinaryLinking(&self, support_fragment_binary_linking: bool);

        /// Configures a logical-to-physical rendering remap state.
        ///
        /// Use this property to assign how a ``MTL4RenderCommandEncoder`` instance maps the output of your fragment shader to
        /// physical color attachments.
        #[unsafe(method(colorAttachmentMappingState))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorAttachmentMappingState(
            &self,
        ) -> MTL4LogicalToPhysicalColorAttachmentMappingState;

        /// Setter for [`colorAttachmentMappingState`][Self::colorAttachmentMappingState].
        #[unsafe(method(setColorAttachmentMappingState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColorAttachmentMappingState(
            &self,
            color_attachment_mapping_state: MTL4LogicalToPhysicalColorAttachmentMappingState,
        );

        /// Indicates whether the pipeline supports indirect command buffers.
        #[unsafe(method(supportIndirectCommandBuffers))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportIndirectCommandBuffers(&self)
            -> MTL4IndirectCommandBufferSupportState;

        /// Setter for [`supportIndirectCommandBuffers`][Self::supportIndirectCommandBuffers].
        #[unsafe(method(setSupportIndirectCommandBuffers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportIndirectCommandBuffers(
            &self,
            support_indirect_command_buffers: MTL4IndirectCommandBufferSupportState,
        );

        /// Resets this descriptor to its default state.
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MTL4PipelineState")]
impl MTL4RenderPipelineDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
