//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use objc2::__framework_prelude::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/metal/mtlpackedfloatquaternion?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MTLPackedFloatQuaternion {
    pub x: c_float,
    pub y: c_float,
    pub z: c_float,
    pub w: c_float,
}

unsafe impl Encode for MTLPackedFloatQuaternion {
    const ENCODING: Encoding = Encoding::Struct(
        "MTLPackedFloatQuaternion",
        &[
            <c_float>::ENCODING,
            <c_float>::ENCODING,
            <c_float>::ENCODING,
            <c_float>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for MTLPackedFloatQuaternion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl MTLPackedFloatQuaternion {
    // TODO: pub fn MTLPackedFloatQuaternionMake(x: c_float,y: c_float,z: c_float,w: c_float,) -> MTLPackedFloatQuaternion;
}

/// [Apple's documentation](https://developer.apple.com/documentation/metal/mtlpackedfloat4x3?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MTLPackedFloat4x3 {
    pub columns: [MTLPackedFloat3; 4],
}

unsafe impl Encode for MTLPackedFloat4x3 {
    const ENCODING: Encoding =
        Encoding::Struct("_MTLPackedFloat4x3", &[<[MTLPackedFloat3; 4]>::ENCODING]);
}

unsafe impl RefEncode for MTLPackedFloat4x3 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An axis aligned bounding box with a min and max point
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtlaxisalignedboundingbox?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MTLAxisAlignedBoundingBox {
    /// Minimum point
    pub min: MTLPackedFloat3,
    /// Maximum point
    pub max: MTLPackedFloat3,
}

unsafe impl Encode for MTLAxisAlignedBoundingBox {
    const ENCODING: Encoding = Encoding::Struct(
        "_MTLAxisAlignedBoundingBox",
        &[<MTLPackedFloat3>::ENCODING, <MTLPackedFloat3>::ENCODING],
    );
}

unsafe impl RefEncode for MTLAxisAlignedBoundingBox {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A transformation represented by individual components such as translation and
/// rotation. The rotation is represented by a quaternion, allowing for correct motion
/// interpolation.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtlcomponenttransform?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MTLComponentTransform {
    /// The scale of the instance applied before rotation alongside shear and pivot
    pub scale: MTLPackedFloat3,
    /// The shear of the instance applied before rotation alongside scale and pivot
    pub shear: MTLPackedFloat3,
    /// Translation applied before rotation alongside scale and shear. Allows
    /// rotation to pivot around a point.
    pub pivot: MTLPackedFloat3,
    /// The rotation of the instance as a normalized quaternion. Applied after scale,
    /// shear, and pivot and before translation
    pub rotation: MTLPackedFloatQuaternion,
    /// The translation of the instance. Applied after rotation. Typically contains
    /// the composition of object translation and the inverse of the pivot translation.
    pub translation: MTLPackedFloat3,
}

unsafe impl Encode for MTLComponentTransform {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <MTLPackedFloat3>::ENCODING,
            <MTLPackedFloat3>::ENCODING,
            <MTLPackedFloat3>::ENCODING,
            <MTLPackedFloatQuaternion>::ENCODING,
            <MTLPackedFloat3>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for MTLComponentTransform {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A struct representing a range of a Metal buffer. The offset into the buffer is included in the address.
/// The length is generally optional, which a value of (uint64_t)-1 representing the range from the given address to
/// the end of the buffer. However, providing the length can enable more accurate API validation, especially when
/// sub-allocating ranges of a buffer.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metal/mtl4bufferrange?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MTL4BufferRange {
    /// Buffer address returned by the gpuAddress property of an MTLBuffer plus any offset into the buffer
    pub bufferAddress: u64,
    /// Length of the region which begins at the given address. If the length is not known, a value of
    /// (uint64_t)-1 represents the range from the given address to the end of the buffer.
    pub length: u64,
}

unsafe impl Encode for MTL4BufferRange {
    const ENCODING: Encoding =
        Encoding::Struct("MTL4BufferRange", &[<u64>::ENCODING, <u64>::ENCODING]);
}

unsafe impl RefEncode for MTL4BufferRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl MTL4BufferRange {
    // TODO: pub fn MTL4BufferRangeMake(buffer_address: u64,length: u64,) -> MTL4BufferRange;
}
