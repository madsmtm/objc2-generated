//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// A simple semaphore to synchronize access to Metal resources.
    ///
    /// ## Overview
    ///
    /// You can only get an [`MTLEvent`](https://developer.apple.com/documentation/metal/mtlevent) using the [`newEvent`](https://developer.apple.com/documentation/metal/mtldevice/makeevent()) method of an [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) instance. Events allow you to synchronize commands executing on a single Metal device.
    ///
    /// An event is an unsigned 64-bit integer, starting with an initial value of `0` and can only increase in value afterwards. You signal an event change by calling an [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) instance’s [`encodeSignalEvent:value:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/encodesignalevent(_:value:)) method. The command buffer signals the event after the GPU completes running all previous commands, and updates its value if necessary.
    ///
    /// To wait for an event signal, call [`encodeWaitForEvent:value:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/encodewaitforevent(_:value:)) on a command buffer, passing in the value to wait for. When the device executes the command buffer and reaches this wait command, it compares the event’s current value to the provided value. The device only starts new commands when the event reaches a value equal to or greater than the requested value.
    ///
    /// You can encode signaling and waiting on events into different command buffers, even command buffers executing on two different command queues for the same device. You can also encode these commands independently of each other, meaning, for example, that you can wait on signals you haven’t encoded yet.
    ///
    /// For more information, see [Synchronizing events within a single device](https://developer.apple.com/documentation/metal/synchronizing-events-within-a-single-device).
    ///
    ///
    pub unsafe trait MTLEvent: NSObjectProtocol + Send + Sync {
        #[cfg(feature = "MTLDevice")]
        /// The device this event can be used with. Will be nil when the event is shared across devices (i.e. MTLSharedEvent).
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Option<Retained<ProtocolObject<dyn MTLDevice>>>;

        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);
    }
);

extern_class!(
    /// A listener for shareable event notifications.
    /// This class provides a simple interface for handling the dispatching of MTLSharedEvent notifications from Metal.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLSharedEventListener;
);

unsafe impl Send for MTLSharedEventListener {}

unsafe impl Sync for MTLSharedEventListener {}

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLSharedEventListener {}
);

impl MTLSharedEventListener {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// # Safety
        ///
        /// `dispatch_queue` possibly has additional threading requirements.
        #[unsafe(method(initWithDispatchQueue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDispatchQueue(
            this: Allocated<Self>,
            dispatch_queue: &DispatchQueue,
        ) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        #[unsafe(method(dispatchQueue))]
        #[unsafe(method_family = none)]
        pub fn dispatchQueue(&self) -> Retained<DispatchQueue>;

        #[unsafe(method(sharedListener))]
        #[unsafe(method_family = none)]
        pub fn sharedListener() -> Retained<MTLSharedEventListener>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLSharedEventListener {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLSharedEventListener {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// A block of code invoked after a shareable event’s signal value equals or exceeds a given value.
#[cfg(feature = "block2")]
pub type MTLSharedEventNotificationBlock =
    *mut block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn MTLSharedEvent>>, u64)>;

extern_protocol!(
    /// An instance you use to synchronize access to Metal resources across multiple CPUs, GPUs, and processes.
    ///
    /// ## Overview
    ///
    /// The [`MTLSharedEvent`](https://developer.apple.com/documentation/metal/mtlsharedevent) protocol inherits from and adds additional behaviors to [`MTLEvent`](https://developer.apple.com/documentation/metal/mtlevent). Use shared events only when you need to synchronize changes to resources across multiple Metal device instances, across processes, or between a device instance and CPU access to resources. Otherwise, use nonshared events.
    ///
    /// Don’t implement this protocol yourself; instead, to create an [`MTLSharedEvent`](https://developer.apple.com/documentation/metal/mtlsharedevent) instance, call the [`newSharedEvent`](https://developer.apple.com/documentation/metal/mtldevice/makesharedevent()) method of an [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) instance.
    ///
    /// To pass this event to another process, first create a handle to the shared event by calling its [`newSharedEventHandle`](https://developer.apple.com/documentation/metal/mtlsharedevent/makesharedeventhandle()) method. Then, transfer the handle to another process with XPC, and from that process, call the [`newSharedEventWithHandle:`](https://developer.apple.com/documentation/metal/mtldevice/makesharedevent(handle:)) of an [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) instance.
    ///
    /// For more information, see [Synchronizing events across multiple devices or processes](https://developer.apple.com/documentation/metal/synchronizing-events-across-multiple-devices-or-processes) and [Synchronizing events between a GPU and the CPU](https://developer.apple.com/documentation/metal/synchronizing-events-between-a-gpu-and-the-cpu).
    ///
    ///
    pub unsafe trait MTLSharedEvent: MTLEvent {
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `block` must be a valid pointer.
        #[unsafe(method(notifyListener:atValue:block:))]
        #[unsafe(method_family = none)]
        unsafe fn notifyListener_atValue_block(
            &self,
            listener: &MTLSharedEventListener,
            value: u64,
            block: MTLSharedEventNotificationBlock,
        );

        #[unsafe(method(newSharedEventHandle))]
        #[unsafe(method_family = new)]
        fn newSharedEventHandle(&self) -> Retained<MTLSharedEventHandle>;

        #[unsafe(method(waitUntilSignaledValue:timeoutMS:))]
        #[unsafe(method_family = none)]
        fn waitUntilSignaledValue_timeoutMS(&self, value: u64, milliseconds: u64) -> bool;

        #[unsafe(method(signaledValue))]
        #[unsafe(method_family = none)]
        fn signaledValue(&self) -> u64;

        /// Setter for [`signaledValue`][Self::signaledValue].
        #[unsafe(method(setSignaledValue:))]
        #[unsafe(method_family = none)]
        fn setSignaledValue(&self, signaled_value: u64);
    }
);

extern_class!(
    /// An instance you use to recreate a shareable event.
    ///
    /// ## Overview
    ///
    /// To create a `MTLSharedEventHandle` instance, call the [`newSharedEventHandle`](https://developer.apple.com/documentation/metal/mtlsharedevent/makesharedeventhandle()) method on an [`MTLSharedEvent`](https://developer.apple.com/documentation/metal/mtlsharedevent) instance. Use an XPC conection to pass a `MTLSharedEventHandle` instance to another process. To recreate the event, call the [`newSharedEventWithHandle:`](https://developer.apple.com/documentation/metal/mtldevice/makesharedevent(handle:)) on an [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) instance.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MTLSharedEventHandle;
);

unsafe impl Send for MTLSharedEventHandle {}

unsafe impl Sync for MTLSharedEventHandle {}

extern_conformance!(
    unsafe impl NSCoding for MTLSharedEventHandle {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MTLSharedEventHandle {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for MTLSharedEventHandle {}
);

impl MTLSharedEventHandle {
    extern_methods!(
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        pub fn label(&self) -> Option<Retained<NSString>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MTLSharedEventHandle {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for MTLSharedEventHandle {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
