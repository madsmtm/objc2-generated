//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The purgeable state of the resource.
/// Options for setPurgeable call.
///
///
/// The contents of this resource may not be discarded.
///
///
/// The contents of this resource may be discarded.
///
///
/// The contents of this are discarded.
///
///
/// The purgeabelity state is not changed.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLPurgeableState(pub NSUInteger);
impl MTLPurgeableState {
    /// The current state is queried but doesn’t change.
    ///
    /// ## Discussion
    ///
    /// The [`setPurgeableState:`](https://developer.apple.com/documentation/metal/mtlresource/setpurgeablestate(_:)) method never returns this value. When this value is passed to that function, it returns the current purgability state without changing it.
    ///
    ///
    #[doc(alias = "MTLPurgeableStateKeepCurrent")]
    pub const KeepCurrent: Self = Self(1);
    /// The contents of the resource aren’t allowed to be discarded.
    #[doc(alias = "MTLPurgeableStateNonVolatile")]
    pub const NonVolatile: Self = Self(2);
    /// The system is allowed to discard the resource to free up memory.
    #[doc(alias = "MTLPurgeableStateVolatile")]
    pub const Volatile: Self = Self(3);
    /// A state that indicates to the system that it needs to consider the contents of a resource as invalid, typically because you’re discarding it.
    #[doc(alias = "MTLPurgeableStateEmpty")]
    pub const Empty: Self = Self(4);
}

unsafe impl Encode for MTLPurgeableState {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLPurgeableState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for the CPU cache mode that define the CPU mapping of the resource.
/// Describes what CPU cache mode is used for the CPU's mapping of a texture resource.
///
/// The default cache mode for the system.
///
///
/// Write combined memory is optimized for resources that the CPU will write into, but never read.  On some implementations, writes may bypass caches avoiding cache pollution, and reads perform very poorly.
///
///
/// Applications should only investigate changing the cache mode if writing to normally cached buffers is known to cause performance issues due to cache pollution, as write combined memory can have surprising performance pitfalls.  Another approach is to use non-temporal stores to normally cached memory (STNP on ARMv8, _mm_stream_* on x86_64).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLCPUCacheMode(pub NSUInteger);
impl MTLCPUCacheMode {
    /// The default CPU cache mode for the resource, which guarantees that read and write operations are executed in the expected order.
    #[doc(alias = "MTLCPUCacheModeDefaultCache")]
    pub const DefaultCache: Self = Self(0);
    /// A write-combined CPU cache mode that is optimized for resources that the CPU writes into, but never reads.
    ///
    /// ## Discussion
    ///
    /// Write-combined memory is optimized for resources that the CPU writes into, but never reads. On some implementations, writes may bypass caches to avoid cache pollution. Read actions may perform very poorly.
    ///
    /// Applications should use write combining only if writing to normally cached buffers is known to cause performance issues due to cache pollution, as write-combined memory can have surprising performance pitfalls.  Another approach is to use non-temporal writes to normally cached memory (STNP on ARMv8, _mm_stream_* on x86_64).
    ///
    ///
    #[doc(alias = "MTLCPUCacheModeWriteCombined")]
    pub const WriteCombined: Self = Self(1);
}

unsafe impl Encode for MTLCPUCacheMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLCPUCacheMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for the memory location and access permissions for a resource.
///
/// ## Overview
///
/// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
///
///
/// Describes location and CPU mapping of MTLTexture.
///
/// In this mode, CPU and device will nominally both use the same underlying memory when accessing the contents of the texture resource.
/// However, coherency is only guaranteed at command buffer boundaries to minimize the required flushing of CPU and GPU caches.
/// This is the default storage mode for iOS Textures.
///
///
/// This mode relaxes the coherency requirements and requires that the developer make explicit requests to maintain
/// coherency between a CPU and GPU version of the texture resource.  In order for CPU to access up to date GPU results,
/// first, a blit synchronizations must be completed (see synchronize methods of MTLBlitCommandEncoder).
/// Blit overhead is only incurred if GPU has modified the resource.
/// This is the default storage mode for OS X Textures.
///
///
/// This mode allows the texture resource data to be kept entirely to GPU (or driver) private memory that will never be accessed by the CPU directly, so no
/// conherency of any kind must be maintained.
///
///
/// This mode allows creation of resources that do not have a GPU or CPU memory backing, but do have on-chip storage for TBDR
/// devices. The contents of the on-chip storage is undefined and does not persist, but its configuration is controlled by the
/// MTLTexture descriptor. Textures created with MTLStorageModeMemoryless dont have an IOAccelResource at any point in their
/// lifetime. The only way to populate such resource is to perform rendering operations on it. Blit operations are disallowed.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLStorageMode(pub NSUInteger);
impl MTLStorageMode {
    /// The CPU and GPU share access to the resource, allocated in system memory.
    ///
    /// ## Discussion
    ///
    /// This is the default storage mode for [`MTLBuffer`](https://developer.apple.com/documentation/metal/mtlbuffer) instances on integrated GPUs and both [`MTLBuffer`](https://developer.apple.com/documentation/metal/mtlbuffer) and [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture) instances on Apple silicon GPUs. On non-Apple family GPUs, the shared storage mode isn’t available for [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture) instances.
    ///
    /// When either the CPU or GPU changes the contents of the resource, you’re responsible for synchronizing access to the texture from the other participant. Ensure that all changes you schedule on either the CPU or GPU for a resource that uses shared memory complete before accessing that resource on the other processor.
    ///
    /// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
    ///
    ///
    #[doc(alias = "MTLStorageModeShared")]
    pub const Shared: Self = Self(0);
    /// The CPU and GPU may maintain separate copies of the resource, and any changes must be explicitly synchronized.
    ///
    /// ## Discussion
    ///
    /// On Intel-based Mac computers, this is the default storage mode for [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture) objects. In iOS and tvOS, the managed storage mode isn’t available. With managed storage, you synchronize changes between the CPU and GPU manually. For instructions and examples of resource synchronization, see [Synchronizing a managed resource in macOS](https://developer.apple.com/documentation/metal/synchronizing-a-managed-resource-in-macos).
    ///
    /// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
    ///
    ///
    #[doc(alias = "MTLStorageModeManaged")]
    pub const Managed: Self = Self(1);
    /// The resource is only available to the GPU.
    ///
    /// ## Discussion
    ///
    /// Metal may apply additional optimizations to private resources that aren’t allowed on shared or managed resources.
    ///
    /// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
    ///
    ///
    #[doc(alias = "MTLStorageModePrivate")]
    pub const Private: Self = Self(2);
    /// The resource’s contents are only available to the GPU, and only exist temporarily during a render pass.
    ///
    /// ## Discussion
    ///
    /// The memoryless storage mode uses tile memory, and is only available on Apple family GPUs. Memoryless resources are temporary targets used in a pass and you can’t access their contents with [`MTLLoadActionLoad`](https://developer.apple.com/documentation/metal/mtlloadaction/load) or [`MTLStoreActionStore`](https://developer.apple.com/documentation/metal/mtlstoreaction/store).
    ///
    /// Use memoryless resources for temporary elements used only within a single pass. For example, most render passes don’t store depth attachments and multisample attachments to memory. You can significantly reduce your memory usage by creating these attachments as memoryless resources.
    ///
    /// On Metal devices that support tile rendering, you can use imageblocks to manage transient rendering data more flexibly. For more information about imageblock memory and using it with your shader functions, see the [Metal Shading Language Specification (PDF)](https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf) sections 2.11, 4.5, and 5.6.
    ///
    /// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
    ///
    ///
    #[doc(alias = "MTLStorageModeMemoryless")]
    pub const Memoryless: Self = Self(3);
}

unsafe impl Encode for MTLStorageMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLStorageMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The options you use to specify the hazard tracking mode.
/// Describes how hazard tracking is performed.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLHazardTrackingMode(pub NSUInteger);
impl MTLHazardTrackingMode {
    /// An option specifying that the default tracking mode should be used.
    ///
    /// ## Discussion
    ///
    /// The default behavior varies depending on the type of object being tracked:
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Resource" }] }], [Paragraph { inline_content: [Reference { identifier: "doc://com.apple.metal/documentation/Metal/MTLHazardTrackingMode/tracked", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }]], [[Paragraph { inline_content: [Text { text: "Heap" }] }], [Paragraph { inline_content: [Reference { identifier: "doc://com.apple.metal/documentation/Metal/MTLHazardTrackingMode/untracked", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }]]], alignments: None, metadata: None })
    ///
    #[doc(alias = "MTLHazardTrackingModeDefault")]
    pub const Default: Self = Self(0);
    /// An option specifying that the app must prevent hazards when modifying this object’s contents.
    ///
    /// ## Discussion
    ///
    /// Metal does not do any dependency analysis on untracked resources. You are responsible for ensuring that resources are modified safely. See [Resource synchronization](https://developer.apple.com/documentation/metal/resource-synchronization). When you already have detailed knowledge of how your app works, using untracked resources can improve performance.
    ///
    ///
    #[doc(alias = "MTLHazardTrackingModeUntracked")]
    pub const Untracked: Self = Self(1);
    /// An option specifying that Metal prevents hazards when modifying this object’s contents.
    ///
    /// ## Discussion
    ///
    /// For a resource, Metal tracks dependencies on any accesses to the resource. If you submit a command that modifies the resource, Metal delays that command from executing until prior commands accessing that resource are complete, and prevents future commands from executing until the modifications are complete.
    ///
    /// For a heap, Metal tracks dependencies on accesses to _any_ resources on the heap. If you submit a command that modifies a resource on a heap, Metal delays that command from executing until prior commands accessing the heap’s resources are complete, and prevents future commands accessing the heap’s resources from executing until the modifications are complete. For better performance, use untracked resources and synchronize access yourself.
    ///
    ///
    #[doc(alias = "MTLHazardTrackingModeTracked")]
    pub const Tracked: Self = Self(2);
}

unsafe impl Encode for MTLHazardTrackingMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLHazardTrackingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Optional arguments used to set the behavior of a resource.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLResourceOptions(pub NSUInteger);
bitflags::bitflags! {
    impl MTLResourceOptions: NSUInteger {
/// The default CPU cache mode for the resource, which guarantees that read and write operations are executed in the expected order.
        #[doc(alias = "MTLResourceCPUCacheModeDefaultCache")]
        const CPUCacheModeDefaultCache = MTLCPUCacheMode::DefaultCache.0<<MTLResourceCPUCacheModeShift;
/// A write-combined CPU cache mode that is optimized for resources that the CPU writes into, but never reads.
        #[doc(alias = "MTLResourceCPUCacheModeWriteCombined")]
        const CPUCacheModeWriteCombined = MTLCPUCacheMode::WriteCombined.0<<MTLResourceCPUCacheModeShift;
/// The CPU and GPU share access to the resource, allocated in system memory.
///
/// ## Discussion
///
/// This is the default storage mode for [`MTLBuffer`](https://developer.apple.com/documentation/metal/mtlbuffer) instances on integrated GPUs and both [`MTLBuffer`](https://developer.apple.com/documentation/metal/mtlbuffer) and [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture) instances on Apple silicon GPUs. On non-Apple family GPUs, the shared storage mode isn’t available for [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture) instances.
///
/// When either the CPU or GPU changes the contents of the resource, you’re responsible for synchronizing access to the texture from the other participant. Ensure that all changes you schedule on either the CPU or GPU for a resource that uses shared memory complete before accessing that resource on the other processor.
///
/// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
///
///
        #[doc(alias = "MTLResourceStorageModeShared")]
        const StorageModeShared = MTLStorageMode::Shared.0<<MTLResourceStorageModeShift;
/// The CPU and GPU may maintain separate copies of the resource, and any changes must be explicitly synchronized.
///
/// ## Discussion
///
/// On Intel-based Mac computers, this is the default storage mode for [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture) objects. In iOS and tvOS, the managed storage mode isn’t available. With managed storage, you synchronize changes between the CPU and GPU manually. For instructions and examples of resource synchronization, see [Synchronizing a managed resource in macOS](https://developer.apple.com/documentation/metal/synchronizing-a-managed-resource-in-macos).
///
/// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
///
///
        #[doc(alias = "MTLResourceStorageModeManaged")]
        const StorageModeManaged = MTLStorageMode::Managed.0<<MTLResourceStorageModeShift;
/// The resource is only available to the GPU.
///
/// ## Discussion
///
/// Metal may apply additional optimizations to private resources that aren’t allowed on shared or managed resources.
///
/// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
///
///
        #[doc(alias = "MTLResourceStorageModePrivate")]
        const StorageModePrivate = MTLStorageMode::Private.0<<MTLResourceStorageModeShift;
/// The resource’s contents are only available to the GPU, and only exist temporarily during a render pass.
///
/// ## Discussion
///
/// The memoryless storage mode uses tile memory, and is only available on Apple family GPUs. Memoryless resources are temporary targets used in a pass and you can’t access their contents with [`MTLLoadActionLoad`](https://developer.apple.com/documentation/metal/mtlloadaction/load) or [`MTLStoreActionStore`](https://developer.apple.com/documentation/metal/mtlstoreaction/store).
///
/// Use memoryless resources for temporary elements used only within a single pass. For example, most render passes don’t store depth attachments and multisample attachments to memory. You can significantly reduce your memory usage by creating these attachments as memoryless resources.
///
/// On Metal devices that support tile rendering, you can use imageblocks to manage transient rendering data more flexibly. For more information about imageblock memory and using it with your shader functions, see the [Metal Shading Language Specification (PDF)](https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf) sections 2.11, 4.5, and 5.6.
///
/// For more guidance on how to choose storage modes, see [Setting resource storage modes](https://developer.apple.com/documentation/metal/setting-resource-storage-modes).
///
///
        #[doc(alias = "MTLResourceStorageModeMemoryless")]
        const StorageModeMemoryless = MTLStorageMode::Memoryless.0<<MTLResourceStorageModeShift;
/// An option specifying that the default tracking mode should be used.
///
/// ## Discussion
///
/// For more information, see [`MTLHazardTrackingMode.default`](https://developer.apple.com/documentation/metal/mtlhazardtrackingmode/default).
///
///
        #[doc(alias = "MTLResourceHazardTrackingModeDefault")]
        const HazardTrackingModeDefault = MTLHazardTrackingMode::Default.0<<MTLResourceHazardTrackingModeShift;
/// An option specifying that the app must prevent hazards when modifying this object’s contents.
///
/// ## Discussion
///
/// For more information, see [`MTLHazardTrackingModeUntracked`](https://developer.apple.com/documentation/metal/mtlhazardtrackingmode/untracked).
///
///
        #[doc(alias = "MTLResourceHazardTrackingModeUntracked")]
        const HazardTrackingModeUntracked = MTLHazardTrackingMode::Untracked.0<<MTLResourceHazardTrackingModeShift;
/// An option specifying that Metal prevents hazards when modifying this object’s contents.
///
/// ## Discussion
///
/// For more information, see [`MTLHazardTrackingModeTracked`](https://developer.apple.com/documentation/metal/mtlhazardtrackingmode/tracked).
///
///
        #[doc(alias = "MTLResourceHazardTrackingModeTracked")]
        const HazardTrackingModeTracked = MTLHazardTrackingMode::Tracked.0<<MTLResourceHazardTrackingModeShift;
/// This constant was deprecated in iOS 9.0 and macOS 10.11.
        #[doc(alias = "MTLResourceOptionCPUCacheModeDefault")]
#[deprecated]
        const OptionCPUCacheModeDefault = MTLResourceOptions::CPUCacheModeDefaultCache.0;
/// This constant was deprecated in iOS 9.0 and macOS 10.11.
        #[doc(alias = "MTLResourceOptionCPUCacheModeWriteCombined")]
#[deprecated]
        const OptionCPUCacheModeWriteCombined = MTLResourceOptions::CPUCacheModeWriteCombined.0;
    }
}

unsafe impl Encode for MTLResourceOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MTLResourceOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The page size options, in kilobytes, for sparse textures.
/// Physical size of sparse resource page in KBs.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MTLSparsePageSize(pub NSInteger);
impl MTLSparsePageSize {
    /// Represents a sparse texture’s page size of 16 kilobytes.
    #[doc(alias = "MTLSparsePageSize16")]
    pub const Size16: Self = Self(101);
    /// Represents a sparse texture’s page size of 64 kilobytes.
    #[doc(alias = "MTLSparsePageSize64")]
    pub const Size64: Self = Self(102);
    /// Represents a sparse texture’s page size of 256 kilobytes.
    #[doc(alias = "MTLSparsePageSize256")]
    pub const Size256: Self = Self(103);
}

unsafe impl Encode for MTLSparsePageSize {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLSparsePageSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerates the different support levels for sparse buffers.
/// Enumerates the different support levels for sparse buffers.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLBufferSparseTier(pub NSInteger);
impl MTLBufferSparseTier {
    /// Indicates that the buffer is not sparse.
    /// Indicates that the buffer is not sparse.
    #[doc(alias = "MTLBufferSparseTierNone")]
    pub const TierNone: Self = Self(0);
    /// Indicates support for sparse buffers tier 1.
    ///
    /// ## Discussion
    ///
    /// Tier 1 sparse buffers allow the following:
    ///
    /// - Partial memory backing at sparse page granularity.
    ///
    /// - Defined behavior for accessing an _unbacked_ buffer range.
    ///
    /// An unbacked buffer range indicates a range within the buffer that doesn’t have memory backing at a given point in time. Accessing an unbacked buffer range of a sparse buffer produces the following results:
    ///
    /// - Reading return zero.
    ///
    /// - Writing produces no result.
    ///
    ///
    /// Indicates support for sparse buffers tier 1.
    ///
    /// Tier 1 sparse buffers allow the following:
    /// * Partial memory backing at sparse page granularity.
    /// * Defined behavior for accessing an *unbacked* buffer range.
    ///
    /// An unbacked buffer range indicates a range within the buffer that doesn't
    /// have memory backing at a given point in time. Accessing an unbacked buffer
    /// range of a sparse buffer produces the following results:
    /// * Reading return zero.
    /// * Writing produces no result.
    #[doc(alias = "MTLBufferSparseTier1")]
    pub const Tier1: Self = Self(1);
}

unsafe impl Encode for MTLBufferSparseTier {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLBufferSparseTier {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerates the different support levels for sparse textures.
/// Enumerates the different support levels for sparse textures.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MTLTextureSparseTier(pub NSInteger);
impl MTLTextureSparseTier {
    /// Indicates that the texture is not sparse.
    /// Indicates that the texture is not sparse.
    #[doc(alias = "MTLTextureSparseTierNone")]
    pub const TierNone: Self = Self(0);
    /// Indicates support for sparse textures tier 1.
    ///
    /// ## Discussion
    ///
    /// Tier 1 sparse textures allow the following:
    ///
    /// - Partial memory backing at sparse tile granularity.
    ///
    /// - Defined behavior for accessing an unbacked texture region.
    ///
    /// - Shader feedback on texture access to determine memory backing.
    ///
    /// An unbacked texture region indicates a region within the texture that doesn’t have memory backing at a given point in time. Accessing an unbacked texture region produces the following results:
    ///
    /// - Reading returns zero (transparent black) for pixel formats with an alpha (A) channel.
    ///
    /// - Reading return zero in RGB and one in alpha (A) channels (opaque black) otherwise.
    ///
    /// - Writing produces no result.
    ///
    ///
    /// Indicates support for sparse textures tier 1.
    ///
    /// Tier 1 sparse textures allow the following:
    /// * Partial memory backing at sparse tile granularity.
    /// * Defined behavior for accessing an unbacked texture region.
    /// * Shader feedback on texture access to determine memory backing.
    ///
    /// An unbacked texture region indicates a region within the texture that doesn't
    /// have memory backing at a given point in time. Accessing an unbacked texture
    /// region produces the following results:
    /// * Reading returns zero (transparent black) for pixel formats with an alpha (A) channel.
    /// * Reading return zero in RGB and one in alpha (A) channels (opaque black) otherwise.
    /// * Writing produces no result.
    #[doc(alias = "MTLTextureSparseTier1")]
    pub const Tier1: Self = Self(1);
    /// Indicates support for sparse textures tier 2.
    ///
    /// ## Discussion
    ///
    /// In addition to the guarantees tier 1 sparse textures provide, tier 2 sparse textures allow the following:
    ///
    /// - Obtain per-tile activity counters.
    ///
    ///
    /// Indicates support for sparse textures tier 2.
    ///
    /// In addition to the guarantees tier 1 sparse textures provide,
    /// tier 2 sparse textures allow the following:
    /// * Obtain per-tile activity counters.
    #[doc(alias = "MTLTextureSparseTier2")]
    pub const Tier2: Self = Self(2);
}

unsafe impl Encode for MTLTextureSparseTier {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MTLTextureSparseTier {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// An allocation of memory accessible to a GPU.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t implement this protocol yourself. Create resources by calling methods on [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice), [`MTLBuffer`](https://developer.apple.com/documentation/metal/mtlbuffer), or [`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture).
    ///
    ///
    ///
    /// </div>
    /// When you execute commands on the GPU, those commands can only affect memory allocated as [`MTLResource`](https://developer.apple.com/documentation/metal/mtlresource) objects. Only the [`MTLDevice`](https://developer.apple.com/documentation/metal/mtldevice) that created these resources can modify them. Different resource types have different uses. The most common resource types are buffers ([`MTLBuffer`](https://developer.apple.com/documentation/metal/mtlbuffer)), which are linear allocations of memory, and textures ([`MTLTexture`](https://developer.apple.com/documentation/metal/mtltexture)), which hold structured image data.
    ///
    ///
    /// Common APIs available for MTLBuffer and MTLTexture instances
    #[cfg(feature = "MTLAllocation")]
    pub unsafe trait MTLResource: MTLAllocation {
        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        fn setLabel(&self, label: Option<&NSString>);

        #[cfg(feature = "MTLDevice")]
        /// The device this resource was created against.  This resource can only be used with this device.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// The cache mode used for the CPU mapping for this resource
        #[unsafe(method(cpuCacheMode))]
        #[unsafe(method_family = none)]
        fn cpuCacheMode(&self) -> MTLCPUCacheMode;

        /// The resource storage mode used for the CPU mapping for this resource
        #[unsafe(method(storageMode))]
        #[unsafe(method_family = none)]
        fn storageMode(&self) -> MTLStorageMode;

        /// Whether or not the resource is hazard tracked.
        ///
        /// This value can be either MTLHazardTrackingModeUntracked or MTLHazardTrackingModeTracked.
        /// Resources created from heaps are by default untracked, whereas resources created from the device are by default tracked.
        #[unsafe(method(hazardTrackingMode))]
        #[unsafe(method_family = none)]
        fn hazardTrackingMode(&self) -> MTLHazardTrackingMode;

        /// A packed tuple of the storageMode, cpuCacheMode and hazardTrackingMode properties.
        #[unsafe(method(resourceOptions))]
        #[unsafe(method_family = none)]
        fn resourceOptions(&self) -> MTLResourceOptions;

        /// Set (or query) the purgeability state of a resource
        ///
        /// Synchronously set the purgeability state of a resource and return what the prior (or current) state is.
        /// FIXME: If the device is keeping a cached copy of the resource, both the shared copy and cached copy are made purgeable.  Any access to the resource by either the CPU or device will be undefined.
        #[unsafe(method(setPurgeableState:))]
        #[unsafe(method_family = none)]
        fn setPurgeableState(&self, state: MTLPurgeableState) -> MTLPurgeableState;

        #[cfg(feature = "MTLHeap")]
        /// The heap from which this resouce was created.
        ///
        /// Nil when this resource is not backed by a heap.
        #[unsafe(method(heap))]
        #[unsafe(method_family = none)]
        fn heap(&self) -> Option<Retained<ProtocolObject<dyn MTLHeap>>>;

        /// The offset inside the heap at which this resource was created.
        ///
        /// Zero when this resource was not created on a heap with MTLHeapTypePlacement.
        #[unsafe(method(heapOffset))]
        #[unsafe(method_family = none)]
        fn heapOffset(&self) -> NSUInteger;

        /// The size in bytes occupied by this resource
        #[unsafe(method(allocatedSize))]
        #[unsafe(method_family = none)]
        fn allocatedSize(&self) -> NSUInteger;

        /// Allow future heap sub-allocations to alias against this resource's memory.
        ///
        /// It is illegal to call this method on a non heap-based resource.
        /// It is also illegal to call this method on texture views created from heap-based textures.
        /// The debug layer will raise an exception. Calling this method on textures sub-allocated
        /// from Buffers backed by heap memory has no effect.
        /// Once a resource is made aliasable, the decision cannot be reverted.
        #[unsafe(method(makeAliasable))]
        #[unsafe(method_family = none)]
        unsafe fn makeAliasable(&self);

        /// Returns whether future heap sub-allocations may alias against this resource's memory.
        ///
        /// Returns: YES if
        /// <st
        /// >makeAliasable
        /// </st
        /// > was previously successfully called on this resource. NO otherwise.
        /// If resource is sub-allocated from other resource created on the heap, isAliasable returns
        /// aliasing state of that base resource. Also returns NO when storage mode is memoryless.
        #[unsafe(method(isAliasable))]
        #[unsafe(method_family = none)]
        fn isAliasable(&self) -> bool;

        #[cfg(feature = "libc")]
        /// Assigns ownership of the resource's underlying memory to another task for the purposes of VM accounting.
        #[unsafe(method(setOwnerWithIdentity:))]
        #[unsafe(method_family = none)]
        unsafe fn setOwnerWithIdentity(
            &self,
            task_id_token: task_id_token_t,
        ) -> libc::kern_return_t;
    }
);
