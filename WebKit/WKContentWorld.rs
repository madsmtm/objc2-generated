//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An object that defines a scope of execution for JavaScript code, and which you use to prevent conflicts between different scripts.
    ///
    /// ## Overview
    ///
    /// Use a [`WKContentWorld`](https://developer.apple.com/documentation/webkit/wkcontentworld) object as a namespace to separate your app’s web environment from the environment of individual webpages or scripts you execute. Content worlds help prevent issues that occur when two scripts modify environment variables in conflicting ways. Executing a script in its own content world effectively gives it a separate copy of the environment variables to modify. You might use this support in the following scenarios:
    ///
    /// - You have complex script logic to bridge your web content to your app, but your web content has complex script libraries of its own. In that scenario, use one content world for your app-specific scripts and a separate content world for your content-specific scripts.
    ///
    /// - You implement a web browser that supports JavaScript extensions. In that scenario, create a unique content world for each extension to prevent conflicts between the extensions.
    ///
    /// A [`WKContentWorld`](https://developer.apple.com/documentation/webkit/wkcontentworld) object is a namespace and doesn’t persist data outside of the current web view or webpage. If you use the same content world in two [`WKWebView`](https://developer.apple.com/documentation/webkit/wkwebview) objects, variables in one web view’s content world don’t appear in the other web view. Similarly, when the user or your app navigates to a new webpage, variables from the previous page are gone, even if both pages share the same content world.
    ///
    /// Use the methods and properties of this class to fetch the content world you need. [`WKContentWorld`](https://developer.apple.com/documentation/webkit/wkcontentworld) provides a default content world for your app and a content world for the current web page. You can also create new content worlds. For example, you might create a custom content world for each JavaScript extension you manage. Specify the content world object when configuring or executing scripts associated with your content.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The content world doesn’t apply to the current document or DOM of a webpage. Changes you make to the DOM are visible to all script code, regardless of content world. The content world affects only references to other JavaScript variables.
    ///
    ///
    ///
    /// </div>
    ///
    /// A WKContentWorld object allows you to separate your application's interaction with content displayed in a WKWebView into different roles that cannot interfere with one another.
    ///
    /// WKContentWorld objects should be treated as namespaces. This is useful for keeping your application's web content environment separate from the environment of the web page content itself,
    /// as well as managing multiple different environments within your own application.
    /// For example:
    /// - If you have complex scripting logic to bridge your web content to your application but your web content also has complex scripting libraries of its own,
    /// you avoid possible conflicts by using a client WKContentWorld.
    /// - If you are writing a general purpose web browser that supports JavaScript extensions, you would use a different client WKContentWorld for each extension.
    ///
    /// Since a WKContentWorld object is a namespace it does not contain any data itself.
    /// For example:
    /// - If you store a variable in JavaScript in the scope of a particular WKContentWorld while viewing a particular web page document, after navigating to a new document that variable will be gone.
    /// - If you store a variable in JavaScript in the scope of a particular WKContentWorld in one WKWebView, that variable will not exist in the same world in another WKWebView.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WKContentWorld;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for WKContentWorld {}
);

impl WKContentWorld {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Retrieve the main world that page content itself uses.
        ///
        /// When interacting with page content in a WKWebView using the page content world you can disrupt the operation of page content (e.g. by conflicting with variable names in JavaScript set by the web page content itself).
        #[unsafe(method(pageWorld))]
        #[unsafe(method_family = none)]
        pub unsafe fn pageWorld(mtm: MainThreadMarker) -> Retained<WKContentWorld>;

        /// Retrieve the default world for API client use.
        ///
        /// When using a content world different from the page content world you can still manipulate the DOM and built-in DOM APIs but without conflicting with other aspects of the page content (e.g. JavaScript from the web page content itself)
        /// Repeated calls will retrieve the same WKContentWorld instance.
        #[unsafe(method(defaultClientWorld))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultClientWorld(mtm: MainThreadMarker) -> Retained<WKContentWorld>;

        /// Retrieves a named content world for API client use.
        ///
        /// Parameter `name`: The name of the WKContentWorld to retrieve.
        ///
        /// When using a content world different from the page content world you can still manipulate the DOM and built-in DOM APIs but without conflicting with other aspects of the page content (e.g. JavaScript from the web page content itself)
        /// As long as a particular named WKContentWorld instance has not been deallocated, repeated calls with the same name will retrieve that same WKContentWorld instance.
        /// Each named content world is distinct from all other named content worlds, the defaultClientWorld, and the pageWorld.
        /// The name can be used to keep distinct worlds identifiable anywhere a world might be surfaced in a user interface. For example, the different worlds used in your application will be surfaced by name in the WebKit Web Inspector.
        #[unsafe(method(worldWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldWithName(
            name: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<WKContentWorld>;

        /// The name of the WKContentWorld
        ///
        /// The pageWorld and defaultClientWorld instances will have a nil name.
        /// All other instances will have the non-nil name they were accessed by.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;
    );
}
