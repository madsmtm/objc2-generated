//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-avf-audio")]
use objc2_avf_audio::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/ptchanneljoinreason?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PTChannelJoinReason(pub NSInteger);
impl PTChannelJoinReason {
    /// The app joined via a programmatic call to requestJoinChannelWithUUID:descriptor: while in the foreground
    #[doc(alias = "PTChannelJoinReasonDeveloperRequest")]
    pub const DeveloperRequest: Self = Self(0);
    /// Rejoined via channel restoration
    #[doc(alias = "PTChannelJoinReasonChannelRestoration")]
    pub const ChannelRestoration: Self = Self(1);
}

unsafe impl Encode for PTChannelJoinReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PTChannelJoinReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/ptchannelleavereason?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PTChannelLeaveReason(pub NSInteger);
impl PTChannelLeaveReason {
    #[doc(alias = "PTChannelLeaveReasonUnknown")]
    pub const Unknown: Self = Self(0);
    /// User pressed the leave button in the system UI
    #[doc(alias = "PTChannelLeaveReasonUserRequest")]
    pub const UserRequest: Self = Self(1);
    /// The app made a call to leaveChannelWithUUID:
    #[doc(alias = "PTChannelLeaveReasonDeveloperRequest")]
    pub const DeveloperRequest: Self = Self(2);
    /// For example, a new managed device restriction has come into effect
    #[doc(alias = "PTChannelLeaveReasonSystemPolicy")]
    pub const SystemPolicy: Self = Self(3);
}

unsafe impl Encode for PTChannelLeaveReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PTChannelLeaveReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/ptchanneltransmitrequestsource?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PTChannelTransmitRequestSource(pub NSInteger);
impl PTChannelTransmitRequestSource {
    #[doc(alias = "PTChannelTransmitRequestSourceUnknown")]
    pub const Unknown: Self = Self(0);
    /// User pressed the transmit button in the on-screen system user interface
    #[doc(alias = "PTChannelTransmitRequestSourceUserRequest")]
    pub const UserRequest: Self = Self(1);
    /// The app made a call to requestBeginTransmittingWithChannelUUID:
    #[doc(alias = "PTChannelTransmitRequestSourceDeveloperRequest")]
    pub const DeveloperRequest: Self = Self(2);
    /// User pressed a button on a hands-free device such as a wired headset
    #[doc(alias = "PTChannelTransmitRequestSourceHandsfreeButton")]
    pub const HandsfreeButton: Self = Self(3);
}

unsafe impl Encode for PTChannelTransmitRequestSource {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PTChannelTransmitRequestSource {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/ptchannelmanagerdelegate?language=objc)
    pub unsafe trait PTChannelManagerDelegate: NSObjectProtocol {
        #[cfg(feature = "PTChannelManager")]
        /// This method is called when your channel becomes active in the system user interface
        #[unsafe(method(channelManager:didJoinChannelWithUUID:reason:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_didJoinChannelWithUUID_reason(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            reason: PTChannelJoinReason,
        );

        #[cfg(feature = "PTChannelManager")]
        /// This method is called once your channel is ended
        #[unsafe(method(channelManager:didLeaveChannelWithUUID:reason:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_didLeaveChannelWithUUID_reason(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            reason: PTChannelLeaveReason,
        );

        #[cfg(feature = "PTChannelManager")]
        /// This method is called when the user begins pressing the Talk button in the system user interface,  when a programmatic transmit start request succeeds, or transmitting began due to a hands-free accessory button press.
        #[unsafe(method(channelManager:channelUUID:didBeginTransmittingFromSource:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_channelUUID_didBeginTransmittingFromSource(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            source: PTChannelTransmitRequestSource,
        );

        #[cfg(feature = "PTChannelManager")]
        /// This method is called when the user stops pressing the Talk button in the system user interface,  when a programmatic transmit stop request succeeds, or transmitting ends due to a hands-free accessory button press.
        #[unsafe(method(channelManager:channelUUID:didEndTransmittingFromSource:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_channelUUID_didEndTransmittingFromSource(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            source: PTChannelTransmitRequestSource,
        );

        #[cfg(feature = "PTChannelManager")]
        /// This method is called when your channel manager receives a push token after joining a channel. This token is ephemeral and is only valid while joined to the channel; it is invalidated when the user or a push request leave the channel. When sending pushes, the apns-topic header field must use your appâ€™s bundle ID with .voip-ptt appended to the end
        #[unsafe(method(channelManager:receivedEphemeralPushToken:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_receivedEphemeralPushToken(
            &self,
            channel_manager: &PTChannelManager,
            push_token: &NSData,
        );

        #[cfg(all(feature = "PTChannelManager", feature = "PTPushResult"))]
        /// This method is called for each incoming push. You must instantiate and return nonnil PTPushResult for each incoming push. The system will fulfill the action specified by the PTPushResult on your behalf automatically.
        ///
        /// # Safety
        ///
        /// `push_payload` generic should be of the correct type.
        #[unsafe(method(incomingPushResultForChannelManager:channelUUID:pushPayload:))]
        #[unsafe(method_family = none)]
        unsafe fn incomingPushResultForChannelManager_channelUUID_pushPayload(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            push_payload: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<PTPushResult>;

        #[cfg(all(feature = "PTChannelManager", feature = "objc2-avf-audio"))]
        #[unsafe(method(channelManager:didActivateAudioSession:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_didActivateAudioSession(
            &self,
            channel_manager: &PTChannelManager,
            audio_session: &AVAudioSession,
        );

        #[cfg(all(feature = "PTChannelManager", feature = "objc2-avf-audio"))]
        #[unsafe(method(channelManager:didDeactivateAudioSession:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_didDeactivateAudioSession(
            &self,
            channel_manager: &PTChannelManager,
            audio_session: &AVAudioSession,
        );

        #[cfg(feature = "PTChannelManager")]
        #[optional]
        #[unsafe(method(channelManager:failedToJoinChannelWithUUID:error:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_failedToJoinChannelWithUUID_error(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            error: &NSError,
        );

        #[cfg(feature = "PTChannelManager")]
        #[optional]
        #[unsafe(method(channelManager:failedToLeaveChannelWithUUID:error:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_failedToLeaveChannelWithUUID_error(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            error: &NSError,
        );

        #[cfg(feature = "PTChannelManager")]
        #[optional]
        #[unsafe(method(channelManager:failedToBeginTransmittingInChannelWithUUID:error:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_failedToBeginTransmittingInChannelWithUUID_error(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            error: &NSError,
        );

        #[cfg(feature = "PTChannelManager")]
        #[optional]
        #[unsafe(method(channelManager:failedToStopTransmittingInChannelWithUUID:error:))]
        #[unsafe(method_family = none)]
        unsafe fn channelManager_failedToStopTransmittingInChannelWithUUID_error(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            error: &NSError,
        );

        #[cfg(all(feature = "PTChannelManager", feature = "block2"))]
        /// This method is called for each incoming service update push. Use this method to extract service update data from the notification's payload and to
        /// perform the relevant task for that data. When you finish the task, execute the provided `completion` handler block to let PushToTalk know you are finished.
        ///
        /// Service Update push notifications that are sent with high priority (priority=10) are subject to a budget of six per hour. Use the `remainingHighPriorityBudget`
        /// value to monitor the number of remaining high priority push notifications available to your app. Low-priority push notifications (priority
        /// <
        /// =5) are not subject
        /// to a budget limit and should be used whenever possible.
        ///
        /// # Safety
        ///
        /// `push_payload` generic should be of the correct type.
        #[optional]
        #[unsafe(method(incomingServiceUpdatePushForChannelManager:channelUUID:pushPayload:isHighPriority:remainingHighPriorityBudget:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn incomingServiceUpdatePushForChannelManager_channelUUID_pushPayload_isHighPriority_remainingHighPriorityBudget_withCompletionHandler(
            &self,
            channel_manager: &PTChannelManager,
            channel_uuid: &NSUUID,
            push_payload: &NSDictionary<NSString, AnyObject>,
            is_high_priority: bool,
            remaining_high_priority_budget: NSInteger,
            completion: &block2::DynBlock<dyn Fn()>,
        );
    }
);
