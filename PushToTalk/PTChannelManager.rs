//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/ptservicestatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PTServiceStatus(pub NSInteger);
impl PTServiceStatus {
    /// The service is available for use and ready for use by the client.
    #[doc(alias = "PTServiceStatusReady")]
    pub const Ready: Self = Self(0);
    /// The client is attempting to establish a connection to the service.
    #[doc(alias = "PTServiceStatusConnecting")]
    pub const Connecting: Self = Self(1);
    /// The service has become unavailable and availability needs to be re-established once conditions have changed.
    #[doc(alias = "PTServiceStatusUnavailable")]
    pub const Unavailable: Self = Self(2);
}

unsafe impl Encode for PTServiceStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PTServiceStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/pttransmissionmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PTTransmissionMode(pub NSInteger);
impl PTTransmissionMode {
    /// Users can transmit and receive simultaneously.
    #[doc(alias = "PTTransmissionModeFullDuplex")]
    pub const FullDuplex: Self = Self(0);
    /// Users can transmit and receive but not simultaneously. This is the default value.
    #[doc(alias = "PTTransmissionModeHalfDuplex")]
    pub const HalfDuplex: Self = Self(1);
    /// User is able to receive only, transmit is not permitted.
    #[doc(alias = "PTTransmissionModeListenOnly")]
    pub const ListenOnly: Self = Self(2);
}

unsafe impl Encode for PTTransmissionMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PTTransmissionMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/pushtotalk/ptchannelmanager?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PTChannelManager;
);

unsafe impl Send for PTChannelManager {}

unsafe impl Sync for PTChannelManager {}

extern_conformance!(
    unsafe impl NSObjectProtocol for PTChannelManager {}
);

impl PTChannelManager {
    extern_methods!(
        #[cfg(all(
            feature = "PTChannelManagerDelegate",
            feature = "PTChannelRestorationDelegate",
            feature = "block2"
        ))]
        /// You must instantiate a channel manager upon launching your app, otherwise the system will tear down channels and their ability to receive pushes. By providing a restoration delegate, you can decide whether to rejoin or leave any previously active channels that the system knows about. Once the channel restoration process is completed, you will be given the PTChannelManager instance.
        #[unsafe(method(channelManagerWithDelegate:restorationDelegate:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn channelManagerWithDelegate_restorationDelegate_completionHandler(
            delegate: &ProtocolObject<dyn PTChannelManagerDelegate>,
            restoration_delegate: &ProtocolObject<dyn PTChannelRestorationDelegate>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut PTChannelManager, *mut NSError)>,
        );

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Only one channel can be active at a time -- this is the channel that will handle user events
        /// This being nonnull reflects whether the user can see this channel is active in the user interface
        /// The ephemeral push token is only usable when this is nonnull.
        ///
        /// This property is not atomic.
        #[unsafe(method(activeChannelUUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn activeChannelUUID(&self) -> Option<Retained<NSUUID>>;

        #[cfg(feature = "PTChannelDescriptor")]
        /// You may only join a channel in the foreground. If successful, you will receive the delegate callback channelManager:didJoinChannelWithUUID:reason: with reason PTChannelJoinReasonProgrammaticRequest. Otherwise, the delegate callback channelManager:failedToJoinChannelWithUUID:error: will be invoked if implemented.
        #[unsafe(method(requestJoinChannelWithUUID:descriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestJoinChannelWithUUID_descriptor(
            &self,
            channel_uuid: &NSUUID,
            descriptor: &PTChannelDescriptor,
        );

        /// If successful, you will receive the delegate callback channelManager:channelUUID:didBeginTransmittingFromSource: with PTChannelTransmitRequestSourceProgrammaticRequest. Otherwise, the delegate callback channelManager:failedToBeginTransmittingInChannelWithUUID:error: will be invoked if implemented.
        #[unsafe(method(requestBeginTransmittingWithChannelUUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestBeginTransmittingWithChannelUUID(&self, channel_uuid: &NSUUID);

        /// If successful, you will receive the delegate callback channelManager:channelUUID:didEndTransmittingFromSource with request source PTChannelTransmitRequestSourceProgrammaticRequest. Otherwise, the delegate callback channelManager:failedToStopTransmittingInChannelWithUUID:error: will be invoked if implemented. Generally, this should always succeed, unless you are not currently transmitting or are not joined to a channel.
        #[unsafe(method(stopTransmittingWithChannelUUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopTransmittingWithChannelUUID(&self, channel_uuid: &NSUUID);

        /// If successful, you will receive the delegate callback channelManager:channelUUID:didLeaveChannelWithUUID:reason: with reason PTChannelLeaveReasonProgrammaticRequest, Otherwise, the delegate callback channelManager:failedToLeaveChannelWithUUID:error: will be invoked if implemented. Generally, this should always succeed so long as you are already joined to a channel.
        #[unsafe(method(leaveChannelWithUUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn leaveChannelWithUUID(&self, channel_uuid: &NSUUID);

        #[cfg(all(feature = "PTChannelDescriptor", feature = "block2"))]
        /// Updates the channel descriptor
        #[unsafe(method(setChannelDescriptor:forChannelUUID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setChannelDescriptor_forChannelUUID_completionHandler(
            &self,
            channel_descriptor: &PTChannelDescriptor,
            channel_uuid: &NSUUID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(all(feature = "PTParticipant", feature = "block2"))]
        /// When receiving incoming audio from a remote participant, set the participant to a nonnull value, which will update the system user interface and block transmitting. When the user has stopped speaking, set the participant to nil.
        #[unsafe(method(setActiveRemoteParticipant:forChannelUUID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setActiveRemoteParticipant_forChannelUUID_completionHandler(
            &self,
            participant: Option<&PTParticipant>,
            channel_uuid: &NSUUID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// The default value for service status is PTServiceStatusReady. If your underlying network connection is experiencing issues, set the appropriate service status. The service status will be reflected in the system user interface.
        #[unsafe(method(setServiceStatus:forChannelUUID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServiceStatus_forChannelUUID_completionHandler(
            &self,
            status: PTServiceStatus,
            channel_uuid: &NSUUID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// The default value for transmission mode is PTTransmissionModeHalfDuplex. If your application support one of the other transmission modes set it using this function. The system user interface will be updated to reflect the transmission mode.
        #[unsafe(method(setTransmissionMode:forChannelUUID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTransmissionMode_forChannelUUID_completionHandler(
            &self,
            transmission_mode: PTTransmissionMode,
            channel_uuid: &NSUUID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// The default channel behavior is to map supported accessory button events to begin/end transmission actions. If your application does not wish to map these button events to transmission actions you can disable them by setting the enabled value to false.
        #[unsafe(method(setAccessoryButtonEventsEnabled:forChannelUUID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAccessoryButtonEventsEnabled_forChannelUUID_completionHandler(
            &self,
            enabled: bool,
            channel_uuid: &NSUUID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );
    );
}
