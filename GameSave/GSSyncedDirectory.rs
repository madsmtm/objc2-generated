//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
use objc2_app_kit::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/gamesave/gssyncstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct GSSyncState(pub NSInteger);
impl GSSyncState {
    /// The directory is fully synced and ready to use.
    ///
    /// In this state, the value of ``GSSyncedDirectoryState/url`` is nonnull.
    #[doc(alias = "GSSyncStateReady")]
    pub const Ready: Self = Self(0);
    /// The directory is available locally, but not fully synced because the device is offline.
    ///
    /// In this state, the value of ``GSSyncedDirectoryState/url`` is nonnull.
    #[doc(alias = "GSSyncStateOffline")]
    pub const Offline: Self = Self(1);
    /// The directory is local-only and not synced to iCloud.
    ///
    /// In this state, the value of ``GSSyncedDirectoryState/url`` is nonnull.
    #[doc(alias = "GSSyncStateLocal")]
    pub const Local: Self = Self(2);
    /// The directory is currently syncing and is not ready yet.
    #[doc(alias = "GSSyncStateSyncing")]
    pub const Syncing: Self = Self(3);
    /// The directory has conflicts with the cloud, which the game needs to resolve.
    ///
    /// In this state, the value of ``GSSyncedDirectoryState/conflictedVersions`` is nonnull.
    #[doc(alias = "GSSyncStateConflicted")]
    pub const Conflicted: Self = Self(4);
    /// The directory is in error state and can't be used.
    ///
    /// In this state, the value of ``GSSyncedDirectoryState/error`` is nonnull.
    #[doc(alias = "GSSyncStateError")]
    pub const Error: Self = Self(5);
    /// The directory is closed.
    #[doc(alias = "GSSyncStateClosed")]
    pub const Closed: Self = Self(6);
}

unsafe impl Encode for GSSyncState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GSSyncState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/gamesave/gssynceddirectoryversion?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GSSyncedDirectoryVersion;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GSSyncedDirectoryVersion {}
);

impl GSSyncedDirectoryVersion {
    extern_methods!(
        /// `YES` if the directory version is local; otherwise `NO`.
        #[unsafe(method(isLocal))]
        #[unsafe(method_family = none)]
        pub unsafe fn isLocal(&self) -> bool;

        /// The localized name of the device that saved this version.
        #[unsafe(method(localizedNameOfSavingComputer))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedNameOfSavingComputer(&self) -> Retained<NSString>;

        /// The date that this version was last modified.
        #[unsafe(method(modifiedDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn modifiedDate(&self) -> Retained<NSDate>;

        /// The URL of a directory where you read and write game-save data.
        ///
        /// You define the format and structure of files you write in this directory.
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Retained<NSURL>;

        #[unsafe(method(description))]
        #[unsafe(method_family = none)]
        pub unsafe fn description(&self) -> Retained<NSString>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(&self) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GSSyncedDirectoryVersion {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new_class() -> Retained<Self>;
    );
}

extern_class!(
    /// Represents the state and its associated properties of the directory
    ///
    /// Use the ``state`` property to determine the validity of the other properties
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamesave/gssynceddirectorystate?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GSSyncedDirectoryState;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GSSyncedDirectoryState {}
);

impl GSSyncedDirectoryState {
    extern_methods!(
        /// Specifies the current state of the directory
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> GSSyncState;

        /// The URL of a directory to read and write game-save data in.
        ///
        /// This property's value is `nil` unless the state is `GSSyncStateReady`, `GSSyncStateOffline`, or `GSSyncStateLocal`.
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Option<Retained<NSURL>>;

        /// The conflicting versions.
        ///
        /// If you're implementing your own conflict resolution,
        /// read all of the conflicting versions,
        /// and modify one of them to incorporate the state and changes from the others.
        /// Then call ``GSSyncedDirectory/resolveConflictsWithVersion:``, passing that version.
        ///
        /// This property's value is `nil` unless the state is `GSSyncStateConflicted`.
        #[unsafe(method(conflictedVersions))]
        #[unsafe(method_family = none)]
        pub unsafe fn conflictedVersions(
            &self,
        ) -> Option<Retained<NSArray<GSSyncedDirectoryVersion>>>;

        /// The error preventing you from using the directory.
        ///
        /// This property's value is `nil` unless the state is `GSSyncStateError`.
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        pub unsafe fn error(&self) -> Option<Retained<NSError>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(&self) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GSSyncedDirectoryState {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new_class() -> Retained<Self>;
    );
}

extern_class!(
    /// A cloud-synced directory for game-save data.
    ///
    /// To get an instance of the directory,
    /// call ``openDirectoryForContainerIdentifier:``,
    /// which returns the directory for the iCloud container associated with the specified identifier.
    /// Calling this method starts syncing the directory in the background on the specified container.
    /// When the game needs to access the contents of the directory,
    /// show a UI while the directory fully syncs using
    /// the ``finishSyncing:completionHandler:`` method.
    /// If you're showing your own UI,
    /// call the ``finishSyncingWithCompletionHandler:`` method to wait for the directory to finish syncing.
    ///
    /// After the directory is ready to use,
    /// syncing pauses until you close the directory object or the object is deallocated.
    /// To resume syncing during the game,
    /// close and re-open the directory by calling ``close`` and then ``openDirectoryForContainerIdentifier:``.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamesave/gssynceddirectory?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GSSyncedDirectory;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GSSyncedDirectory {}
);

impl GSSyncedDirectory {
    extern_methods!(
        /// Requests an instance of the game-save directory.
        ///
        /// - Parameter containerIdentifier: The identifier of the directory to request.
        /// If you pass `nil`, this method uses the first container identifier
        /// listed in the `com.apple.developer.icloud-container-identifiers` entitlements array.
        ///
        /// This method returns immediately, and starts syncing the directory in the background.
        /// To wait for syncing to complete, call the ``finishSyncingWithCompletionHandler:`` method.
        #[unsafe(method(openDirectoryForContainerIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openDirectoryForContainerIdentifier(
            container_identifier: Option<&NSString>,
        ) -> Retained<GSSyncedDirectory>;

        /// Closes the directory, and resumes syncing the directory to the cloud.
        #[unsafe(method(close))]
        #[unsafe(method_family = none)]
        pub unsafe fn close(&self);

        #[cfg(feature = "block2")]
        /// Triggers an upload of the directory for any changes that were pending.
        ///
        /// Calls the completion block with `YES` if there were pending uploads; otherwise with `NO`.
        #[unsafe(method(triggerPendingUploadWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn triggerPendingUploadWithCompletionHandler(
            &self,
            completion: &block2::DynBlock<dyn Fn(Bool)>,
        );

        /// Indicates that you resolved a conflict.
        ///
        /// - Parameter version: The version to use.
        ///
        /// If you're implementing your own conflict resolution,
        /// read all of the conflicting versions,
        /// and modify one of them to incorporate the state and changes from the others.
        /// Then call this method, passing that version.
        ///
        /// Call this method only when the directory is in the ``GSSyncState/GSSyncStateConflicted`` state.
        #[unsafe(method(resolveConflictsWithVersion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resolveConflictsWithVersion(&self, version: &GSSyncedDirectoryVersion);

        #[cfg(feature = "block2")]
        /// Waits for the directory sync to complete, without showing any user interface.
        ///
        /// Use this method to wait if your app displays its own syncing UI.
        #[unsafe(method(finishSyncingWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn finishSyncingWithCompletionHandler(
            &self,
            completion: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-app-kit"))]
        #[cfg(target_os = "macos")]
        /// Waits for the directory sync to complete, showing the sync's progress in a modal alert.
        ///
        /// - Parameters:
        /// - statusDisplay: The window where the system shows progress and alerts.
        /// - completion: The block that GameSave calls after syncing finishes.
        ///
        /// If the sync results in a conflict, the framework displays a conflict resolution UI
        /// for the user to chose a version that will be used.
        /// If the user isn't signed in to iCloud or iCloud drive,
        /// the framework informs the user and then switches to local saving.
        #[unsafe(method(finishSyncing:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn finishSyncing_completionHandler(
            &self,
            status_display: &NSWindow,
            completion: &block2::DynBlock<dyn Fn()>,
        );

        /// The state of the directory.
        #[unsafe(method(directoryState))]
        #[unsafe(method_family = none)]
        pub unsafe fn directoryState(&self) -> Retained<GSSyncedDirectoryState>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(&self) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GSSyncedDirectory {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new_class() -> Retained<Self>;
    );
}
