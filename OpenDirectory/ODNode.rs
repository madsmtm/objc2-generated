//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// This class is used to work with OpenDirectory nodes.
    ///
    /// OpenDirectory uses nodes to represent different sources of directory information, via the local disk, LDAP, etc.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/opendirectory/odnode?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct ODNode;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for ODNode {}
);

impl ODNode {
    extern_methods!(
        #[cfg(all(
            feature = "CFOpenDirectory",
            feature = "CFOpenDirectoryConstants",
            feature = "ODSession"
        ))]
        /// Create an autoreleased ODNode of the given type, optionally in a specific session.
        ///
        /// Autoreleased instance of an ODNode with a provided ODSession and ODNodeType.  outError is
        /// optional parameter, nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_session` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(nodeWithSession:type:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodeWithSession_type_error(
            in_session: Option<&ODSession>,
            in_type: ODNodeType,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "ODSession")]
        /// Create an autoreleased ODNode with the given name, optionally in a specific session.
        ///
        /// autoreleased instance of an ODNode with a provided ODSession and node name.  outError is
        /// optional parameter, nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_session` might not allow `None`.
        /// - `in_name` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(nodeWithSession:name:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodeWithSession_name_error(
            in_session: Option<&ODSession>,
            in_name: Option<&NSString>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "CFOpenDirectory",
            feature = "CFOpenDirectoryConstants",
            feature = "ODSession"
        ))]
        /// Initialize an ODNode instance of the given type, optionally in a specific session.
        ///
        /// initialize instance of an ODNode with a provided ODSession and ODNodeType.  outError is
        /// optional parameter, nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_session` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(initWithSession:type:error:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSession_type_error(
            this: Allocated<Self>,
            in_session: Option<&ODSession>,
            in_type: ODNodeType,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "ODSession")]
        /// Initialize an ODNode instance with the given name, optionally in a specific session.
        ///
        /// initialize instance of an ODNode with a provided ODSession and node name.  outError is optional
        /// parameter, nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_session` might not allow `None`.
        /// - `in_name` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(initWithSession:name:error:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSession_name_error(
            this: Allocated<Self>,
            in_session: Option<&ODSession>,
            in_name: Option<&NSString>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<Self>>;

        /// Returns NSArray of node names for this node, which may contain sub-nodes or search policy nodes
        ///
        /// Returns NSArray of node names for this node, which may contain sub-nodes or search policy nodes.
        /// Commonly used with Search policy nodes.  outError is optional parameter, nil can be passed if error
        /// details are not needed.
        ///
        /// # Safety
        ///
        /// `out_error` might not allow `None`.
        #[unsafe(method(subnodeNamesAndReturnError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn subnodeNamesAndReturnError(
            &self,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSArray>>;

        /// Will return NSArray of names of subnodes that are not currently reachable.
        ///
        /// Will return NSArray of names of subnodes that are not currently reachable.  Commonly used with Search policy
        /// nodes to determine if any nodes are currently unreachable, but may also return other subnodes if the
        /// OpenDirectory plugin supports.  outError is optional parameter, nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// `out_error` might not allow `None`.
        #[unsafe(method(unreachableSubnodeNamesAndReturnError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unreachableSubnodeNamesAndReturnError(
            &self,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSArray>>;

        /// The node name.
        ///
        /// The node name, corresponding to its path in OpenDirectory.
        #[unsafe(method(nodeName))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodeName(&self) -> Retained<NSString>;

        /// Returns a dictionary of information about the instance of ODNode
        ///
        /// Returns a dictionary of information about the instance of ODNode.  Details such as Trust information
        /// (kODAttributeTypeTrustInformation) or other Node details can be retrieved.  outError is optional parameter,
        /// nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_keys` generic should be of the correct type.
        /// - `in_keys` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(nodeDetailsForKeys:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodeDetailsForKeys_error(
            &self,
            in_keys: Option<&NSArray>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSDictionary>>;

        /// Returns a NSArray of the record types supported by this node.
        ///
        /// Returns a NSArray of the record types supported by this node.  If node does not support the check
        /// then all possible types will be returned.  outError is optional parameter, nil can be passed if error details
        /// are not needed.
        ///
        /// # Safety
        ///
        /// `out_error` might not allow `None`.
        #[unsafe(method(supportedRecordTypesAndReturnError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedRecordTypesAndReturnError(
            &self,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSArray>>;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// Will return a list of attribute types supported for that attribute if possible
        ///
        /// Will return a list of attribute types supported for that attribute if possible.  If no specific
        /// types are available, then all possible values will be returned instead.  outError is optional parameter,
        /// nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_record_type` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(supportedAttributesForRecordType:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedAttributesForRecordType_error(
            &self,
            in_record_type: Option<&ODRecordType>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSArray>>;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// Sets the credentials for interaction with the ODNode
        ///
        /// Sets the credentials for interaction with the ODNode.  Record references, etc. will use these credentials
        /// to query or change data.  Setting the credentials on a node referenced by other OD object types will
        /// change the credentials for all for all references.  outError is optional parameter, nil can be passed if error
        /// details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_record_type` might not allow `None`.
        /// - `in_record_name` might not allow `None`.
        /// - `in_password` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(setCredentialsWithRecordType:recordName:password:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCredentialsWithRecordType_recordName_password_error(
            &self,
            in_record_type: Option<&ODRecordType>,
            in_record_name: Option<&NSString>,
            in_password: Option<&NSString>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// Allows use of other OpenDirectory types of authentications to set the credentials for an ODNode
        ///
        /// Allows the caller to use other types of authentications that are available in OpenDirectory, that may
        /// require response-request loops, etc.  Not all OD plugins will support this call, look for
        /// kODErrorCredentialsMethodNotSupported in outError.  outError is optional parameter, nil can be passed if
        /// error details is not needed.
        ///
        /// # Safety
        ///
        /// - `in_record_type` might not allow `None`.
        /// - `in_type` might not allow `None`.
        /// - `in_items` generic should be of the correct type.
        /// - `in_items` might not allow `None`.
        /// - `out_items` generic should be of the correct type.
        /// - `out_items` might not allow `None`.
        /// - `out_context` should be of the correct type.
        /// - `out_context` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(setCredentialsWithRecordType:authenticationType:authenticationItems:continueItems:context:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCredentialsWithRecordType_authenticationType_authenticationItems_continueItems_context_error(
            &self,
            in_record_type: Option<&ODRecordType>,
            in_type: Option<&ODAuthenticationType>,
            in_items: Option<&NSArray>,
            out_items: Option<&mut Option<Retained<NSArray>>>,
            out_context: Option<&mut Option<Retained<AnyObject>>>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        /// Unsupported method.
        ///
        /// Unsupported method.
        ///
        /// # Safety
        ///
        /// - `in_cache_name` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[deprecated]
        #[unsafe(method(setCredentialsUsingKerberosCache:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCredentialsUsingKerberosCache_error(
            &self,
            in_cache_name: Option<&NSString>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(all(
            feature = "CFOpenDirectory",
            feature = "CFOpenDirectoryConstants",
            feature = "ODRecord"
        ))]
        /// Creates a record in this node, using the given name and attributes.
        ///
        /// Takes all the provided attributes and type to create an entire record.  The function will assign a
        /// UUID to the record automatically.  This UUID can be overwritten by the client by passing with the
        /// other attributes.  inAttributes is optional, nil can be passed if no other attributes are to be set.
        ///
        /// # Safety
        ///
        /// - `in_record_type` might not allow `None`.
        /// - `in_record_name` might not allow `None`.
        /// - `in_attributes` generic should be of the correct type.
        /// - `in_attributes` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(createRecordWithRecordType:name:attributes:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createRecordWithRecordType_name_attributes_error(
            &self,
            in_record_type: Option<&ODRecordType>,
            in_record_name: Option<&NSString>,
            in_attributes: Option<&NSDictionary>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<ODRecord>>;

        #[cfg(all(
            feature = "CFOpenDirectory",
            feature = "CFOpenDirectoryConstants",
            feature = "ODRecord"
        ))]
        /// Returns an ODRecord object that references the requested type and name
        ///
        /// Returns an ODRecord object that references the requested type and name.  The record will have cached the
        /// attributes requested.  Further attributes can be requested via ODRecord APIs.  For performance it is best
        /// to ask for as many attributes that are needed as possible up front.
        ///
        /// # Safety
        ///
        /// - `in_record_type` might not allow `None`.
        /// - `in_record_name` might not allow `None`.
        /// - `in_attributes` should be of the correct type.
        /// - `in_attributes` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(recordWithRecordType:name:attributes:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordWithRecordType_name_attributes_error(
            &self,
            in_record_type: Option<&ODRecordType>,
            in_record_name: Option<&NSString>,
            in_attributes: Option<&AnyObject>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<ODRecord>>;

        /// Sends a custom code to the node; input and output data formats are specific to the call.
        ///
        /// Sends a custom code to the node; input and output data formats are specific to the call.  outError is
        /// optional parameter, nil can be passed if error details are not needed.
        ///
        /// # Safety
        ///
        /// - `in_send_data` might not allow `None`.
        /// - `out_error` might not allow `None`.
        #[unsafe(method(customCall:sendData:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn customCall_sendData_error(
            &self,
            in_custom_code: NSInteger,
            in_send_data: Option<&NSData>,
            out_error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSData>>;

        /// Sends a custom function call to the node; data is a type specific to the call.
        ///
        /// Sends a custom function call to the node; data is a type specific to the call.  'error' is an
        /// optional parameter therefore nil can be passed if error details are not needed.  Return type is
        /// defined by the custom function requested.
        ///
        /// # Safety
        ///
        /// - `function` might not allow `None`.
        /// - `payload` should be of the correct type.
        /// - `payload` might not allow `None`.
        /// - `error` might not allow `None`.
        #[unsafe(method(customFunction:payload:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn customFunction_payload_error(
            &self,
            function: Option<&NSString>,
            payload: Option<&AnyObject>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "ODConfiguration")]
        /// Returns an ODConfiguration object for the node.
        ///
        ///
        /// Returns an ODConfiguration object for the node.
        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn configuration(&self) -> Option<Retained<ODConfiguration>>;

        /// This will copy any policies configured for the node.
        ///
        /// This will copy any policies configured for the node.
        ///
        /// # Safety
        ///
        /// `error` might not allow `None`.
        #[deprecated = "use accountPoliciesAndReturnError:"]
        #[unsafe(method(policiesAndReturnError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn policiesAndReturnError(
            &self,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSDictionary>>;

        /// This will return a dictionary of supported policies.
        ///
        /// This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
        /// for the policy in question.  For example, if password history is available, it will state how much history is
        /// supported.
        ///
        /// # Safety
        ///
        /// `error` might not allow `None`.
        #[deprecated]
        #[unsafe(method(supportedPoliciesAndReturnError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedPoliciesAndReturnError(
            &self,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSDictionary>>;

        /// This will set the policy for the node.
        ///
        /// This will set the policy for the node.  Policies are evaluated in combination with record-level policies.
        ///
        /// # Safety
        ///
        /// - `policies` generic should be of the correct type.
        /// - `policies` might not allow `None`.
        /// - `error` might not allow `None`.
        #[deprecated = "use setAccountPolicies:error:"]
        #[unsafe(method(setPolicies:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPolicies_error(
            &self,
            policies: Option<&NSDictionary>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// This will set a specific policy setting for the node.
        ///
        /// This will set a specific policy setting for the node.
        ///
        /// # Safety
        ///
        /// - `policy` might not allow `None`.
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        /// - `error` might not allow `None`.
        #[deprecated = "use addAccountPolicy:toCategory:error:"]
        #[unsafe(method(setPolicy:value:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPolicy_value_error(
            &self,
            policy: Option<&ODPolicyType>,
            value: Option<&AnyObject>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// This will remove a specific policy setting from the node.
        ///
        /// This will remove a specific policy setting from the node.
        ///
        /// # Safety
        ///
        /// - `policy` might not allow `None`.
        /// - `error` might not allow `None`.
        #[deprecated = "use removeAccountPolicy:fromCategory:error:"]
        #[unsafe(method(removePolicy:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removePolicy_error(
            &self,
            policy: Option<&ODPolicyType>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// This will add an account policy to the node for the specified category.
        ///
        /// This will add an account policy to the node for the specified category.
        /// The specified policy will be applied to all users in the
        /// specified node when policies are evaluated.
        ///
        /// Parameter `policy`: a dictionary containing the specific policy to be added.
        /// The dictionary may contain the following keys:
        /// kODPolicyKeyIdentifier a required key identifying the policy.
        /// kODPolicyKeyParameters an optional key containing a dictionary of
        /// parameters that can be used for informational purposes or in
        /// the policy format string.
        /// kODPolicyKeyContent a required key specifying the policy,
        /// from which a predicate will be created for evaluating
        /// the policy.
        ///
        /// Parameter `category`: a valid ODPolicyCategoryType to which the specified policy will be added.
        ///
        /// Parameter `error`: an optional NSError reference for error details.
        ///
        /// Returns: a BOOL which signifies if the policy addition succeeded, otherwise error is set.
        ///
        /// # Safety
        ///
        /// - `policy` generic should be of the correct type.
        /// - `policy` might not allow `None`.
        /// - `category` might not allow `None`.
        /// - `error` might not allow `None`.
        #[unsafe(method(addAccountPolicy:toCategory:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAccountPolicy_toCategory_error(
            &self,
            policy: Option<&NSDictionary>,
            category: Option<&ODPolicyCategoryType>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(all(feature = "CFOpenDirectory", feature = "CFOpenDirectoryConstants"))]
        /// This will remove an account policy from the node for the specified category.
        ///
        /// This will remove an account policy from the node for the specified category.
        ///
        /// Parameter `policy`: a dictionary containing the specific policy to be
        /// removed, with the same format as described in addAccountPolicy.
        ///
        /// Parameter `category`: a valid ODPolicyCategoryType from which the specified policy will be removed.
        ///
        /// Parameter `error`: an optional NSError reference for error details.
        ///
        /// Returns: a BOOL which signifies if the policy removal succeeded, otherwise error is set.
        ///
        /// # Safety
        ///
        /// - `policy` generic should be of the correct type.
        /// - `policy` might not allow `None`.
        /// - `category` might not allow `None`.
        /// - `error` might not allow `None`.
        #[unsafe(method(removeAccountPolicy:fromCategory:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAccountPolicy_fromCategory_error(
            &self,
            policy: Option<&NSDictionary>,
            category: Option<&ODPolicyCategoryType>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        /// This will set the policies for the node.
        ///
        /// This will set the policies for the node, replacing any existing
        /// policies.  All of the policies in the set will be applied to all
        /// users in the specified node when policies are evaluated.
        ///
        /// Parameter `policies`: a dictionary containing all of the policies to be set
        /// for the node.  The dictionary may contain the following keys:
        /// kODPolicyCategoryAuthentication an optional key with a value
        /// of an array of policy dictionaries that specify when
        /// authentications should be allowed.
        /// kODPolicyCategoryPasswordContent an optional key with a
        /// value of an array of policy dictionaries the specify the
        /// required content of passwords.
        /// kODPolicyCategoryPasswordChange an optional key with a value
        /// of an array of policy dictionaries that specify when
        /// passwords are required to be changed.
        ///
        /// Parameter `error`: an optional NSError reference for error details.
        ///
        /// Returns: a BOOL which signifies if the policy set succeeded, otherwise error is set.
        ///
        /// # Safety
        ///
        /// - `policies` generic should be of the correct type.
        /// - `policies` might not allow `None`.
        /// - `error` might not allow `None`.
        #[unsafe(method(setAccountPolicies:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAccountPolicies_error(
            &self,
            policies: Option<&NSDictionary>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        /// Returns a dictionary containing any policies configured for the node.
        ///
        /// Returns a dictionary containing any policies configured for the node.
        ///
        /// Parameter `error`: an optional NSError reference for error details.
        ///
        /// Returns: an NSDictionary containing all currently set policies.  The
        /// format of the dictionary is the same as described in
        /// setAccountPolicies.
        ///
        /// # Safety
        ///
        /// `error` might not allow `None`.
        #[unsafe(method(accountPoliciesAndReturnError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn accountPoliciesAndReturnError(
            &self,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> Option<Retained<NSDictionary>>;

        /// Validates a password against the node's password content policies.
        ///
        /// Validates a password against the node's password content policies.
        /// The node's password content policies will be evaluated to
        /// determine if the password is acceptable.  May be used prior to
        /// creating the record.
        ///
        /// This check is only definitive at the time it was requested. The
        /// policy or the environment could change before the password change
        /// is actually requested.  Errors from the password change request
        /// should be consulted.
        ///
        ///
        /// Parameter `password`: the password to be evaluated against the content policies.
        ///
        /// Parameter `recordName`: the name of the record.
        ///
        /// Parameter `error`: an optional NSError reference for error details.
        ///
        /// Returns: a bool which signifies if the password passes all content policies, otherwise error is set.
        ///
        /// # Safety
        ///
        /// - `password` might not allow `None`.
        /// - `record_name` might not allow `None`.
        /// - `error` might not allow `None`.
        #[unsafe(method(passwordContentCheck:forRecordName:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn passwordContentCheck_forRecordName_error(
            &self,
            password: Option<&NSString>,
            record_name: Option<&NSString>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl ODNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
