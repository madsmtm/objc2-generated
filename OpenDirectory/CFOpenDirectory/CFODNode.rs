//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "objc2-core-foundation")]
unsafe impl ConcreteType for ODNodeRef {
    /// Standard GetTypeID function support for CF-based objects
    ///
    /// Returns the typeID for the ODNode objects
    ///
    /// Returns: a valid CFTypeID for the ODNode object
    #[doc(alias = "ODNodeGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn ODNodeGetTypeID() -> CFTypeID;
        }
        unsafe { ODNodeGetTypeID() }
    }
}

impl ODNodeRef {
    /// Creates an ODNodeRef based on a specific node type
    ///
    /// Creates an ODNodeRef based on a specific node type
    ///
    /// Parameter `allocator`: a memory allocator to use for this object
    ///
    /// Parameter `session`: an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
    ///
    /// Parameter `nodeType`: an ODNodeType of the node to open
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a valid ODNodeRef if successful, otherwise returns NULL.  outError can be checked for details upon
    /// failure.
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `session` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCreateWithNodeType")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn with_node_type(
        allocator: Option<&CFAllocator>,
        session: Option<&ODSessionRef>,
        node_type: ODNodeType,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<ODNodeRef>> {
        extern "C-unwind" {
            fn ODNodeCreateWithNodeType(
                allocator: Option<&CFAllocator>,
                session: Option<&ODSessionRef>,
                node_type: ODNodeType,
                error: *mut *mut CFError,
            ) -> Option<NonNull<ODNodeRef>>;
        }
        let ret = unsafe { ODNodeCreateWithNodeType(allocator, session, node_type, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an ODNodeRef based on a partciular node name
    ///
    /// Creates an ODNodeRef based on a particular node name
    ///
    /// Parameter `allocator`: a memory allocator to use for this object
    ///
    /// Parameter `session`: an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
    ///
    /// Parameter `nodeName`: a CFStringRef of the name of the node to open
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a valid ODNodeRef if successful, otherwise returns NULL. outError can be checked for specific
    /// error
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `session` might not allow `None`.
    /// - `node_name` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCreateWithName")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn with_name(
        allocator: Option<&CFAllocator>,
        session: Option<&ODSessionRef>,
        node_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<ODNodeRef>> {
        extern "C-unwind" {
            fn ODNodeCreateWithName(
                allocator: Option<&CFAllocator>,
                session: Option<&ODSessionRef>,
                node_name: Option<&CFString>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<ODNodeRef>>;
        }
        let ret = unsafe { ODNodeCreateWithName(allocator, session, node_name, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a copy, including any remote credentials used for Proxy and/or Node authentication
    ///
    /// Creates a copy of the object including all credentials used for the original.  Can be used for future
    /// references to the same node setup.
    ///
    /// Parameter `allocator`: a memory allocator to use for this object
    ///
    /// Parameter `node`: an ODNodeRef to make a copy of
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a valid ODNodeRef if successful, otherwise returns NULL, with outError set to a CFErrorRef
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `node` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCreateCopy")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        node: Option<&ODNodeRef>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<ODNodeRef>> {
        extern "C-unwind" {
            fn ODNodeCreateCopy(
                allocator: Option<&CFAllocator>,
                node: Option<&ODNodeRef>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<ODNodeRef>>;
        }
        let ret = unsafe { ODNodeCreateCopy(allocator, node, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a CFArray of subnode names for this node, which may contain sub-nodes or search policy nodes
    ///
    /// Returns a CFArray of subnode names for this node, which may contain sub-nodes or search policy nodes.
    /// Commonly used with Search policy nodes.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a CFArrayRef with the list of nodes, otherwise NULL, with outError set to a CFErrorRef
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopySubnodeNames")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn subnode_names(&self, error: *mut *mut CFError) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn ODNodeCopySubnodeNames(
                node: &ODNodeRef,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { ODNodeCopySubnodeNames(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Will return names of subnodes that are not currently reachable.
    ///
    /// Will return names of subnodes that are not currently reachable.  Commonly used with Search policy nodes
    /// to determine if any nodes are currently unreachable, but may also return other subnodes if the
    /// Open Directory plugin supports.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a CFArrayRef with the list of unreachable nodes or NULL if no bad nodes
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopyUnreachableSubnodeNames")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn unreachable_subnode_names(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn ODNodeCopyUnreachableSubnodeNames(
                node: &ODNodeRef,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { ODNodeCopyUnreachableSubnodeNames(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the node name of the node that was opened
    ///
    /// Returns the node name of the node that was opened
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Returns: a CFStringRef of the node name that is current or NULL if no open node
    #[doc(alias = "ODNodeGetName")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn name(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn ODNodeGetName(node: &ODNodeRef) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { ODNodeGetName(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a dictionary with details about the node in dictionary form
    ///
    /// Returns a dictionary with details about the node in dictionary form.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `keys`: a CFArrayRef listing the keys the user wants returned, such as
    /// kODAttributeTypeStreet
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a CFDictionaryRef containing the requested key and values in form of a CFArray
    ///
    /// # Safety
    ///
    /// - `keys` generic must be of the correct type.
    /// - `keys` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopyDetails")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn details(
        &self,
        keys: Option<&CFArray>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn ODNodeCopyDetails(
                node: &ODNodeRef,
                keys: Option<&CFArray>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { ODNodeCopyDetails(self, keys, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a CFArrayRef of the record types supported by this node.
    ///
    /// Returns a CFArrayRef of the record types supported by this node.  If node does not support the check
    /// then all possible types will be returned.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a valid CFArrayRef of CFStrings listing the supported Record types on this node.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopySupportedRecordTypes")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn supported_record_types(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn ODNodeCopySupportedRecordTypes(
                node: &ODNodeRef,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { ODNodeCopySupportedRecordTypes(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Will return a list of attribute types supported for that attribute if possible
    ///
    /// Will return a list of attribute types supported for that attribute if possible.  If no specific
    /// types are available, then all possible values will be returned instead.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordTypeRef with the type of record to check attribute types.  If NULL is passed it will
    /// return all possible attributes that are available.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a valid CFArrayRef of CFStrings listing the attributes supported for the requested record type
    ///
    /// # Safety
    ///
    /// - `record_type` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopySupportedAttributes")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn supported_attributes(
        &self,
        record_type: Option<&ODRecordType>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn ODNodeCopySupportedAttributes(
                node: &ODNodeRef,
                record_type: Option<&ODRecordType>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { ODNodeCopySupportedAttributes(self, record_type, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets the credentials for interaction with the ODNode
    ///
    /// Sets the credentials for interaction with the ODNode.  Record references, etc. will use these credentials
    /// to query or change data.  Setting the credentials on a node referenced by other OD object types will
    /// change the credentials for all for all references.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordTypeRef of the Record Type to use, if NULL is passed, defaults to a
    /// kODRecordTypeUsers
    ///
    /// Parameter `recordName`: a CFString of the username to be used for this node authentication
    ///
    /// Parameter `password`: a CFString of the password to be used for this node authentication
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: returns true on success, otherwise outError can be checked for details.  If the authentication failed,
    /// the previous credentials are used.
    ///
    /// # Safety
    ///
    /// - `record_type` might not allow `None`.
    /// - `record_name` might not allow `None`.
    /// - `password` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeSetCredentials")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn set_credentials(
        &self,
        record_type: Option<&ODRecordType>,
        record_name: Option<&CFString>,
        password: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeSetCredentials(
                node: &ODNodeRef,
                record_type: Option<&ODRecordType>,
                record_name: Option<&CFString>,
                password: Option<&CFString>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeSetCredentials(self, record_type, record_name, password, error) }
    }

    /// Allows use of other Open Directory types of authentications to set the credentials for an ODNode
    ///
    /// Allows the caller to use other types of authentications that are available in Open Directory, that may
    /// require response-request loops, etc.  Not all OD plugins will support this call, look for
    /// kODErrorCredentialsMethodNotSupported in outError.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordType of the type of record to do the authentication with
    ///
    /// Parameter `authType`: a ODAuthenticationType of the type of authentication to be used (e.g., kDSStdAuthNTLMv2)
    ///
    /// Parameter `authItems`: a CFArray of CFData or CFString items that will be sent in order to the auth process
    ///
    /// Parameter `outAuthItems`: will be assigned to a pointer of a CFArray of CFData items if there are returned values
    ///
    /// Parameter `outContext`: will return a pointer to a context if caller supplies a container, and the call requires a
    /// context.  If a non-NULL value is returned, then more calls must be made with the Context to continue
    /// the authorization.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool will be returned with the result of the operation and outAuthItems set with response items
    /// and outContext set for any needed continuation.
    ///
    /// # Safety
    ///
    /// - `record_type` might not allow `None`.
    /// - `auth_type` might not allow `None`.
    /// - `auth_items` generic must be of the correct type.
    /// - `auth_items` might not allow `None`.
    /// - `out_auth_items` must be a valid pointer.
    /// - `out_context` must be a valid pointer.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeSetCredentialsExtended")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn set_credentials_extended(
        &self,
        record_type: Option<&ODRecordType>,
        auth_type: Option<&ODAuthenticationType>,
        auth_items: Option<&CFArray>,
        out_auth_items: *mut *const CFArray,
        out_context: *mut *const ODContextRef,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeSetCredentialsExtended(
                node: &ODNodeRef,
                record_type: Option<&ODRecordType>,
                auth_type: Option<&ODAuthenticationType>,
                auth_items: Option<&CFArray>,
                out_auth_items: *mut *const CFArray,
                out_context: *mut *const ODContextRef,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe {
            ODNodeSetCredentialsExtended(
                self,
                record_type,
                auth_type,
                auth_items,
                out_auth_items,
                out_context,
                error,
            )
        }
    }

    /// Unsupported function.
    ///
    /// Unsupported function.
    ///
    /// # Safety
    ///
    /// - `cache_name` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeSetCredentialsUsingKerberosCache")]
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated]
    #[inline]
    pub unsafe fn set_credentials_using_kerberos_cache(
        &self,
        cache_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeSetCredentialsUsingKerberosCache(
                node: &ODNodeRef,
                cache_name: Option<&CFString>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeSetCredentialsUsingKerberosCache(self, cache_name, error) }
    }

    /// Takes a record and all of the provided attributes and creates the record in the node
    ///
    /// Takes all the provided attributes and type to create an entire record.  The function will assign a
    /// UUID to the record automatically.  This UUID can be overwritten by the client by passing with the
    /// other attributes.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordTypeRef of the type of record (e.g., kODRecordTypeUsers, etc.)
    ///
    /// Parameter `recordName`: a CFStringRef of the name of record
    ///
    /// Parameter `attributeDict`: a CFDictionaryRef of key-value pairs for attribute values.  The key is a CFStringRef of the
    /// attribute name or ODRecordType constant such as kODAttributeTypeRecordName.  The value must be a CFArrayRef of
    /// CFDataRef or CFStringRef.  If additional kODAttributeTypeRecordName are to be set, they can be passed in the
    /// inAttributes list.  This parameter is optional and can be NULL.  If any of the attributes passed
    /// fail to be set, the record will be deleted and outError will be set with the appropriate error.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: returns a valid ODRecordRef.  If the add fails, outError can be checked for details.
    ///
    /// # Safety
    ///
    /// - `record_type` might not allow `None`.
    /// - `record_name` might not allow `None`.
    /// - `attribute_dict` generics must be of the correct type.
    /// - `attribute_dict` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCreateRecord")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn create_record(
        &self,
        record_type: Option<&ODRecordType>,
        record_name: Option<&CFString>,
        attribute_dict: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<ODRecordRef>> {
        extern "C-unwind" {
            fn ODNodeCreateRecord(
                node: &ODNodeRef,
                record_type: Option<&ODRecordType>,
                record_name: Option<&CFString>,
                attribute_dict: Option<&CFDictionary>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<ODRecordRef>>;
        }
        let ret =
            unsafe { ODNodeCreateRecord(self, record_type, record_name, attribute_dict, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Simple API to open / create a references to a particular record on a Node
    ///
    /// Simple API to open / create a references to a particular record on a Node
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordTypeRef of the record type to copy
    ///
    /// Parameter `recordName`: a CFStringRef of the record name to copy
    ///
    /// Parameter `attributes`: (optional) a CFArrayRef (or single ODAttributeType) of the attributes to copy from the directory.  Can be NULL when no
    /// attributes are needed.  Any standard types can be passed, for example
    /// kODAttributeTypeAllAttributes will fetch all attributes up front.  If just standard attributes are needed, then
    /// kODAttributeTypeStandardOnly can be passed.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: returns a valid ODRecordRef.  If the record copy fails, the error can be checked for details.
    /// If the record is not found, will return NULL with a NULL error.
    ///
    /// # Safety
    ///
    /// - `record_type` might not allow `None`.
    /// - `record_name` might not allow `None`.
    /// - `attributes` should be of the correct type.
    /// - `attributes` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopyRecord")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn copy_record(
        &self,
        record_type: Option<&ODRecordType>,
        record_name: Option<&CFString>,
        attributes: Option<&CFType>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<ODRecordRef>> {
        extern "C-unwind" {
            fn ODNodeCopyRecord(
                node: &ODNodeRef,
                record_type: Option<&ODRecordType>,
                record_name: Option<&CFString>,
                attributes: Option<&CFType>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<ODRecordRef>>;
        }
        let ret = unsafe { ODNodeCopyRecord(self, record_type, record_name, attributes, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sends a custom call to a node.
    ///
    /// This will send a custom call to a node along with the specified data, returning the result.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `customCode`: the custom code to be sent to the node
    ///
    /// Parameter `data`: a data blob expected by the custom code, can be NULL of no send data
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a CFDataRef with the result of the operation, otherwise outError can be checked for specific details
    ///
    /// # Safety
    ///
    /// - `data` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCustomCall")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn custom_call(
        &self,
        custom_code: CFIndex,
        data: Option<&CFData>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn ODNodeCustomCall(
                node: &ODNodeRef,
                custom_code: CFIndex,
                data: Option<&CFData>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { ODNodeCustomCall(self, custom_code, data, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sends a named custom function call to a node.
    ///
    ///
    /// Sends a named custom function call to a node.  Custom functions are defined by the modules that implement them
    /// and the parameter is defined by the module.
    ///
    ///
    /// Parameter `node`: An ODNodeRef to use
    ///
    ///
    /// Parameter `function`: A CFStringRef that specifies the name of the function
    ///
    ///
    /// Parameter `payload`: A CFType appropriate for the custom function.  The type is dictated by the module implementing the function.
    ///
    ///
    /// Parameter `error`: An optional CFErrorRef reference to receive any errors from the custom function call.
    ///
    ///
    /// Returns: Returns a CFType appropriate for the function.
    ///
    /// # Safety
    ///
    /// - `function` might not allow `None`.
    /// - `payload` should be of the correct type.
    /// - `payload` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeCustomFunction")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn custom_function(
        &self,
        function: Option<&CFString>,
        payload: Option<&CFType>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn ODNodeCustomFunction(
                node: &ODNodeRef,
                function: Option<&CFString>,
                payload: Option<&CFType>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { ODNodeCustomFunction(self, function, payload, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// This will copy any policies configured for the node.
    ///
    /// This will copy any policies configured for the node.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a CFDictionaryRef containing all currently set policies
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopyPolicies")]
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "use ODNodeCopyAccountPolicies"]
    #[inline]
    pub unsafe fn policies(&self, error: *mut *mut CFError) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn ODNodeCopyPolicies(
                node: &ODNodeRef,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { ODNodeCopyPolicies(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// This will return a dictionary of supported policies.
    ///
    /// This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
    /// for the policy in question.  For example, if password history is available, it will state how much history is
    /// supported.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a CFDictionaryRef containing all currently supported policies.  The values will be the maximum value allowed.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopySupportedPolicies")]
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated]
    #[inline]
    pub unsafe fn supported_policies(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn ODNodeCopySupportedPolicies(
                node: &ODNodeRef,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { ODNodeCopySupportedPolicies(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// This will set the policy for the node.
    ///
    /// This will set the policy for the node.  Policies are evaluated in combination with record-level policies.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `policies`: a CFDictionary of policies to be set
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool which signifies if the policy set succeeded, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `policies` generics must be of the correct type.
    /// - `policies` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeSetPolicies")]
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "use ODNodeSetAccountPolicies"]
    #[inline]
    pub unsafe fn set_policies(
        &self,
        policies: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeSetPolicies(
                node: &ODNodeRef,
                policies: Option<&CFDictionary>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeSetPolicies(self, policies, error) }
    }

    /// This will set a specific policy setting for the node.
    ///
    /// This will set a specific policy setting for the node.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `policy`: a valid ODPolicyType
    ///
    /// Parameter `value`: a CFTypeRef to be set (should be of appropriate type for the policy)
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool which signifies if the policy set succeeded, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `policy_type` might not allow `None`.
    /// - `value` should be of the correct type.
    /// - `value` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeSetPolicy")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "use ODNodeAddAccountPolicy"]
    #[inline]
    pub unsafe fn set_policy(
        &self,
        policy_type: Option<&ODPolicyType>,
        value: Option<&CFType>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeSetPolicy(
                node: &ODNodeRef,
                policy_type: Option<&ODPolicyType>,
                value: Option<&CFType>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeSetPolicy(self, policy_type, value, error) }
    }

    /// This will remove a specific policy setting from the node.
    ///
    /// This will remove a specific policy setting from the node.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `policy`: a valid ODPolicyType
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool which signifies if the policy removal succeeded, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `policy_type` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeRemovePolicy")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "use ODNodeRemoveAccountPolicy"]
    #[inline]
    pub unsafe fn remove_policy(
        &self,
        policy_type: Option<&ODPolicyType>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeRemovePolicy(
                node: &ODNodeRef,
                policy_type: Option<&ODPolicyType>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeRemovePolicy(self, policy_type, error) }
    }

    /// This will add an account policy to the node for the specified category.
    ///
    /// This will add an account policy to the node for the specified category.
    /// The specified policy will be applied to all users in the
    /// specified node when policies are evaluated.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `policy`: a dictionary containing the specific policy to be added.
    /// The dictionary may contain the following keys:
    /// kODPolicyKeyIdentifier a required key identifying the policy.
    /// kODPolicyKeyParameters an optional key containing a dictionary of
    /// parameters that can be used for informational purposes or in
    /// the policy format string.
    /// kODPolicyKeyContent a required key specifying the policy,
    /// from which a predicate will be created for evaluating
    /// the policy.
    ///
    /// Parameter `category`: a valid ODPolicyCategoryType to which the specified policy will be added.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the policy addition succeeded, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `policy` generics must be of the correct type.
    /// - `policy` might not allow `None`.
    /// - `category` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeAddAccountPolicy")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn add_account_policy(
        &self,
        policy: Option<&CFDictionary>,
        category: Option<&ODPolicyCategoryType>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeAddAccountPolicy(
                node: &ODNodeRef,
                policy: Option<&CFDictionary>,
                category: Option<&ODPolicyCategoryType>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeAddAccountPolicy(self, policy, category, error) }
    }

    /// This will remove an account policy from the node for the specified category.
    ///
    /// This will remove an account policy from the node for the specified category.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `policy`: a dictionary containing the specific policy to be
    /// removed, with the same format as described in ODNodeAddAccountPolicy.
    ///
    /// Parameter `category`: a valid ODPolicyCategoryType from which the specified policy will be removed.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the policy removal succeeded, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `policy` generics must be of the correct type.
    /// - `policy` might not allow `None`.
    /// - `category` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeRemoveAccountPolicy")]
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[inline]
    pub unsafe fn remove_account_policy(
        &self,
        policy: Option<&CFDictionary>,
        category: Option<&ODPolicyCategoryType>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeRemoveAccountPolicy(
                node: &ODNodeRef,
                policy: Option<&CFDictionary>,
                category: Option<&ODPolicyCategoryType>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeRemoveAccountPolicy(self, policy, category, error) }
    }

    /// This will set the policies for the node.
    ///
    /// This will set the policies for the node, replacing any existing
    /// policies.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `policies`: a dictionary containing all of the policies to be set
    /// for the node.  The dictionary may contain the following keys:
    /// kODPolicyCategoryAuthentication an optional key with a value
    /// of an array of policy dictionaries that specify when
    /// authentications should be allowed.
    /// kODPolicyCategoryPasswordContent an optional key with a
    /// value of an array of policy dictionaries the specify the
    /// required content of passwords.
    /// kODPolicyCategoryPasswordChange an optional key with a value
    /// of an array of policy dictionaries that specify when
    /// passwords are required to be changed.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the policy set succeeded, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `policies` generics must be of the correct type.
    /// - `policies` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodeSetAccountPolicies")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn set_account_policies(
        &self,
        policies: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodeSetAccountPolicies(
                node: &ODNodeRef,
                policies: Option<&CFDictionary>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodeSetAccountPolicies(self, policies, error) }
    }

    /// This will copy any policies configured for the node.
    ///
    /// This will copy any policies configured for the node.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a CFDictionaryRef containing all currently set policies.  The
    /// format of the dictionary is the same as described in
    /// ODNodeSetAccountPolicies().
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "ODNodeCopyAccountPolicies")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn account_policies(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn ODNodeCopyAccountPolicies(
                node: &ODNodeRef,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { ODNodeCopyAccountPolicies(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Validates a password against the node's password content policies.
    ///
    /// Validates a password against the node's password content policies.
    /// The node's password content policies will be evaluated to
    /// determine if the password is acceptable.  May be used prior to
    /// creating the record.
    ///
    /// This check is only definitive at the time it was requested. The
    /// policy or the environment could change before the password change
    /// is actually requested.  Errors from the password change request
    /// should be consulted.
    ///
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `password`: the password to be evaluated against the content policies.
    ///
    /// Parameter `recordName`: the name of the record.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the password passes all content policies, otherwise error is set.
    ///
    /// # Safety
    ///
    /// - `password` might not allow `None`.
    /// - `record_name` might not allow `None`.
    /// - `error` must be a valid pointer.
    #[doc(alias = "ODNodePasswordContentCheck")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn password_content_check(
        &self,
        password: Option<&CFString>,
        record_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn ODNodePasswordContentCheck(
                node: &ODNodeRef,
                password: Option<&CFString>,
                record_name: Option<&CFString>,
                error: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { ODNodePasswordContentCheck(self, password, record_name, error) }
    }
}

#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[deprecated = "renamed to `ODNodeRef::with_node_type`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateWithNodeType(
    allocator: Option<&CFAllocator>,
    session: Option<&ODSessionRef>,
    node_type: ODNodeType,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODNodeRef>> {
    extern "C-unwind" {
        fn ODNodeCreateWithNodeType(
            allocator: Option<&CFAllocator>,
            session: Option<&ODSessionRef>,
            node_type: ODNodeType,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODNodeRef>>;
    }
    let ret = unsafe { ODNodeCreateWithNodeType(allocator, session, node_type, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::with_name`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateWithName(
    allocator: Option<&CFAllocator>,
    session: Option<&ODSessionRef>,
    node_name: Option<&CFString>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODNodeRef>> {
    extern "C-unwind" {
        fn ODNodeCreateWithName(
            allocator: Option<&CFAllocator>,
            session: Option<&ODSessionRef>,
            node_name: Option<&CFString>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODNodeRef>>;
    }
    let ret = unsafe { ODNodeCreateWithName(allocator, session, node_name, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateCopy(
    allocator: Option<&CFAllocator>,
    node: Option<&ODNodeRef>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODNodeRef>> {
    extern "C-unwind" {
        fn ODNodeCreateCopy(
            allocator: Option<&CFAllocator>,
            node: Option<&ODNodeRef>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODNodeRef>>;
    }
    let ret = unsafe { ODNodeCreateCopy(allocator, node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::subnode_names`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySubnodeNames(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopySubnodeNames(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopySubnodeNames(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::unreachable_subnode_names`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyUnreachableSubnodeNames(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopyUnreachableSubnodeNames(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopyUnreachableSubnodeNames(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::name`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeGetName(node: &ODNodeRef) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn ODNodeGetName(node: &ODNodeRef) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { ODNodeGetName(node) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::details`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyDetails(
    node: &ODNodeRef,
    keys: Option<&CFArray>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopyDetails(
            node: &ODNodeRef,
            keys: Option<&CFArray>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopyDetails(node, keys, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::supported_record_types`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySupportedRecordTypes(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopySupportedRecordTypes(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopySupportedRecordTypes(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[deprecated = "renamed to `ODNodeRef::supported_attributes`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySupportedAttributes(
    node: &ODNodeRef,
    record_type: Option<&ODRecordType>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopySupportedAttributes(
            node: &ODNodeRef,
            record_type: Option<&ODRecordType>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopySupportedAttributes(node, record_type, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "renamed to `ODNodeRef::set_credentials`"]
    pub fn ODNodeSetCredentials(
        node: &ODNodeRef,
        record_type: Option<&ODRecordType>,
        record_name: Option<&CFString>,
        password: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "renamed to `ODNodeRef::set_credentials_extended`"]
    pub fn ODNodeSetCredentialsExtended(
        node: &ODNodeRef,
        record_type: Option<&ODRecordType>,
        auth_type: Option<&ODAuthenticationType>,
        auth_items: Option<&CFArray>,
        out_auth_items: *mut *const CFArray,
        out_context: *mut *const ODContextRef,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `ODNodeRef::set_credentials_using_kerberos_cache`"]
    pub fn ODNodeSetCredentialsUsingKerberosCache(
        node: &ODNodeRef,
        cache_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool;
}

#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[deprecated = "renamed to `ODNodeRef::create_record`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateRecord(
    node: &ODNodeRef,
    record_type: Option<&ODRecordType>,
    record_name: Option<&CFString>,
    attribute_dict: Option<&CFDictionary>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODRecordRef>> {
    extern "C-unwind" {
        fn ODNodeCreateRecord(
            node: &ODNodeRef,
            record_type: Option<&ODRecordType>,
            record_name: Option<&CFString>,
            attribute_dict: Option<&CFDictionary>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODRecordRef>>;
    }
    let ret = unsafe { ODNodeCreateRecord(node, record_type, record_name, attribute_dict, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[deprecated = "renamed to `ODNodeRef::copy_record`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyRecord(
    node: &ODNodeRef,
    record_type: Option<&ODRecordType>,
    record_name: Option<&CFString>,
    attributes: Option<&CFType>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODRecordRef>> {
    extern "C-unwind" {
        fn ODNodeCopyRecord(
            node: &ODNodeRef,
            record_type: Option<&ODRecordType>,
            record_name: Option<&CFString>,
            attributes: Option<&CFType>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODRecordRef>>;
    }
    let ret = unsafe { ODNodeCopyRecord(node, record_type, record_name, attributes, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::custom_call`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCustomCall(
    node: &ODNodeRef,
    custom_code: CFIndex,
    data: Option<&CFData>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn ODNodeCustomCall(
            node: &ODNodeRef,
            custom_code: CFIndex,
            data: Option<&CFData>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { ODNodeCustomCall(node, custom_code, data, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::custom_function`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCustomFunction(
    node: &ODNodeRef,
    function: Option<&CFString>,
    payload: Option<&CFType>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn ODNodeCustomFunction(
            node: &ODNodeRef,
            function: Option<&CFString>,
            payload: Option<&CFType>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { ODNodeCustomFunction(node, function, payload, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::policies`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyPolicies(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopyPolicies(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopyPolicies(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::supported_policies`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySupportedPolicies(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopySupportedPolicies(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopySupportedPolicies(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `ODNodeRef::set_policies`"]
    pub fn ODNodeSetPolicies(
        node: &ODNodeRef,
        policies: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "renamed to `ODNodeRef::set_policy`"]
    pub fn ODNodeSetPolicy(
        node: &ODNodeRef,
        policy_type: Option<&ODPolicyType>,
        value: Option<&CFType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "renamed to `ODNodeRef::remove_policy`"]
    pub fn ODNodeRemovePolicy(
        node: &ODNodeRef,
        policy_type: Option<&ODPolicyType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "renamed to `ODNodeRef::add_account_policy`"]
    pub fn ODNodeAddAccountPolicy(
        node: &ODNodeRef,
        policy: Option<&CFDictionary>,
        category: Option<&ODPolicyCategoryType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "renamed to `ODNodeRef::remove_account_policy`"]
    pub fn ODNodeRemoveAccountPolicy(
        node: &ODNodeRef,
        policy: Option<&CFDictionary>,
        category: Option<&ODPolicyCategoryType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `ODNodeRef::set_account_policies`"]
    pub fn ODNodeSetAccountPolicies(
        node: &ODNodeRef,
        policies: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> bool;
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `ODNodeRef::account_policies`"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyAccountPolicies(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopyAccountPolicies(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopyAccountPolicies(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `ODNodeRef::password_content_check`"]
    pub fn ODNodePasswordContentCheck(
        node: &ODNodeRef,
        password: Option<&CFString>,
        record_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool;
}
