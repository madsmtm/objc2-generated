//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "objc2-core-foundation")]
unsafe impl ConcreteType for ODNodeRef {
    /// Standard GetTypeID function support for CF-based objects
    ///
    /// Returns the typeID for the ODNode objects
    ///
    /// Returns: a valid CFTypeID for the ODNode object
    #[doc(alias = "ODNodeGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn ODNodeGetTypeID() -> CFTypeID;
        }
        unsafe { ODNodeGetTypeID() }
    }
}

/// Creates an ODNodeRef based on a specific node type
///
/// Creates an ODNodeRef based on a specific node type
///
/// Parameter `allocator`: a memory allocator to use for this object
///
/// Parameter `session`: an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
///
/// Parameter `nodeType`: an ODNodeType of the node to open
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a valid ODNodeRef if successful, otherwise returns NULL.  outError can be checked for details upon
/// failure.
#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateWithNodeType(
    allocator: Option<&CFAllocator>,
    session: Option<&ODSessionRef>,
    node_type: ODNodeType,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODNodeRef>> {
    extern "C-unwind" {
        fn ODNodeCreateWithNodeType(
            allocator: Option<&CFAllocator>,
            session: Option<&ODSessionRef>,
            node_type: ODNodeType,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODNodeRef>>;
    }
    let ret = unsafe { ODNodeCreateWithNodeType(allocator, session, node_type, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates an ODNodeRef based on a partciular node name
///
/// Creates an ODNodeRef based on a particular node name
///
/// Parameter `allocator`: a memory allocator to use for this object
///
/// Parameter `session`: an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
///
/// Parameter `nodeName`: a CFStringRef of the name of the node to open
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a valid ODNodeRef if successful, otherwise returns NULL. outError can be checked for specific
/// error
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateWithName(
    allocator: Option<&CFAllocator>,
    session: Option<&ODSessionRef>,
    node_name: Option<&CFString>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODNodeRef>> {
    extern "C-unwind" {
        fn ODNodeCreateWithName(
            allocator: Option<&CFAllocator>,
            session: Option<&ODSessionRef>,
            node_name: Option<&CFString>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODNodeRef>>;
    }
    let ret = unsafe { ODNodeCreateWithName(allocator, session, node_name, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates a copy, including any remote credentials used for Proxy and/or Node authentication
///
/// Creates a copy of the object including all credentials used for the original.  Can be used for future
/// references to the same node setup.
///
/// Parameter `allocator`: a memory allocator to use for this object
///
/// Parameter `node`: an ODNodeRef to make a copy of
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a valid ODNodeRef if successful, otherwise returns NULL, with outError set to a CFErrorRef
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateCopy(
    allocator: Option<&CFAllocator>,
    node: Option<&ODNodeRef>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODNodeRef>> {
    extern "C-unwind" {
        fn ODNodeCreateCopy(
            allocator: Option<&CFAllocator>,
            node: Option<&ODNodeRef>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODNodeRef>>;
    }
    let ret = unsafe { ODNodeCreateCopy(allocator, node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns a CFArray of subnode names for this node, which may contain sub-nodes or search policy nodes
///
/// Returns a CFArray of subnode names for this node, which may contain sub-nodes or search policy nodes.
/// Commonly used with Search policy nodes.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a CFArrayRef with the list of nodes, otherwise NULL, with outError set to a CFErrorRef
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySubnodeNames(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopySubnodeNames(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopySubnodeNames(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Will return names of subnodes that are not currently reachable.
///
/// Will return names of subnodes that are not currently reachable.  Commonly used with Search policy nodes
/// to determine if any nodes are currently unreachable, but may also return other subnodes if the
/// Open Directory plugin supports.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a CFArrayRef with the list of unreachable nodes or NULL if no bad nodes
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyUnreachableSubnodeNames(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopyUnreachableSubnodeNames(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopyUnreachableSubnodeNames(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the node name of the node that was opened
///
/// Returns the node name of the node that was opened
///
/// Parameter `node`: an ODNodeRef to use
///
/// Returns: a CFStringRef of the node name that is current or NULL if no open node
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeGetName(node: &ODNodeRef) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn ODNodeGetName(node: &ODNodeRef) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { ODNodeGetName(node) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Returns a dictionary with details about the node in dictionary form
///
/// Returns a dictionary with details about the node in dictionary form.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `keys`: a CFArrayRef listing the keys the user wants returned, such as
/// kODAttributeTypeStreet
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a CFDictionaryRef containing the requested key and values in form of a CFArray
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyDetails(
    node: &ODNodeRef,
    keys: Option<&CFArray>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopyDetails(
            node: &ODNodeRef,
            keys: Option<&CFArray>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopyDetails(node, keys, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns a CFArrayRef of the record types supported by this node.
///
/// Returns a CFArrayRef of the record types supported by this node.  If node does not support the check
/// then all possible types will be returned.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a valid CFArrayRef of CFStrings listing the supported Record types on this node.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySupportedRecordTypes(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopySupportedRecordTypes(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopySupportedRecordTypes(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Will return a list of attribute types supported for that attribute if possible
///
/// Will return a list of attribute types supported for that attribute if possible.  If no specific
/// types are available, then all possible values will be returned instead.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `recordType`: a ODRecordTypeRef with the type of record to check attribute types.  If NULL is passed it will
/// return all possible attributes that are available.
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a valid CFArrayRef of CFStrings listing the attributes supported for the requested record type
#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySupportedAttributes(
    node: &ODNodeRef,
    record_type: Option<&ODRecordType>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn ODNodeCopySupportedAttributes(
            node: &ODNodeRef,
            record_type: Option<&ODRecordType>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { ODNodeCopySupportedAttributes(node, record_type, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Sets the credentials for interaction with the ODNode
    ///
    /// Sets the credentials for interaction with the ODNode.  Record references, etc. will use these credentials
    /// to query or change data.  Setting the credentials on a node referenced by other OD object types will
    /// change the credentials for all for all references.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordTypeRef of the Record Type to use, if NULL is passed, defaults to a
    /// kODRecordTypeUsers
    ///
    /// Parameter `recordName`: a CFString of the username to be used for this node authentication
    ///
    /// Parameter `password`: a CFString of the password to be used for this node authentication
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: returns true on success, otherwise outError can be checked for details.  If the authentication failed,
    /// the previous credentials are used.
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    pub fn ODNodeSetCredentials(
        node: &ODNodeRef,
        record_type: Option<&ODRecordType>,
        record_name: Option<&CFString>,
        password: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// Allows use of other Open Directory types of authentications to set the credentials for an ODNode
    ///
    /// Allows the caller to use other types of authentications that are available in Open Directory, that may
    /// require response-request loops, etc.  Not all OD plugins will support this call, look for
    /// kODErrorCredentialsMethodNotSupported in outError.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `recordType`: a ODRecordType of the type of record to do the authentication with
    ///
    /// Parameter `authType`: a ODAuthenticationType of the type of authentication to be used (e.g., kDSStdAuthNTLMv2)
    ///
    /// Parameter `authItems`: a CFArray of CFData or CFString items that will be sent in order to the auth process
    ///
    /// Parameter `outAuthItems`: will be assigned to a pointer of a CFArray of CFData items if there are returned values
    ///
    /// Parameter `outContext`: will return a pointer to a context if caller supplies a container, and the call requires a
    /// context.  If a non-NULL value is returned, then more calls must be made with the Context to continue
    /// the authorization.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool will be returned with the result of the operation and outAuthItems set with response items
    /// and outContext set for any needed continuation.
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    pub fn ODNodeSetCredentialsExtended(
        node: &ODNodeRef,
        record_type: Option<&ODRecordType>,
        auth_type: Option<&ODAuthenticationType>,
        auth_items: Option<&CFArray>,
        out_auth_items: *mut *mut CFArray,
        out_context: *mut *mut ODContextRef,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// Unsupported function.
    ///
    /// Unsupported function.
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated]
    pub fn ODNodeSetCredentialsUsingKerberosCache(
        node: &ODNodeRef,
        cache_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool;
}

/// Takes a record and all of the provided attributes and creates the record in the node
///
/// Takes all the provided attributes and type to create an entire record.  The function will assign a
/// UUID to the record automatically.  This UUID can be overwritten by the client by passing with the
/// other attributes.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `recordType`: a ODRecordTypeRef of the type of record (e.g., kODRecordTypeUsers, etc.)
///
/// Parameter `recordName`: a CFStringRef of the name of record
///
/// Parameter `attributeDict`: a CFDictionaryRef of key-value pairs for attribute values.  The key is a CFStringRef of the
/// attribute name or ODRecordType constant such as kODAttributeTypeRecordName.  The value must be a CFArrayRef of
/// CFDataRef or CFStringRef.  If additional kODAttributeTypeRecordName are to be set, they can be passed in the
/// inAttributes list.  This parameter is optional and can be NULL.  If any of the attributes passed
/// fail to be set, the record will be deleted and outError will be set with the appropriate error.
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: returns a valid ODRecordRef.  If the add fails, outError can be checked for details.
#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCreateRecord(
    node: &ODNodeRef,
    record_type: Option<&ODRecordType>,
    record_name: Option<&CFString>,
    attribute_dict: Option<&CFDictionary>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODRecordRef>> {
    extern "C-unwind" {
        fn ODNodeCreateRecord(
            node: &ODNodeRef,
            record_type: Option<&ODRecordType>,
            record_name: Option<&CFString>,
            attribute_dict: Option<&CFDictionary>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODRecordRef>>;
    }
    let ret = unsafe { ODNodeCreateRecord(node, record_type, record_name, attribute_dict, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Simple API to open / create a references to a particular record on a Node
///
/// Simple API to open / create a references to a particular record on a Node
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `recordType`: a ODRecordTypeRef of the record type to copy
///
/// Parameter `recordName`: a CFStringRef of the record name to copy
///
/// Parameter `attributes`: (optional) a CFArrayRef (or single ODAttributeType) of the attributes to copy from the directory.  Can be NULL when no
/// attributes are needed.  Any standard types can be passed, for example
/// kODAttributeTypeAllAttributes will fetch all attributes up front.  If just standard attributes are needed, then
/// kODAttributeTypeStandardOnly can be passed.
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: returns a valid ODRecordRef.  If the record copy fails, the error can be checked for details.
/// If the record is not found, will return NULL with a NULL error.
#[cfg(all(
    feature = "CFOpenDirectoryConstants",
    feature = "objc2-core-foundation"
))]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyRecord(
    node: &ODNodeRef,
    record_type: Option<&ODRecordType>,
    record_name: Option<&CFString>,
    attributes: Option<&CFType>,
    error: *mut *mut CFError,
) -> Option<CFRetained<ODRecordRef>> {
    extern "C-unwind" {
        fn ODNodeCopyRecord(
            node: &ODNodeRef,
            record_type: Option<&ODRecordType>,
            record_name: Option<&CFString>,
            attributes: Option<&CFType>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<ODRecordRef>>;
    }
    let ret = unsafe { ODNodeCopyRecord(node, record_type, record_name, attributes, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Sends a custom call to a node.
///
/// This will send a custom call to a node along with the specified data, returning the result.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `customCode`: the custom code to be sent to the node
///
/// Parameter `data`: a data blob expected by the custom code, can be NULL of no send data
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a CFDataRef with the result of the operation, otherwise outError can be checked for specific details
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCustomCall(
    node: &ODNodeRef,
    custom_code: CFIndex,
    data: Option<&CFData>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn ODNodeCustomCall(
            node: &ODNodeRef,
            custom_code: CFIndex,
            data: Option<&CFData>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { ODNodeCustomCall(node, custom_code, data, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Sends a named custom function call to a node.
///
///
/// Sends a named custom function call to a node.  Custom functions are defined by the modules that implement them
/// and the parameter is defined by the module.
///
///
/// Parameter `node`: An ODNodeRef to use
///
///
/// Parameter `function`: A CFStringRef that specifies the name of the function
///
///
/// Parameter `payload`: A CFType appropriate for the custom function.  The type is dictated by the module implementing the function.
///
///
/// Parameter `error`: An optional CFErrorRef reference to receive any errors from the custom function call.
///
///
/// Returns: Returns a CFType appropriate for the function.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCustomFunction(
    node: &ODNodeRef,
    function: Option<&CFString>,
    payload: Option<&CFType>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn ODNodeCustomFunction(
            node: &ODNodeRef,
            function: Option<&CFString>,
            payload: Option<&CFType>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { ODNodeCustomFunction(node, function, payload, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// This will copy any policies configured for the node.
///
/// This will copy any policies configured for the node.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a CFDictionaryRef containing all currently set policies
#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "use ODNodeCopyAccountPolicies"]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyPolicies(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopyPolicies(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopyPolicies(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// This will return a dictionary of supported policies.
///
/// This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
/// for the policy in question.  For example, if password history is available, it will state how much history is
/// supported.
///
/// Parameter `node`: an ODNodeRef to use
///
/// Parameter `error`: an optional CFErrorRef reference for error details
///
/// Returns: a CFDictionaryRef containing all currently supported policies.  The values will be the maximum value allowed.
#[cfg(feature = "objc2-core-foundation")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopySupportedPolicies(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopySupportedPolicies(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopySupportedPolicies(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// This will set the policy for the node.
    ///
    /// This will set the policy for the node.  Policies are evaluated in combination with record-level policies.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `policies`: a CFDictionary of policies to be set
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool which signifies if the policy set succeeded, otherwise error is set.
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "use ODNodeSetAccountPolicies"]
    pub fn ODNodeSetPolicies(
        node: &ODNodeRef,
        policies: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// This will set a specific policy setting for the node.
    ///
    /// This will set a specific policy setting for the node.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `policy`: a valid ODPolicyType
    ///
    /// Parameter `value`: a CFTypeRef to be set (should be of appropriate type for the policy)
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool which signifies if the policy set succeeded, otherwise error is set.
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "use ODNodeAddAccountPolicy"]
    pub fn ODNodeSetPolicy(
        node: &ODNodeRef,
        policy_type: Option<&ODPolicyType>,
        value: Option<&CFType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// This will remove a specific policy setting from the node.
    ///
    /// This will remove a specific policy setting from the node.
    ///
    /// Parameter `node`: an ODNodeRef to use
    ///
    /// Parameter `policy`: a valid ODPolicyType
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details
    ///
    /// Returns: a bool which signifies if the policy removal succeeded, otherwise error is set.
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    #[deprecated = "use ODNodeRemoveAccountPolicy"]
    pub fn ODNodeRemovePolicy(
        node: &ODNodeRef,
        policy_type: Option<&ODPolicyType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// This will add an account policy to the node for the specified category.
    ///
    /// This will add an account policy to the node for the specified category.
    /// The specified policy will be applied to all users in the
    /// specified node when policies are evaluated.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `policy`: a dictionary containing the specific policy to be added.
    /// The dictionary may contain the following keys:
    /// kODPolicyKeyIdentifier a required key identifying the policy.
    /// kODPolicyKeyParameters an optional key containing a dictionary of
    /// parameters that can be used for informational purposes or in
    /// the policy format string.
    /// kODPolicyKeyContent a required key specifying the policy,
    /// from which a predicate will be created for evaluating
    /// the policy.
    ///
    /// Parameter `category`: a valid ODPolicyCategoryType to which the specified policy will be added.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the policy addition succeeded, otherwise error is set.
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    pub fn ODNodeAddAccountPolicy(
        node: &ODNodeRef,
        policy: Option<&CFDictionary>,
        category: Option<&ODPolicyCategoryType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// This will remove an account policy from the node for the specified category.
    ///
    /// This will remove an account policy from the node for the specified category.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `policy`: a dictionary containing the specific policy to be
    /// removed, with the same format as described in ODNodeAddAccountPolicy.
    ///
    /// Parameter `category`: a valid ODPolicyCategoryType from which the specified policy will be removed.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the policy removal succeeded, otherwise error is set.
    #[cfg(all(
        feature = "CFOpenDirectoryConstants",
        feature = "objc2-core-foundation"
    ))]
    pub fn ODNodeRemoveAccountPolicy(
        node: &ODNodeRef,
        policy: Option<&CFDictionary>,
        category: Option<&ODPolicyCategoryType>,
        error: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    /// This will set the policies for the node.
    ///
    /// This will set the policies for the node, replacing any existing
    /// policies.
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `policies`: a dictionary containing all of the policies to be set
    /// for the node.  The dictionary may contain the following keys:
    /// kODPolicyCategoryAuthentication an optional key with a value
    /// of an array of policy dictionaries that specify when
    /// authentications should be allowed.
    /// kODPolicyCategoryPasswordContent an optional key with a
    /// value of an array of policy dictionaries the specify the
    /// required content of passwords.
    /// kODPolicyCategoryPasswordChange an optional key with a value
    /// of an array of policy dictionaries that specify when
    /// passwords are required to be changed.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the policy set succeeded, otherwise error is set.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn ODNodeSetAccountPolicies(
        node: &ODNodeRef,
        policies: Option<&CFDictionary>,
        error: *mut *mut CFError,
    ) -> bool;
}

/// This will copy any policies configured for the node.
///
/// This will copy any policies configured for the node.
///
/// Parameter `node`: an ODNodeRef to use.
///
/// Parameter `error`: an optional CFErrorRef reference for error details.
///
/// Returns: a CFDictionaryRef containing all currently set policies.  The
/// format of the dictionary is the same as described in
/// ODNodeSetAccountPolicies().
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn ODNodeCopyAccountPolicies(
    node: &ODNodeRef,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn ODNodeCopyAccountPolicies(
            node: &ODNodeRef,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { ODNodeCopyAccountPolicies(node, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Validates a password against the node's password content policies.
    ///
    /// Validates a password against the node's password content policies.
    /// The node's password content policies will be evaluated to
    /// determine if the password is acceptable.  May be used prior to
    /// creating the record.
    ///
    /// This check is only definitive at the time it was requested. The
    /// policy or the environment could change before the password change
    /// is actually requested.  Errors from the password change request
    /// should be consulted.
    ///
    ///
    /// Parameter `node`: an ODNodeRef to use.
    ///
    /// Parameter `password`: the password to be evaluated against the content policies.
    ///
    /// Parameter `recordName`: the name of the record.
    ///
    /// Parameter `error`: an optional CFErrorRef reference for error details.
    ///
    /// Returns: a bool which signifies if the password passes all content policies, otherwise error is set.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn ODNodePasswordContentCheck(
        node: &ODNodeRef,
        password: Option<&CFString>,
        record_name: Option<&CFString>,
        error: *mut *mut CFError,
    ) -> bool;
}
