//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;
#[cfg(feature = "objc2-ui-kit")]
use objc2_ui_kit::*;

use crate::*;

extern "C" {
    /// The standard filename extension for exported [`ARReferenceObject`](https://developer.apple.com/documentation/arkit/arreferenceobject) instances.
    ///
    /// ## Discussion
    ///
    /// Use this filename extension when constructing a URL to save a reference object file with the [`exportObjectToURL:previewImage:error:`](https://developer.apple.com/documentation/arkit/arreferenceobject/export(to:previewimage:)) method.
    ///
    ///
    #[cfg(feature = "objc2-foundation")]
    pub static ARReferenceObjectArchiveExtension: &'static NSString;
}

#[cfg(feature = "objc2")]
extern_class!(
    /// The description of a 3D object that you want ARKit to detect in the physical environment.
    ///
    /// ## Overview
    ///
    /// Object detection in ARKit lets you trigger AR content when the session recognizes a known 3D object. For example, your app could detect sculptures in an art museum and provide a virtual curator, or detect tabletop gaming figures and create visual effects for the game.
    ///
    /// To provide a known 3D object for detection, you scan a real-world object using ARKit:
    ///
    /// 1. Run an AR session using [`ARObjectScanningConfiguration`](https://developer.apple.com/documentation/arkit/arobjectscanningconfiguration) to enable collection of high-fidelity spatial mapping data.
    ///
    /// 2. In that session, point the device camera at the real-world object from various angles, allowing ARKit to build up an internal map of the object and its surroundings. For an example of guiding user interactions to produce good scan data, see [Scanning and Detecting 3D Objects](https://developer.apple.com/documentation/arkit/scanning-and-detecting-3d-objects).
    ///
    /// 3. Determine the portion of the session’s world coordinate space representing the object to be recognized, and call [`createReferenceObjectWithTransform:center:extent:completionHandler:`](https://developer.apple.com/documentation/arkit/arsession/createreferenceobject(transform:center:extent:completionhandler:)) to get that portion as an [`ARReferenceObject`](https://developer.apple.com/documentation/arkit/arreferenceobject) ready for use in object detection.
    ///
    /// 4. To save the reference object for use later or elsewhere, use the [`exportObjectToURL:previewImage:error:`](https://developer.apple.com/documentation/arkit/arreferenceobject/export(to:previewimage:)) method to create an `.arobject` file.
    ///
    /// To detect objects in an AR session, pass a collection of reference objects to your session configuration’s [`detectionObjects`](https://developer.apple.com/documentation/arkit/arworldtrackingconfiguration/detectionobjects) property. You need not scan and detect objects in the same app: For example, you might create one app for scanning museum collections that outputs `.arobject` files, then bundle those files into another app meant for museum visitors.
    ///
    /// To bundle reference objects into an app, use your Xcode project’s asset catalog:
    ///
    /// 1. In your asset catalog, use the Add (+) button to create an AR Resource Group.
    ///
    /// 2. Drag `.arobject` into the resource group to create AR Reference Object entries in the asset catalog.
    ///
    /// 3. Optionally, use the Xcode inspector panel to provide a descriptive name for the object, which appears as the [`name`](https://developer.apple.com/documentation/arkit/arreferenceobject/name) property at runtime and can be useful for debugging.
    ///
    ///
    /// A reference object to track in the scene.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2")]
    pub struct ARReferenceObject;
);

#[cfg(feature = "objc2")]
unsafe impl Send for ARReferenceObject {}

#[cfg(feature = "objc2")]
unsafe impl Sync for ARReferenceObject {}

#[cfg(all(feature = "objc2", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCoding for ARReferenceObject {}
);

#[cfg(feature = "objc2")]
extern_conformance!(
    unsafe impl NSObjectProtocol for ARReferenceObject {}
);

#[cfg(all(feature = "objc2", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSSecureCoding for ARReferenceObject {}
);

#[cfg(feature = "objc2")]
impl ARReferenceObject {
    extern_methods!(
        #[cfg(feature = "objc2-foundation")]
        /// An optional name used to identify the object.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "objc2-foundation")]
        /// The AR resource group name for this object.
        ///
        /// If this object was loaded via an AR resource group in the Xcode asset catalogue this property will have the name of the resource group,
        /// else be set to nil.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(resourceGroupName))]
        #[unsafe(method_family = none)]
        pub unsafe fn resourceGroupName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "ARPointCloud")]
        /// The feature points of the object.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(rawFeaturePoints))]
        #[unsafe(method_family = none)]
        pub unsafe fn rawFeaturePoints(&self) -> Retained<ARPointCloud>;

        #[cfg(feature = "objc2-foundation")]
        /// Returns the set of ARReferenceObjects in the specified resource group and bundle.
        ///
        ///
        /// Parameter `name`: The name of the resource group.
        ///
        /// Parameter `bundle`: The bundle containing the image file or asset catalog. Specify nil to search the app’s main bundle.
        ///
        /// Returns: The set of reference objects or nil on error.
        #[unsafe(method(referenceObjectsInGroupNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn referenceObjectsInGroupNamed_bundle(
            name: &NSString,
            bundle: Option<&NSBundle>,
        ) -> Option<Retained<NSSet<ARReferenceObject>>>;

        #[cfg(feature = "objc2-foundation")]
        /// Initializes a new reference object with the contents of an archive at the specified URL.
        ///
        /// Parameter `url`: The URL from which to read data (.arobject archive).
        ///
        /// Parameter `error`: The error to populate if the object could not be initialized.
        #[unsafe(method(initWithArchiveURL:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithArchiveURL_error(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "objc2-foundation", feature = "objc2-ui-kit"))]
        /// Exports the object as an archive at the given URL.
        ///
        ///
        /// The URL path should use ARReferenceObjectArchiveExtension (.arobject) for the file extension.
        /// If serialization across devices is desired, NSKeyedArchiver should be used instead.
        ///
        /// Parameter `url`: The URL at which to write the exported object.
        ///
        /// Parameter `previewImage`: An optional preview image to include in the archive.
        ///
        /// Parameter `error`: The error to populate if the write is not successful.
        ///
        /// Returns: YES if the location is written successfully, otherwise NO.
        #[unsafe(method(exportObjectToURL:previewImage:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportObjectToURL_previewImage_error(
            &self,
            url: &NSURL,
            preview_image: Option<&UIImage>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-foundation")]
        /// Returns a new reference object by aligning and merging the provided object with this reference.
        ///
        /// This can be used to combine multiple scans of the same object for detection in different conditions. The object being merged
        /// must share similar feature points for the merge to succeed.
        ///
        /// Parameter `object`: The reference object to align and merge.
        ///
        /// Parameter `error`: The error to populate if the merge is not successful.
        ///
        /// Returns: A new reference object combining features of both scans or nil if the merge was not successful.
        #[unsafe(method(referenceObjectByMergingObject:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn referenceObjectByMergingObject_error(
            &self,
            object: &ARReferenceObject,
        ) -> Result<Retained<ARReferenceObject>, Retained<NSError>>;

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
