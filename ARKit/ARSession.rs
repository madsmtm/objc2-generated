//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-av-foundation")]
use objc2_av_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

/// Set of options for running the session.
///
/// These options alter the behavior of calling run on a session.
/// Providing no options will result in the default behavior of resuming tracking
/// from the last known position and keeping all existing anchors.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/arkit/arsessionrunoptions?language=objc)
// NS_OPTIONS
#[cfg(feature = "objc2")]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct ARSessionRunOptions(pub NSUInteger);
#[cfg(feature = "objc2")]
bitflags::bitflags! {
    impl ARSessionRunOptions: NSUInteger {
/// The session will reset tracking.
        #[doc(alias = "ARSessionRunOptionResetTracking")]
        const ResetTracking = 1<<0;
/// The session will remove existing anchors.
        #[doc(alias = "ARSessionRunOptionRemoveExistingAnchors")]
        const RemoveExistingAnchors = 1<<1;
/// The session will stop currently active tracked raycasts.
        #[doc(alias = "ARSessionRunOptionStopTrackedRaycasts")]
        const StopTrackedRaycasts = 1<<2;
/// The session will reset scene reconstruction.
        #[doc(alias = "ARSessionRunOptionResetSceneReconstruction")]
        const ResetSceneReconstruction = 1<<3;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for ARSessionRunOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for ARSessionRunOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2")]
extern_class!(
    /// The ARSession class configures and runs different Augmented Reality techniques on a device.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/arkit/arsession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2")]
    pub struct ARSession;
);

#[cfg(feature = "objc2")]
extern_conformance!(
    unsafe impl NSObjectProtocol for ARSession {}
);

#[cfg(feature = "objc2")]
impl ARSession {
    extern_methods!(
        #[cfg(feature = "objc2-foundation")]
        /// Unique identifier of the running session.
        ///
        ///
        /// The identifier may change after calling runWithConfiguration.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSUUID>;

        /// A delegate for receiving ARSession updates.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn ARSessionDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn ARSessionDelegate>>);

        #[cfg(feature = "dispatch2")]
        /// The dispatch queue on which the delegate calls are performed.
        ///
        /// If not provided or nil, delegate calls will be performed on the main queue.
        #[unsafe(method(delegateQueue))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegateQueue(&self) -> Option<Retained<DispatchQueue>>;

        #[cfg(feature = "dispatch2")]
        /// Setter for [`delegateQueue`][Self::delegateQueue].
        #[unsafe(method(setDelegateQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegateQueue(&self, delegate_queue: Option<&DispatchQueue>);

        #[cfg(feature = "ARFrame")]
        /// The current frame of the session.
        #[unsafe(method(currentFrame))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentFrame(&self) -> Option<Retained<ARFrame>>;

        #[cfg(feature = "ARConfiguration")]
        /// The configuration currently being used by the session.
        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn configuration(&self) -> Option<Retained<ARConfiguration>>;

        #[cfg(feature = "ARConfiguration")]
        /// Runs the session with the provided configuration.
        ///
        /// Calling run on a session that has already started will
        /// transition immediately to using the new configuration.
        ///
        /// Parameter `configuration`: The configuration to use.
        #[unsafe(method(runWithConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runWithConfiguration(&self, configuration: &ARConfiguration);

        #[cfg(feature = "ARConfiguration")]
        /// Runs the session with the provided configuration and options.
        ///
        /// Calling run on a session that has already started will
        /// transition immediately to using the new configuration. Options
        /// can be used to alter the default behavior when transitioning configurations.
        ///
        /// Parameter `configuration`: The configuration to use.
        ///
        /// Parameter `options`: The run options to use.
        #[unsafe(method(runWithConfiguration:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runWithConfiguration_options(
            &self,
            configuration: &ARConfiguration,
            options: ARSessionRunOptions,
        );

        /// Pauses the session.
        ///
        /// Once paused, no more updates will be received from the
        /// session until run is called again.
        #[unsafe(method(pause))]
        #[unsafe(method_family = none)]
        pub unsafe fn pause(&self);

        #[cfg(feature = "ARAnchor")]
        /// Adds an anchor to the session.
        ///
        /// The anchor will be added in the next frame update.
        ///
        /// Parameter `anchor`: The anchor to add.
        #[unsafe(method(addAnchor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAnchor(&self, anchor: &ARAnchor);

        #[cfg(feature = "ARAnchor")]
        /// Removes an anchor from the session.
        ///
        /// The anchor will be removed from subsequent frame updates.
        ///
        /// Parameter `anchor`: The anchor to remove.
        #[unsafe(method(removeAnchor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAnchor(&self, anchor: &ARAnchor);

        #[cfg(all(
            feature = "ARWorldMap",
            feature = "block2",
            feature = "objc2-foundation"
        ))]
        /// Copies the current state of the world being tracked by the session.
        ///
        /// A world map is only provided when running an ARWorldTrackingConfiguration.
        ///
        /// Parameter `completionHandler`: The completion handler to call when the get has completed. This handler is executed
        /// on the session's delegate queue. The completion handler takes the following parameters:
        /// worldMap - The current world map or nil if unavailable.
        /// error - An error that indicates why the world map is unavailable, or nil if a world map was provided.
        #[unsafe(method(getCurrentWorldMapWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCurrentWorldMapWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut ARWorldMap, *mut NSError)>,
        );

        #[cfg(all(
            feature = "ARRaycastQuery",
            feature = "ARRaycastResult",
            feature = "objc2-foundation"
        ))]
        /// Perform a raycast.
        ///
        /// Parameter `query`: Raycast query used for raycasting.
        ///
        /// Returns: List of raycast results, sorted from nearest to farthest (in distance from the camera). The results could be empty if raycast fails.
        #[unsafe(method(raycast:))]
        #[unsafe(method_family = none)]
        pub unsafe fn raycast(&self, query: &ARRaycastQuery) -> Retained<NSArray<ARRaycastResult>>;

        #[cfg(all(
            feature = "ARRaycastQuery",
            feature = "ARRaycastResult",
            feature = "ARTrackedRaycast",
            feature = "block2",
            feature = "objc2-foundation"
        ))]
        /// Perform a tracked raycast.
        ///
        /// The session performs continuous raycasting and calls the update handler with the updated results.
        /// The ARTrackedRaycast object returned can be used to update the raycast with a new raycast query or stop raycasting.
        ///
        /// Parameter `query`: Raycast query used for raycasting.
        ///
        /// Parameter `updateHandler`: update handler where updated list of results, sorted from nearest to farthest (in distance from
        /// the camera) are delivered. updateHandler will be called on session's delegate queue.
        ///
        /// Returns: Tracked raycast object used to update or stop raycasting. This could be nil if the raycast fails or if the
        /// configuration is not `ARWorldTrackingConfiguration` or its subclasses.
        #[unsafe(method(trackedRaycast:updateHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackedRaycast_updateHandler(
            &self,
            query: &ARRaycastQuery,
            update_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<ARRaycastResult>>)>,
        ) -> Option<Retained<ARTrackedRaycast>>;

        #[cfg(feature = "ARCollaborationData")]
        /// Update session with collaboration data.
        ///
        ///
        /// Use this to update the session with collaboration data received from other participants.
        ///
        ///
        /// Parameter `collaborationData`: Collaboration data for updating the session.
        ///
        /// See: ARCollaborationData
        #[unsafe(method(updateWithCollaborationData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateWithCollaborationData(&self, collaboration_data: &ARCollaborationData);

        #[cfg(all(feature = "ARFrame", feature = "block2", feature = "objc2-foundation"))]
        /// Requests a single, high resolution frame to be captured.
        ///
        /// Some video formats do not support a significantly higher still image resolution than the streaming camera resolution. Use the
        /// `isRecommendedForHighResolutionFrameCapturing`method on the video format to check if the format is recommended.
        ///
        /// See: -[ARVideoFormat isRecommendedForHighResolutionFrameCapturing]
        ///
        /// Parameter `completion`: Block being called when the call completes.
        #[unsafe(method(captureHighResolutionFrameWithCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn captureHighResolutionFrameWithCompletion(
            &self,
            completion: &block2::DynBlock<dyn Fn(*mut ARFrame, *mut NSError)>,
        );

        #[cfg(all(
            feature = "ARFrame",
            feature = "block2",
            feature = "objc2-av-foundation",
            feature = "objc2-foundation"
        ))]
        /// Requests a single, high resolution frame to be captured.
        ///
        /// Some video formats do not support a significantly higher still image resolution than the streaming camera resolution. Use the
        /// `isRecommendedForHighResolutionFrameCapturing`method on the video format to check if the format is recommended. For passing customized photo settings
        /// to this method, obtain a
        /// `defaultPhotoSettings`object from the video format and modify it.
        ///
        /// See: -[ARVideoFormat isRecommendedForHighResolutionFrameCapturing]
        ///
        /// See: -[ARVideoFormat defaultPhotoSettings]
        ///
        /// Parameter `photoSettings`: Custom AVCapturePhotoSettings to be used.
        ///
        /// Parameter `completion`: Block being called when the call completes.
        #[unsafe(method(captureHighResolutionFrameUsingPhotoSettings:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn captureHighResolutionFrameUsingPhotoSettings_completion(
            &self,
            photo_settings: Option<&AVCapturePhotoSettings>,
            completion: &block2::DynBlock<dyn Fn(*mut ARFrame, *mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2")]
impl ARSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/arkit/arsessionobserver?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait ARSessionObserver: NSObjectProtocol {
        #[cfg(feature = "objc2-foundation")]
        /// This is called when a session fails.
        ///
        ///
        /// On failure the session will be paused.
        ///
        /// Parameter `session`: The session that failed.
        ///
        /// Parameter `error`: The error being reported (see ARError.h).
        #[optional]
        #[unsafe(method(session:didFailWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didFailWithError(&self, session: &ARSession, error: &NSError);

        #[cfg(feature = "ARCamera")]
        /// This is called when the camera’s tracking state has changed.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `camera`: The camera that changed tracking states.
        #[optional]
        #[unsafe(method(session:cameraDidChangeTrackingState:))]
        #[unsafe(method_family = none)]
        unsafe fn session_cameraDidChangeTrackingState(
            &self,
            session: &ARSession,
            camera: &ARCamera,
        );

        /// This is called when a session is interrupted.
        ///
        ///
        /// A session will be interrupted and no longer able to track when
        /// it fails to receive required sensor data. This happens when video capture is interrupted,
        /// for example when the application is sent to the background or when there are
        /// multiple foreground applications (see AVCaptureSessionInterruptionReason).
        /// No additional frame updates will be delivered until the interruption has ended.
        ///
        /// Parameter `session`: The session that was interrupted.
        #[optional]
        #[unsafe(method(sessionWasInterrupted:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionWasInterrupted(&self, session: &ARSession);

        /// This is called when a session interruption has ended.
        ///
        ///
        /// A session will continue running from the last known state once
        /// the interruption has ended. If the device has moved, anchors will be misaligned.
        /// To avoid this, some applications may want to reset tracking (see ARSessionRunOptions)
        /// or attempt to relocalize (see `-[ARSessionObserver sessionShouldAttemptRelocalization:]`).
        ///
        /// Parameter `session`: The session that was interrupted.
        #[optional]
        #[unsafe(method(sessionInterruptionEnded:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionInterruptionEnded(&self, session: &ARSession);

        /// This is called after a session resumes from a pause or interruption to determine
        /// whether or not the session should attempt to relocalize.
        ///
        ///
        /// To avoid misaligned anchors, apps may wish to attempt a relocalization after
        /// a session pause or interruption. If YES is returned: the session will begin relocalizing
        /// and tracking state will switch to limited with reason relocalizing. If successful, the
        /// session's tracking state will return to normal. Because relocalization depends on
        /// the user's location, it can run indefinitely. Apps that wish to give up on relocalization
        /// may call run with `ARSessionRunOptionResetTracking` at any time.
        ///
        /// Parameter `session`: The session to relocalize.
        ///
        /// Returns: Return YES to begin relocalizing.
        #[optional]
        #[unsafe(method(sessionShouldAttemptRelocalization:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionShouldAttemptRelocalization(&self, session: &ARSession) -> bool;

        #[cfg(feature = "objc2-core-media")]
        /// This is called when the session outputs a new audio sample buffer.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `audioSampleBuffer`: The captured audio sample buffer.
        #[optional]
        #[unsafe(method(session:didOutputAudioSampleBuffer:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didOutputAudioSampleBuffer(
            &self,
            session: &ARSession,
            audio_sample_buffer: &CMSampleBuffer,
        );

        #[cfg(feature = "ARCollaborationData")]
        /// This is called when the session generated new collaboration data.
        ///
        ///
        /// This data should be sent to all participants.
        ///
        ///
        /// Parameter `session`: The session that produced world tracking collaboration data.
        ///
        /// Parameter `data`: Collaboration data to be sent to participants.
        ///
        /// See: ARCollaborationData
        #[optional]
        #[unsafe(method(session:didOutputCollaborationData:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didOutputCollaborationData(
            &self,
            session: &ARSession,
            data: &ARCollaborationData,
        );

        #[cfg(feature = "ARGeoTrackingTypes")]
        /// This is called when geo tracking status changes.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `geoTrackingStatus`: Latest geo tracking status.
        #[optional]
        #[unsafe(method(session:didChangeGeoTrackingStatus:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didChangeGeoTrackingStatus(
            &self,
            session: &ARSession,
            geo_tracking_status: &ARGeoTrackingStatus,
        );
    }
);

#[cfg(feature = "objc2")]
extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/arkit/arsessiondelegate?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait ARSessionDelegate: ARSessionObserver {
        #[cfg(feature = "ARFrame")]
        /// This is called when a new frame has been updated.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `frame`: The frame that has been updated.
        #[optional]
        #[unsafe(method(session:didUpdateFrame:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didUpdateFrame(&self, session: &ARSession, frame: &ARFrame);

        #[cfg(all(feature = "ARAnchor", feature = "objc2-foundation"))]
        /// This is called when new anchors are added to the session.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `anchors`: An array of added anchors.
        #[optional]
        #[unsafe(method(session:didAddAnchors:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didAddAnchors(&self, session: &ARSession, anchors: &NSArray<ARAnchor>);

        #[cfg(all(feature = "ARAnchor", feature = "objc2-foundation"))]
        /// This is called when anchors are updated.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `anchors`: An array of updated anchors.
        #[optional]
        #[unsafe(method(session:didUpdateAnchors:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didUpdateAnchors(&self, session: &ARSession, anchors: &NSArray<ARAnchor>);

        #[cfg(all(feature = "ARAnchor", feature = "objc2-foundation"))]
        /// This is called when anchors are removed from the session.
        ///
        ///
        /// Parameter `session`: The session being run.
        ///
        /// Parameter `anchors`: An array of removed anchors.
        #[optional]
        #[unsafe(method(session:didRemoveAnchors:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didRemoveAnchors(&self, session: &ARSession, anchors: &NSArray<ARAnchor>);
    }
);

#[cfg(feature = "objc2")]
extern_protocol!(
    /// A data source for an ARSession
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/arkit/arsessionproviding?language=objc)
    #[cfg(feature = "objc2")]
    pub unsafe trait ARSessionProviding: NSObjectProtocol {
        /// To ensure session changes are detected, Swift classes should mark this property as `
        /// ` and `dynamic`
        #[unsafe(method(session))]
        #[unsafe(method_family = none)]
        unsafe fn session(&self) -> Retained<ARSession>;
    }
);
