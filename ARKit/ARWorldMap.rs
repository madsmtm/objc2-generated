//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

#[cfg(feature = "objc2")]
extern_class!(
    /// The state in a world-tracking AR session during which a device maps the user’s position in physical space and proximity to anchor objects.
    ///
    /// ## Overview
    ///
    /// The session state in a world map includes ARKit’s awareness of the physical space in which the user moves the device. ARKit uses the details of the user’s physical space to determine the device’s position and orientation, as well as any [`ARAnchor`](https://developer.apple.com/documentation/arkit/aranchor) objects added to the session that can represent detected real-world features or virtual content placed by your app.
    ///
    /// ### Serialize and Deserialize a World Map
    ///
    /// When your app quits, you can save the current world map (acquired using [`getCurrentWorldMapWithCompletionHandler:`](https://developer.apple.com/documentation/arkit/arsession/getcurrentworldmap(completionhandler:))). Because [`ARWorldMap`](https://developer.apple.com/documentation/arkit/arworldmap) conforms to [`NSSecureCoding`](https://developer.apple.com/documentation/foundation/nssecurecoding), you serialize it using [`NSKeyedArchiver`](https://developer.apple.com/documentation/foundation/nskeyedarchiver).
    ///
    /// ```swift
    /// func writeWorldMap(_ worldMap: ARWorldMap, to url: URL) throws {
    ///     let data = try NSKeyedArchiver.archivedData(withRootObject: worldMap, requiringSecureCoding: true)
    ///     try data.write(to: url)
    /// }
    /// ```
    ///
    /// To restore the world map the next time your app launches, use [`NSKeyedUnarchiver`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver).
    ///
    /// ```swift
    /// func loadWorldMap(from url: URL) throws -> ARWorldMap {
    ///     let mapData = try Data(contentsOf: url)
    ///     guard let worldMap = try NSKeyedUnarchiver.unarchivedObject(ofClass: ARWorldMap.self, from: mapData)
    ///         else { throw ARError(.invalidWorldMap) }
    ///     return worldMap
    /// }
    /// ```
    ///
    /// You can use anchors from a resumed world map to place the same virtual content at the same positions from the saved session, if the app launches in the same physical environment.
    ///
    /// For more information, see [Saving and loading world data](https://developer.apple.com/documentation/arkit/saving-and-loading-world-data).
    ///
    /// ### Share a Saved World Map
    ///
    /// With two devices tracking the same world map, you can build a networked experience in which both users can see and interact with the same virtual content. To send an [`ARWorldMap`](https://developer.apple.com/documentation/arkit/arworldmap) to another device:
    ///
    /// 1. On one device, use [`NSKeyedArchiver`](https://developer.apple.com/documentation/foundation/nskeyedarchiver) to convert the world map to a data object. You don’t need to write the data to a file to send it over the network.
    ///
    /// 2. Use the networking technology of your choice to send the resulting data to another device. For example, in a [`Multipeer Connectivity`](https://developer.apple.com/documentation/multipeerconnectivity) session, call [`sendData:toPeers:withMode:error:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/send(_:topeers:with:)) to send data, and implement [`MCSessionDelegate`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate) methods on the other device to receive data.
    ///
    /// 3. On the receiving device, use [`NSKeyedUnarchiver`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver) to instantiate an [`ARWorldMap`](https://developer.apple.com/documentation/arkit/arworldmap) from the data.
    ///
    /// For more information, see [Creating a multiuser AR experience](https://developer.apple.com/documentation/arkit/creating-a-multiuser-ar-experience).
    ///
    /// ### Run a Deserialized World Map
    ///
    /// To begin a new session from an existing [`ARWorldMap`](https://developer.apple.com/documentation/arkit/arworldmap), set a world-tracking configuration’s [`initialWorldMap`](https://developer.apple.com/documentation/arkit/arworldtrackingconfiguration/initialworldmap) property and use [`runWithConfiguration:options:`](https://developer.apple.com/documentation/arkit/arsession/run(_:options:)). This starts a new session using the same spatial awareness and anchors loaded from the saved world map.
    ///
    ///
    /// Object representing the mapping of a physical 3D space.
    ///
    /// ARWorldMap supports archiving and unarchiving across devices
    /// and versions with NSDecodingFailurePolicySetErrorAndReturn, providing an error
    /// if the map format is not supported.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2")]
    pub struct ARWorldMap;
);

#[cfg(all(feature = "objc2", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCoding for ARWorldMap {}
);

#[cfg(all(feature = "objc2", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCopying for ARWorldMap {}
);

#[cfg(all(feature = "objc2", feature = "objc2-foundation"))]
unsafe impl CopyingHelper for ARWorldMap {
    type Result = Self;
}

#[cfg(feature = "objc2")]
extern_conformance!(
    unsafe impl NSObjectProtocol for ARWorldMap {}
);

#[cfg(all(feature = "objc2", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSSecureCoding for ARWorldMap {}
);

#[cfg(feature = "objc2")]
impl ARWorldMap {
    extern_methods!(
        #[cfg(all(feature = "ARAnchor", feature = "objc2-foundation"))]
        /// A list of anchors in the map.
        #[unsafe(method(anchors))]
        #[unsafe(method_family = none)]
        pub unsafe fn anchors(&self) -> Retained<NSArray<ARAnchor>>;

        #[cfg(all(feature = "ARAnchor", feature = "objc2-foundation"))]
        /// Setter for [`anchors`][Self::anchors].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAnchors:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnchors(&self, anchors: &NSArray<ARAnchor>);

        #[cfg(feature = "ARPointCloud")]
        /// The feature points in the map.
        #[unsafe(method(rawFeaturePoints))]
        #[unsafe(method_family = none)]
        pub unsafe fn rawFeaturePoints(&self) -> Retained<ARPointCloud>;

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
