//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

pub const kAudioEndPointDeviceUIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"uid\0") };
pub const kAudioEndPointDeviceNameKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAudioEndPointDeviceEndPointListKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"endpoints\0") };
pub const kAudioEndPointDeviceMainEndPointKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"main\0") };
pub const kAudioEndPointDeviceMasterEndPointKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"master\0") };
pub const kAudioEndPointDeviceIsPrivateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"private\0") };
pub const kAudioEndPointUIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"uid\0") };
pub const kAudioEndPointNameKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAudioEndPointInputChannelsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"channels-in\0") };
pub const kAudioEndPointOutputChannelsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"channels-out\0") };
pub const kAudioAggregateDeviceUIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"uid\0") };
pub const kAudioAggregateDeviceNameKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAudioAggregateDeviceSubDeviceListKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"subdevices\0") };
pub const kAudioAggregateDeviceMainSubDeviceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"master\0") };
pub const kAudioAggregateDeviceClockDeviceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"clock\0") };
pub const kAudioAggregateDeviceIsPrivateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"private\0") };
pub const kAudioAggregateDeviceIsStackedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"stacked\0") };
pub const kAudioAggregateDeviceTapListKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"taps\0") };
pub const kAudioAggregateDeviceTapAutoStartKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"tapautostart\0") };
pub const kAudioSubDeviceUIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"uid\0") };
pub const kAudioSubDeviceNameKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"name\0") };
pub const kAudioSubDeviceInputChannelsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"channels-in\0") };
pub const kAudioSubDeviceOutputChannelsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"channels-out\0") };
pub const kAudioSubDeviceExtraInputLatencyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"latency-in\0") };
pub const kAudioSubDeviceExtraOutputLatencyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"latency-out\0") };
pub const kAudioSubDeviceDriftCompensationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"drift\0") };
pub const kAudioSubDeviceDriftCompensationQualityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"drift quality\0") };
pub const kAudioSubTapUIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"uid\0") };
pub const kAudioSubTapExtraInputLatencyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"latency-in\0") };
pub const kAudioSubTapExtraOutputLatencyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"latency-out\0") };
pub const kAudioSubTapDriftCompensationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"drift\0") };
pub const kAudioSubTapDriftCompensationQualityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"drift quality\0") };
/// A UInt32 that provides a handle on a specific AudioObject.
pub type AudioObjectID = u32;

/// AudioClassIDs are used to identify the class of an AudioObject.
pub type AudioClassID = u32;

/// An AudioObjectPropertySelector is a four char code that identifies, along with
/// the AudioObjectPropertyScope and AudioObjectPropertyElement, a specific piece of
/// information about an AudioObject.
///
/// The property selector specifies the general classification of the property such
/// as volume, stream format, latency, etc. Note that each class has a different set
/// of selectors. A subclass inherits its super class's set of selectors, although
/// it may not implement them all.
pub type AudioObjectPropertySelector = u32;

/// An AudioObjectPropertyScope is a four char code that identifies, along with the
/// AudioObjectPropertySelector and AudioObjectPropertyElement, a specific piece of
/// information about an AudioObject.
///
/// The scope specifies the section of the object in which to look for the property,
/// such as input, output, global, etc. Note that each class has a different set of
/// scopes. A subclass inherits its superclass's set of scopes.
pub type AudioObjectPropertyScope = u32;

/// An AudioObjectPropertyElement is an integer that identifies, along with the
/// AudioObjectPropertySelector and AudioObjectPropertyScope, a specific piece of
/// information about an AudioObject.
///
/// The element selects one of possibly many items in the section of the object in
/// which to look for the property. Elements are number sequentially where 0
/// represents the main element. Elements are particular to an instance of a
/// class, meaning that two instances can have different numbers of elements in the
/// same scope. There is no inheritance of elements.
pub type AudioObjectPropertyElement = u32;

/// An AudioObjectPropertyAddress collects the three parts that identify a specific
/// property together in a struct for easy transmission.
/// Field: mSelector
/// The AudioObjectPropertySelector for the property.
/// Field: mScope
/// The AudioObjectPropertyScope for the property.
/// Field: mElement
/// The AudioObjectPropertyElement for the property.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioObjectPropertyAddress {
    pub mSelector: AudioObjectPropertySelector,
    pub mScope: AudioObjectPropertyScope,
    pub mElement: AudioObjectPropertyElement,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for AudioObjectPropertyAddress {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioObjectPropertyAddress",
        &[
            <AudioObjectPropertySelector>::ENCODING,
            <AudioObjectPropertyScope>::ENCODING,
            <AudioObjectPropertyElement>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AudioObjectPropertyAddress {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioHardwareNoError: OSStatus = 0;
pub const kAudioHardwareNotRunningError: OSStatus = 0x73746f70;
pub const kAudioHardwareUnspecifiedError: OSStatus = 0x77686174;
pub const kAudioHardwareUnknownPropertyError: OSStatus = 0x77686f3f;
pub const kAudioHardwareBadPropertySizeError: OSStatus = 0x2173697a;
pub const kAudioHardwareIllegalOperationError: OSStatus = 0x6e6f7065;
pub const kAudioHardwareBadObjectError: OSStatus = 0x216f626a;
pub const kAudioHardwareBadDeviceError: OSStatus = 0x21646576;
pub const kAudioHardwareBadStreamError: OSStatus = 0x21737472;
pub const kAudioHardwareUnsupportedOperationError: OSStatus = 0x756e6f70;
pub const kAudioHardwareNotReadyError: OSStatus = 0x6e726479;
pub const kAudioDeviceUnsupportedFormatError: OSStatus = 0x21646174;
pub const kAudioDevicePermissionsError: OSStatus = 0x21686f67;

pub const kAudioObjectUnknown: AudioObjectID = 0;

pub const kAudioObjectPropertyScopeGlobal: AudioObjectPropertyScope = 0x676c6f62;
pub const kAudioObjectPropertyScopeInput: AudioObjectPropertyScope = 0x696e7074;
pub const kAudioObjectPropertyScopeOutput: AudioObjectPropertyScope = 0x6f757470;
pub const kAudioObjectPropertyScopePlayThrough: AudioObjectPropertyScope = 0x70747275;
pub const kAudioObjectPropertyElementMain: AudioObjectPropertyScope = 0;
#[deprecated]
pub const kAudioObjectPropertyElementMaster: AudioObjectPropertyScope =
    kAudioObjectPropertyElementMain;

pub const kAudioObjectPropertySelectorWildcard: AudioObjectPropertySelector = 0x2a2a2a2a;

pub const kAudioObjectPropertyScopeWildcard: AudioObjectPropertyScope = 0x2a2a2a2a;

pub const kAudioObjectPropertyElementWildcard: AudioObjectPropertyElement = 0xFFFFFFFF;

pub const kAudioObjectClassIDWildcard: AudioClassID = 0x2a2a2a2a;

pub const kAudioObjectClassID: AudioClassID = 0x616f626a;

pub const kAudioObjectPropertyBaseClass: AudioObjectPropertySelector = 0x62636c73;
pub const kAudioObjectPropertyClass: AudioObjectPropertySelector = 0x636c6173;
pub const kAudioObjectPropertyOwner: AudioObjectPropertySelector = 0x73746476;
pub const kAudioObjectPropertyName: AudioObjectPropertySelector = 0x6c6e616d;
pub const kAudioObjectPropertyModelName: AudioObjectPropertySelector = 0x6c6d6f64;
pub const kAudioObjectPropertyManufacturer: AudioObjectPropertySelector = 0x6c6d616b;
pub const kAudioObjectPropertyElementName: AudioObjectPropertySelector = 0x6c63686e;
pub const kAudioObjectPropertyElementCategoryName: AudioObjectPropertySelector = 0x6c63636e;
pub const kAudioObjectPropertyElementNumberName: AudioObjectPropertySelector = 0x6c636e6e;
pub const kAudioObjectPropertyOwnedObjects: AudioObjectPropertySelector = 0x6f776e64;
pub const kAudioObjectPropertyIdentify: AudioObjectPropertySelector = 0x6964656e;
pub const kAudioObjectPropertySerialNumber: AudioObjectPropertySelector = 0x736e756d;
pub const kAudioObjectPropertyFirmwareVersion: AudioObjectPropertySelector = 0x6677766e;

pub const kAudioPlugInClassID: AudioClassID = 0x61706c67;

pub const kAudioPlugInPropertyBundleID: AudioObjectPropertySelector = 0x70696964;
pub const kAudioPlugInPropertyDeviceList: AudioObjectPropertySelector = 0x64657623;
pub const kAudioPlugInPropertyTranslateUIDToDevice: AudioObjectPropertySelector = 0x75696464;
pub const kAudioPlugInPropertyBoxList: AudioObjectPropertySelector = 0x626f7823;
pub const kAudioPlugInPropertyTranslateUIDToBox: AudioObjectPropertySelector = 0x75696462;
pub const kAudioPlugInPropertyClockDeviceList: AudioObjectPropertySelector = 0x636c6b23;
pub const kAudioPlugInPropertyTranslateUIDToClockDevice: AudioObjectPropertySelector = 0x75696463;

pub const kAudioTransportManagerClassID: AudioClassID = 0x7472706d;

pub const kAudioTransportManagerPropertyEndPointList: AudioObjectPropertySelector = 0x656e6423;
pub const kAudioTransportManagerPropertyTranslateUIDToEndPoint: AudioObjectPropertySelector =
    0x75696465;
pub const kAudioTransportManagerPropertyTransportType: AudioObjectPropertySelector = 0x7472616e;

pub const kAudioBoxClassID: AudioClassID = 0x61626f78;

pub const kAudioBoxPropertyBoxUID: AudioObjectPropertySelector = 0x62756964;
pub const kAudioBoxPropertyTransportType: AudioObjectPropertySelector = 0x7472616e;
pub const kAudioBoxPropertyHasAudio: AudioObjectPropertySelector = 0x62686175;
pub const kAudioBoxPropertyHasVideo: AudioObjectPropertySelector = 0x62687669;
pub const kAudioBoxPropertyHasMIDI: AudioObjectPropertySelector = 0x62686d69;
pub const kAudioBoxPropertyIsProtected: AudioObjectPropertySelector = 0x6270726f;
pub const kAudioBoxPropertyAcquired: AudioObjectPropertySelector = 0x62786f6e;
pub const kAudioBoxPropertyAcquisitionFailed: AudioObjectPropertySelector = 0x62786f66;
pub const kAudioBoxPropertyDeviceList: AudioObjectPropertySelector = 0x62647623;
pub const kAudioBoxPropertyClockDeviceList: AudioObjectPropertySelector = 0x62636c23;

pub const kAudioDeviceClassID: AudioClassID = 0x61646576;

pub const kAudioDeviceTransportTypeUnknown: u32 = 0;
pub const kAudioDeviceTransportTypeBuiltIn: u32 = 0x626c746e;
pub const kAudioDeviceTransportTypeAggregate: u32 = 0x67727570;
pub const kAudioDeviceTransportTypeVirtual: u32 = 0x76697274;
pub const kAudioDeviceTransportTypePCI: u32 = 0x70636920;
pub const kAudioDeviceTransportTypeUSB: u32 = 0x75736220;
pub const kAudioDeviceTransportTypeFireWire: u32 = 0x31333934;
pub const kAudioDeviceTransportTypeBluetooth: u32 = 0x626c7565;
pub const kAudioDeviceTransportTypeBluetoothLE: u32 = 0x626c6561;
pub const kAudioDeviceTransportTypeHDMI: u32 = 0x68646d69;
pub const kAudioDeviceTransportTypeDisplayPort: u32 = 0x64707274;
pub const kAudioDeviceTransportTypeAirPlay: u32 = 0x61697270;
pub const kAudioDeviceTransportTypeAVB: u32 = 0x65617662;
pub const kAudioDeviceTransportTypeThunderbolt: u32 = 0x7468756e;
pub const kAudioDeviceTransportTypeContinuityCaptureWired: u32 = 0x63637764;
pub const kAudioDeviceTransportTypeContinuityCaptureWireless: u32 = 0x6363776c;
#[deprecated = "Please use kAudioDeviceTransportTypeContinuityCaptureWired and kAudioDeviceTransportTypeContinuityCaptureWireless to describe Continuity Capture devices."]
pub const kAudioDeviceTransportTypeContinuityCapture: u32 = 0x63636170;

pub const kAudioDevicePropertyConfigurationApplication: AudioObjectPropertySelector = 0x63617070;
pub const kAudioDevicePropertyDeviceUID: AudioObjectPropertySelector = 0x75696420;
pub const kAudioDevicePropertyModelUID: AudioObjectPropertySelector = 0x6d756964;
pub const kAudioDevicePropertyTransportType: AudioObjectPropertySelector = 0x7472616e;
pub const kAudioDevicePropertyRelatedDevices: AudioObjectPropertySelector = 0x616b696e;
pub const kAudioDevicePropertyClockDomain: AudioObjectPropertySelector = 0x636c6b64;
pub const kAudioDevicePropertyDeviceIsAlive: AudioObjectPropertySelector = 0x6c69766e;
pub const kAudioDevicePropertyDeviceIsRunning: AudioObjectPropertySelector = 0x676f696e;
pub const kAudioDevicePropertyDeviceCanBeDefaultDevice: AudioObjectPropertySelector = 0x64666c74;
pub const kAudioDevicePropertyDeviceCanBeDefaultSystemDevice: AudioObjectPropertySelector =
    0x73666c74;
pub const kAudioDevicePropertyLatency: AudioObjectPropertySelector = 0x6c746e63;
pub const kAudioDevicePropertyStreams: AudioObjectPropertySelector = 0x73746d23;
pub const kAudioObjectPropertyControlList: AudioObjectPropertySelector = 0x6374726c;
pub const kAudioDevicePropertySafetyOffset: AudioObjectPropertySelector = 0x73616674;
pub const kAudioDevicePropertyNominalSampleRate: AudioObjectPropertySelector = 0x6e737274;
pub const kAudioDevicePropertyAvailableNominalSampleRates: AudioObjectPropertySelector = 0x6e737223;
pub const kAudioDevicePropertyIcon: AudioObjectPropertySelector = 0x69636f6e;
pub const kAudioDevicePropertyIsHidden: AudioObjectPropertySelector = 0x6869646e;
pub const kAudioDevicePropertyPreferredChannelsForStereo: AudioObjectPropertySelector = 0x64636832;
pub const kAudioDevicePropertyPreferredChannelLayout: AudioObjectPropertySelector = 0x73726e64;

pub const kAudioClockDeviceClassID: AudioObjectPropertySelector = 0x61636c6b;

pub const kAudioClockDevicePropertyDeviceUID: AudioObjectPropertySelector = 0x63756964;
pub const kAudioClockDevicePropertyTransportType: AudioObjectPropertySelector = 0x7472616e;
pub const kAudioClockDevicePropertyClockDomain: AudioObjectPropertySelector = 0x636c6b64;
pub const kAudioClockDevicePropertyDeviceIsAlive: AudioObjectPropertySelector = 0x6c69766e;
pub const kAudioClockDevicePropertyDeviceIsRunning: AudioObjectPropertySelector = 0x676f696e;
pub const kAudioClockDevicePropertyLatency: AudioObjectPropertySelector = 0x6c746e63;
pub const kAudioClockDevicePropertyControlList: AudioObjectPropertySelector = 0x6374726c;
pub const kAudioClockDevicePropertyNominalSampleRate: AudioObjectPropertySelector = 0x6e737274;
pub const kAudioClockDevicePropertyAvailableNominalSampleRates: AudioObjectPropertySelector =
    0x6e737223;

pub const kAudioEndPointDeviceClassID: AudioClassID = 0x65646576;

pub const kAudioEndPointDevicePropertyComposition: AudioObjectPropertySelector = 0x61636f6d;
pub const kAudioEndPointDevicePropertyEndPointList: AudioObjectPropertySelector = 0x61677270;
pub const kAudioEndPointDevicePropertyIsPrivate: AudioObjectPropertySelector = 0x70726976;

pub const kAudioEndPointClassID: AudioClassID = 0x656e6470;

/// This structure allows a specific sample rate range to be associated with an
/// AudioStreamBasicDescription that specifies its sample rate as
/// kAudioStreamAnyRate.
///
/// Note that this structure is only used to describe the the available formats
/// for a stream. It is not used for the current format.
/// Field: mFormat
/// The AudioStreamBasicDescription that describes the format of the stream.
/// Note that the mSampleRate field of the structure will be the same as the
/// the values in mSampleRateRange when only a single sample rate is supported.
/// It will be kAudioStreamAnyRate when there is a range with more elements.
/// Field: mSampleRateRange
/// The AudioValueRange that describes the minimum and maximum sample rate for
/// the stream. If the mSampleRate field of mFormat is kAudioStreamAnyRate the
/// format supports the range of sample rates described by this structure.
/// Otherwise, the minimum will be the same as the maximum which will be the
/// same as the mSampleRate field of mFormat.
#[cfg(feature = "objc2-core-audio-types")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct AudioStreamRangedDescription {
    pub mFormat: AudioStreamBasicDescription,
    pub mSampleRateRange: AudioValueRange,
}

#[cfg(all(feature = "objc2", feature = "objc2-core-audio-types"))]
unsafe impl Encode for AudioStreamRangedDescription {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioStreamRangedDescription",
        &[
            <AudioStreamBasicDescription>::ENCODING,
            <AudioValueRange>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "objc2", feature = "objc2-core-audio-types"))]
unsafe impl RefEncode for AudioStreamRangedDescription {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioStreamClassID: AudioClassID = 0x61737472;

pub const kAudioStreamTerminalTypeUnknown: u32 = 0;
pub const kAudioStreamTerminalTypeLine: u32 = 0x6c696e65;
pub const kAudioStreamTerminalTypeDigitalAudioInterface: u32 = 0x73706466;
pub const kAudioStreamTerminalTypeSpeaker: u32 = 0x73706b72;
pub const kAudioStreamTerminalTypeHeadphones: u32 = 0x68647068;
pub const kAudioStreamTerminalTypeLFESpeaker: u32 = 0x6c666573;
pub const kAudioStreamTerminalTypeReceiverSpeaker: u32 = 0x7273706b;
pub const kAudioStreamTerminalTypeMicrophone: u32 = 0x6d696372;
pub const kAudioStreamTerminalTypeHeadsetMicrophone: u32 = 0x686d6963;
pub const kAudioStreamTerminalTypeReceiverMicrophone: u32 = 0x726d6963;
pub const kAudioStreamTerminalTypeTTY: u32 = 0x7474795f;
pub const kAudioStreamTerminalTypeHDMI: u32 = 0x68646d69;
pub const kAudioStreamTerminalTypeDisplayPort: u32 = 0x64707274;

pub const kAudioStreamPropertyIsActive: AudioObjectPropertySelector = 0x73616374;
pub const kAudioStreamPropertyDirection: AudioObjectPropertySelector = 0x73646972;
pub const kAudioStreamPropertyTerminalType: AudioObjectPropertySelector = 0x7465726d;
pub const kAudioStreamPropertyStartingChannel: AudioObjectPropertySelector = 0x7363686e;
pub const kAudioStreamPropertyLatency: AudioObjectPropertySelector = kAudioDevicePropertyLatency;
pub const kAudioStreamPropertyVirtualFormat: AudioObjectPropertySelector = 0x73666d74;
pub const kAudioStreamPropertyAvailableVirtualFormats: AudioObjectPropertySelector = 0x73666d61;
pub const kAudioStreamPropertyPhysicalFormat: AudioObjectPropertySelector = 0x70667420;
pub const kAudioStreamPropertyAvailablePhysicalFormats: AudioObjectPropertySelector = 0x70667461;

pub const kAudioControlClassID: AudioClassID = 0x6163746c;

pub const kAudioControlPropertyScope: AudioObjectPropertySelector = 0x63736370;
pub const kAudioControlPropertyElement: AudioObjectPropertySelector = 0x63656c6d;

pub const kAudioSliderControlClassID: AudioClassID = 0x736c6472;

pub const kAudioSliderControlPropertyValue: AudioObjectPropertySelector = 0x73647276;
pub const kAudioSliderControlPropertyRange: AudioObjectPropertySelector = 0x73647272;

pub const kAudioLevelControlClassID: AudioClassID = 0x6c65766c;
pub const kAudioVolumeControlClassID: AudioClassID = 0x766c6d65;
pub const kAudioLFEVolumeControlClassID: AudioClassID = 0x73756276;

pub const kAudioLevelControlPropertyScalarValue: AudioObjectPropertySelector = 0x6c637376;
pub const kAudioLevelControlPropertyDecibelValue: AudioObjectPropertySelector = 0x6c636476;
pub const kAudioLevelControlPropertyDecibelRange: AudioObjectPropertySelector = 0x6c636472;
pub const kAudioLevelControlPropertyConvertScalarToDecibels: AudioObjectPropertySelector =
    0x6c637364;
pub const kAudioLevelControlPropertyConvertDecibelsToScalar: AudioObjectPropertySelector =
    0x6c636473;

pub const kAudioBooleanControlClassID: AudioClassID = 0x746f676c;
pub const kAudioMuteControlClassID: AudioClassID = 0x6d757465;
pub const kAudioSoloControlClassID: AudioClassID = 0x736f6c6f;
pub const kAudioJackControlClassID: AudioClassID = 0x6a61636b;
pub const kAudioLFEMuteControlClassID: AudioClassID = 0x7375626d;
pub const kAudioPhantomPowerControlClassID: AudioClassID = 0x7068616e;
pub const kAudioPhaseInvertControlClassID: AudioClassID = 0x70687369;
pub const kAudioClipLightControlClassID: AudioClassID = 0x636c6970;
pub const kAudioTalkbackControlClassID: AudioClassID = 0x74616c62;
pub const kAudioListenbackControlClassID: AudioClassID = 0x6c736e62;

pub const kAudioBooleanControlPropertyValue: AudioObjectPropertySelector = 0x6263766c;

pub const kAudioSelectorControlClassID: AudioClassID = 0x736c6374;
pub const kAudioDataSourceControlClassID: AudioClassID = 0x64737263;
pub const kAudioDataDestinationControlClassID: AudioClassID = 0x64657374;
pub const kAudioClockSourceControlClassID: AudioClassID = 0x636c636b;
pub const kAudioLineLevelControlClassID: AudioClassID = 0x6e6c766c;
pub const kAudioHighPassFilterControlClassID: AudioClassID = 0x68697066;

pub const kAudioSelectorControlPropertyCurrentItem: AudioObjectPropertySelector = 0x73636369;
pub const kAudioSelectorControlPropertyAvailableItems: AudioObjectPropertySelector = 0x73636169;
pub const kAudioSelectorControlPropertyItemName: AudioObjectPropertySelector = 0x7363696e;
pub const kAudioSelectorControlPropertyItemKind: AudioObjectPropertySelector = 0x636c6b6b;

pub const kAudioSelectorControlItemKindSpacer: u32 = 0x73706372;

pub const kAudioClockSourceItemKindInternal: u32 = 0x696e7420;

pub const kAudioStereoPanControlClassID: AudioClassID = 0x7370616e;

pub const kAudioStereoPanControlPropertyValue: AudioObjectPropertySelector = 0x73706376;
pub const kAudioStereoPanControlPropertyPanningChannels: AudioObjectPropertySelector = 0x73706363;

pub const kAudioObjectSystemObject: c_int = 1;

/// Clients register an AudioObjectPropertyListenerProc with an AudioObject in order
/// to receive notifications when the properties of the object change.
///
/// Listeners will be called when possibly many properties have changed.
/// Consequently, the implementation of a listener must go through the array of
/// addresses to see what exactly has changed. Note that the array of addresses will
/// always have at least one address in it for which the listener is signed up to
/// receive notifications about but may contain addresses for properties for which
/// the listener is not signed up to receive notifications.
///
/// Parameter `inObjectID`: The AudioObject whose properties have changed.
///
/// Parameter `inNumberAddresses`: The number of elements in the inAddresses array.
///
/// Parameter `inAddresses`: An array of AudioObjectPropertyAddresses indicating which properties
/// changed.
///
/// Parameter `inClientData`: A pointer to client data established when the listener proc was registered
/// with the AudioObject.
///
/// Returns: The return value is currently unused and should always be 0.
pub type AudioObjectPropertyListenerProc = Option<
    unsafe extern "C-unwind" fn(
        AudioObjectID,
        u32,
        NonNull<AudioObjectPropertyAddress>,
        *mut c_void,
    ) -> OSStatus,
>;

/// Clients register an AudioObjectPropertyListenerBlock with an AudioObject in
/// order to receive notifications when the properties of the object change.
///
/// Listeners will be called when possibly many properties have changed.
/// Consequently, the implementation of a listener must go through the array of
/// addresses to see what exactly has changed. Note that the array of addresses will
/// always have at least one address in it for which the listener is signed up to
/// receive notifications about but may contain addresses for properties for which
/// the listener is not signed up to receive notifications.
///
/// Parameter `inNumberAddresses`: The number of elements in the inAddresses array.
///
/// Parameter `inAddresses`: An array of AudioObjectPropertyAddresses indicating which properties
/// changed.
#[cfg(feature = "block2")]
pub type AudioObjectPropertyListenerBlock =
    *mut block2::DynBlock<dyn Fn(u32, NonNull<AudioObjectPropertyAddress>)>;

pub const kAudioObjectPropertyCreator: AudioObjectPropertySelector = 0x6f706c67;
pub const kAudioObjectPropertyListenerAdded: AudioObjectPropertySelector = 0x6c697361;
pub const kAudioObjectPropertyListenerRemoved: AudioObjectPropertySelector = 0x6c697372;

extern "C-unwind" {
    /// Prints to standard out a textural description of the AudioObject.
    ///
    /// Parameter `inObjectID`: The AudioObject to show.
    pub fn AudioObjectShow(in_object_id: AudioObjectID);
}

/// Queries an AudioObject about whether or not it has the given property.
///
/// Parameter `inObjectID`: The AudioObject to query.
///
/// Parameter `inAddress`: An AudioObjectPropertyAddress indicating which property is being queried.
///
/// Returns: A Boolean indicating whether or not the AudioObject has the given property.
///
/// # Safety
///
/// `in_address` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn AudioObjectHasProperty(
    in_object_id: AudioObjectID,
    in_address: NonNull<AudioObjectPropertyAddress>,
) -> bool {
    extern "C-unwind" {
        fn AudioObjectHasProperty(
            in_object_id: AudioObjectID,
            in_address: NonNull<AudioObjectPropertyAddress>,
        ) -> Boolean;
    }
    let ret = unsafe { AudioObjectHasProperty(in_object_id, in_address) };
    ret != 0
}

extern "C-unwind" {
    /// Queries an AudioObject about whether or not the given property can be set using
    /// AudioObjectSetPropertyData.
    ///
    /// Parameter `inObjectID`: The AudioObject to query.
    ///
    /// Parameter `inAddress`: An AudioObjectPropertyAddress indicating which property is being queried.
    ///
    /// Parameter `outIsSettable`: A Boolean indicating whether or not the property can be set.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `out_is_settable` must be a valid pointer.
    pub fn AudioObjectIsPropertySettable(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        out_is_settable: NonNull<Boolean>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Queries an AudioObject to find the size of the data for the given property.
    ///
    /// Parameter `inObjectID`: The AudioObject to query.
    ///
    /// Parameter `inAddress`: An AudioObjectPropertyAddress indicating which property is being queried.
    ///
    /// Parameter `inQualifierDataSize`: A UInt32 indicating the size of the buffer pointed to by inQualifierData.
    /// Note that not all properties require qualification, in which case this
    /// value will be 0.
    ///
    /// Parameter `inQualifierData`: A buffer of data to be used in determining the data of the property being
    /// queried. Note that not all properties require qualification, in which case
    /// this value will be NULL.
    ///
    /// Parameter `outDataSize`: A UInt32 indicating how many bytes the data for the given property occupies.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_qualifier_data` must be a valid pointer or null.
    /// - `out_data_size` must be a valid pointer.
    pub fn AudioObjectGetPropertyDataSize(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_qualifier_data_size: u32,
        in_qualifier_data: *const c_void,
        out_data_size: NonNull<u32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Queries an AudioObject to get the data of the given property and places it in
    /// the provided buffer.
    ///
    /// Parameter `inObjectID`: The AudioObject to query.
    ///
    /// Parameter `inAddress`: An AudioObjectPropertyAddress indicating which property is being queried.
    ///
    /// Parameter `inQualifierDataSize`: A UInt32 indicating the size of the buffer pointed to by inQualifierData.
    /// Note that not all properties require qualification, in which case this
    /// value will be 0.
    ///
    /// Parameter `inQualifierData`: A buffer of data to be used in determining the data of the property being
    /// queried. Note that not all properties require qualification, in which case
    /// this value will be NULL.
    ///
    /// Parameter `ioDataSize`: A UInt32 which on entry indicates the size of the buffer pointed to by
    /// outData and on exit indicates how much of the buffer was used.
    ///
    /// Parameter `outData`: The buffer into which the AudioObject will put the data for the given
    /// property.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_qualifier_data` must be a valid pointer or null.
    /// - `io_data_size` must be a valid pointer.
    /// - `out_data` must be a valid pointer.
    pub fn AudioObjectGetPropertyData(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_qualifier_data_size: u32,
        in_qualifier_data: *const c_void,
        io_data_size: NonNull<u32>,
        out_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Tells an AudioObject to change the value of the given property using the
    /// provided data.
    ///
    /// Note that the value of the property should not be considered changed until the
    /// HAL has called the listeners as many properties values are changed
    /// asynchronously.
    ///
    /// Parameter `inObjectID`: The AudioObject to change.
    ///
    /// Parameter `inAddress`: An AudioObjectPropertyAddress indicating which property is being changed.
    ///
    /// Parameter `inQualifierDataSize`: A UInt32 indicating the size of the buffer pointed to by inQualifierData.
    /// Note that not all properties require qualification, in which case this
    /// value will be 0.
    ///
    /// Parameter `inQualifierData`: A buffer of data to be used in determining the data of the property being
    /// queried. Note that not all properties require qualification, in which case
    /// this value will be NULL.
    ///
    /// Parameter `inDataSize`: A UInt32 indicating the size of the buffer pointed to by inData.
    ///
    /// Parameter `inData`: The buffer containing the data to be used to change the property's value.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_qualifier_data` must be a valid pointer or null.
    /// - `in_data` must be a valid pointer.
    pub fn AudioObjectSetPropertyData(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_qualifier_data_size: u32,
        in_qualifier_data: *const c_void,
        in_data_size: u32,
        in_data: NonNull<c_void>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Registers the given AudioObjectPropertyListenerProc to receive notifications
    /// when the given properties change.
    ///
    /// Parameter `inObjectID`: The AudioObject to register the listener with.
    ///
    /// Parameter `inAddress`: The AudioObjectPropertyAddresses indicating which property the listener
    /// should be notified about.
    ///
    /// Parameter `inListener`: The AudioObjectPropertyListenerProc to call.
    ///
    /// Parameter `inClientData`: A pointer to client data that is passed to the listener when it is called.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_listener` must be implemented correctly.
    /// - `in_client_data` must be a valid pointer or null.
    pub fn AudioObjectAddPropertyListener(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_listener: AudioObjectPropertyListenerProc,
        in_client_data: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Unregisters the given AudioObjectPropertyListenerProc from receiving
    /// notifications when the given properties change.
    ///
    /// Parameter `inObjectID`: The AudioObject to unregister the listener from.
    ///
    /// Parameter `inAddress`: The AudioObjectPropertyAddress indicating from which property the listener
    /// should be removed.
    ///
    /// Parameter `inListener`: The AudioObjectPropertyListenerProc being removed.
    ///
    /// Parameter `inClientData`: A pointer to client data that is passed to the listener when it is called.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_listener` must be implemented correctly.
    /// - `in_client_data` must be a valid pointer or null.
    pub fn AudioObjectRemovePropertyListener(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_listener: AudioObjectPropertyListenerProc,
        in_client_data: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Registers the given AudioObjectPropertyListenerBlock to receive notifications
    /// when the given properties change.
    ///
    /// Parameter `inObjectID`: The AudioObject to register the listener with.
    ///
    /// Parameter `inAddress`: The AudioObjectPropertyAddresses indicating which property the listener
    /// should be notified about.
    ///
    /// Parameter `inDispatchQueue`: The dispatch queue on which the listener block will be dispatched. All
    /// listener blocks will be dispatched asynchronously save for those dispatched
    /// from the IO context (of which kAudioDevicePropertyDeviceIsRunning and
    /// kAudioDeviceProcessorOverload are the only examples) which will be
    /// dispatched synchronously. Note that this dispatch queue will be retained
    /// until a matching call to AudioObjectRemovePropertyListenerBlock is made. If
    /// this value is NULL, then the block will be directly invoked.
    ///
    /// Parameter `inListener`: The AudioObjectPropertyListenerBlock to call. Note that this block will be
    /// Block_copy'd and the reference maintained until a matching call to
    /// AudioObjectRemovePropertyListenerBlock is made.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_dispatch_queue` possibly has additional threading requirements.
    /// - `in_listener` must be a valid pointer.
    #[cfg(all(feature = "block2", feature = "dispatch2"))]
    pub fn AudioObjectAddPropertyListenerBlock(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_dispatch_queue: Option<&DispatchQueue>,
        in_listener: AudioObjectPropertyListenerBlock,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Unregisters the given AudioObjectPropertyListenerBlock from receiving
    /// notifications when the given properties change.
    ///
    /// Parameter `inObjectID`: The AudioObject to unregister the listener from.
    ///
    /// Parameter `inAddress`: The AudioObjectPropertyAddress indicating from which property the listener
    /// should be removed.
    ///
    /// Parameter `inDispatchQueue`: The dispatch queue on which the listener block was being dispatched to.
    ///
    /// Parameter `inListener`: The AudioObjectPropertyListenerBlock being removed.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_address` must be a valid pointer.
    /// - `in_dispatch_queue` possibly has additional threading requirements.
    /// - `in_listener` must be a valid pointer.
    #[cfg(all(feature = "block2", feature = "dispatch2"))]
    pub fn AudioObjectRemovePropertyListenerBlock(
        in_object_id: AudioObjectID,
        in_address: NonNull<AudioObjectPropertyAddress>,
        in_dispatch_queue: Option<&DispatchQueue>,
        in_listener: AudioObjectPropertyListenerBlock,
    ) -> OSStatus;
}

pub const kAudioSystemObjectClassID: AudioClassID = 0x61737973;

/// The values for kAudioHardwarePropertyPowerHint
///
/// The system object property, kAudioHardwarePropertyPowerHint, allows a process to
/// to indicate how aggressive the system can be with optimizations that save power.
/// Note that the value of this property can be set in an application's info.plist
/// using the key, "AudioHardwarePowerHint". The values for this key are the strings
/// that correspond to the values in the enum.
///
/// This is the default value and it indicates that the system will not make any
/// power optimizations that compromise latency or quality in order to save
/// power. The info.plist value is "None" or the "AudioHardwarePowerHint" entry
/// can be omitted entirely.
///
/// The system will choose to save power even at the expense of latency. The
/// info.plist value is "Favor Saving Power"
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AudioHardwarePowerHint(pub u32);
impl AudioHardwarePowerHint {
    #[doc(alias = "kAudioHardwarePowerHintNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "kAudioHardwarePowerHintFavorSavingPower")]
    pub const FavorSavingPower: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for AudioHardwarePowerHint {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AudioHardwarePowerHint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioHardwarePropertyDevices: AudioObjectPropertySelector = 0x64657623;
pub const kAudioHardwarePropertyDefaultInputDevice: AudioObjectPropertySelector = 0x64496e20;
pub const kAudioHardwarePropertyDefaultOutputDevice: AudioObjectPropertySelector = 0x644f7574;
pub const kAudioHardwarePropertyDefaultSystemOutputDevice: AudioObjectPropertySelector = 0x734f7574;
pub const kAudioHardwarePropertyTranslateUIDToDevice: AudioObjectPropertySelector = 0x75696464;
pub const kAudioHardwarePropertyMixStereoToMono: AudioObjectPropertySelector = 0x73746d6f;
pub const kAudioHardwarePropertyPlugInList: AudioObjectPropertySelector = 0x706c6723;
pub const kAudioHardwarePropertyTranslateBundleIDToPlugIn: AudioObjectPropertySelector = 0x62696470;
pub const kAudioHardwarePropertyTransportManagerList: AudioObjectPropertySelector = 0x746d6723;
pub const kAudioHardwarePropertyTranslateBundleIDToTransportManager: AudioObjectPropertySelector =
    0x746d6269;
pub const kAudioHardwarePropertyBoxList: AudioObjectPropertySelector = 0x626f7823;
pub const kAudioHardwarePropertyTranslateUIDToBox: AudioObjectPropertySelector = 0x75696462;
pub const kAudioHardwarePropertyClockDeviceList: AudioObjectPropertySelector = 0x636c6b23;
pub const kAudioHardwarePropertyTranslateUIDToClockDevice: AudioObjectPropertySelector = 0x75696463;
pub const kAudioHardwarePropertyProcessIsMain: AudioObjectPropertySelector = 0x6d61696e;
pub const kAudioHardwarePropertyIsInitingOrExiting: AudioObjectPropertySelector = 0x696e6f74;
pub const kAudioHardwarePropertyUserIDChanged: AudioObjectPropertySelector = 0x65756964;
pub const kAudioHardwarePropertyProcessInputMute: AudioObjectPropertySelector = 0x706d696e;
pub const kAudioHardwarePropertyProcessIsAudible: AudioObjectPropertySelector = 0x706d7574;
pub const kAudioHardwarePropertySleepingIsAllowed: AudioObjectPropertySelector = 0x736c6570;
pub const kAudioHardwarePropertyUnloadingIsAllowed: AudioObjectPropertySelector = 0x756e6c64;
pub const kAudioHardwarePropertyHogModeIsAllowed: AudioObjectPropertySelector = 0x686f6772;
pub const kAudioHardwarePropertyUserSessionIsActiveOrHeadless: AudioObjectPropertySelector =
    0x75736572;
pub const kAudioHardwarePropertyServiceRestarted: AudioObjectPropertySelector = 0x73727374;
pub const kAudioHardwarePropertyPowerHint: AudioObjectPropertySelector = 0x706f7768;
pub const kAudioHardwarePropertyProcessObjectList: AudioObjectPropertySelector = 0x70727323;
pub const kAudioHardwarePropertyTranslatePIDToProcessObject: AudioObjectPropertySelector =
    0x69643270;
pub const kAudioHardwarePropertyTapList: AudioObjectPropertySelector = 0x74707323;
pub const kAudioHardwarePropertyTranslateUIDToTap: AudioObjectPropertySelector = 0x75696474;

extern "C-unwind" {
    /// When this routine is called, all IO on all devices within a process will be
    /// terminated and all resources capable of being released will be released. This
    /// routine essentially returns the HAL to its uninitialized state.
    ///
    /// Returns: An OSStatus indicating success or failure.
    pub fn AudioHardwareUnload() -> OSStatus;
}

extern "C-unwind" {
    /// This routine creates a new AudioAggregateDevice using the provided description.
    ///
    /// Parameter `inDescription`: The CFDictionary that specifies how to build the AudioAggregateDevice. The
    /// supported keys are described in the AudioAggregateDevice Constants section.
    ///
    /// Parameter `outDeviceID`: The AudioObjectID of the newly created AudioAggregateDevice.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_description` generic must be of the correct type.
    /// - `in_description` generic must be of the correct type.
    /// - `out_device_id` must be a valid pointer.
    pub fn AudioHardwareCreateAggregateDevice(
        in_description: &CFDictionary,
        out_device_id: NonNull<AudioObjectID>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// This routine destroys the given AudioAggregateDevice.
    ///
    /// The actual destruction of the device is asynchronous and may take place after
    /// the call to this routine has returned.
    ///
    /// Parameter `inDeviceID`: The AudioObjectID of the AudioAggregateDevice to destroy.
    ///
    /// Returns: An OSStatus indicating success or failure.
    pub fn AudioHardwareDestroyAggregateDevice(in_device_id: AudioObjectID) -> OSStatus;
}

pub const kAudioPlugInCreateAggregateDevice: AudioObjectPropertySelector = 0x63616767;
pub const kAudioPlugInDestroyAggregateDevice: AudioObjectPropertySelector = 0x64616767;

pub const kAudioTransportManagerCreateEndPointDevice: AudioObjectPropertySelector = 0x63646576;
pub const kAudioTransportManagerDestroyEndPointDevice: AudioObjectPropertySelector = 0x64646576;

/// An AudioDeviceIOProc is called by an AudioDevice to provide input data read from
/// the device and collect output data to be written to the device for the current
/// IO cycle.
///
/// Parameter `inDevice`: The AudioDevice doing the IO.
///
/// Parameter `inNow`: An AudioTimeStamp that indicates the IO cycle started. Note that this time
/// includes any scheduling latency that may have been incurred waking the
/// thread on which IO is being done.
///
/// Parameter `inInputData`: An AudioBufferList containing the input data for the current IO cycle. For
/// streams that are disabled, the AudioBuffer's mData field will be NULL but
/// the mDataByteSize field will still say how much data would have been there
/// if it was enabled. Note that the contents of this structure should never be
/// modified.
///
/// Parameter `inInputTime`: An AudioTimeStamp that indicates the time at which the first frame in the
/// data was acquired from the hardware. If the device has no input streams, the
/// time stamp will be zeroed out.
///
/// Parameter `outOutputData`: An AudioBufferList in which the output data for the current IO cycle is to
/// be placed. On entry, each AudioBuffer's mDataByteSize field indicates the
/// maximum amount of data that can be placed in the buffer and the buffer's
/// memory has been zeroed out. For formats where the number of bytes per packet
/// can vary (as with AC-3, for example), the client has to fill out on exit
/// each mDataByteSize field in each AudioBuffer with the amount of data that
/// was put in the buffer. Otherwise, the mDataByteSize field should not be
/// changed. For streams that are disabled, the AudioBuffer's mData field will
/// be NULL but the mDataByteSize field will still say how much data would have
/// been there if it was enabled. Except as noted above, the contents of this
/// structure should not other wise be modified.
///
/// Parameter `inOutputTime`: An AudioTimeStamp that indicates the time at which the first frame in the
/// data will be passed to the hardware. If the device has no output streams,
/// the time stamp will be zeroed out.
///
/// Parameter `inClientData`: A pointer to client data established when the AudioDeviceIOProc was
/// registered with the AudioDevice.
///
/// Returns: The return value is currently unused and should always be 0.
#[cfg(feature = "objc2-core-audio-types")]
pub type AudioDeviceIOProc = Option<
    unsafe extern "C-unwind" fn(
        AudioObjectID,
        NonNull<AudioTimeStamp>,
        NonNull<AudioBufferList>,
        NonNull<AudioTimeStamp>,
        NonNull<AudioBufferList>,
        NonNull<AudioTimeStamp>,
        *mut c_void,
    ) -> OSStatus,
>;

/// An AudioDeviceIOBlock is called by an AudioDevice to provide input data read
/// from the device and collect output data to be written to the device for the
/// current IO cycle.
///
/// Parameter `inNow`: An AudioTimeStamp that indicates the IO cycle started. Note that this time
/// includes any scheduling latency that may have been incurred waking the
/// thread on which IO is being done.
///
/// Parameter `inInputData`: An AudioBufferList containing the input data for the current IO cycle. For
/// streams that are disabled, the AudioBuffer's mData field will be NULL but
/// the mDataByteSize field will still say how much data would have been there
/// if it was enabled. Note that the contents of this structure should never be
/// modified.
///
/// Parameter `inInputTime`: An AudioTimeStamp that indicates the time at which the first frame in the
/// data was acquired from the hardware. If the device has no input streams, the
/// time stamp will be zeroed out.
///
/// Parameter `outOutputData`: An AudioBufferList in which the output data for the current IO cycle is to
/// be placed. On entry, each AudioBuffer's mDataByteSize field indicates the
/// maximum amount of data that can be placed in the buffer and the buffer's
/// memory has been zeroed out. For formats where the number of bytes per packet
/// can vary (as with AC-3, for example), the client has to fill out on exit
/// each mDataByteSize field in each AudioBuffer with the amount of data that
/// was put in the buffer. Otherwise, the mDataByteSize field should not be
/// changed. For streams that are disabled, the AudioBuffer's mData field will
/// be NULL but the mDataByteSize field will still say how much data would have
/// been there if it was enabled. Except as noted above, the contents of this
/// structure should not other wise be modified.
///
/// Parameter `inOutputTime`: An AudioTimeStamp that indicates the time at which the first frame in the
/// data will be passed to the hardware. If the device has no output streams,
/// the time stamp will be zeroed out.
#[cfg(all(feature = "block2", feature = "objc2-core-audio-types"))]
pub type AudioDeviceIOBlock = *mut block2::DynBlock<
    dyn Fn(
        NonNull<AudioTimeStamp>,
        NonNull<AudioBufferList>,
        NonNull<AudioTimeStamp>,
        NonNull<AudioBufferList>,
        NonNull<AudioTimeStamp>,
    ),
>;

/// An AudioDeviceIOProcID represents both an IOProc and the client data that goes
/// with it. Once created, an AudioDeviceIOProcID can be used everywhere one would
/// use a regular IOProc. The purpose for an AudioDeviceIOProcID is to allow a
/// client to register the same function pointer as an IOProc with a device multiple
/// times provided
#[cfg(feature = "objc2-core-audio-types")]
pub type AudioDeviceIOProcID = AudioDeviceIOProc;

/// This structure describes which streams a given AudioDeviceIOProc will use. It is
/// used in conjunction with kAudioDevicePropertyIOProcStreamUsage.
/// Field: mIOProc
/// The IOProc whose stream usage is being specified.
/// Field: mNumberStreams
/// The number of streams being specified.
/// Field: mStreamIsOn
/// An array of UInt32's whose length is specified by mNumberStreams. Each
/// element of the array corresponds to a stream. A value of 0 means the stream
/// is not to be enabled. Any other value means the stream is to be used.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AudioHardwareIOProcStreamUsage {
    pub mIOProc: NonNull<c_void>,
    pub mNumberStreams: u32,
    pub mStreamIsOn: [u32; 1],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for AudioHardwareIOProcStreamUsage {
    const ENCODING: Encoding = Encoding::Struct(
        "AudioHardwareIOProcStreamUsage",
        &[
            <NonNull<c_void>>::ENCODING,
            <u32>::ENCODING,
            <[u32; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AudioHardwareIOProcStreamUsage {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kAudioDeviceStartTimeIsInputFlag: u32 = 1 << 0;
pub const kAudioDeviceStartTimeDontConsultDeviceFlag: u32 = 1 << 1;
pub const kAudioDeviceStartTimeDontConsultHALFlag: u32 = 1 << 2;

pub const kAudioDevicePropertyPlugIn: AudioObjectPropertySelector = 0x706c7567;
pub const kAudioDevicePropertyDeviceHasChanged: AudioObjectPropertySelector = 0x64696666;
pub const kAudioDevicePropertyDeviceIsRunningSomewhere: AudioObjectPropertySelector = 0x676f6e65;
pub const kAudioDeviceProcessorOverload: AudioObjectPropertySelector = 0x6f766572;
pub const kAudioDevicePropertyIOStoppedAbnormally: AudioObjectPropertySelector = 0x73747064;
pub const kAudioDevicePropertyHogMode: AudioObjectPropertySelector = 0x6f696e6b;
pub const kAudioDevicePropertyBufferFrameSize: AudioObjectPropertySelector = 0x6673697a;
pub const kAudioDevicePropertyBufferFrameSizeRange: AudioObjectPropertySelector = 0x66737a23;
pub const kAudioDevicePropertyUsesVariableBufferFrameSizes: AudioObjectPropertySelector =
    0x7666737a;
pub const kAudioDevicePropertyIOCycleUsage: AudioObjectPropertySelector = 0x6e637963;
pub const kAudioDevicePropertyStreamConfiguration: AudioObjectPropertySelector = 0x736c6179;
pub const kAudioDevicePropertyIOProcStreamUsage: AudioObjectPropertySelector = 0x73757365;
pub const kAudioDevicePropertyActualSampleRate: AudioObjectPropertySelector = 0x61737274;
pub const kAudioDevicePropertyClockDevice: AudioObjectPropertySelector = 0x61706364;
/// The devices workgroup object, which you use to coordinate your threads with the threads of the device.
pub const kAudioDevicePropertyIOThreadOSWorkgroup: AudioObjectPropertySelector = 0x6f737767;
pub const kAudioDevicePropertyProcessMute: AudioObjectPropertySelector = 0x6170706d;

pub const kAudioDevicePropertyJackIsConnected: AudioObjectPropertySelector = 0x6a61636b;
pub const kAudioDevicePropertyVolumeScalar: AudioObjectPropertySelector = 0x766f6c6d;
pub const kAudioDevicePropertyVolumeDecibels: AudioObjectPropertySelector = 0x766f6c64;
pub const kAudioDevicePropertyVolumeRangeDecibels: AudioObjectPropertySelector = 0x76646223;
pub const kAudioDevicePropertyVolumeScalarToDecibels: AudioObjectPropertySelector = 0x76326462;
pub const kAudioDevicePropertyVolumeDecibelsToScalar: AudioObjectPropertySelector = 0x64623276;
pub const kAudioDevicePropertyStereoPan: AudioObjectPropertySelector = 0x7370616e;
pub const kAudioDevicePropertyStereoPanChannels: AudioObjectPropertySelector = 0x73706e23;
pub const kAudioDevicePropertyMute: AudioObjectPropertySelector = 0x6d757465;
pub const kAudioDevicePropertySolo: AudioObjectPropertySelector = 0x736f6c6f;
pub const kAudioDevicePropertyPhantomPower: AudioObjectPropertySelector = 0x7068616e;
pub const kAudioDevicePropertyPhaseInvert: AudioObjectPropertySelector = 0x70687369;
pub const kAudioDevicePropertyClipLight: AudioObjectPropertySelector = 0x636c6970;
pub const kAudioDevicePropertyTalkback: AudioObjectPropertySelector = 0x74616c62;
pub const kAudioDevicePropertyListenback: AudioObjectPropertySelector = 0x6c736e62;
pub const kAudioDevicePropertyDataSource: AudioObjectPropertySelector = 0x73737263;
pub const kAudioDevicePropertyDataSources: AudioObjectPropertySelector = 0x73736323;
pub const kAudioDevicePropertyDataSourceNameForIDCFString: AudioObjectPropertySelector = 0x6c73636e;
pub const kAudioDevicePropertyDataSourceKindForID: AudioObjectPropertySelector = 0x7373636b;
pub const kAudioDevicePropertyClockSource: AudioObjectPropertySelector = 0x63737263;
pub const kAudioDevicePropertyClockSources: AudioObjectPropertySelector = 0x63736323;
pub const kAudioDevicePropertyClockSourceNameForIDCFString: AudioObjectPropertySelector =
    0x6c63736e;
pub const kAudioDevicePropertyClockSourceKindForID: AudioObjectPropertySelector = 0x6373636b;
pub const kAudioDevicePropertyPlayThru: AudioObjectPropertySelector = 0x74687275;
pub const kAudioDevicePropertyPlayThruSolo: AudioObjectPropertySelector = 0x74687273;
pub const kAudioDevicePropertyPlayThruVolumeScalar: AudioObjectPropertySelector = 0x6d767363;
pub const kAudioDevicePropertyPlayThruVolumeDecibels: AudioObjectPropertySelector = 0x6d766462;
pub const kAudioDevicePropertyPlayThruVolumeRangeDecibels: AudioObjectPropertySelector = 0x6d766423;
pub const kAudioDevicePropertyPlayThruVolumeScalarToDecibels: AudioObjectPropertySelector =
    0x6d763264;
pub const kAudioDevicePropertyPlayThruVolumeDecibelsToScalar: AudioObjectPropertySelector =
    0x6d763273;
pub const kAudioDevicePropertyPlayThruStereoPan: AudioObjectPropertySelector = 0x6d73706e;
pub const kAudioDevicePropertyPlayThruStereoPanChannels: AudioObjectPropertySelector = 0x6d737023;
pub const kAudioDevicePropertyPlayThruDestination: AudioObjectPropertySelector = 0x6d646473;
pub const kAudioDevicePropertyPlayThruDestinations: AudioObjectPropertySelector = 0x6d646423;
pub const kAudioDevicePropertyPlayThruDestinationNameForIDCFString: AudioObjectPropertySelector =
    0x6d646463;
pub const kAudioDevicePropertyChannelNominalLineLevel: AudioObjectPropertySelector = 0x6e6c766c;
pub const kAudioDevicePropertyChannelNominalLineLevels: AudioObjectPropertySelector = 0x6e6c7623;
pub const kAudioDevicePropertyChannelNominalLineLevelNameForIDCFString:
    AudioObjectPropertySelector = 0x6c636e6c;
pub const kAudioDevicePropertyHighPassFilterSetting: AudioObjectPropertySelector = 0x68697066;
pub const kAudioDevicePropertyHighPassFilterSettings: AudioObjectPropertySelector = 0x68697023;
pub const kAudioDevicePropertyHighPassFilterSettingNameForIDCFString: AudioObjectPropertySelector =
    0x6869706c;
pub const kAudioDevicePropertySubVolumeScalar: AudioObjectPropertySelector = 0x73766c6d;
pub const kAudioDevicePropertySubVolumeDecibels: AudioObjectPropertySelector = 0x73766c64;
pub const kAudioDevicePropertySubVolumeRangeDecibels: AudioObjectPropertySelector = 0x73766423;
pub const kAudioDevicePropertySubVolumeScalarToDecibels: AudioObjectPropertySelector = 0x73763264;
pub const kAudioDevicePropertySubVolumeDecibelsToScalar: AudioObjectPropertySelector = 0x73643276;
pub const kAudioDevicePropertySubMute: AudioObjectPropertySelector = 0x736d7574;
pub const kAudioDevicePropertyVoiceActivityDetectionEnable: AudioObjectPropertySelector =
    0x7641642b;
pub const kAudioDevicePropertyVoiceActivityDetectionState: AudioObjectPropertySelector = 0x76416453;
pub const kAudioDevicePropertyWantsControlsRestored: AudioObjectPropertySelector = 0x72657363;
pub const kAudioDevicePropertyWantsStreamFormatsRestored: AudioObjectPropertySelector = 0x72657366;

extern "C-unwind" {
    /// Creates an AudioDeviceIOProcID from an AudioDeviceIOProc and a client data
    /// pointer.
    ///
    /// AudioDeviceIOProcIDs allow for the client to register the same function pointer
    /// with a device multiple times
    ///
    /// Parameter `inDevice`: The AudioDevice to register the IOProc with.
    ///
    /// Parameter `inProc`: The AudioDeviceIOProc to register.
    ///
    /// Parameter `inClientData`: A pointer to client data that is passed back to the IOProc when it is
    /// called.
    ///
    /// Parameter `outIOProcID`: The newly created AudioDeviceIOProcID.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_proc` must be implemented correctly.
    /// - `in_client_data` must be a valid pointer or null.
    /// - `out_io_proc_id` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceCreateIOProcID(
        in_device: AudioObjectID,
        in_proc: AudioDeviceIOProc,
        in_client_data: *mut c_void,
        out_io_proc_id: NonNull<AudioDeviceIOProcID>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates an AudioDeviceIOProcID from an AudioDeviceIOBlock
    ///
    /// Parameter `outIOProcID`: The newly created AudioDeviceIOProcID.
    ///
    /// Parameter `inDevice`: The AudioDevice to register the Block with.
    ///
    /// Parameter `inDispatchQueue`: The dispatch queue on which the IOBlock will be dispatched. All
    /// IOBlocks are dispatched synchronously. Note that this dispatch queue will be
    /// retained until a matching call to AudioDeviceDestroyIOProcID is made. If
    /// this value is NULL, then the IOBlock will be directly invoked.
    ///
    /// Parameter `inIOBlock`: The AudioDeviceIOBlock to register.  Note that this block will be
    /// Block_copy'd and the reference maintained until a matching call to
    /// AudioDeviceDestroyIOProcID is made.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `out_io_proc_id` must be a valid pointer.
    /// - `in_dispatch_queue` possibly has additional threading requirements.
    /// - `in_io_block` must be a valid pointer.
    #[cfg(all(
        feature = "block2",
        feature = "dispatch2",
        feature = "objc2-core-audio-types"
    ))]
    pub fn AudioDeviceCreateIOProcIDWithBlock(
        out_io_proc_id: NonNull<AudioDeviceIOProcID>,
        in_device: AudioObjectID,
        in_dispatch_queue: Option<&DispatchQueue>,
        in_io_block: AudioDeviceIOBlock,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Destroys an AudioDeviceIOProcID.
    ///
    /// AudioDeviceIOProcIDs allow for the client to register the same function pointer
    /// with a device multiple times
    ///
    /// Parameter `inDevice`: The AudioDevice from which the ID came.
    ///
    /// Parameter `inIOProcID`: The AudioDeviceIOProcID to get rid of.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// `in_io_proc_id` must be implemented correctly.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceDestroyIOProcID(
        in_device: AudioObjectID,
        in_io_proc_id: AudioDeviceIOProcID,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Starts IO for the given AudioDeviceIOProcID.
    ///
    /// Parameter `inDevice`: The AudioDevice to start the IOProc on.
    ///
    /// Parameter `inProcID`: The AudioDeviceIOProcID to start. Note that this can be NULL, which starts
    /// the hardware regardless of whether or not there are any IOProcs registered.
    /// This is necessary if any of the AudioDevice's timing services are to be
    /// used. A balancing call to AudioDeviceStop with a NULL IOProc is required to
    /// stop the hardware.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// `in_proc_id` must be implemented correctly.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceStart(in_device: AudioObjectID, in_proc_id: AudioDeviceIOProcID) -> OSStatus;
}

extern "C-unwind" {
    /// Starts IO for the given AudioDeviceIOProcID and aligns the IO cycle of the
    /// AudioDevice with the given time.
    ///
    /// Parameter `inDevice`: The AudioDevice to start the IOProc on.
    ///
    /// Parameter `inProcID`: The AudioDeviceIOProcID to start. Note that this can be NULL, which starts
    /// the hardware regardless of whether or not there are any IOProcs registered.
    ///
    /// Parameter `ioRequestedStartTime`: A pointer to an AudioTimeStamp that, on entry, is the requested time to
    /// start the IOProc. On exit, it will be the actual time the IOProc will start.
    ///
    /// Parameter `inFlags`: A UInt32 containing flags that modify how this function behaves.
    ///
    /// Returns: An OSStatus indicating success or failure.
    /// kAudioHardwareUnsupportedOperationError will be returned if the AudioDevice does
    /// not support starting at a specific time and inProc and ioRequestedStartTime are
    /// not NULL.
    ///
    /// # Safety
    ///
    /// - `in_proc_id` must be implemented correctly.
    /// - `io_requested_start_time` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceStartAtTime(
        in_device: AudioObjectID,
        in_proc_id: AudioDeviceIOProcID,
        io_requested_start_time: NonNull<AudioTimeStamp>,
        in_flags: u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Stops IO for the given AudioDeviceIOProcID.
    ///
    /// Parameter `inDevice`: The AudioDevice to stop the IOProc on.
    ///
    /// Parameter `inProcID`: The AudioDeviceIOProcID to stop.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// `in_proc_id` must be implemented correctly.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceStop(in_device: AudioObjectID, in_proc_id: AudioDeviceIOProcID) -> OSStatus;
}

extern "C-unwind" {
    /// Retrieves the current time from an AudioDevice. Note that the device has to be
    /// running.
    ///
    /// Parameter `inDevice`: The AudioDevice to from which to get the time.
    ///
    /// Parameter `outTime`: An AudioTimeStamp into which the current time is put. On entry, the
    /// mFlags field specifies which representations to provide. Because not every
    /// device supports all time representations, on exit, the mFlags field will
    /// indicate what values are actually valid.
    ///
    /// Returns: An OSStatus indicating success or failure. kAudioHardwareNotRunningError will be
    /// returned if the AudioDevice isn't running.
    ///
    /// # Safety
    ///
    /// `out_time` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceGetCurrentTime(
        in_device: AudioObjectID,
        out_time: NonNull<AudioTimeStamp>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Translates the time in the AudioDevice's time base from one representation to
    /// another. Note that the device has to be running
    ///
    /// Parameter `inDevice`: The AudioDevice whose time base governs the translation.
    ///
    /// Parameter `inTime`: An AudioTimeStamp containing the time to be translated.
    ///
    /// Parameter `outTime`: An AudioTimeStamp into which the translated time is put. On entry, the
    /// mFlags field specifies which representations to translate the input time
    /// into. Because not every device supports all time representations, on exit,
    /// the mFlags field will indicate which translations were actually done.
    ///
    /// Returns: An OSStatus indicating success or failure. kAudioHardwareNotRunningError will be
    /// returned if the AudioDevice isn't running.
    ///
    /// # Safety
    ///
    /// - `in_time` must be a valid pointer.
    /// - `out_time` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceTranslateTime(
        in_device: AudioObjectID,
        in_time: NonNull<AudioTimeStamp>,
        out_time: NonNull<AudioTimeStamp>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Query an AudioDevice to get a time equal to or later than the given time that is
    /// the best time to start IO.
    ///
    /// The time that is returned is dictated by the constraints of the device and the
    /// system. For instance, the driver of a device that provides both audio and video
    /// data may only allow start times that coincide with the edge of a video frame.
    /// Also, if the device already has one or more active IOProcs, the start time will
    /// be shifted to the beginning of the next IO cycle so as not to cause
    /// discontinuities in the existing IOProcs. Another reason the start time may shift
    /// is to allow for aligning the buffer accesses in an optimal fashion. Note that
    /// the device must be running to use this function.
    ///
    /// Parameter `inDevice`: The AudioDevice to query.
    ///
    /// Parameter `ioRequestedStartTime`: A pointer to an AudioTimeStamp that, on entry, is the requested start time.
    /// On exit, it will have the a time equal to or later than the requested time,
    /// as dictated by the device's constraints.
    ///
    /// Parameter `inFlags`: A UInt32 containing flags that modify how this function behaves.
    ///
    /// Returns: An OSStatus indicating success or failure. kAudioHardwareNotRunningError will be
    /// returned if the AudioDevice isn't running.
    /// kAudioHardwareUnsupportedOperationError will be returned if the AudioDevice does
    /// not support starting at a specific time.
    ///
    /// # Safety
    ///
    /// `io_requested_start_time` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn AudioDeviceGetNearestStartTime(
        in_device: AudioObjectID,
        io_requested_start_time: NonNull<AudioTimeStamp>,
        in_flags: u32,
    ) -> OSStatus;
}

pub const kAudioAggregateDeviceClassID: AudioClassID = 0x61616767;

pub const kAudioAggregateDevicePropertyFullSubDeviceList: AudioObjectPropertySelector = 0x67727570;
pub const kAudioAggregateDevicePropertyActiveSubDeviceList: AudioObjectPropertySelector =
    0x61677270;
pub const kAudioAggregateDevicePropertyComposition: AudioObjectPropertySelector = 0x61636f6d;
pub const kAudioAggregateDevicePropertyMainSubDevice: AudioObjectPropertySelector = 0x616d7374;
pub const kAudioAggregateDevicePropertyClockDevice: AudioObjectPropertySelector = 0x61706364;
pub const kAudioAggregateDevicePropertyTapList: AudioObjectPropertySelector = 0x74617023;
pub const kAudioAggregateDevicePropertySubTapList: AudioObjectPropertySelector = 0x61746170;

pub const kAudioAggregateDriftCompensationMinQuality: u32 = 0;
pub const kAudioAggregateDriftCompensationLowQuality: u32 = 0x20;
pub const kAudioAggregateDriftCompensationMediumQuality: u32 = 0x40;
pub const kAudioAggregateDriftCompensationHighQuality: u32 = 0x60;
pub const kAudioAggregateDriftCompensationMaxQuality: u32 = 0x7F;

pub const kAudioSubDeviceClassID: AudioClassID = 0x61737562;

#[deprecated]
pub const kAudioSubDeviceDriftCompensationMinQuality: u32 = 0;
#[deprecated]
pub const kAudioSubDeviceDriftCompensationLowQuality: u32 = 0x20;
#[deprecated]
pub const kAudioSubDeviceDriftCompensationMediumQuality: u32 = 0x40;
#[deprecated]
pub const kAudioSubDeviceDriftCompensationHighQuality: u32 = 0x60;
#[deprecated]
pub const kAudioSubDeviceDriftCompensationMaxQuality: u32 = 0x7F;

pub const kAudioSubDevicePropertyExtraLatency: AudioObjectPropertySelector = 0x786c7463;
pub const kAudioSubDevicePropertyDriftCompensation: AudioObjectPropertySelector = 0x64726674;
pub const kAudioSubDevicePropertyDriftCompensationQuality: AudioObjectPropertySelector = 0x64726671;

pub const kAudioSubTapClassID: AudioClassID = 0x73746170;

pub const kAudioSubTapPropertyExtraLatency: AudioObjectPropertySelector = 0x786c7463;
pub const kAudioSubTapPropertyDriftCompensation: AudioObjectPropertySelector = 0x64726674;
pub const kAudioSubTapPropertyDriftCompensationQuality: AudioObjectPropertySelector = 0x64726671;

pub const kAudioProcessClassID: AudioClassID = 0x636c6e74;

pub const kAudioProcessPropertyPID: AudioObjectPropertySelector = 0x70706964;
pub const kAudioProcessPropertyBundleID: AudioObjectPropertySelector = 0x70626964;
pub const kAudioProcessPropertyDevices: AudioObjectPropertySelector = 0x70647623;
pub const kAudioProcessPropertyIsRunning: AudioObjectPropertySelector = 0x7069723f;
pub const kAudioProcessPropertyIsRunningInput: AudioObjectPropertySelector = 0x70697269;
pub const kAudioProcessPropertyIsRunningOutput: AudioObjectPropertySelector = 0x7069726f;

pub const kAudioTapClassID: AudioClassID = 0x74636c73;

pub const kAudioTapPropertyUID: AudioObjectPropertySelector = 0x74756964;
pub const kAudioTapPropertyDescription: AudioObjectPropertySelector = 0x74647363;
pub const kAudioTapPropertyFormat: AudioObjectPropertySelector = 0x74666d74;

extern "C-unwind" {
    /// This routine creates a new Tap using the provided description.
    ///
    /// Parameter `inDescription`: The CATapDescription that specifies how to build the Tap.
    ///
    /// Parameter `outTapID`: The AudioObjectID of the newly created Tap.
    ///
    /// Returns: An OSStatus indicating success or failure.
    ///
    /// # Safety
    ///
    /// - `in_description` might not allow `None`.
    /// - `out_tap_id` must be a valid pointer.
    #[cfg(feature = "objc2")]
    pub fn AudioHardwareCreateProcessTap(
        in_description: Option<&CATapDescription>,
        out_tap_id: *mut AudioObjectID,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// This routine destroys the given Tap.
    ///
    /// Parameter `inTapID`: The AudioObjectID of the Tap to destroy.
    ///
    /// Returns: An OSStatus indicating success or failure.
    pub fn AudioHardwareDestroyProcessTap(in_tap_id: AudioObjectID) -> OSStatus;
}

/// CATapMuteBehavior describes the playback behavior of the process being tapped. The default value is CATapUnmuted.
///
/// Audio is captured by the tap and also sent to the audio hardware
///
/// Audio is captured by the tap but no audio is sent from the process to the audio hardware
///
/// Audio is captured by the tap and also sent to the audio hardware until the tap is read by another audio client.
/// For the duration of the read activity on the tap no audio is sent to the audio hardware.
// NS_ENUM
#[cfg(feature = "objc2")]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CATapMuteBehavior(pub NSInteger);
#[cfg(feature = "objc2")]
impl CATapMuteBehavior {
    #[doc(alias = "CATapUnmuted")]
    pub const Unmuted: Self = Self(0);
    #[doc(alias = "CATapMuted")]
    pub const Muted: Self = Self(1);
    #[doc(alias = "CATapMutedWhenTapped")]
    pub const MutedWhenTapped: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CATapMuteBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CATapMuteBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2")]
extern_class!(
    /// This class describes a tap object that contains an input stream.  The input stream is a mix of all of the specified processes output audio.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2")]
    pub struct CATapDescription;
);

#[cfg(feature = "objc2")]
extern_conformance!(
    unsafe impl NSObjectProtocol for CATapDescription {}
);

#[cfg(feature = "objc2")]
impl CATapDescription {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Mix all given process audio streams down to stereo.  Mono sources will be duplicated in
        /// both right and left channels.
        ///
        /// Parameter `processesObjectIDsToIncludeInTap`: An NSArray of NSNumbers where each NSNumber holds an AudioObjectID of the process object to include in the tap
        #[unsafe(method(initStereoMixdownOfProcesses:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initStereoMixdownOfProcesses(
            this: Allocated<Self>,
            processes_object_i_ds_to_include_in_tap: &NSArray<NSNumber>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Mix all processes to a stereo stream except the given processes.  Mono sources will be
        /// duplicated in both right and left channels.
        ///
        /// Parameter `processesObjectIDsToExcludeFromTap`: An NSArray of NSNumbers where each NSNumber holds an AudioObjectID of the process object to exclude from the tap.
        /// All other processes that output audio will be included in the tap.
        #[unsafe(method(initStereoGlobalTapButExcludeProcesses:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initStereoGlobalTapButExcludeProcesses(
            this: Allocated<Self>,
            processes_object_i_ds_to_exclude_from_tap: &NSArray<NSNumber>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Mix all given process audio streams audio to mono.
        ///
        /// Parameter `processesObjectIDsToIncludeInTap`: An NSArray of NSNumbers where each NSNumber holds an AudioObjectID of the process object to include in the tap
        #[unsafe(method(initMonoMixdownOfProcesses:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initMonoMixdownOfProcesses(
            this: Allocated<Self>,
            processes_object_i_ds_to_include_in_tap: &NSArray<NSNumber>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Mix all processes to a mono stream except the given processes
        ///
        /// Parameter `processesObjectIDsToExcludeFromTap`: An NSArray of NSNumbers where each NSNumber holds an AudioObjectID of the process object to exclude from the tap.
        /// All other processes that output audio will be included in the tap.
        #[unsafe(method(initMonoGlobalTapButExcludeProcesses:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initMonoGlobalTapButExcludeProcesses(
            this: Allocated<Self>,
            processes_object_i_ds_to_exclude_from_tap: &NSArray<NSNumber>,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Mix all given process audio streams destined for the selected device stream
        ///
        /// Parameter `processesObjectIDsToIncludeInTap`: An NSArray of NSNumbers where each NSNumber holds an AudioObjectID of the process object to exclude from the tap.
        /// All other processes that output audio will be included in the tap.
        ///
        /// Parameter `deviceUID`: The device UID of the output device whose audio will be captured
        ///
        /// Parameter `stream`: NSInteger that represents the index of the stream on the device whose audio will be captured. The format of the tap
        /// will match the format of this stream.
        #[unsafe(method(initWithProcesses:andDeviceUID:withStream:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithProcesses_andDeviceUID_withStream(
            this: Allocated<Self>,
            processes_object_i_ds_to_include_in_tap: &NSArray<NSNumber>,
            device_uid: &NSString,
            stream: NSInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Mix all process audio streams destined for the selected device stream except the given processes
        ///
        /// Parameter `processesObjectIDsToExcludeFromTap`: An NSArray of NSNumbers where each NSNumber holds an AudioObjectID of the process object to exclude from the tap.
        /// All other processes that output audio will be included in the tap.
        ///
        /// Parameter `deviceUID`: The device UID of the output device whose audio will be captured
        ///
        /// Parameter `stream`: NSInteger that represents the index of the stream on the device whose audio will be captured. The format of the tap
        /// will match the format of this stream.
        #[unsafe(method(initExcludingProcesses:andDeviceUID:withStream:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initExcludingProcesses_andDeviceUID_withStream(
            this: Allocated<Self>,
            processes_object_i_ds_to_exclude_from_tap: &NSArray<NSNumber>,
            device_uid: &NSString,
            stream: NSInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-foundation")]
        /// Human readable name of this tap.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: &NSString);

        #[cfg(feature = "objc2-foundation")]
        /// UID of this tap.
        #[unsafe(method(UUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn UUID(&self) -> Retained<NSUUID>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`UUID`][Self::UUID].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUUID(&self, uuid: &NSUUID);

        #[cfg(feature = "objc2-foundation")]
        /// An NSArray of NSNumbers where each NSNumber holds the AudioObjectID of a process object to tap or exclude.
        #[unsafe(method(processes))]
        #[unsafe(method_family = none)]
        pub unsafe fn processes(&self) -> Retained<NSArray<NSNumber>>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`processes`][Self::processes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProcesses:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProcesses(&self, processes: &NSArray<NSNumber>);

        #[cfg(feature = "objc2-foundation")]
        /// An Array of Strings where each String holds the bundle ID of a process to tap or exclude.
        #[unsafe(method(bundleIDs))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleIDs(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`bundleIDs`][Self::bundleIDs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBundleIDs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBundleIDs(&self, bundle_i_ds: &NSArray<NSString>);

        /// True if this description is a mono mixdown of channels.
        #[unsafe(method(isMono))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMono(&self) -> bool;

        /// Setter for [`isMono`][Self::isMono].
        #[unsafe(method(setMono:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMono(&self, mono: bool);

        /// True if this description should tap all processes except the process listed in the 'processes' property.
        #[unsafe(method(isExclusive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isExclusive(&self) -> bool;

        /// Setter for [`isExclusive`][Self::isExclusive].
        #[unsafe(method(setExclusive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExclusive(&self, exclusive: bool);

        /// True if this description is a mono or stereo mix of the tapped device's channels.
        #[unsafe(method(isMixdown))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMixdown(&self) -> bool;

        /// Setter for [`isMixdown`][Self::isMixdown].
        #[unsafe(method(setMixdown:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMixdown(&self, mixdown: bool);

        /// True if this tap is only visible to the client process that created the tap.
        #[unsafe(method(isPrivate))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPrivate(&self) -> bool;

        /// Setter for [`isPrivate`][Self::isPrivate].
        #[unsafe(method(setPrivate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrivate(&self, private_tap: bool);

        /// True if this tap should save tapped processes by bundle ID when they exit, and restore them to the tap when they start up again.
        #[unsafe(method(isProcessRestoreEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isProcessRestoreEnabled(&self) -> bool;

        /// Setter for [`isProcessRestoreEnabled`][Self::isProcessRestoreEnabled].
        #[unsafe(method(setProcessRestoreEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProcessRestoreEnabled(&self, process_restore_enabled: bool);

        /// Set the tap's mute behavior. See CATapMuteBehavior above.
        #[unsafe(method(isMuted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMuted(&self) -> CATapMuteBehavior;

        /// Setter for [`isMuted`][Self::isMuted].
        #[unsafe(method(setMuteBehavior:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMuteBehavior(&self, mute_behavior: CATapMuteBehavior);

        #[cfg(feature = "objc2-foundation")]
        /// An optional deviceUID that will have a value if this tap only taps a specific hardware device
        #[unsafe(method(deviceUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceUID(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`deviceUID`][Self::deviceUID].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDeviceUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDeviceUID(&self, device_uid: Option<&NSString>);

        #[cfg(feature = "objc2-foundation")]
        /// An optional NSNumber that will have a value if this tap taps a specific device stream.
        /// The value represents the index of the hardware stream.
        #[unsafe(method(stream))]
        #[unsafe(method_family = none)]
        pub unsafe fn stream(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "objc2-foundation")]
        /// Setter for [`stream`][Self::stream].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setStream:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStream(&self, stream: Option<&NSNumber>);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2")]
impl CATapDescription {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
