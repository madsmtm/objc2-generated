//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

///
/// ## Discussion
///
/// Indicates an invalid connection.
///
///
pub const EAConnectionIDNone: c_uint = 0;

extern_class!(
    /// An object that contains information about a single, connected hardware accessory.
    ///
    /// ## Overview
    ///
    /// An [`EAAccessory`](https://developer.apple.com/documentation/externalaccessory/eaaccessory) object gives your app information about a single connected hardware accessory. You can use the information in this class to determine whether your app is able to open a session to a given accessory. After you have an open session, you can also associate a custom delegate with the accessory object to be notified to changes in the accessory state. Your delegate must adopt the [`EAAccessoryDelegate`](https://developer.apple.com/documentation/externalaccessory/eaaccessorydelegate) protocol.
    ///
    /// You use an accessory object to create an [`EASession`](https://developer.apple.com/documentation/externalaccessory/easession) object, which itself provides the communications channel to and from the accessory hardware. The accessory object provides information about the communications protocols the accessory supports, along with information about current hardware and firmware revisions.
    ///
    /// When deciding whether to connect to an accessory, you should always first check the accessory’s declared protocols in the [`protocolStrings`](https://developer.apple.com/documentation/externalaccessory/eaaccessory/protocolstrings) array. This list indicates the types of data the accessory is capable of processing at that moment, which may not be the full list of protocols for which the accessory is designed. For example, an accessory that is connected but not yet authenticated will report no supported protocols until authentication is successful. Don’t connect to the accessory unless and until the list includes the protocol you intend to use.
    ///
    /// Accessories can be physically connected to the device through the Lightning connector (or through the 30-pin connector on older devices) or wirelessly using Bluetooth.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct EAAccessory;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for EAAccessory {}
);

impl EAAccessory {
    extern_methods!(
        #[unsafe(method(isConnected))]
        #[unsafe(method_family = none)]
        pub unsafe fn isConnected(&self) -> bool;

        #[unsafe(method(connectionID))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectionID(&self) -> NSUInteger;

        #[unsafe(method(manufacturer))]
        #[unsafe(method_family = none)]
        pub unsafe fn manufacturer(&self) -> Retained<NSString>;

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        #[unsafe(method(modelNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn modelNumber(&self) -> Retained<NSString>;

        #[unsafe(method(serialNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn serialNumber(&self) -> Retained<NSString>;

        #[unsafe(method(firmwareRevision))]
        #[unsafe(method_family = none)]
        pub unsafe fn firmwareRevision(&self) -> Retained<NSString>;

        #[unsafe(method(hardwareRevision))]
        #[unsafe(method_family = none)]
        pub unsafe fn hardwareRevision(&self) -> Retained<NSString>;

        #[deprecated = "Not supported"]
        #[unsafe(method(dockType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dockType(&self) -> Retained<NSString>;

        #[unsafe(method(protocolStrings))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocolStrings(&self) -> Retained<NSArray<NSString>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn EAAccessoryDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn EAAccessoryDelegate>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl EAAccessory {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A protocol that defines an optional method for receiving notifications when the associated accessory object is disconnected.
    pub unsafe trait EAAccessoryDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(accessoryDidDisconnect:))]
        #[unsafe(method_family = none)]
        unsafe fn accessoryDidDisconnect(&self, accessory: &EAAccessory);
    }
);
