//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Combines via bitwise-OR all the constants listed in [Logging and Handling Constants](https://developer.apple.com/documentation/exceptionhandling/logging-and-handling-constants).
pub const NSLogAndHandleEveryExceptionMask: c_uint = NSLogUncaughtExceptionMask
    | NSLogUncaughtSystemExceptionMask
    | NSLogUncaughtRuntimeErrorMask
    | NSHandleUncaughtExceptionMask
    | NSHandleUncaughtSystemExceptionMask
    | NSHandleUncaughtRuntimeErrorMask
    | NSLogTopLevelExceptionMask
    | NSHandleTopLevelExceptionMask
    | NSLogOtherExceptionMask
    | NSHandleOtherExceptionMask;
/// Combines via bitwise-OR all the constants listed in [System Hang Constants](https://developer.apple.com/documentation/exceptionhandling/system-hang-constants).
pub const NSHangOnEveryExceptionMask: c_uint = NSHangOnUncaughtExceptionMask
    | NSHangOnUncaughtSystemExceptionMask
    | NSHangOnUncaughtRuntimeErrorMask
    | NSHangOnTopLevelExceptionMask
    | NSHangOnOtherExceptionMask;
extern "C" {
    /// Identifies an uncaught system exception.
    pub static NSUncaughtSystemExceptionException: Option<&'static NSString>;
}

extern "C" {
    /// Identifies an Objective-C runtime error.
    pub static NSUncaughtRuntimeErrorException: Option<&'static NSString>;
}

extern "C" {
    /// The key for fetching the stack trace (an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object) in the [`userInfo`](https://developer.apple.com/documentation/foundation/nsexception/userinfo-swift.property) dictionary of the [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) object passed into one of the delegate methods described in [NSExceptionHandlerDelegate](https://developer.apple.com/documentation/exceptionhandling/nsexceptionhandlerdelegate).
    pub static NSStackTraceKey: Option<&'static NSString>;
}

impl NSExceptionHandler {
    #[doc(alias = "NSExceptionHandlerResume")]
    #[inline]
    pub unsafe fn resume() {
        extern "C-unwind" {
            fn NSExceptionHandlerResume();
        }
        unsafe { NSExceptionHandlerResume() }
    }
}

/// The exception handler logs uncaught exceptions.
pub const NSLogUncaughtExceptionMask: c_uint = 1 << 0;
/// The exception handler handles uncaught exceptions by terminating the thread in which they occur.
pub const NSHandleUncaughtExceptionMask: c_uint = 1 << 1;
/// The exception handler logs uncaught system exceptions.
pub const NSLogUncaughtSystemExceptionMask: c_uint = 1 << 2;
/// The exception handler handles uncaught system exceptions by converting them to [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) objects containing a stack trace.
pub const NSHandleUncaughtSystemExceptionMask: c_uint = 1 << 3;
/// The exception handler logs uncaught runtime errors.
pub const NSLogUncaughtRuntimeErrorMask: c_uint = 1 << 4;
/// The exception handler handles uncaught runtime errors by converting them to [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) objects containing a stack trace.
pub const NSHandleUncaughtRuntimeErrorMask: c_uint = 1 << 5;
/// The exception handler logs exceptions that would be caught by the top-level handler.
pub const NSLogTopLevelExceptionMask: c_uint = 1 << 6;
/// The exception handler handles exceptions caught by the top-level handler by converting them to [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) objects containing a stack trace.
pub const NSHandleTopLevelExceptionMask: c_uint = 1 << 7;
/// The exception handler logs exceptions caught by handlers lower than the top-level handler.
pub const NSLogOtherExceptionMask: c_uint = 1 << 8;
/// The exception handler handles exceptions caught by handlers lower than the top-level handler by converting them to [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) objects containing a stack trace.
pub const NSHandleOtherExceptionMask: c_uint = 1 << 9;

/// The exception handler suspends execution when it detects an uncaught exception (other than a system exception or runtime error).
pub const NSHangOnUncaughtExceptionMask: c_uint = 1 << 0;
/// The exception handler suspends execution when it detects an uncaught system exception.
pub const NSHangOnUncaughtSystemExceptionMask: c_uint = 1 << 1;
/// The exception handler suspends execution when it detects an uncaught runtime error.
pub const NSHangOnUncaughtRuntimeErrorMask: c_uint = 1 << 2;
/// The exception handler suspends execution when it detects an exception that would be handled by the top-level handler.
pub const NSHangOnTopLevelExceptionMask: c_uint = 1 << 3;
/// The exception handler suspends execution when it detects an exception that would be handled by an object other than the top-level handler.
pub const NSHangOnOtherExceptionMask: c_uint = 1 << 4;

extern_class!(
    /// The `NSExceptionHandler` class provides facilities for monitoring and debugging exceptional conditions in Objective-C programs. It works by installing a special uncaught exception handler via the  [`NSSetUncaughtExceptionHandler`](https://developer.apple.com/documentation/foundation/nssetuncaughtexceptionhandler(_:)) function. Consequently, to use the services of `NSExceptionHandler`, you must not install your own custom uncaught exception handler.
    ///
    /// ## Overview
    ///
    /// To use these services, you set a bit mask in the singleton `NSExceptionHandler` instance and, optionally, a delegate. The constants comprising the bit mask indicate the type of exception to be monitored and the behavior of the `NSExceptionHandler` object (or, simply, the exception handler). The delegate is asked to approve the logging and handling of each monitored [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) object using the NSExceptionHandlerDelegate protocol.
    ///
    /// The constants for configuring exception handler behavior can be categorized in several ways:
    ///
    /// - Uncaught exceptions versus caught exceptions—or, more accurately, exceptions that would be caught (for example, by the top-level handler)
    ///
    /// - Exception type or cause: system exceptions (such as invalid memory accesses), Objective-C runtime errors (such as messages sent to freed objects), and other exceptions
    ///
    /// - Exception handler behavior: logging the exception (including a stack trace) to the console, handling the exception, and suspending program execution so the debugger can be attached
    ///
    /// The way the exception handler handles an exception depends on the type of exception; the exception handler converts system exceptions and runtime errors into [`NSException`](https://developer.apple.com/documentation/foundation/nsexception) objects with a stack trace embedded in their `userInfo` dictionary; for all other uncaught exceptions, it terminates the thread on which they occur . The constants used to configure an `NSExceptionHandler` object are described in [Logging and Handling Constants](https://developer.apple.com/documentation/exceptionhandling/logging-and-handling-constants) and [System Hang Constants](https://developer.apple.com/documentation/exceptionhandling/system-hang-constants).
    ///
    /// The `defaults` command-line system also allows you to set values corresponding to the `enum` constants used to configure the exception handler; see [Controlling a Program’s Response to Exceptions](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Exceptions/Tasks/ControllingAppResponse.html#//apple_ref/doc/uid/20000473) for details.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSExceptionHandler;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSExceptionHandler {}
);

impl NSExceptionHandler {
    extern_methods!(
        #[unsafe(method(defaultExceptionHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultExceptionHandler() -> Option<Retained<NSExceptionHandler>>;

        #[unsafe(method(setExceptionHandlingMask:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExceptionHandlingMask(&self, a_mask: NSUInteger);

        #[unsafe(method(exceptionHandlingMask))]
        #[unsafe(method_family = none)]
        pub unsafe fn exceptionHandlingMask(&self) -> NSUInteger;

        #[unsafe(method(setExceptionHangingMask:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExceptionHangingMask(&self, a_mask: NSUInteger);

        #[unsafe(method(exceptionHangingMask))]
        #[unsafe(method_family = none)]
        pub unsafe fn exceptionHangingMask(&self) -> NSUInteger;

        /// # Safety
        ///
        /// - `an_object` should be of the correct type.
        /// - `an_object` might not allow `None`.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, an_object: Option<&AnyObject>);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<AnyObject>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSExceptionHandler {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

mod private_NSObjectNSExceptionHandlerDelegate {
    pub trait Sealed {}
}

/// Category "NSExceptionHandlerDelegate" on [`NSObject`].
#[doc(alias = "NSExceptionHandlerDelegate")]
pub unsafe trait NSObjectNSExceptionHandlerDelegate:
    ClassType + Sized + private_NSObjectNSExceptionHandlerDelegate::Sealed
{
    extern_methods!(
        /// # Safety
        ///
        /// - `sender` might not allow `None`.
        /// - `exception` might not allow `None`.
        #[unsafe(method(exceptionHandler:shouldLogException:mask:))]
        #[unsafe(method_family = none)]
        unsafe fn exceptionHandler_shouldLogException_mask(
            &self,
            sender: Option<&NSExceptionHandler>,
            exception: Option<&NSException>,
            a_mask: NSUInteger,
        ) -> bool;

        /// # Safety
        ///
        /// - `sender` might not allow `None`.
        /// - `exception` might not allow `None`.
        #[unsafe(method(exceptionHandler:shouldHandleException:mask:))]
        #[unsafe(method_family = none)]
        unsafe fn exceptionHandler_shouldHandleException_mask(
            &self,
            sender: Option<&NSExceptionHandler>,
            exception: Option<&NSException>,
            a_mask: NSUInteger,
        ) -> bool;
    );
}

impl private_NSObjectNSExceptionHandlerDelegate::Sealed for NSObject {}
unsafe impl NSObjectNSExceptionHandlerDelegate for NSObject {}

extern "C-unwind" {
    #[deprecated = "renamed to `NSExceptionHandler::resume`"]
    pub fn NSExceptionHandlerResume();
}
