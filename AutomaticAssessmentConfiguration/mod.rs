// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "AutomaticAssessmentConfiguration", kind = "framework")]
extern "C" {}

use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A representation of an app that users can access during an assessment.
    ///
    /// ## Overview
    ///
    /// Use an instance of this class when you want to make an app besides yours, like a calculator or a dictionary, available during an assessment. Create a representation of the app that you want to allow using the app’s bundle identifier and optionally the identifier of the team that distributes the app. You can get both identifiers for an app that you have installed using the `codesign` command line utility:
    ///
    /// ```shell
    /// % codesign -v -d /Applications/MyApp.app
    /// ```
    ///
    /// By default, the system requires that the app’s code signature is valid, and that either Apple distributes the app, or the developer notarizes the app or distributes it through the App Store. You can relax these requirements by setting the [`requiresSignatureValidation`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentapplication/requiressignaturevalidation) property to `false`, but that creates a potential security risk. In that case, the only requirement is that the app has the specified bundle and team identifiers. Prefer to keep the signature requirement.
    ///
    /// Add the app to a session configuration by calling the [`setConfiguration:forApplication:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/setconfiguration(_:for:)) method, and then apply the configuration to either a new session that you create, or an existing session with the [`updateToConfiguration:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/update(to:)) method.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AEAssessmentApplication;
);

extern_conformance!(
    unsafe impl NSCopying for AEAssessmentApplication {}
);

unsafe impl CopyingHelper for AEAssessmentApplication {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AEAssessmentApplication {}
);

impl AEAssessmentApplication {
    extern_methods!(
        #[unsafe(method(bundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleIdentifier(&self) -> Retained<NSString>;

        #[unsafe(method(teamIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn teamIdentifier(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(requiresSignatureValidation))]
        #[unsafe(method_family = none)]
        pub unsafe fn requiresSignatureValidation(&self) -> bool;

        /// Setter for [`requiresSignatureValidation`][Self::requiresSignatureValidation].
        #[unsafe(method(setRequiresSignatureValidation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRequiresSignatureValidation(&self, requires_signature_validation: bool);

        #[unsafe(method(initWithBundleIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBundleIdentifier(
            this: Allocated<Self>,
            bundle_identifier: &NSString,
        ) -> Retained<Self>;

        #[unsafe(method(initWithBundleIdentifier:teamIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBundleIdentifier_teamIdentifier(
            this: Allocated<Self>,
            bundle_identifier: &NSString,
            team_identifier: Option<&NSString>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The set of autocorrect features that you can enable during an assessment.
///
/// ## Overview
///
/// Use one or more of the autocorrect modes to set the [`autocorrectMode`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/autocorrectmode-swift.property) property of an [`AEAssessmentConfiguration`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration) instance. For example, you can enable both spelling and punctuation corrections by combining [`AEAutocorrectModeSpelling`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/autocorrectmode-swift.struct/spelling) and [`AEAutocorrectModePunctuation`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/autocorrectmode-swift.struct/punctuation):
///
/// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let config = AEAssessmentConfiguration()", "", "#if os(iOS) // Available only on iOS and iPadOS.", "config.autocorrectMode = [.punctuation, .spelling]", "#endif", "", "let session = AEAssessmentSession(configuration: config)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["AEAssessmentConfiguration *config = [AEAssessmentConfiguration new];", "", "#if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR // Available only on iOS and iPadOS.", "config.autocorrectMode = AEAutocorrectModePunctuation | AEAutocorrectModeSpelling;", "#endif", "", "AEAssessmentSession *session = [[AEAssessmentSession alloc] initWithConfiguration:config];"], metadata: None }] }] })
///
/// The set of autocorrect features that you can enable during an assessment.
///
/// Use one or more of the autocorrect modes to set the ``AEAssessmentConfiguration/autocorrectMode-swift.property`` property of an ``AEAssessmentConfiguration`` instance. For example, you can enable both spelling and punctuation corrections by combining ``AEAssessmentConfiguration/AutocorrectMode-swift.struct/spelling`` and ``AEAssessmentConfiguration/AutocorrectMode-swift.struct/punctuation``:
///
/// ```swift
/// let config = AEAssessmentConfiguration()
///
/// #if os(iOS) // Available only on iOS and iPadOS.
/// config.autocorrectMode = [.punctuation, .spelling]
/// #endif
///
/// let session = AEAssessmentSession(configuration: config)
/// ```
///
/// ## Topics
///
/// ### Creating a mode
///
/// - ``AEAssessmentConfiguration/AutocorrectMode-swift.struct/init(rawValue:)``
///
/// ### Modes
///
/// - ``AEAssessmentConfiguration/AutocorrectMode-swift.struct/punctuation``
/// - ``AEAssessmentConfiguration/AutocorrectMode-swift.struct/spelling``
/// - ``AEAutocorrectMode/AEAutocorrectModeNone``
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AEAutocorrectMode(pub NSUInteger);
bitflags::bitflags! {
    impl AEAutocorrectMode: NSUInteger {
/// A mode that indicates autocorrect doesn’t check anything.
///
/// ## Discussion
///
/// Set the [`autocorrectMode`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/autocorrectmode-swift.property) value of an [`AEAssessmentConfiguration`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration) instance to [`AEAutocorrectModeNone`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeautocorrectmode/aeautocorrectmodenone) to disable all autocorrect features during an assessment.
///
/// ```objc
/// config.autocorrectMode = AEAutocorrectModeNone;
/// ```
///
/// This is the default value of the [`autocorrectMode`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/autocorrectmode-swift.property) property.
///
///
        #[doc(alias = "AEAutocorrectModeNone")]
        const None = 0;
/// A mode in which autocorrect checks for spelling as the user types.
/// A mode in which autocorrect checks for spelling as the user types.
        #[doc(alias = "AEAutocorrectModeSpelling")]
        const Spelling = 1<<0;
/// A mode in which autocorrect checks punctuation as the user types.
/// A mode in which autocorrect checks punctuation as the user types.
        #[doc(alias = "AEAutocorrectModePunctuation")]
        const Punctuation = 1<<1;
    }
}

unsafe impl Encode for AEAutocorrectMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for AEAutocorrectMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Configuration information for an assessment session.
    ///
    /// ## Overview
    ///
    /// Create a configuration instance and pass it to the [`initWithConfiguration:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/init(configuration:)) initializer of an [`AEAssessmentSession`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession) instance to create a new assessment session. Before using the configuration, indicate which exceptions you want to allow for the assessment session’s restrictions by setting values on the configuration instance. For example, you can set values to allow dictation and certain aspects of autocorrect:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let config = AEAssessmentConfiguration()", "", "#if os(iOS) // These exceptions available only on iOS and iPadOS.", "config.allowsDictation = true", "config.autocorrectMode = [.punctuation, .spelling]", "#endif", "", "let session = AEAssessmentSession(configuration: config)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["AEAssessmentConfiguration *config = [AEAssessmentConfiguration new];", "", "#if TARGET_OS_IPHONE || TARGET_IPHONE_SIMULATOR // These exceptions available only on iOS and iPadOS.", "config.allowsDictation = YES;", "config.autocorrectMode = AEAutocorrectModePunctuation | AEAutocorrectModeSpelling;", "#endif", "", "AEAssessmentSession *session = [[AEAssessmentSession alloc] initWithConfiguration:config];"], metadata: None }] }] })
    /// While you provide a configuration instance when creating a session on iOS, iPadOS, and macOS, specific exceptions apply only to certain platforms. In particular, on macOS, you can selectively make specific apps besides your own available during an assessment — for example, to allow users to access a calculator or a dictionary. All other exceptions apply only to iOS and iPadOS.
    ///
    ///
    /// Configuration information for an assessment session.
    ///
    /// Create a configuration instance and pass it to the ``AEAssessmentSession/init(configuration:)`` initializer of an ``AEAssessmentSession`` instance to create a new assessment session. Before using the configuration, indicate which exceptions you want to allow for the assessment session's restrictions by setting values on the configuration instance. For example, you can set values to allow dictation and certain aspects of autocorrect:
    ///
    /// ```swift
    /// let config = AEAssessmentConfiguration()
    ///
    /// #if os(iOS) // These exceptions available only on iOS and iPadOS.
    /// config.allowsDictation = true
    /// config.autocorrectMode = [.punctuation, .spelling]
    /// #endif
    ///
    /// let session = AEAssessmentSession(configuration: config)
    /// ```
    ///
    /// While you provide a configuration instance when creating a session on iOS, iPadOS, and macOS, specific exceptions apply only to certain platforms. In particular, on macOS, you can selectively make specific apps besides your own available during an assessment — for example, to allow users to access a calculator or a dictionary. All other exceptions apply only to iOS and iPadOS.
    ///
    /// ## Topics
    ///
    /// ### Allowing access to other apps
    ///
    /// - ``setConfiguration(_:for:)``
    /// - ``configurationsByApplication``
    /// - ``remove(_:)``
    /// - ``mainParticipantConfiguration``
    /// - ``AEAssessmentApplication``
    /// - ``AEAssessmentParticipantConfiguration``
    ///
    /// ### Allowing accessibility
    ///
    /// - ``allowsAccessibilityKeyboard``
    /// - ``allowsAccessibilityLiveCaptions``
    /// - ``allowsAccessibilityReader``
    /// - ``allowsAccessibilitySpeech``
    /// - ``allowsAccessibilityTypingFeedback``
    /// - ``allowsDictation``
    ///
    /// ### Allowing typing assistance
    ///
    /// - ``allowsContinuousPathKeyboard``
    /// - ``allowsKeyboardShortcuts``
    /// - ``allowsPredictiveKeyboard``
    /// - ``allowsPasswordAutoFill``
    ///
    /// ### Allowing corrections
    ///
    /// - ``allowsSpellCheck``
    /// - ``autocorrectMode-swift.property``
    /// - ``AutocorrectMode-swift.struct``
    ///
    /// ### Allowing handoff
    ///
    /// - ``allowsActivityContinuation``
    ///
    /// ### Allowing content capture
    ///
    /// - ``allowsScreenshots``
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AEAssessmentConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for AEAssessmentConfiguration {}
);

unsafe impl CopyingHelper for AEAssessmentConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AEAssessmentConfiguration {}
);

impl AEAssessmentConfiguration {
    extern_methods!(
        /// The autocorrect mode that specifies which autocorrect features to allow during an assessment.
        ///
        /// Users can turn on autocorrect in the Settings app (General > Keyboard > Auto-Correction). An assessment session disables this feature by default, but you can allow it by setting ``AEAssessmentConfiguration/autocorrectMode-swift.property`` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session. Set the mode's value to some combination of the the values from the ``AEAssessmentConfiguration/AutocorrectMode-swift.struct`` structure.
        #[unsafe(method(autocorrectMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn autocorrectMode(&self) -> AEAutocorrectMode;

        /// Setter for [`autocorrectMode`][Self::autocorrectMode].
        #[unsafe(method(setAutocorrectMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAutocorrectMode(&self, autocorrect_mode: AEAutocorrectMode);

        /// A Boolean value that indicates whether to allow spell check during an assessment.
        ///
        /// Users can activate the spell checker by turning on the Check Spelling feature in the Settings app (General > Keyboard). An assessment session disables spell checking by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsSpellCheck`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsSpellCheck))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsSpellCheck(&self) -> bool;

        /// Setter for [`allowsSpellCheck`][Self::allowsSpellCheck].
        #[unsafe(method(setAllowsSpellCheck:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsSpellCheck(&self, allows_spell_check: bool);

        /// A Boolean value that indicates whether to enable the predictive keyboard during an assessment.
        ///
        /// Users can turn on the Predictive Keyboard feature in the Settings app (General > Keyboard). An assessment session disables this feature by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsPredictiveKeyboard`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsPredictiveKeyboard))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsPredictiveKeyboard(&self) -> bool;

        /// Setter for [`allowsPredictiveKeyboard`][Self::allowsPredictiveKeyboard].
        #[unsafe(method(setAllowsPredictiveKeyboard:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsPredictiveKeyboard(&self, allows_predictive_keyboard: bool);

        /// A Boolean value that indicates whether to allow keyboard shortcuts during an assessment.
        ///
        /// Users can add Keyboard Shortcuts in the Settings app (General > Keyboard > Text Replacement). An assessment session disables the use of keyboard shortcuts by default, but you can allow them by setting ``AEAssessmentConfiguration/allowsKeyboardShortcuts`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsKeyboardShortcuts))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsKeyboardShortcuts(&self) -> bool;

        /// Setter for [`allowsKeyboardShortcuts`][Self::allowsKeyboardShortcuts].
        #[unsafe(method(setAllowsKeyboardShortcuts:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsKeyboardShortcuts(&self, allows_keyboard_shortcuts: bool);

        /// A Boolean value that indicates whether to allow Handoff during an assessment.
        ///
        /// Handoff lets users start an activity on one device and seamlessly resume the activity on another. Users control whether a device participates in Handoff by turning the feature on or off in the Settings app (General > AirPlay
        /// &
        /// Handoff > Handoff). An assessment disables this feature by default, but you can allow users undergoing an assessment to continue to use Handoff by setting ``AEAssessmentConfiguration/allowsActivityContinuation`` to `true`.
        #[unsafe(method(allowsActivityContinuation))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsActivityContinuation(&self) -> bool;

        /// Setter for [`allowsActivityContinuation`][Self::allowsActivityContinuation].
        #[unsafe(method(setAllowsActivityContinuation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsActivityContinuation(&self, allows_activity_continuation: bool);

        /// A Boolean value that indicates whether to allow the use of dictation during an assessment.
        ///
        /// By turning on Enable Dictation (General > Keyboard in the Settings app on iOS and iPadOS), users can speak into their device and have the words they speak converted to text. An assessment session disables this feature by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsDictation`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsDictation))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsDictation(&self) -> bool;

        /// Setter for [`allowsDictation`][Self::allowsDictation].
        #[unsafe(method(setAllowsDictation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsDictation(&self, allows_dictation: bool);

        /// A Boolean value that indicates whether to allow alternative input methods in the Accessibility Keyboard during an assessment.
        ///
        /// Users can enable the Accessibility Keyboard in the Settings app (Accessibility > Keyboard > Accessibility Keyboard) to access an on-screen keyboard with alternative input methods. An assessment session disables alternative input methods in the Accessibility Keyboard by default, but you can allow them by setting ``AEAssessmentConfiguration/allowsAccessibilityKeyboard`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsAccessibilityKeyboard))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsAccessibilityKeyboard(&self) -> bool;

        /// Setter for [`allowsAccessibilityKeyboard`][Self::allowsAccessibilityKeyboard].
        #[unsafe(method(setAllowsAccessibilityKeyboard:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsAccessibilityKeyboard(&self, allows_accessibility_keyboard: bool);

        /// A Boolean value that indicates whether to allow Live Captions during an assessment.
        ///
        /// Users can enable Live Captions in the Settings app (Accessibility > Live Captions) to receive real-time transcription of spoken audio as text on screen. An assessment session disables Live Captions by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsAccessibilityLiveCaptions`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsAccessibilityLiveCaptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsAccessibilityLiveCaptions(&self) -> bool;

        /// Setter for [`allowsAccessibilityLiveCaptions`][Self::allowsAccessibilityLiveCaptions].
        #[unsafe(method(setAllowsAccessibilityLiveCaptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsAccessibilityLiveCaptions(
            &self,
            allows_accessibility_live_captions: bool,
        );

        /// A Boolean value that indicates whether to allow the Accessibility Reader during an assessment.
        ///
        /// Users can enable the Accessibility Reader in the Settings app (Accessibility > Read
        /// &
        /// Speak > Accessibility Reader) to have text content formatted or read aloud. An assessment session disables the Accessibility Reader by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsAccessibilityReader`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsAccessibilityReader))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsAccessibilityReader(&self) -> bool;

        /// Setter for [`allowsAccessibilityReader`][Self::allowsAccessibilityReader].
        #[unsafe(method(setAllowsAccessibilityReader:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsAccessibilityReader(&self, allows_accessibility_reader: bool);

        /// A Boolean value that indicates whether to allow the speech-related accessibility features during an assessment.
        ///
        /// A device reads text aloud for users who need it. In particular, users can enable the following features from Accessibility > Spoken Content in the Settings app on iOS and iPadOS:
        /// - Speak Selection
        /// - Speak Screen
        /// - Typing Feedback > Speak Words
        ///
        /// An assessment session disables these features by default, but you can allow them by setting ``AEAssessmentConfiguration/allowsAccessibilitySpeech`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsAccessibilitySpeech))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsAccessibilitySpeech(&self) -> bool;

        /// Setter for [`allowsAccessibilitySpeech`][Self::allowsAccessibilitySpeech].
        #[unsafe(method(setAllowsAccessibilitySpeech:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsAccessibilitySpeech(&self, allows_accessibility_speech: bool);

        /// A Boolean value that indicates whether to allow accessibility typing feedback during an assessment.
        ///
        /// Users can enable typing feedback features in the Settings app (Accessibility > Keyboards
        /// &
        /// Typing > Typing Feedback)  to receive audio feedback when typing. An assessment session disables these accessibility typing feedback features by default, but you can allow them by setting ``AEAssessmentConfiguration/allowsAccessibilityTypingFeedback`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsAccessibilityTypingFeedback))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsAccessibilityTypingFeedback(&self) -> bool;

        /// Setter for [`allowsAccessibilityTypingFeedback`][Self::allowsAccessibilityTypingFeedback].
        #[unsafe(method(setAllowsAccessibilityTypingFeedback:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsAccessibilityTypingFeedback(
            &self,
            allows_accessibility_typing_feedback: bool,
        );

        /// A Boolean value that indicates whether to allow password autofill during an assessment.
        ///
        /// Users can store passwords for use with Password Autofill by turning on the feature in the Settings app (General > Passwords > AutoFill Passwords). An assessment session disables Password Autofill by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsPasswordAutoFill`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsPasswordAutoFill))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsPasswordAutoFill(&self) -> bool;

        /// Setter for [`allowsPasswordAutoFill`][Self::allowsPasswordAutoFill].
        #[unsafe(method(setAllowsPasswordAutoFill:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsPasswordAutoFill(&self, allows_password_auto_fill: bool);

        /// A Boolean value that indicates whether to allow Slide to Type to operate during an assessment.
        ///
        /// Users can turn on Slide to Type in the Settings app (General > Keyboard). An assessment session disables this feature by default, but you can allow it by setting ``AEAssessmentConfiguration/allowsContinuousPathKeyboard`` to `true` in the ``AEAssessmentConfiguration`` instance that you use to initialize a session.
        #[unsafe(method(allowsContinuousPathKeyboard))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsContinuousPathKeyboard(&self) -> bool;

        /// Setter for [`allowsContinuousPathKeyboard`][Self::allowsContinuousPathKeyboard].
        #[unsafe(method(setAllowsContinuousPathKeyboard:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsContinuousPathKeyboard(&self, allows_continuous_path_keyboard: bool);

        /// A Boolean value that indicates whether to allow screenshots copied to the clipboard during an assessment.
        ///
        /// An assessment session disables the ability to take screenshots by default to maintain assessment integrity. This property specifically applies to screenshots that are copied to the clipboard, typically those taken using the Command+Control+Shift+3 and Command+Control+Shift+4 keyboard shortcuts. You can allow clipboard screenshots by setting `allowsScreenshots` to `true`.
        ///
        /// - Note: The clipboard is cleared before the assessment session ends to prevent exporting captured content.
        #[unsafe(method(allowsScreenshots))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsScreenshots(&self) -> bool;

        /// Setter for [`allowsScreenshots`][Self::allowsScreenshots].
        #[unsafe(method(setAllowsScreenshots:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsScreenshots(&self, allows_screenshots: bool);

        /// The app-specific configuration for the app that invokes the assessment.
        ///
        /// Use this property to get and customize the app-specific configuration that's applied to your own app. For example, you can set the `allowsNetworkAccess` property for your own app:
        ///
        /// ```swift
        /// let config = AEAssessmentConfiguration()
        /// config.mainParticipantConfiguration.allowsNetworkAccess = false
        /// ```
        #[unsafe(method(mainParticipantConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn mainParticipantConfiguration(
            &self,
        ) -> Retained<AEAssessmentParticipantConfiguration>;

        /// The collection of apps available during an assessment, along with their associated configurations.
        ///
        /// Access this property to get a list of the currently allowed secondary apps and their individual configurations. Add apps to the list by calling the ``AEAssessmentConfiguration/setConfiguration(_:for:)`` method. Remove them from the list by calling the ``AEAssessmentConfiguration/remove(_:)`` method.
        #[unsafe(method(configurationsByApplication))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationsByApplication(
            &self,
        ) -> Retained<NSDictionary<AEAssessmentApplication, AEAssessmentParticipantConfiguration>>;

        /// Adds an app to the list of apps available during an assessment.
        ///
        /// Use this method to make an app besides your own available during an assessment. Create a representation of the app that you want to allow as an ``AEAssessmentApplication`` instance, and the configuration for that app using an ``AEAssessmentParticipantConfiguration`` instance:
        ///
        /// ```swift
        /// let calculator = AEAssessmentApplication(bundleIdentifier: "com.apple.calculator")
        /// let calculatorConfig = AEAssessmentParticipantConfiguration()
        /// calculatorConfig.allowsNetworkAccess = false // Calculator doesn't need the network.
        /// ```
        ///
        /// Use the app and its configuration to create an assessment configuration, and either create an assessment session with that, or update an existing session as shown below:
        ///
        /// ```swift
        /// let configuration = AEAssessmentConfiguration()
        /// configuration.setConfiguration(calculatorConfig, for: calculator)
        /// session.update(to: configuration)
        /// ```
        ///
        /// You can get a list of the currently allowed apps by accessing the ``AEAssessmentConfiguration/configurationsByApplication`` property. You can disallow a previously allowed app by using the ``AEAssessmentConfiguration/remove(_:)`` method.
        ///
        /// - Parameters:
        /// - configuration: The configuration of the secondary app.
        /// - application: The app that you want to configure.
        #[unsafe(method(setConfiguration:forApplication:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConfiguration_forApplication(
            &self,
            configuration: &AEAssessmentParticipantConfiguration,
            application: &AEAssessmentApplication,
        );

        /// Removes the availability of a previously allowed app.
        ///
        /// Use this method to remove apps that you previously added to the list of apps that are available during an assessment with the ``AEAssessmentConfiguration/setConfiguration(_:for:)`` method. You can get the list of currently allowed apps by accessing the configuration's ``AEAssessmentConfiguration/configurationsByApplication`` property.
        ///
        /// - Parameters:
        /// - application: The app that you want to remove from the list of allowed secondary apps.
        #[unsafe(method(removeApplication:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeApplication(&self, application: &AEAssessmentApplication);
    );
}

/// Methods declared on superclass `NSObject`.
impl AEAssessmentConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Configuration information for an app that’s available during an assessment.
    ///
    /// ## Overview
    ///
    /// Use an instance of this class to configure the properties of an app that you allow to run during an assessment. Associate the participant configuration with an app (an [`AEAssessmentApplication`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentapplication) instance) when you call the [`setConfiguration:forApplication:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration/setconfiguration(_:for:)) method of a session configuration.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AEAssessmentParticipantConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for AEAssessmentParticipantConfiguration {}
);

unsafe impl CopyingHelper for AEAssessmentParticipantConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AEAssessmentParticipantConfiguration {}
);

impl AEAssessmentParticipantConfiguration {
    extern_methods!(
        #[unsafe(method(allowsNetworkAccess))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsNetworkAccess(&self) -> bool;

        /// Setter for [`allowsNetworkAccess`][Self::allowsNetworkAccess].
        #[unsafe(method(setAllowsNetworkAccess:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsNetworkAccess(&self, allows_network_access: bool);

        #[unsafe(method(isRequired))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRequired(&self) -> bool;

        /// Setter for [`isRequired`][Self::isRequired].
        #[unsafe(method(setRequired:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRequired(&self, required: bool);

        #[unsafe(method(configurationInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationInfo(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        /// Setter for [`configurationInfo`][Self::configurationInfo].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `configuration_info` generic should be of the correct type.
        #[unsafe(method(setConfigurationInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConfigurationInfo(
            &self,
            configuration_info: &NSDictionary<NSString, AnyObject>,
        );

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A session that your app uses to protect an assessment.
    ///
    /// ## Overview
    ///
    /// Use the [`AEAssessmentSession`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession) class to manage an assessment session. The system allows only one active session at a time across all processes. The first session to run gets exclusive access to the system; subsequent session attempts fail until the first session ends.
    ///
    /// To create an assessment session, pass a new [`AEAssessmentConfiguration`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentconfiguration) instance to the [`initWithConfiguration:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/init(configuration:)) method. Then, provide the session with a delegate that conforms to the [`AEAssessmentSessionDelegate`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsessiondelegate) protocol:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let config = AEAssessmentConfiguration()", "let session = AEAssessmentSession(configuration: config)", "session.delegate = self"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["AEAssessmentConfiguration *config = [AEAssessmentConfiguration new];", "AEAssessmentSession *session = [[AEAssessmentSession alloc] initWithConfiguration:config];", "session.delegate = self;"], metadata: None }] }] })
    /// You can indicate exceptions to the restrictions imposed by an assessment session by setting the properties of the configuration instance, or you can use the default restrictions as shown above. The session tells its delegate about state changes during its life cycle. To start a session, call the session’s [`begin`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/begin()) method:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["session.begin()"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[session begin];"], metadata: None }] }] })
    /// The method returns immediately, and the session starts disabling system features. After achieving the desired state, the session calls its delegate’s [`assessmentSessionDidBegin:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsessiondelegate/assessmentsessiondidbegin(_:)) method. Only after receiving this callback is it safe to begin your assessment. Be sure to keep a strong reference to the session as long as you want it to remain active. If the system deallocates an active session, the session automatically ends.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Prior to macOS 12.1, a DNS lookup that your app initiates during a session might fail. Be sure your app resolves all required domain names before beginning a session so that the system can cache the results. You can do this by using [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) to send a `HEAD` request to each domain name that your app needs to access.
    ///
    ///
    ///
    /// </div>
    /// After completing an assessment and hiding all sensitive information, call the session’s [`end`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/end()) method:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["session.end()"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[session end];"], metadata: None }] }] })
    /// After making the call, wait for the session to call its delegate’s [`assessmentSessionDidEnd:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsessiondelegate/assessmentsessiondidend(_:)) method before reporting assessment completion to the user.
    ///
    /// During assessment, the session’s delegate might receive an [`assessmentSession:wasInterruptedWithError:`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsessiondelegate/assessmentsession(_:wasinterruptedwitherror:)) callback to indicate a failure. If this happens, immediately stop the assessment, hide all sensitive content, and end the session. Because it might take time for your app to finalize the assessment, the session relies on your app to call the session’s [`end`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/end()) method:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func assessmentSession(_ session: AEAssessmentSession, wasInterruptedWithError error: Error) {", "    // Hide sensitive UI and optionally store assessment progress.", "", "    // End the session.", "    session.end()", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (void)assessmentSession:(AEAssessmentSession *)session wasInterruptedWithError:(NSError *)error {", "    // Hide sensitive UI and optionally store assessment progress.", "", "    // End the session.", "    [session end];", "}"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AEAssessmentSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for AEAssessmentSession {}
);

impl AEAssessmentSession {
    extern_methods!(
        #[unsafe(method(supportsMultipleParticipants))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsMultipleParticipants() -> bool;

        #[unsafe(method(supportsConfigurationUpdates))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsConfigurationUpdates() -> bool;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn AEAssessmentSessionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn AEAssessmentSessionDelegate>>,
        );

        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn configuration(&self) -> Retained<AEAssessmentConfiguration>;

        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isActive(&self) -> bool;

        #[unsafe(method(initWithConfiguration:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithConfiguration(
            this: Allocated<Self>,
            configuration: &AEAssessmentConfiguration,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(begin))]
        #[unsafe(method_family = none)]
        pub unsafe fn begin(&self);

        #[unsafe(method(end))]
        #[unsafe(method_family = none)]
        pub unsafe fn end(&self);

        #[unsafe(method(updateToConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateToConfiguration(&self, configuration: &AEAssessmentConfiguration);
    );
}

extern_protocol!(
    /// An interface that the session uses to provide information about session state changes to a delegate.
    ///
    /// ## Overview
    ///
    /// An assessment session operates asynchronously because it takes time to make the changes associated with starting or stopping a session, and external events might affect the state of the session. Adopt the [`AEAssessmentSessionDelegate`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsessiondelegate) protocol to receive callbacks at key points in the session life cycle. Store your adopter in the session’s [`delegate`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/delegate) property before starting a session.
    ///
    /// By listening for delegate callbacks, you learn when you can safely start an assessment after calling the session’s [`begin`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/begin()) method, when the session has finished after calling the [`end`](https://developer.apple.com/documentation/automaticassessmentconfiguration/aeassessmentsession/end()) method, or if the session has been interrupted for some reason. You also find out when it’s safe to proceed after changing a session’s configuration.
    ///
    /// The session calls all delegate methods on the main thread.
    ///
    ///
    pub unsafe trait AEAssessmentSessionDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(assessmentSessionDidBegin:))]
        #[unsafe(method_family = none)]
        unsafe fn assessmentSessionDidBegin(&self, session: &AEAssessmentSession);

        #[optional]
        #[unsafe(method(assessmentSession:failedToBeginWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn assessmentSession_failedToBeginWithError(
            &self,
            session: &AEAssessmentSession,
            error: &NSError,
        );

        #[optional]
        #[unsafe(method(assessmentSession:wasInterruptedWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn assessmentSession_wasInterruptedWithError(
            &self,
            session: &AEAssessmentSession,
            error: &NSError,
        );

        #[optional]
        #[unsafe(method(assessmentSessionDidEnd:))]
        #[unsafe(method_family = none)]
        unsafe fn assessmentSessionDidEnd(&self, session: &AEAssessmentSession);

        #[optional]
        #[unsafe(method(assessmentSessionDidUpdate:))]
        #[unsafe(method_family = none)]
        unsafe fn assessmentSessionDidUpdate(&self, session: &AEAssessmentSession);

        #[optional]
        #[unsafe(method(assessmentSession:failedToUpdateToConfiguration:error:))]
        #[unsafe(method_family = none)]
        unsafe fn assessmentSession_failedToUpdateToConfiguration_error(
            &self,
            session: &AEAssessmentSession,
            configuration: &AEAssessmentConfiguration,
            error: &NSError,
        );
    }
);

extern "C" {
    /// A constant representing the error domain that the framework uses when issuing errors.
    pub static AEAssessmentErrorDomain: &'static NSErrorDomain;
}

/// Error codes that the framework returns if a session fails.
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AEAssessmentErrorCode(pub NSInteger);
impl AEAssessmentErrorCode {
    /// The session encountered an unknown error.
    #[doc(alias = "AEAssessmentErrorUnknown")]
    pub const Unknown: Self = Self(1);
    /// The feature isn’t supported on this platform.
    #[doc(alias = "AEAssessmentErrorUnsupportedPlatform")]
    pub const UnsupportedPlatform: Self = Self(2);
    /// A session fails to begin or update with a configuration that contains one or more participant applications because mulitple participant configurations are not supported by the device or platform.
    #[doc(alias = "AEAssessmentErrorMultipleParticipantsNotSupported")]
    pub const MultipleParticipantsNotSupported: Self = Self(3);
    /// An active session fails to update its configuration because configuration updates are not supported by the current device or platform.
    #[doc(alias = "AEAssessmentErrorConfigurationUpdatesNotSupported")]
    pub const ConfigurationUpdatesNotSupported: Self = Self(4);
    #[doc(alias = "AEAssessmentErrorRequiredParticipantsNotAvailable")]
    pub const RequiredParticipantsNotAvailable: Self = Self(5);
}

unsafe impl Encode for AEAssessmentErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AEAssessmentErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    pub static AENotInstalledParticipantsKey: &'static NSString;
}

extern "C" {
    pub static AERestrictedSystemParticipantsKey: &'static NSString;
}
