//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// Unimplemented code signing feature.
pub const errSecCSUnimplemented: OSStatus = -67072;
/// Invalid API object reference.
pub const errSecCSInvalidObjectRef: OSStatus = -67071;
/// Invalid or inappropriate API flags specified.
pub const errSecCSInvalidFlags: OSStatus = -67070;
/// A required pointer argument was null.
pub const errSecCSObjectRequired: OSStatus = -67069;
/// Cannot find code object on disk.
///
/// ## Discussion
///
/// You can get this error if you specify a location on disk and the system can’t find the code at that location or if the system is checking the validity of running code and it can’t find the code on disk that was the source for the code in memory.
///
///
pub const errSecCSStaticCodeNotFound: OSStatus = -67068;
/// Cannot locate guest code using this attribute set.
///
/// ## Discussion
///
/// When calling the [`SecHostCreateGuest`](https://developer.apple.com/documentation/security/sechostcreateguest) function or the [`SecCodeCopyGuestWithAttributes`](https://developer.apple.com/documentation/security/seccodecopyguestwithattributes(_:_:_:_:)) function, you passed a key that either isn’t understood, recognized, or supported.
///
///
pub const errSecCSUnsupportedGuestAttributes: OSStatus = -67067;
/// An attribute value associated with a key is out of range or is the wrong type.
pub const errSecCSInvalidAttributeValues: OSStatus = -67066;
/// Code signing host has no guest code with the requested attributes.
pub const errSecCSNoSuchCode: OSStatus = -67065;
/// Code signing host has more than one block of guest code with this attribute value.
pub const errSecCSMultipleGuests: OSStatus = -67064;
/// The identity of guest code has been invalidated.
pub const errSecCSGuestInvalid: OSStatus = -67063;
/// Code object is not signed.
pub const errSecCSUnsigned: OSStatus = -67062;
/// Code or signature modified.
pub const errSecCSSignatureFailed: OSStatus = -67061;
/// Signature cannot be read.
///
/// ## Discussion
///
/// This error might be due to a filesystem that maps root to an unprivileged user, for example.
///
///
pub const errSecCSSignatureNotVerifiable: OSStatus = -67060;
/// Unsupported type or version of signature.
pub const errSecCSSignatureUnsupported: OSStatus = -67059;
/// A required information property list (Info.plist) file or resource is malformed.
pub const errSecCSBadDictionaryFormat: OSStatus = -67058;
/// Resources are not sealed by the signature.
pub const errSecCSResourcesNotSealed: OSStatus = -67057;
/// Cannot find sealed resources in code.
pub const errSecCSResourcesNotFound: OSStatus = -67056;
/// The sealed resource directory is invalid.
pub const errSecCSResourcesInvalid: OSStatus = -67055;
/// A sealed resource is missing or invalid.
pub const errSecCSBadResource: OSStatus = -67054;
/// Invalid resource selection rule or rules.
pub const errSecCSResourceRulesInvalid: OSStatus = -67053;
/// Invalid or corrupted code requirements.
pub const errSecCSReqInvalid: OSStatus = -67052;
/// Unsupported type or version of code requirements.
pub const errSecCSReqUnsupported: OSStatus = -67051;
/// The code failed to satisfy one of the code requirements.
pub const errSecCSReqFailed: OSStatus = -67050;
/// The object file format invalid or unsuitable.
pub const errSecCSBadObjectFormat: OSStatus = -67049;
/// Internal error in Code Signing Services subsystem.
pub const errSecCSInternalError: OSStatus = -67048;
/// Code rejected its host.
///
/// ## Discussion
///
/// This error indicates that there’s an internal requirement in the signature on the guest code that specifies conditions that the code host must meet, and the host failed to meet that requirement. For example, if the guest requires that the host be signed by Apple and it wasn’t, the system returns this error when validating requirements.
///
///
pub const errSecCSHostReject: OSStatus = -67047;
/// This code is not a code signing host.
pub const errSecCSNotAHost: OSStatus = -67046;
/// Invalid format for signature.
pub const errSecCSSignatureInvalid: OSStatus = -67045;
/// Host protocol violation: absolute guest path required.
pub const errSecCSHostProtocolRelativePath: OSStatus = -67044;
/// Host protocol violation: contradictory hosting modes.
pub const errSecCSHostProtocolContradiction: OSStatus = -67043;
/// Host protocol violation: operation not allowed with or for a dedicated guest.
pub const errSecCSHostProtocolDedicationError: OSStatus = -67042;
/// Host protocol violation: proxy hosting not engaged.
pub const errSecCSHostProtocolNotProxy: OSStatus = -67041;
/// Host protocol violation: invalid guest state change request.
pub const errSecCSHostProtocolStateError: OSStatus = -67040;
/// Host protocol violation: the specified code is not a guest of the specified code signing host.
pub const errSecCSHostProtocolUnrelated: OSStatus = -67039;
/// Operation not supported for this type of code.
pub const errSecCSNotSupported: OSStatus = -67037;
/// The signature is too large to embed.
pub const errSecCSCMSTooLarge: OSStatus = -67036;
/// Host protocol violation: invalid hash of guest code.
pub const errSecCSHostProtocolInvalidHash: OSStatus = -67035;
/// The code on disk has been modified after the code started running.
pub const errSecCSStaticCodeChanged: OSStatus = -67034;
/// Access to signature database denied.
///
/// ## Database
///
/// This error is returned when the system is attempting to sign unsigned code ad-hoc and couldn’t write to the signature database because of a permission problem.
///
///
pub const errSecCSDBDenied: OSStatus = -67033;
/// Cannot access signature database.
///
/// ## Discussion
///
/// This error is returned when the system is attempting to sign unsigned code ad-hoc and couldn’t write to the signature database because of some problem other than a permission problem. For example, the signature database might be missing or corrupted.
///
///
pub const errSecCSDBAccess: OSStatus = -67032;
/// Access to signature database denied.
///
/// ## Discussion
///
/// This error is returned when the system is attempting to sign unsigned code ad-hoc and couldn’t write to the signature database because of a permission problem.
///
///
pub const errSecCSSigDBDenied: OSStatus = -67033;
/// Can’t access signature database.
///
/// ## Discussion
///
/// This error is returned when the system is attempting to sign unsigned code ad-hoc and couldn’t write to the signature database because of some problem other than a permission problem. For example, the signature database might be missing or corrupted.
///
///
pub const errSecCSSigDBAccess: OSStatus = -67032;
/// Code signing host returned invalid or inconsistent attributes for guest code.
pub const errSecCSHostProtocolInvalidAttribute: OSStatus = -67031;
/// The Info.plist file or the signature has been modified.
pub const errSecCSInfoPlistFailed: OSStatus = -67030;
/// The code has no main executable file.
pub const errSecCSNoMainExecutable: OSStatus = -67029;
/// The bundle format is unrecognized, invalid, or unsuitable.
pub const errSecCSBadBundleFormat: OSStatus = -67028;
/// No matches were found for a search or update operation.
pub const errSecCSNoMatches: OSStatus = -67027;
/// File open or execution not allowed.
///
/// ## Discussion
///
/// File has quarantine flags indicating that it should not be opened or executed under any circumstances. This usually occurs because the file was downloaded by a sandboxed application that does not have file download entitlements.
///
///
pub const errSecCSFileHardQuarantined: OSStatus = -67026;
/// The presented data is out of date.
pub const errSecCSOutdated: OSStatus = -67025;
/// A system database or file is corrupt.
pub const errSecCSDbCorrupt: OSStatus = -67024;
/// A directory or its signature has been modified and is therefore invalid.
pub const errSecCSResourceDirectoryFailed: OSStatus = -67023;
/// Nested code is unsigned.
pub const errSecCSUnsignedNestedCode: OSStatus = -67022;
/// The nested code is modified or invalid.
pub const errSecCSBadNestedCode: OSStatus = -67021;
/// The monitor callback returned invalid value.
pub const errSecCSBadCallbackValue: OSStatus = -67020;
/// The codesign_allocate helper tool can’t be found or used.
pub const errSecCSHelperFailed: OSStatus = -67019;
pub const errSecCSVetoed: OSStatus = -67018;
/// The library validation flag cannot be used with an i386 binary.
pub const errSecCSBadLVArch: OSStatus = -67017;
/// Found an unsupported resource.
///
/// ## Discussion
///
/// Resources other than directories, plain files, and symbolic links are not supported.
///
///
pub const errSecCSResourceNotSupported: OSStatus = -67016;
/// The main executable or Info.plist must be a regular file (and not, for example, a symbolic link).
pub const errSecCSRegularFile: OSStatus = -67015;
/// Unsealed contents present in the bundle root.
pub const errSecCSUnsealedAppRoot: OSStatus = -67014;
/// The resource envelope is obsolete (custom omit rules).
pub const errSecCSWeakResourceRules: OSStatus = -67013;
/// A `.DS_Store` file can’t be a symlink.
pub const errSecCSDSStoreSymlink: OSStatus = -67012;
/// The bundle could be an app or a framework.
pub const errSecCSAmbiguousBundleFormat: OSStatus = -67011;
/// The main executable failed strict validation.
pub const errSecCSBadMainExecutable: OSStatus = -67010;
/// The embedded framework contains a modified or invalid version.
pub const errSecCSBadFrameworkVersion: OSStatus = -67009;
/// Unsealed contents present in the root directory of an embedded framework.
pub const errSecCSUnsealedFrameworkRoot: OSStatus = -67008;
/// The resource envelope is obsolete (version 1 signature).
pub const errSecCSWeakResourceEnvelope: OSStatus = -67007;
/// The operation was terminated by explicit cancellation.
pub const errSecCSCancelled: OSStatus = -67006;
/// Invalid platform identifier or platform mismatch.
pub const errSecCSInvalidPlatform: OSStatus = -67005;
/// The code is too big for current signing format.
pub const errSecCSTooBig: OSStatus = -67004;
/// Invalid destination for symbolic link in bundle.
pub const errSecCSInvalidSymlink: OSStatus = -67003;
/// The code is valid but does not seem to be an app.
pub const errSecCSNotAppLike: OSStatus = -67002;
/// The disk image format unrecognized, invalid, or unsuitable.
pub const errSecCSBadDiskImageFormat: OSStatus = -67001;
/// The signature digest algorithm(s) specified are not supported.
pub const errSecCSUnsupportedDigestAlgorithm: OSStatus = -67000;
/// Resource fork, Finder information, or similar detritus not allowed.
pub const errSecCSInvalidAssociatedFileData: OSStatus = -66999;
/// A Team Identifier string is invalid.
pub const errSecCSInvalidTeamIdentifier: OSStatus = -66998;
/// A Team Identifier is wrong or inappropriate.
pub const errSecCSBadTeamIdentifier: OSStatus = -66997;
/// The signature is valid but signer isn’t trusted.
pub const errSecCSSignatureUntrusted: OSStatus = -66996;
/// The image contains multiple executable segments.
pub const errSecMultipleExecSegments: OSStatus = -66995;
/// Encountered an invalid entitlement plist.
pub const errSecCSInvalidEntitlements: OSStatus = -66994;
/// An invalid runtime version was explicity set.
pub const errSecCSInvalidRuntimeVersion: OSStatus = -66993;
/// Notarization indicates this code has been revoked.
pub const errSecCSRevokedNotarization: OSStatus = -66992;
pub const errSecCSCMSConstructionFailed: OSStatus = -66991;
pub const errSecCSRemoteSignerFailed: OSStatus = -66990;

extern "C" {
    /// A key whose value is a string containing the name of the architecture that is causing the problem.
    pub static kSecCFErrorArchitecture: &'static CFString;
}

extern "C" {
    /// A key whose value is a string containing a regular expression that’s part of a resource specification that did not parse correctly.
    ///
    /// ## Discussion
    ///
    /// A resource specification is an information property list (`Info.plist` file) that says which files are resources and which are not. This error is returned if any part of the resource specification can’t be parsed.
    ///
    ///
    pub static kSecCFErrorPattern: &'static CFString;
}

extern "C" {
    /// A key whose value is a Core Foundation object containing the part of the resource seal that had a problem.
    ///
    /// ## Discussion
    ///
    /// The `CodeResources` file that gets generated as part of the code signing process serves as the bundle’s seal. This file is a CFDictionary that contains a listing of all the files found within your bundle coupled with their respective hash values and a set of rule definitions. The type of object returned depends on which item in the dictionary had a problem. See [macOS Code Signing In Depth](https://developer.apple.com/library/archive/technotes/tn2206/_index.html#//apple_ref/doc/uid/DTS40007919) for more information on the `CodeResources` file.
    ///
    ///
    pub static kSecCFErrorResourceSeal: &'static CFString;
}

extern "C" {
    /// A key whose value is a URL pointing to the resource on disk that is not included in the signed resources for the code.
    ///
    /// ## Discussion
    ///
    /// This key is present when an unsealed resource is found.
    ///
    ///
    pub static kSecCFErrorResourceAdded: &'static CFString;
}

extern "C" {
    /// A key whose value is a URL pointing to the resource on disk that has been altered.
    ///
    /// ## Discussion
    ///
    /// This key is present when a modified resource is found.
    ///
    ///
    pub static kSecCFErrorResourceAltered: &'static CFString;
}

extern "C" {
    /// A key whose value is a URL indicating the location of the missing resource as it is specified in the `CodeResources` file.
    ///
    /// ## Discussion
    ///
    /// This key is present when a non-optional sealed resource is missing.
    ///
    ///
    pub static kSecCFErrorResourceMissing: &'static CFString;
}

extern "C" {
    /// A key whose value is a URL representing a sealed resource with invalid sideband data (resource fork, etc.).
    pub static kSecCFErrorResourceSideband: &'static CFString;
}

extern "C" {
    pub static kSecCFErrorResourceRecursive: &'static CFString;
}

extern "C" {
    /// A key whose value is a Core Foundation object identifying the invalid component or key in the dictionary.
    ///
    /// ## Discussion
    ///
    /// This key is present when the `Info.plist` dictionary or other component has been found to be invalid.
    ///
    ///
    pub static kSecCFErrorInfoPlist: &'static CFString;
}

extern "C" {
    /// A key whose value is a Core Foundation object containing an attribute that is unrecognized or that contains a value of the wrong type.
    ///
    /// ## Discussion
    ///
    /// This key is present when you pass a bad guest attribute to the [`SecHostCreateGuest`](https://developer.apple.com/documentation/security/sechostcreateguest) or [`SecHostSetGuestStatus`](https://developer.apple.com/documentation/security/sechostsetgueststatus) function.
    ///
    ///
    pub static kSecCFErrorGuestAttributes: &'static CFString;
}

extern "C" {
    /// A key whose value is a string containing a compilation error generated when parsing a requirement.
    ///
    /// ## Discussion
    ///
    /// This key is present when a call to the [`SecRequirementCreateWithStringAndErrors`](https://developer.apple.com/documentation/security/secrequirementcreatewithstringanderrors(_:_:_:_:)) function results in a compilation error during the processing of the code requirement string.
    ///
    ///
    pub static kSecCFErrorRequirementSyntax: &'static CFString;
}

extern "C" {
    /// A key whose value is a URL indicating the subcomponent containing the error.
    pub static kSecCFErrorPath: &'static CFString;
}

/// A code object representing signed code running on the system.
///
/// ## Overview
///
/// In many function calls, a value of type [`SecCodeRef`](https://developer.apple.com/documentation/security/seccode) can be passed to a parameter that is typed as a [`SecStaticCodeRef`](https://developer.apple.com/documentation/security/secstaticcode). In these cases, the function performs an implicit call to the [`SecCodeCopyStaticCode`](https://developer.apple.com/documentation/security/seccodecopystaticcode(_:_:_:)) function and operates on the result.
///
///
/// This is the type of a reference to running code.
///
/// In many (but not all) calls, this can be passed to a SecStaticCodeRef
/// argument, which performs an implicit SecCodeCopyStaticCode call and
/// operates on the result.
#[doc(alias = "SecCodeRef")]
#[repr(C)]
pub struct SecCode {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl SecCode {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__SecCode"> for SecCode {}
);

/// A static code object representing signed code on disk.
///
/// ## Discussion
///
/// Compare with [`SecCodeRef`](https://developer.apple.com/documentation/security/seccode).
///
///
/// This is the type of a reference to static code on disk.
#[doc(alias = "SecStaticCodeRef")]
#[repr(C)]
pub struct SecStaticCode {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl SecStaticCode {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__SecCode"> for SecStaticCode {}
);

/// A code requirement object.
/// This is the type of a reference to a code requirement.
#[doc(alias = "SecRequirementRef")]
#[repr(C)]
pub struct SecRequirement {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl SecRequirement {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__SecRequirement"> for SecRequirement {}
);

/// A reference to a guest object, which identifies a particular block of guest code in the context of its code signing host.
///
/// ## Discussion
///
/// Guest handles are assigned by the host at will, with [`kSecNoGuest`](https://developer.apple.com/documentation/security/ksecnoguest) being reserved as the `NULL` value. They can be reused for new children if desired.
///
///
/// An abstract handle to identify a particular Guest in the context of its Host.
///
/// Guest handles are assigned by the host at will, with kSecNoGuest (zero) being
/// reserved as the null value. They can be reused for new children if desired.
pub type SecGuestRef = u32;

/// Not a valid `SecGuestRef` object.
///
/// ## Discussion
///
/// Some functions in the API use this value to indicate that there is no guest, and some functions use it to indicate that the function applies to the host itself rather than to a guest.
///
///
pub const kSecNoGuest: SecGuestRef = 0;

/// Values that can be used in the `flags` parameter to most code signing functions.
///
/// ## Overview
///
/// All of the bits in the [`SecCSFlags`](https://developer.apple.com/documentation/security/seccsflags) enumeration are reserved by Apple. If you set any bits not defined here, the behavior is undefined.
///
///
/// This is the type of flags arguments to Code Signing API calls.
/// It provides a bit mask of request and option flags. All of the bits in these
/// masks are reserved to Apple; if you set any bits not defined in these headers,
/// the behavior is generally undefined.
///
/// This list describes the flags that are shared among several Code Signing API calls.
/// Flags that only apply to one call are defined and documented with that call.
/// Global flags are assigned from high order down (31 -> 0); call-specific flags
/// are assigned from the bottom up (0 -> 31).
///
///
/// When passed to a flags argument throughout, indicates that default behavior
/// is desired. Do not mix with other flags values.
///
/// When passed to a call that performs code validation, requests that code signatures
/// made by expired certificates be rejected. By default, expiration of participating
/// certificates is not automatic grounds for rejection.
///
/// When passed to a call that performs code validation, configures the validation to
/// not perform any work that requires the network. Using this flag disables security features
/// like online certificate revocation and notarization checks by removing potentially
/// slow network requests that can delay evaluations. This flag has always been usable for
/// SecStaticCode objects and is usable with SecCode objects starting with macOS 11.3.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecCSFlags(pub u32);
bitflags::bitflags! {
    impl SecCSFlags: u32 {
/// No flags (use the default behavior).
///
/// ## Discussion
///
/// Do not mix this value with other flag values.
///
///
        #[doc(alias = "kSecCSDefaultFlags")]
        const DefaultFlags = 0;
/// Consider expired certificates invalid.
///
/// ## Discussion
///
/// When passed to a function that performs code validation, this flag requests that code signatures made by expired certificates be rejected. By default, expiration of participating certificates is not automatic grounds for rejection.
///
///
        #[doc(alias = "kSecCSConsiderExpiration")]
        const ConsiderExpiration = 1<<31;
///
/// ## Discussion
///
/// Forces checking of certificates against revocation lists or OCSP (online certificate status protocol) regardless of preference settings.
///
///
        #[doc(alias = "kSecCSEnforceRevocationChecks")]
        const EnforceRevocationChecks = 1<<30;
        #[doc(alias = "kSecCSNoNetworkAccess")]
        const NoNetworkAccess = 1<<29;
        #[doc(alias = "kSecCSReportProgress")]
        const ReportProgress = 1<<28;
        #[doc(alias = "kSecCSCheckTrustedAnchors")]
        const CheckTrustedAnchors = 1<<27;
        #[doc(alias = "kSecCSQuickCheck")]
        const QuickCheck = 1<<26;
        #[doc(alias = "kSecCSApplyEmbeddedPolicy")]
        const ApplyEmbeddedPolicy = 1<<25;
        #[doc(alias = "kSecCSStripDisallowedXattrs")]
        const StripDisallowedXattrs = 1<<24;
        #[doc(alias = "kSecCSMatchGuestRequirementInKernel")]
        const MatchGuestRequirementInKernel = 1<<23;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecCSFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecCSFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Specify option flags that can be embedded in a code signature during signing and that govern the use of the signature.
///
/// ## Overview
///
/// Some of these flags can be set through the `codesign(1)` command’s `--options` argument and some are set implicitly based on signing circumstances. The flags here appear as the value associated with the [`kSecCodeInfoFlags`](https://developer.apple.com/documentation/security/kseccodeinfoflags) key in the signing information dictionary. See [Signing Information Dictionary Keys](https://developer.apple.com/documentation/security/signing-information-dictionary-keys).
///
///
/// This is the type of option flags that can be embedded in a code signature
/// during signing, and that govern the use of the signature thereafter.
/// Some of these flags can be set through the codesign(1) command's --options
/// argument; some are set implicitly based on signing circumstances; and all
/// can be set with the kSecCodeSignerFlags item of a signing information dictionary.
///
///
/// Indicates that the code may act as a host that controls and supervises guest
/// code. If this flag is not set in a code signature, the code is never considered
/// eligible to be a host, and any attempt to act like one will be ignored or rejected.
///
/// The code has been sealed without a signing identity. No identity may be retrieved
/// from it, and any code requirement placing restrictions on the signing identity
/// will fail. This flag is set by the code signing API and cannot be set explicitly.
///
/// Implicitly set the "hard" status bit for the code when it starts running.
/// This bit indicates that the code prefers to be denied access to a resource
/// if gaining such access would cause its invalidation. Since the hard bit is
/// sticky, setting this option bit guarantees that the code will always have
/// it set.
///
/// Implicitly set the "kill" status bit for the code when it starts running.
/// This bit indicates that the code wishes to be terminated with prejudice if
/// it is ever invalidated. Since the kill bit is sticky, setting this option bit
/// guarantees that the code will always be dynamically valid, since it will die
/// immediately    if it becomes invalid.
///
/// Forces the kSecCSConsiderExpiration flag on all validations of the code.
///
/// Instructs the kernel to apply runtime hardening policies as required by the
/// hardened runtime version
///
/// The code was automatically signed by the linker. This signature should be
/// ignored in any new signing operation.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecCodeSignatureFlags(pub u32);
bitflags::bitflags! {
    impl SecCodeSignatureFlags: u32 {
/// May host guest code.
///
/// ## Discussion
///
/// Indicates that the code may act as a host that controls and supervises guest code. If this flag is not set in a code signature, the code is never considered eligible to be a host, and any attempt to act like one is ignored or rejected.
///
///
        #[doc(alias = "kSecCodeSignatureHost")]
        const Host = 0x0001;
/// Must be used without a signing identity.
///
/// ## Discussion
///
/// The code has been sealed without a signing identity. No identity may be retrieved from it, and any code requirement placing restrictions on the signing identity will fail. This flag is set by Code Signing Services when you create an ad-hoc signature, and cannot be set explicitly. An ad-hoc signature is created by signing with the pseudo-identity “-” (a dash).
///
///
        #[doc(alias = "kSecCodeSignatureAdhoc")]
        const Adhoc = 0x0002;
/// Always set the [`kSecCodeStatusHard`](https://developer.apple.com/documentation/security/seccodestatus/hard) status flag on launch.
///
/// ## Discussion
///
/// The `kSecCodeStatusHard` flag indicates that the code prefers to be denied access to a resource if gaining such access would cause its invalidation. Once the hard bit is set, it cannot be cleared. Therefore, setting this option flag guarantees that the code will always have the `kSecCodeStatusHard` flag set.
///
///
        #[doc(alias = "kSecCodeSignatureForceHard")]
        const ForceHard = 0x0100;
/// Always set the termination status flag on launch.
///
/// ## Discussion
///
/// The `kSecCodeStatusKill` flag indicates that the code wishes to be terminated if it is ever invalidated. Once this is set, it cannot be cleared. Therefore, setting this option flag guarantees that the running code will always be valid, since it will die immediately if it becomes invalid.
///
///
        #[doc(alias = "kSecCodeSignatureForceKill")]
        const ForceKill = 0x0200;
/// Always set the [`kSecCSConsiderExpiration`](https://developer.apple.com/documentation/security/seccsflags/considerexpiration) flag when validating the code.
///
/// ## Discussion
///
/// When passed to a function that performs code validation, the `kSecCSConsiderExpiration` flag requests that code signatures made by expired certificates be rejected. By default, expiration of participating certificates is not automatic grounds for rejection.
///
///
        #[doc(alias = "kSecCodeSignatureForceExpiration")]
        const ForceExpiration = 0x0400;
/// Restrict dyld loading.
        #[doc(alias = "kSecCodeSignatureRestrict")]
        const Restrict = 0x0800;
/// Enforce code signing.
        #[doc(alias = "kSecCodeSignatureEnforcement")]
        const Enforcement = 0x1000;
/// Require library validation.
        #[doc(alias = "kSecCodeSignatureLibraryValidation")]
        const LibraryValidation = 0x2000;
/// Apply runtime hardening policies as required by the hardened runtime version.
        #[doc(alias = "kSecCodeSignatureRuntime")]
        const Runtime = 0x10000;
        #[doc(alias = "kSecCodeSignatureLinkerSigned")]
        const LinkerSigned = 0x20000;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecCodeSignatureFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecCodeSignatureFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Operational flags attached by code signing services to running code.
///
/// ## Overview
///
/// These flags are maintained by the code’s host, and can be read by anyone. Running code may change its own flags, and root may change anyone’s flags. However, each of these flags can change in only one direction and never back, for the lifetime of the code. Not even root can violate this restriction.
///
/// All of the bits in the [`SecCodeStatus`](https://developer.apple.com/documentation/security/seccodestatus) enumeration are reserved by Apple. If you set any bits not defined here, the behavior is undefined.
///
///
/// The code signing system attaches a set of status flags to each running code.
/// These flags are maintained by the code's host, and can be read by anyone.
/// A code may change its own flags, a host may change its guests' flags,
/// and root may change anyone's flags.    However, these flags are sticky in that
/// each can change in only one direction (and never back, for the lifetime of the code).
/// Not even root can violate this restriction.
///
/// There are other flags in SecCodeStatus that are not publicly documented.
/// Do not rely on them, and do not ever attempt to explicitly set them.
///
///
/// Indicates that the code is dynamically valid, i.e. it started correctly
/// and has not been invalidated since then. The valid bit can only be cleared.
///
/// Warning: This bit is not your one-stop shortcut to determining the validity    of code.
/// It represents the dynamic component of the full validity function; if this
/// bit is unset, the code is definitely invalid, but the converse is not always true.
/// In fact, code hosts may represent the outcome of some delayed static validation work in this bit,
/// and thus it strictly represents a blend of (all of) dynamic and (some of) static validity,
/// depending on the implementation of the particular host managing the code. You can (only)
/// rely that (1) dynamic invalidation will clear this bit; and (2) the combination
/// of static validation and dynamic validity (as performed by the SecCodeCheckValidity* APIs)
/// will give a correct answer.
///
///
/// Indicates that the code prefers to be denied access to resources if gaining access
/// would invalidate it. This bit can only be set.
/// It is undefined whether code that is marked hard and is already invalid will still
/// be denied access to a resource that would invalidate it if it were still valid. That is,
/// the code may or may not get access to such a resource while being invalid, and that choice
/// may appear random.
///
///
/// Indicates that the code wants to be killed (terminated) if it ever loses its validity.
/// This bit can only be set. Code that has the kill flag set will never be dynamically invalid
/// (and live). Note however that a change in static validity does not necessarily trigger instant
/// death.
///
///
/// Indicated that code has been debugged by another process that was allowed to do so. The debugger
/// causes this to be set when it attachs.
///
///
/// Indicates the code is platform code, shipping with the operating system and signed by Apple.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecCodeStatus(pub u32);
bitflags::bitflags! {
    impl SecCodeStatus: u32 {
/// The code is dynamically valid.
///
/// ## Discussion
///
/// Code that’s dynamically valid is running code that started properly signed and has not been invalidated since it started. The valid bit can not be set on running code; it can only be cleared. If you do not set the `kSecCodeStatusValid` flag during creation of the guest with the [`SecCodeGetTypeID`](https://developer.apple.com/documentation/security/seccodegettypeid()) function, then the new guest is created dynamically invalid and can never become dynamically valid. Note that this bit does not make any representations about the static validity of the code.
///
///
        #[doc(alias = "kSecCodeStatusValid")]
        const Valid = 0x00000001;
/// The code prefers to be denied access to resources if gaining access would invalidate it.
///
/// ## Discussion
///
/// This bit can not be cleared on running code; it can only be set. It is undefined whether code that has the hard flag set but that starts out with the valid bit cleared (that is, it’s already invalid) will still be denied access to a resource that would invalidate it if it were still valid. That is, the code may or may not get access to such a resource while being invalid.
///
///
        #[doc(alias = "kSecCodeStatusHard")]
        const Hard = 0x00000100;
/// The code wants to be terminated if it ever loses its validity.
///
/// ## Discussion
///
/// This bit can not be cleared on running code; it can only be set. Running code that has this flag set is guaranteed to be valid, because if it were invalid it would have been terminated.
///
///
        #[doc(alias = "kSecCodeStatusKill")]
        const Kill = 0x00000200;
/// The code has been debugged by another process that was allowed to do so.
///
/// ## Discussion
///
/// The debugger sets this flag when it attaches.
///
///
        #[doc(alias = "kSecCodeStatusDebugged")]
        const Debugged = 0x10000000;
/// The code ships with the operating system and is signed by Apple.
        #[doc(alias = "kSecCodeStatusPlatform")]
        const Platform = 0x04000000;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecCodeStatus {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecCodeStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An enumeration indicating different types of internal requirements for code.
///
/// ## Overview
///
/// These constants are indexes into requirement sets and are not currently used in any public API.
///
///
/// An enumeration indicating different types of internal requirements for code.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SecRequirementType(pub u32);
impl SecRequirementType {
    /// What hosts may run this code.
    #[doc(alias = "kSecHostRequirementType")]
    pub const HostRequirementType: Self = Self(1);
    /// What guests this code may run.
    #[doc(alias = "kSecGuestRequirementType")]
    pub const GuestRequirementType: Self = Self(2);
    /// A designated requirement.
    #[doc(alias = "kSecDesignatedRequirementType")]
    pub const DesignatedRequirementType: Self = Self(3);
    /// What libraries this code may link against.
    #[doc(alias = "kSecLibraryRequirementType")]
    pub const LibraryRequirementType: Self = Self(4);
    /// What plug-ins this code may load.
    #[doc(alias = "kSecPluginRequirementType")]
    pub const PluginRequirementType: Self = Self(5);
    /// Invalid type of requirement.
    ///
    /// ## Discussion
    ///
    /// This constant is for Apple internal use.
    ///
    ///
    #[doc(alias = "kSecInvalidRequirementType")]
    pub const InvalidRequirementType: Self = Self(6);
    /// The number of valid requirement types.
    ///
    /// ## Discussion
    ///
    /// This constant is for Apple internal use.
    ///
    ///
    #[doc(alias = "kSecRequirementTypeCount")]
    pub const RequirementTypeCount: Self = Self(SecRequirementType::InvalidRequirementType.0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecRequirementType {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecRequirementType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The list of digest algorithms available for code signatures.
///
/// ## Overview
///
/// Use these values with the [`kSecCodeInfoDigestAlgorithm`](https://developer.apple.com/documentation/security/kseccodeinfodigestalgorithm) and [`kSecCodeInfoDigestAlgorithms`](https://developer.apple.com/documentation/security/kseccodeinfodigestalgorithms) keys described in [Signing Information Dictionary Keys](https://developer.apple.com/documentation/security/signing-information-dictionary-keys).
///
///
/// Types of cryptographic digests (hashes) used to hold code signatures
/// together.
///
/// Each combination of type, length, and other parameters is a separate
/// hash type; we don't understand "families" here.
///
/// These type codes govern the digest links that connect a CodeDirectory
/// to its subordinate data structures (code pages, resources, etc.)
/// They do not directly control other uses of hashes (such as those used
/// within X.509 certificates and CMS blobs).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecCSDigestAlgorithm(pub u32);
impl SecCSDigestAlgorithm {
    #[doc(alias = "kSecCodeSignatureNoHash")]
    pub const CodeSignatureNoHash: Self = Self(0);
    #[doc(alias = "kSecCodeSignatureHashSHA1")]
    pub const CodeSignatureHashSHA1: Self = Self(1);
    #[doc(alias = "kSecCodeSignatureHashSHA256")]
    pub const CodeSignatureHashSHA256: Self = Self(2);
    #[doc(alias = "kSecCodeSignatureHashSHA256Truncated")]
    pub const CodeSignatureHashSHA256Truncated: Self = Self(3);
    #[doc(alias = "kSecCodeSignatureHashSHA384")]
    pub const CodeSignatureHashSHA384: Self = Self(4);
    #[doc(alias = "kSecCodeSignatureHashSHA512")]
    pub const CodeSignatureHashSHA512: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecCSDigestAlgorithm {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecCSDigestAlgorithm {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
