//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "SecBase")]
unsafe impl ConcreteType for SecIdentity {
    /// Returns the unique identifier of the opaque type to which an identity object belongs.
    ///
    /// ## Return Value
    ///
    /// A value that identifies the opaque type of a [`SecIdentityRef`](https://developer.apple.com/documentation/security/secidentity) object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns a value that uniquely identifies the opaque type of a [`SecIdentityRef`](https://developer.apple.com/documentation/security/secidentity) object. You can compare this value to the [`CFTypeID`](https://developer.apple.com/documentation/corefoundation/cftypeid) identifier obtained by calling the [`CFGetTypeID`](https://developer.apple.com/documentation/corefoundation/cfgettypeid(_:)) function on a specific object. These values might change from release to release or platform to platform.
    ///
    ///
    /// Returns the type identifier of SecIdentity instances.
    ///
    /// Returns: The CFTypeID of SecIdentity instances.
    #[doc(alias = "SecIdentityGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecIdentityGetTypeID() -> CFTypeID;
        }
        unsafe { SecIdentityGetTypeID() }
    }
}

#[cfg(feature = "SecBase")]
impl SecIdentity {
    ///
    /// Parameters:
    /// - allocator: CFAllocator to allocate the identity object. Pass NULL to use the default allocator.
    ///
    /// - certificate: A certificate reference.
    ///
    /// - privateKey: A private key reference.
    ///
    ///
    /// ## Return Value
    ///
    /// An identity reference.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Create a new identity object from the provided certificate and its associated private key.
    ///
    /// This interface returns null if the private does not key correspond to the public key in the certifcate.
    ///
    ///
    /// create a new identity object from the provided certificate and its associated private key.
    ///
    /// Parameter `allocator`: CFAllocator to allocate the identity object. Pass NULL to use the default allocator.
    ///
    /// Parameter `certificate`: A certificate reference.
    ///
    /// Parameter `privateKey`: A private key reference.
    ///
    /// Returns: An identity reference.
    ///
    /// This interface returns null if the private does not key correspond to the public key in the certifcate.
    #[doc(alias = "SecIdentityCreate")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        certificate: &SecCertificate,
        private_key: &SecKey,
    ) -> Option<CFRetained<SecIdentity>> {
        extern "C-unwind" {
            fn SecIdentityCreate(
                allocator: Option<&CFAllocator>,
                certificate: &SecCertificate,
                private_key: &SecKey,
            ) -> Option<NonNull<SecIdentity>>;
        }
        let ret = unsafe { SecIdentityCreate(allocator, certificate, private_key) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new identity for a certificate and its associated private key.
    ///
    /// Parameters:
    /// - keychainOrArray: A reference to a keychain or an array of keychains to search for the associated private key. Specify `NULL` to search the user’s default keychain search list.
    ///
    /// - certificateRef: The certificate for which you want to create an identity.
    ///
    /// - identityRef: On return, an identity object for the certificate and its associated private key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the associated private key is not found in one of the specified keychains, this function fails with an appropriate error code (usually [`errSecItemNotFound`](https://developer.apple.com/documentation/security/errsecitemnotfound)), and does not return anything in the `identityRef` parameter.
    ///
    ///
    /// Creates a new identity reference for the given certificate, assuming the associated private key is in one of the specified keychains.
    ///
    /// Parameter `keychainOrArray`: A reference to an array of keychains to search, a single keychain, or NULL to search the user's default keychain search list.
    ///
    /// Parameter `certificateRef`: A certificate reference.
    ///
    /// Parameter `identityRef`: On return, an identity reference. You are responsible for releasing this reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// - `keychain_or_array` should be of the correct type.
    /// - `identity_ref` must be a valid pointer.
    #[doc(alias = "SecIdentityCreateWithCertificate")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn create_with_certificate(
        keychain_or_array: Option<&CFType>,
        certificate_ref: &SecCertificate,
        identity_ref: NonNull<*mut SecIdentity>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentityCreateWithCertificate(
                keychain_or_array: Option<&CFType>,
                certificate_ref: &SecCertificate,
                identity_ref: NonNull<*mut SecIdentity>,
            ) -> OSStatus;
        }
        unsafe {
            SecIdentityCreateWithCertificate(keychain_or_array, certificate_ref, identity_ref)
        }
    }

    /// Retrieves a certificate associated with an identity.
    ///
    /// Parameters:
    /// - identityRef: The identity object for the identity whose certificate you wish to retrieve.
    ///
    /// - certificateRef: On return, points to the certificate object associated with the specified identity. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// An identity is a digital certificate together with its associated private key.
    ///
    /// For a certificate in a keychain, you can cast the `SecCertificateRef` data type to a `SecKeychainItemRef` for use with Keychain Services functions.
    ///
    ///
    /// Returns a reference to a certificate for the given identity
    /// reference.
    ///
    /// Parameter `identityRef`: An identity reference.
    ///
    /// Parameter `certificateRef`: On return, a pointer to the found certificate
    /// reference. You are responsible for releasing this reference by calling
    /// the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// `certificate_ref` must be a valid pointer.
    #[doc(alias = "SecIdentityCopyCertificate")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn copy_certificate(
        &self,
        certificate_ref: NonNull<*mut SecCertificate>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentityCopyCertificate(
                identity_ref: &SecIdentity,
                certificate_ref: NonNull<*mut SecCertificate>,
            ) -> OSStatus;
        }
        unsafe { SecIdentityCopyCertificate(self, certificate_ref) }
    }

    /// Retrieves the private key associated with an identity.
    ///
    /// Parameters:
    /// - identityRef: The identity object for the identity whose private key you wish to retrieve.
    ///
    /// - privateKeyRef: On return, points to the private key object for the specified identity. The private key must be of class type [`kSecPrivateKeyItemClass`](https://developer.apple.com/documentation/security/secitemclass/privatekeyitemclass). In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// An identity is a digital certificate together with its associated private key.
    ///
    ///
    /// Returns the private key associated with an identity.
    ///
    /// Parameter `identityRef`: An identity reference.
    ///
    /// Parameter `privateKeyRef`: On return, a pointer to the private key for the given
    /// identity. On iOS, the private key must be of class type kSecAppleKeyItemClass.
    /// You are responsible for releasing this reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// `private_key_ref` must be a valid pointer.
    #[doc(alias = "SecIdentityCopyPrivateKey")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn copy_private_key(&self, private_key_ref: NonNull<*mut SecKey>) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentityCopyPrivateKey(
                identity_ref: &SecIdentity,
                private_key_ref: NonNull<*mut SecKey>,
            ) -> OSStatus;
        }
        unsafe { SecIdentityCopyPrivateKey(self, private_key_ref) }
    }

    /// Returns the preferred identity for the specified name and key use.
    ///
    /// Parameters:
    /// - name: A string containing a URI, RFC822 email address, DNS hostname, or other name that uniquely identifies the service requiring an identity.
    ///
    /// - keyUsage: A key use value, as defined in `Security.framework/cssmtype.h`. Pass `0` if you don’t want to specify a particular key use.
    ///
    /// - validIssuers: An array of `CFDataRef` instances whose contents are the subject names of allowable issuers, as returned by a call to `SSLCopyDistinguishedNames` (`Security.framework/SecureTransport.h`). Pass `NULL` if you don’t want to limit the search to specific issuers.
    ///
    /// - identity: On return, a reference to the preferred identity, or `NULL` if none was found. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If a preferred identity has not been set for the specified name, the returned identity reference is `NULL`. You should then typically perform a search for possible identities, using [`SecIdentitySearchCreate`](https://developer.apple.com/documentation/security/secidentitysearchcreate) and [`SecIdentitySearchCopyNext`](https://developer.apple.com/documentation/security/secidentitysearchcopynext), allowing the user to choose from a list if more than one is found.
    ///
    /// ### Special Considerations
    ///
    /// Use [`SecIdentityCopyPreferred(_:_:_:)`](https://developer.apple.com/documentation/security/secidentitycopypreferred(_:_:_:)) for new development instead.
    ///
    ///
    /// Returns the preferred identity for the specified name and key usage, optionally limiting the result to an identity issued by a certificate whose subject is one of the distinguished names in validIssuers. If a preferred identity does not exist, NULL is returned.
    ///
    /// Parameter `name`: A string containing a URI, RFC822 email address, DNS hostname, or other name which uniquely identifies the service requiring an identity.
    ///
    /// Parameter `keyUsage`: A CSSM_KEYUSE key usage value, as defined in cssmtype.h. Pass 0 to ignore this parameter.
    ///
    /// Parameter `validIssuers`: (optional) An array of CFDataRef instances whose contents are the subject names of allowable issuers, as returned by a call to SSLCopyDistinguishedNames (SecureTransport.h). Pass NULL if any issuer is allowed.
    ///
    /// Parameter `identity`: On return, a reference to the preferred identity, or NULL if none was found. You are responsible for releasing this reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7. Please use the SecIdentityCopyPreferred API instead.
    ///
    /// # Safety
    ///
    /// - `valid_issuers` generic must be of the correct type.
    /// - `identity` must be a valid pointer.
    #[doc(alias = "SecIdentityCopyPreference")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn copy_preference(
        name: &CFString,
        key_usage: CSSM_KEYUSE,
        valid_issuers: Option<&CFArray>,
        identity: NonNull<*mut SecIdentity>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentityCopyPreference(
                name: &CFString,
                key_usage: CSSM_KEYUSE,
                valid_issuers: Option<&CFArray>,
                identity: NonNull<*mut SecIdentity>,
            ) -> OSStatus;
        }
        unsafe { SecIdentityCopyPreference(name, key_usage, valid_issuers, identity) }
    }

    /// Retrieves the preferred identity for the specified name and key use.
    ///
    /// Parameters:
    /// - name: A string containing an email address (RFC 822) or other name for which a preferred identity is requested.
    ///
    /// - keyUsage: An array containing a list of usage attributes ([`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt), for example), or `NULL` if you do not want to request an identity for a particular usage. See Attribute Item Keys for a complete list of possible usage attributes.
    ///
    /// - validIssuers: An array of `CFDataRef` objects whose contents are the subject names of allowable issuers, as returned by a call to [`SSLCopyDistinguishedNames`](https://developer.apple.com/documentation/security/sslcopydistinguishednames(_:_:)). Pass `NULL` to allow any issuer.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns an identity, or `nil` if no identity from one of the specified issuers has been set as the preferred identity for the specified name and usage. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the identity’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If a preferred identity has not been set for the supplied name, this function returns `NULL`. Your code should then perform a search for possible identities by calling [`SecItemCopyMatching`](https://developer.apple.com/documentation/security/secitemcopymatching(_:_:)).
    ///
    ///
    /// Returns the preferred identity for the specified name and key usage, optionally limiting the result to an identity issued by a certificate whose subject is one of the distinguished names in validIssuers. If a preferred identity does not exist, NULL is returned.
    ///
    /// Parameter `name`: A string containing a URI, RFC822 email address, DNS hostname, or other name which uniquely identifies the service requiring an identity.
    ///
    /// Parameter `keyUsage`: A CFArrayRef value, containing items defined in SecItem.h  Pass NULL to ignore this parameter. (kSecAttrCanEncrypt, kSecAttrCanDecrypt, kSecAttrCanDerive, kSecAttrCanSign, kSecAttrCanVerify, kSecAttrCanWrap, kSecAttrCanUnwrap)
    ///
    /// Parameter `validIssuers`: (optional) An array of CFDataRef instances whose contents are the subject names of allowable issuers, as returned by a call to SSLCopyDistinguishedNames (SecureTransport.h). Pass NULL if any issuer is allowed.
    ///
    /// Returns: An identity or NULL, if the preferred identity has not been set. Your code should then typically perform a search for possible identities using the SecItem APIs.
    ///
    /// If a preferred identity has not been set for the supplied name, the returned identity reference will be NULL. Your code should then perform a search for possible identities, using the SecItemCopyMatching API. Note: in versions of macOS prior to 11.3, identity preferences are shared between processes running as the same user. Starting in 11.3, URI names are considered per-application preferences. An identity preference for a URI name may not be found if the calling application is different from the one which set the preference with SecIdentitySetPreferred.
    ///
    /// # Safety
    ///
    /// - `key_usage` generic must be of the correct type.
    /// - `valid_issuers` generic must be of the correct type.
    #[doc(alias = "SecIdentityCopyPreferred")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn preferred(
        name: &CFString,
        key_usage: Option<&CFArray>,
        valid_issuers: Option<&CFArray>,
    ) -> Option<CFRetained<SecIdentity>> {
        extern "C-unwind" {
            fn SecIdentityCopyPreferred(
                name: &CFString,
                key_usage: Option<&CFArray>,
                valid_issuers: Option<&CFArray>,
            ) -> Option<NonNull<SecIdentity>>;
        }
        let ret = unsafe { SecIdentityCopyPreferred(name, key_usage, valid_issuers) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets the preferred identity for the specified name and key use.
    ///
    /// Parameters:
    /// - identity: A reference to the preferred identity.
    ///
    /// - name: A string containing a URI, RFC822 email address, DNS host name, or other name that uniquely identifies a service requiring this identity.
    ///
    /// - keyUsage: A key use value, as defined in `Security.framework/cssmtype.h`. Pass `0` if you don’t want to specify a particular key use.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use [`SecIdentitySetPreferred(_:_:_:)`](https://developer.apple.com/documentation/security/secidentitysetpreferred(_:_:_:)) for new development instead.
    ///
    ///
    /// Sets the preferred identity for the specified name and key usage.
    ///
    /// Parameter `identity`: A reference to the identity which will be preferred.
    ///
    /// Parameter `name`: A string containing a URI, RFC822 email address, DNS hostname, or other name which uniquely identifies a service requiring this identity.
    ///
    /// Parameter `keyUsage`: A CSSM_KEYUSE key usage value, as defined in cssmtype.h. Pass 0 to specify any key usage.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7. Please use the SecIdentitySetPreferred API instead.
    #[doc(alias = "SecIdentitySetPreference")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn set_preference(&self, name: &CFString, key_usage: CSSM_KEYUSE) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentitySetPreference(
                identity: &SecIdentity,
                name: &CFString,
                key_usage: CSSM_KEYUSE,
            ) -> OSStatus;
        }
        unsafe { SecIdentitySetPreference(self, name, key_usage) }
    }

    /// Sets the identity that should be preferred for the specified name and key use.
    ///
    /// Parameters:
    /// - identity: The identity to set as preferred for the specified name and key usage.
    ///
    /// - name: A string containing an email address (RFC 822) or other name for which a preferred certificate is requested.
    ///
    /// - keyUsage: An array containing a list of usage attributes ([`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt), for example), or `NULL` if you want this identity to be preferred for any usage. See Attribute Item Keys for a complete list of possible usage attributes.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    /// Sets the preferred identity for the specified name and key usage.
    ///
    /// Parameter `identity`: A reference to the identity which will be preferred. If NULL is passed, any existing preference for the specified name is cleared instead.
    ///
    /// Parameter `name`: A string containing a URI, RFC822 email address, DNS hostname, or other name which uniquely identifies a service requiring this identity.
    ///
    /// Parameter `keyUsage`: A CFArrayRef value, containing items defined in SecItem.h  Pass NULL to specify any key usage. (kSecAttrCanEncrypt, kSecAttrCanDecrypt, kSecAttrCanDerive, kSecAttrCanSign, kSecAttrCanVerify, kSecAttrCanWrap, kSecAttrCanUnwrap)
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// Note: in versions of macOS prior to 11.3, identity preferences are shared between processes running as the same user. Starting in 11.3, URI names are considered per-application preferences. An identity preference for a URI name will be scoped to the application which created it, such that a subsequent call to SecIdentityCopyPreferred will only return it for that same application.
    ///
    /// # Safety
    ///
    /// `key_usage` generic must be of the correct type.
    #[doc(alias = "SecIdentitySetPreferred")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn set_preferred(
        identity: Option<&SecIdentity>,
        name: &CFString,
        key_usage: Option<&CFArray>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentitySetPreferred(
                identity: Option<&SecIdentity>,
                name: &CFString,
                key_usage: Option<&CFArray>,
            ) -> OSStatus;
        }
        unsafe { SecIdentitySetPreferred(identity, name, key_usage) }
    }

    /// Obtains the system identity associated with a specified domain.
    ///
    /// Parameters:
    /// - domain: The domain for which you want to find an identity, typically in reverse DNS notation, such as `com.apple.security`. You may also pass the values defined in [System Identity Domains](https://developer.apple.com/documentation/security/system-identity-domains).
    ///
    /// - idRef: On return, the identity object of the system-wide identity associated with the specified domain. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    /// - actualDomain: On return, the actual domain name of the returned identity object is returned here. This may be different from the requested domain. Pass `NULL` if you do not want this information.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If no system identity exists for the specified domain, a domain specific alternate may be returned instead. This is typically (but not exclusively) the system default identity. ([`kSecIdentityDomainDefault`](https://developer.apple.com/documentation/security/ksecidentitydomaindefault)).
    ///
    ///
    /// Obtain the system-wide SecIdentityRef associated with
    /// a specified domain.
    ///
    /// Parameter `domain`: Identifies the SecIdentityRef to be obtained, typically
    /// in the form "com.apple.subdomain...".
    ///
    /// Parameter `idRef`: On return, the system SecIdentityRef assicated with
    /// the specified domain. Caller must CFRelease this when
    /// finished with it.
    ///
    /// Parameter `actualDomain`: (optional) The actual domain name of the
    /// the returned identity is returned here. This
    /// may be different from the requested domain.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// If no system SecIdentityRef exists for the specified
    /// domain, a domain-specific alternate may be returned
    /// instead, typically (but not exclusively) the
    /// kSecIdentityDomainDefault SecIdentityRef.
    ///
    /// # Safety
    ///
    /// - `id_ref` must be a valid pointer.
    /// - `actual_domain` must be a valid pointer or null.
    #[doc(alias = "SecIdentityCopySystemIdentity")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn copy_system_identity(
        domain: &CFString,
        id_ref: NonNull<*mut SecIdentity>,
        actual_domain: *mut *const CFString,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentityCopySystemIdentity(
                domain: &CFString,
                id_ref: NonNull<*mut SecIdentity>,
                actual_domain: *mut *const CFString,
            ) -> OSStatus;
        }
        unsafe { SecIdentityCopySystemIdentity(domain, id_ref, actual_domain) }
    }

    /// Assigns the system identity to be associated with a specified domain.
    ///
    /// Parameters:
    /// - domain: The domain to which the specified identity will be assigned, typically in reverse DNS notation, such as `com.apple.security`.  You may also pass the values defined in [System Identity Domains](https://developer.apple.com/documentation/security/system-identity-domains).
    ///
    /// - idRef: The identity to be assigned to the specified domain. Pass `NULL` to delete any currently-assigned identity for the specified domain; in this case, it is not an error if no identity exists for the specified domain.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The caller must be running as root.
    ///
    ///
    /// Assign the supplied SecIdentityRef to the specified
    /// domain.
    ///
    /// Parameter `domain`: Identifies the domain to which the specified
    /// SecIdentityRef will be assigned.
    ///
    /// Parameter `idRef`: (optional) The identity to be assigned to the specified
    /// domain. Pass NULL to delete a possible entry for the specified
    /// domain; in this case, it is not an error if no identity
    /// exists for the specified domain.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// The caller must be running as root.
    #[doc(alias = "SecIdentitySetSystemIdentity")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn set_system_identity(domain: &CFString, id_ref: Option<&SecIdentity>) -> OSStatus {
        extern "C-unwind" {
            fn SecIdentitySetSystemIdentity(
                domain: &CFString,
                id_ref: Option<&SecIdentity>,
            ) -> OSStatus;
        }
        unsafe { SecIdentitySetSystemIdentity(domain, id_ref) }
    }
}

extern "C" {
    /// The system-wide default identity.
    pub static kSecIdentityDomainDefault: &'static CFString;
}

extern "C" {
    /// Kerberos Key Distribution Center (KDC) identity.
    pub static kSecIdentityDomainKerberosKDC: &'static CFString;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecIdentity::new`"]
#[inline]
pub unsafe extern "C-unwind" fn SecIdentityCreate(
    allocator: Option<&CFAllocator>,
    certificate: &SecCertificate,
    private_key: &SecKey,
) -> Option<CFRetained<SecIdentity>> {
    extern "C-unwind" {
        fn SecIdentityCreate(
            allocator: Option<&CFAllocator>,
            certificate: &SecCertificate,
            private_key: &SecKey,
        ) -> Option<NonNull<SecIdentity>>;
    }
    let ret = unsafe { SecIdentityCreate(allocator, certificate, private_key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecIdentity::create_with_certificate`"]
    pub fn SecIdentityCreateWithCertificate(
        keychain_or_array: Option<&CFType>,
        certificate_ref: &SecCertificate,
        identity_ref: NonNull<*mut SecIdentity>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecIdentity::copy_certificate`"]
    pub fn SecIdentityCopyCertificate(
        identity_ref: &SecIdentity,
        certificate_ref: NonNull<*mut SecCertificate>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecIdentity::copy_private_key`"]
    pub fn SecIdentityCopyPrivateKey(
        identity_ref: &SecIdentity,
        private_key_ref: NonNull<*mut SecKey>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecIdentity::copy_preference`"]
    pub fn SecIdentityCopyPreference(
        name: &CFString,
        key_usage: CSSM_KEYUSE,
        valid_issuers: Option<&CFArray>,
        identity: NonNull<*mut SecIdentity>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecIdentity::preferred`"]
#[inline]
pub unsafe extern "C-unwind" fn SecIdentityCopyPreferred(
    name: &CFString,
    key_usage: Option<&CFArray>,
    valid_issuers: Option<&CFArray>,
) -> Option<CFRetained<SecIdentity>> {
    extern "C-unwind" {
        fn SecIdentityCopyPreferred(
            name: &CFString,
            key_usage: Option<&CFArray>,
            valid_issuers: Option<&CFArray>,
        ) -> Option<NonNull<SecIdentity>>;
    }
    let ret = unsafe { SecIdentityCopyPreferred(name, key_usage, valid_issuers) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecIdentity::set_preference`"]
    pub fn SecIdentitySetPreference(
        identity: &SecIdentity,
        name: &CFString,
        key_usage: CSSM_KEYUSE,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecIdentity::set_preferred`"]
    pub fn SecIdentitySetPreferred(
        identity: Option<&SecIdentity>,
        name: &CFString,
        key_usage: Option<&CFArray>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecIdentity::copy_system_identity`"]
    pub fn SecIdentityCopySystemIdentity(
        domain: &CFString,
        id_ref: NonNull<*mut SecIdentity>,
        actual_domain: *mut *const CFString,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecIdentity::set_system_identity`"]
    pub fn SecIdentitySetSystemIdentity(
        domain: &CFString,
        id_ref: Option<&SecIdentity>,
    ) -> OSStatus;
}
