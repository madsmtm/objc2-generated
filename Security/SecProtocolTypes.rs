//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// These are os_object compatible and ARC-able wrappers around existing CoreFoundation
/// Security types, including: SecTrustRef, SecIdentityRef, and SecCertificateRef. They allow
/// clients to use these types in os_object-type APIs and data structures. The underlying
/// CoreFoundation types may be extracted and used by clients as needed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/sec_trust?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct sec_trust {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for sec_trust {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("sec_trust", &[]));
}

/// These are os_object compatible and ARC-able wrappers around existing CoreFoundation
/// Security types, including: SecTrustRef, SecIdentityRef, and SecCertificateRef. They allow
/// clients to use these types in os_object-type APIs and data structures. The underlying
/// CoreFoundation types may be extracted and used by clients as needed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/sec_trust_t?language=objc)
pub type sec_trust_t = *mut sec_trust;

/// [Apple's documentation](https://developer.apple.com/documentation/security/sec_identity?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct sec_identity {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for sec_identity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("sec_identity", &[]));
}

/// [Apple's documentation](https://developer.apple.com/documentation/security/sec_identity_t?language=objc)
pub type sec_identity_t = *mut sec_identity;

/// [Apple's documentation](https://developer.apple.com/documentation/security/sec_certificate?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct sec_certificate {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for sec_certificate {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("sec_certificate", &[]));
}

/// [Apple's documentation](https://developer.apple.com/documentation/security/sec_certificate_t?language=objc)
pub type sec_certificate_t = *mut sec_certificate;

/// Enumerations for the set of supported TLS and DTLS protocol versions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/tls_protocol_version_t?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct tls_protocol_version_t(pub u16);
impl tls_protocol_version_t {
    #[doc(alias = "tls_protocol_version_TLSv10")]
    #[deprecated = "Use tls_protocol_version_TLSv12 or tls_protocol_version_TLSv13 instead."]
    pub const TLSv10: Self = Self(0x0301);
    #[doc(alias = "tls_protocol_version_TLSv11")]
    #[deprecated = "Use tls_protocol_version_TLSv12 or tls_protocol_version_TLSv13 instead."]
    pub const TLSv11: Self = Self(0x0302);
    #[doc(alias = "tls_protocol_version_TLSv12")]
    pub const TLSv12: Self = Self(0x0303);
    #[doc(alias = "tls_protocol_version_TLSv13")]
    pub const TLSv13: Self = Self(0x0304);
    #[doc(alias = "tls_protocol_version_DTLSv10")]
    #[deprecated = "Use tls_protocol_version_DTLSv12 instead."]
    pub const DTLSv10: Self = Self(0xfeff);
    #[doc(alias = "tls_protocol_version_DTLSv12")]
    pub const DTLSv12: Self = Self(0xfefd);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for tls_protocol_version_t {
    const ENCODING: Encoding = u16::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for tls_protocol_version_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerations for the set of supported TLS and DTLS ciphersuites.
///
/// See https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4
/// for ciphersuite codepoint allocations and reference RFCs.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/tls_ciphersuite_t?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct tls_ciphersuite_t(pub u16);
impl tls_ciphersuite_t {
    #[doc(alias = "tls_ciphersuite_RSA_WITH_3DES_EDE_CBC_SHA")]
    #[deprecated]
    pub const RSA_WITH_3DES_EDE_CBC_SHA: Self = Self(0x000A);
    #[doc(alias = "tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA")]
    pub const RSA_WITH_AES_128_CBC_SHA: Self = Self(0x002F);
    #[doc(alias = "tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA")]
    pub const RSA_WITH_AES_256_CBC_SHA: Self = Self(0x0035);
    #[doc(alias = "tls_ciphersuite_RSA_WITH_AES_128_GCM_SHA256")]
    pub const RSA_WITH_AES_128_GCM_SHA256: Self = Self(0x009C);
    #[doc(alias = "tls_ciphersuite_RSA_WITH_AES_256_GCM_SHA384")]
    pub const RSA_WITH_AES_256_GCM_SHA384: Self = Self(0x009D);
    #[doc(alias = "tls_ciphersuite_RSA_WITH_AES_128_CBC_SHA256")]
    pub const RSA_WITH_AES_128_CBC_SHA256: Self = Self(0x003C);
    #[doc(alias = "tls_ciphersuite_RSA_WITH_AES_256_CBC_SHA256")]
    pub const RSA_WITH_AES_256_CBC_SHA256: Self = Self(0x003D);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA")]
    #[deprecated]
    pub const ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: Self = Self(0xC008);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA")]
    pub const ECDHE_ECDSA_WITH_AES_128_CBC_SHA: Self = Self(0xC009);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA")]
    pub const ECDHE_ECDSA_WITH_AES_256_CBC_SHA: Self = Self(0xC00A);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA")]
    #[deprecated]
    pub const ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: Self = Self(0xC012);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA")]
    pub const ECDHE_RSA_WITH_AES_128_CBC_SHA: Self = Self(0xC013);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA")]
    pub const ECDHE_RSA_WITH_AES_256_CBC_SHA: Self = Self(0xC014);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256")]
    pub const ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: Self = Self(0xC023);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384")]
    pub const ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: Self = Self(0xC024);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_AES_128_CBC_SHA256")]
    pub const ECDHE_RSA_WITH_AES_128_CBC_SHA256: Self = Self(0xC027);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_AES_256_CBC_SHA384")]
    pub const ECDHE_RSA_WITH_AES_256_CBC_SHA384: Self = Self(0xC028);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256")]
    pub const ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: Self = Self(0xC02B);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384")]
    pub const ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: Self = Self(0xC02C);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_AES_128_GCM_SHA256")]
    pub const ECDHE_RSA_WITH_AES_128_GCM_SHA256: Self = Self(0xC02F);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_AES_256_GCM_SHA384")]
    pub const ECDHE_RSA_WITH_AES_256_GCM_SHA384: Self = Self(0xC030);
    #[doc(alias = "tls_ciphersuite_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256")]
    pub const ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: Self = Self(0xCCA8);
    #[doc(alias = "tls_ciphersuite_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256")]
    pub const ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: Self = Self(0xCCA9);
    #[doc(alias = "tls_ciphersuite_AES_128_GCM_SHA256")]
    pub const AES_128_GCM_SHA256: Self = Self(0x1301);
    #[doc(alias = "tls_ciphersuite_AES_256_GCM_SHA384")]
    pub const AES_256_GCM_SHA384: Self = Self(0x1302);
    #[doc(alias = "tls_ciphersuite_CHACHA20_POLY1305_SHA256")]
    pub const CHACHA20_POLY1305_SHA256: Self = Self(0x1303);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for tls_ciphersuite_t {
    const ENCODING: Encoding = u16::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for tls_ciphersuite_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Convenience ciphersuite groups that collate ciphersuites of comparable security
/// properties into a single alias.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/tls_ciphersuite_group_t?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct tls_ciphersuite_group_t(pub u16);
impl tls_ciphersuite_group_t {
    #[doc(alias = "tls_ciphersuite_group_default")]
    pub const default: Self = Self(0);
    #[doc(alias = "tls_ciphersuite_group_compatibility")]
    pub const compatibility: Self = Self(1);
    #[doc(alias = "tls_ciphersuite_group_legacy")]
    pub const legacy: Self = Self(2);
    #[doc(alias = "tls_ciphersuite_group_ats")]
    pub const ats: Self = Self(3);
    #[doc(alias = "tls_ciphersuite_group_ats_compatibility")]
    pub const ats_compatibility: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for tls_ciphersuite_group_t {
    const ENCODING: Encoding = u16::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for tls_ciphersuite_group_t {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Enumerations for the set of supported TLS and DTLS protocol versions.
///
///
/// Note: This enumeration is deprecated. Use `tls_protocol_version_t` instead.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/sslprotocol?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SSLProtocol(pub c_int);
impl SSLProtocol {
    #[doc(alias = "kSSLProtocolUnknown")]
    #[deprecated]
    pub const SSLProtocolUnknown: Self = Self(0);
    #[doc(alias = "kTLSProtocol1")]
    #[deprecated]
    pub const TLSProtocol1: Self = Self(4);
    #[doc(alias = "kTLSProtocol11")]
    #[deprecated]
    pub const TLSProtocol11: Self = Self(7);
    #[doc(alias = "kTLSProtocol12")]
    #[deprecated]
    pub const TLSProtocol12: Self = Self(8);
    #[doc(alias = "kDTLSProtocol1")]
    #[deprecated]
    pub const DTLSProtocol1: Self = Self(9);
    #[doc(alias = "kTLSProtocol13")]
    #[deprecated]
    pub const TLSProtocol13: Self = Self(10);
    #[doc(alias = "kDTLSProtocol12")]
    #[deprecated]
    pub const DTLSProtocol12: Self = Self(11);
    #[doc(alias = "kTLSProtocolMaxSupported")]
    #[deprecated]
    pub const TLSProtocolMaxSupported: Self = Self(999);
    #[doc(alias = "kSSLProtocol2")]
    #[deprecated]
    pub const SSLProtocol2: Self = Self(1);
    #[doc(alias = "kSSLProtocol3")]
    #[deprecated]
    pub const SSLProtocol3: Self = Self(2);
    #[doc(alias = "kSSLProtocol3Only")]
    #[deprecated]
    pub const SSLProtocol3Only: Self = Self(3);
    #[doc(alias = "kTLSProtocol1Only")]
    #[deprecated]
    pub const TLSProtocol1Only: Self = Self(5);
    #[doc(alias = "kSSLProtocolAll")]
    #[deprecated]
    pub const SSLProtocolAll: Self = Self(6);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SSLProtocol {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SSLProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl sec_trust {
    /// Create an ARC-able `sec_trust_t` instance from a `SecTrustRef`.
    ///
    ///
    /// Parameter `trust`: A `SecTrustRef` instance.
    ///
    ///
    /// Returns: a `sec_trust_t` instance.
    #[doc(alias = "sec_trust_create")]
    #[cfg(feature = "SecTrust")]
    #[inline]
    pub unsafe fn create(trust: &SecTrust) -> sec_trust_t {
        extern "C-unwind" {
            fn sec_trust_create(trust: &SecTrust) -> sec_trust_t;
        }
        unsafe { sec_trust_create(trust) }
    }

    /// Copy a retained reference to the underlying `SecTrustRef` instance.
    ///
    ///
    /// Parameter `trust`: A `sec_trust_t` instance.
    ///
    ///
    /// Returns: The underlying `SecTrustRef` instance.
    ///
    /// # Safety
    ///
    /// `trust` must be a valid pointer.
    #[doc(alias = "sec_trust_copy_ref")]
    #[cfg(feature = "SecTrust")]
    #[inline]
    pub unsafe fn r#ref(trust: sec_trust_t) -> CFRetained<SecTrust> {
        extern "C-unwind" {
            fn sec_trust_copy_ref(trust: sec_trust_t) -> Option<NonNull<SecTrust>>;
        }
        let ret = unsafe { sec_trust_copy_ref(trust) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

impl sec_identity {
    /// Create an ARC-able `sec_identity_t` instance from a `SecIdentityRef`.
    ///
    ///
    /// Parameter `identity`: A `SecIdentityRef` instance.
    ///
    ///
    /// Returns: a `sec_identity_t` instance.
    #[doc(alias = "sec_identity_create")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn create(identity: &SecIdentity) -> sec_identity_t {
        extern "C-unwind" {
            fn sec_identity_create(identity: &SecIdentity) -> sec_identity_t;
        }
        unsafe { sec_identity_create(identity) }
    }

    /// Create an ARC-able `sec_identity_t` instance from a `SecIdentityRef` and
    /// array of SecCertificateRef instances.
    ///
    ///
    /// Parameter `identity`: A `SecIdentityRef` instance.
    ///
    ///
    /// Parameter `certificates`: An array of `SecCertificateRef` instances.
    ///
    ///
    /// Returns: a `sec_identity_t` instance.
    ///
    /// # Safety
    ///
    /// `certificates` generic must be of the correct type.
    #[doc(alias = "sec_identity_create_with_certificates")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn create_with_certificates(
        identity: &SecIdentity,
        certificates: &CFArray,
    ) -> sec_identity_t {
        extern "C-unwind" {
            fn sec_identity_create_with_certificates(
                identity: &SecIdentity,
                certificates: &CFArray,
            ) -> sec_identity_t;
        }
        unsafe { sec_identity_create_with_certificates(identity, certificates) }
    }

    /// Access the certificates associated with the `sec_identity_t` instance.
    ///
    ///
    /// Parameter `identity`: A `sec_identity_t` instance.
    ///
    ///
    /// Parameter `handler`: A block to invoke one or more times with `sec_certificate_t` instances.
    ///
    ///
    /// Returns: Returns true if the peer certificates were accessible, false otherwise.
    ///
    /// # Safety
    ///
    /// `identity` must be a valid pointer.
    #[doc(alias = "sec_identity_access_certificates")]
    #[cfg(feature = "block2")]
    #[inline]
    pub unsafe fn access_certificates(
        identity: sec_identity_t,
        handler: &block2::DynBlock<dyn Fn(sec_certificate_t)>,
    ) -> bool {
        extern "C-unwind" {
            fn sec_identity_access_certificates(
                identity: sec_identity_t,
                handler: &block2::DynBlock<dyn Fn(sec_certificate_t)>,
            ) -> bool;
        }
        unsafe { sec_identity_access_certificates(identity, handler) }
    }

    /// Copy a retained reference to the underlying `SecIdentityRef` instance.
    ///
    ///
    /// Parameter `identity`: A `sec_identity_t` instance.
    ///
    ///
    /// Returns: The underlying `SecIdentityRef` instance.
    ///
    /// # Safety
    ///
    /// `identity` must be a valid pointer.
    #[doc(alias = "sec_identity_copy_ref")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn r#ref(identity: sec_identity_t) -> Option<CFRetained<SecIdentity>> {
        extern "C-unwind" {
            fn sec_identity_copy_ref(identity: sec_identity_t) -> Option<NonNull<SecIdentity>>;
        }
        let ret = unsafe { sec_identity_copy_ref(identity) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Copy a retained reference to the underlying `CFArrayRef` container of `SecCertificateRef` types.
    ///
    ///
    /// Parameter `identity`: A `sec_identity_t` instance.
    ///
    ///
    /// Returns: The underlying `CFArrayRef` container with `SecCertificateRef` instances.
    ///
    /// # Safety
    ///
    /// `identity` must be a valid pointer.
    #[doc(alias = "sec_identity_copy_certificates_ref")]
    #[inline]
    pub unsafe fn certificates_ref(identity: sec_identity_t) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn sec_identity_copy_certificates_ref(
                identity: sec_identity_t,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { sec_identity_copy_certificates_ref(identity) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl sec_certificate {
    /// Create an ARC-able `sec_certificate_t` instance from a `SecCertificateRef`.
    ///
    ///
    /// Parameter `certificate`: A `SecCertificateRef` instance.
    ///
    ///
    /// Returns: a `sec_certificate_t` instance.
    #[doc(alias = "sec_certificate_create")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn create(certificate: &SecCertificate) -> sec_certificate_t {
        extern "C-unwind" {
            fn sec_certificate_create(certificate: &SecCertificate) -> sec_certificate_t;
        }
        unsafe { sec_certificate_create(certificate) }
    }

    /// Copy a retained reference to the underlying `SecCertificateRef` instance.
    ///
    ///
    /// Parameter `certificate`: A `sec_certificate_t` instance.
    ///
    ///
    /// Returns: The underlying `SecCertificateRef` instance.
    ///
    /// # Safety
    ///
    /// `certificate` must be a valid pointer.
    #[doc(alias = "sec_certificate_copy_ref")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn r#ref(certificate: sec_certificate_t) -> CFRetained<SecCertificate> {
        extern "C-unwind" {
            fn sec_certificate_copy_ref(
                certificate: sec_certificate_t,
            ) -> Option<NonNull<SecCertificate>>;
        }
        let ret = unsafe { sec_certificate_copy_ref(certificate) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "SecTrust")]
    #[deprecated = "renamed to `sec_trust::create`"]
    pub fn sec_trust_create(trust: &SecTrust) -> sec_trust_t;
}

#[cfg(feature = "SecTrust")]
#[deprecated = "renamed to `sec_trust::ref`"]
#[inline]
pub unsafe extern "C-unwind" fn sec_trust_copy_ref(trust: sec_trust_t) -> CFRetained<SecTrust> {
    extern "C-unwind" {
        fn sec_trust_copy_ref(trust: sec_trust_t) -> Option<NonNull<SecTrust>>;
    }
    let ret = unsafe { sec_trust_copy_ref(trust) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `sec_identity::create`"]
    pub fn sec_identity_create(identity: &SecIdentity) -> sec_identity_t;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `sec_identity::create_with_certificates`"]
    pub fn sec_identity_create_with_certificates(
        identity: &SecIdentity,
        certificates: &CFArray,
    ) -> sec_identity_t;
}

extern "C-unwind" {
    #[cfg(feature = "block2")]
    #[deprecated = "renamed to `sec_identity::access_certificates`"]
    pub fn sec_identity_access_certificates(
        identity: sec_identity_t,
        handler: &block2::DynBlock<dyn Fn(sec_certificate_t)>,
    ) -> bool;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `sec_identity::ref`"]
#[inline]
pub unsafe extern "C-unwind" fn sec_identity_copy_ref(
    identity: sec_identity_t,
) -> Option<CFRetained<SecIdentity>> {
    extern "C-unwind" {
        fn sec_identity_copy_ref(identity: sec_identity_t) -> Option<NonNull<SecIdentity>>;
    }
    let ret = unsafe { sec_identity_copy_ref(identity) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `sec_identity::certificates_ref`"]
#[inline]
pub unsafe extern "C-unwind" fn sec_identity_copy_certificates_ref(
    identity: sec_identity_t,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn sec_identity_copy_certificates_ref(identity: sec_identity_t)
            -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { sec_identity_copy_certificates_ref(identity) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `sec_certificate::create`"]
    pub fn sec_certificate_create(certificate: &SecCertificate) -> sec_certificate_t;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `sec_certificate::ref`"]
#[inline]
pub unsafe extern "C-unwind" fn sec_certificate_copy_ref(
    certificate: sec_certificate_t,
) -> CFRetained<SecCertificate> {
    extern "C-unwind" {
        fn sec_certificate_copy_ref(
            certificate: sec_certificate_t,
        ) -> Option<NonNull<SecCertificate>>;
    }
    let ret = unsafe { sec_certificate_copy_ref(certificate) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}
