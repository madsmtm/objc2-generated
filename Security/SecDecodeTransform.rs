//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// Used with SecTransformGetAttribute to query the attribute type.
    /// Returns one of the strings defined in the previous section.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksecdecodetypeattribute?language=objc)
    pub static kSecDecodeTypeAttribute: &'static CFString;
}

/// Creates an decode computation object.
///
/// Parameter `DecodeType`: The type of digest to decode.  You may pass NULL
/// for this parameter, in which case an appropriate
/// algorithm will be chosen for you.
///
/// Parameter `error`: A pointer to a CFErrorRef.  This pointer will be set
/// if an error occurred.  This value may be NULL if you
/// do not want an error returned.
///
/// Returns: A pointer to a SecTransformRef object.  This object must
/// be released with CFRelease when you are done with
/// it.  This function will return NULL if an error
/// occurred.
///
/// This function creates a transform which computes a
/// decode.
///
/// # Safety
///
/// `error` must be a valid pointer or null.
#[cfg(feature = "SecTransform")]
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecDecodeTransformCreate(
    decode_type: &CFType,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecTransform>> {
    extern "C-unwind" {
        fn SecDecodeTransformCreate(
            decode_type: &CFType,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecTransform>>;
    }
    let ret = unsafe { SecDecodeTransformCreate(decode_type, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
