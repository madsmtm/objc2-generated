//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "SecBase")]
unsafe impl ConcreteType for SecAccessControl {
    /// Returns the unique identifier of the opaque type to which a keychain item access control object belongs.
    /// Returns the type identifier of SecAccessControl instances.
    ///
    /// Returns: The CFTypeID of SecAccessControl instances.
    #[doc(alias = "SecAccessControlGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecAccessControlGetTypeID() -> CFTypeID;
        }
        unsafe { SecAccessControlGetTypeID() }
    }
}

/// Access control constants that dictate how a keychain item may be used.
///
/// ## Overview
///
/// Use these flags with the [`SecAccessControlCreateWithFlags`](https://developer.apple.com/documentation/security/secaccesscontrolcreatewithflags(_:_:_:_:)) function, or as the value associated with the [`kSecAttrAccessControl`](https://developer.apple.com/documentation/security/ksecattraccesscontrol) key in a keychain item’s attribute dictionary, to control keychain item accessibility.
///
///
/// User presence policy using biometry or Passcode. Biometry does not have to be available or enrolled. Item is still
/// accessible by Touch ID even if fingers are added or removed. Item is still accessible by Face ID if user is re-enrolled.
///
///
/// Constraint: Touch ID (any finger) or Face ID. Touch ID or Face ID must be available. With Touch ID
/// at least one finger must be enrolled. With Face ID user has to be enrolled. Item is still accessible by Touch ID even
/// if fingers are added or removed. Item is still accessible by Face ID if user is re-enrolled.
///
///
/// Deprecated, please use kSecAccessControlBiometryAny instead.
///
///
/// Constraint: Touch ID from the set of currently enrolled fingers. Touch ID must be available and at least one finger must
/// be enrolled. When fingers are added or removed, the item is invalidated. When Face ID is re-enrolled this item is invalidated.
///
///
/// Deprecated, please use kSecAccessControlBiometryCurrentSet instead.
///
///
/// Constraint: Device passcode
///
///
/// Deprecated, please use kSecAccessControlCompanion instead.
///
///
/// Constraint: Paired companion device
///
///
/// Constraint logic operation: when using more than one constraint, at least one of them must be satisfied.
///
///
/// Constraint logic operation: when using more than one constraint, all must be satisfied.
///
///
/// Create access control for private key operations (i.e. sign operation)
///
///
/// Security: Application provided password for data encryption key generation. This is not a constraint but additional item
/// encryption mechanism.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecAccessControlCreateFlags(pub CFOptionFlags);
bitflags::bitflags! {
    impl SecAccessControlCreateFlags: CFOptionFlags {
/// Constraint to access an item with either biometry or passcode.
///
/// ## Discussion
///
/// Biometry doesn’t have to be available or enrolled. The item is still accessible by Touch ID even if fingers are added or removed, or by Face ID if the user is re-enrolled.
///
/// This option is equivalent to specifying [`kSecAccessControlBiometryAny`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometryany), [`kSecAccessControlOr`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/or), and [`kSecAccessControlDevicePasscode`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/devicepasscode).
///
///
        #[doc(alias = "kSecAccessControlUserPresence")]
        const UserPresence = 1<<0;
/// Constraint to access an item with Touch ID for any enrolled fingers, or Face ID.
///
/// ## Discussion
///
/// Touch ID must be available and enrolled with at least one finger, or Face ID must be available and enrolled. The item is still accessible by Touch ID if fingers are added or removed, or by Face ID if the user is re-enrolled.
///
///
        #[doc(alias = "kSecAccessControlBiometryAny")]
        const BiometryAny = 1<<1;
/// Constraint to access an item with Touch ID for any enrolled fingers.
///
/// ## Discussion
///
/// Touch ID must be available and enrolled with at least one finger. The item is still accessible by Touch ID if fingers are added or removed.
///
///
        #[doc(alias = "kSecAccessControlTouchIDAny")]
#[deprecated]
        const TouchIDAny = 1<<1;
/// Constraint to access an item with Touch ID for currently enrolled fingers, or from Face ID with the currently enrolled user.
///
/// ## Discussion
///
/// Touch ID must be available and enrolled with at least one finger, or Face ID available and enrolled. The item is invalidated if fingers are added or removed for Touch ID, or if the user re-enrolls for Face ID.
///
///
        #[doc(alias = "kSecAccessControlBiometryCurrentSet")]
        const BiometryCurrentSet = 1<<3;
/// Constraint to access an item with Touch ID for currently enrolled fingers.
///
/// ## Discussion
///
/// Touch ID must be available and enrolled with at least one finger. The item is invalidated if fingers are added or removed.
///
///
        #[doc(alias = "kSecAccessControlTouchIDCurrentSet")]
#[deprecated]
        const TouchIDCurrentSet = 1<<3;
/// Constraint to access an item with a passcode.
        #[doc(alias = "kSecAccessControlDevicePasscode")]
        const DevicePasscode = 1<<4;
/// Constraint to access an item with a watch.
///
/// ## Discussion
///
/// The system attempts to locate a nearby, paired Apple Watch running watchOS 6 or later.
///
///
        #[doc(alias = "kSecAccessControlWatch")]
#[deprecated]
        const Watch = 1<<5;
        #[doc(alias = "kSecAccessControlCompanion")]
        const Companion = 1<<5;
/// Indicates that at least one constraint must be satisfied.
        #[doc(alias = "kSecAccessControlOr")]
        const Or = 1<<14;
/// Indicates that all constraints must be satisfied.
        #[doc(alias = "kSecAccessControlAnd")]
        const And = 1<<15;
/// Enable a private key to be used in signing a block of data or verifying a signed block.
///
/// ## Discussion
///
/// This option can be combined with any other access control flags.
///
/// You typically use this constraint when you create a key pair and store the private key inside a device’s Secure Enclave (by specifying the [`kSecAttrTokenID`](https://developer.apple.com/documentation/security/ksecattrtokenid) attribute with a value of [`kSecAttrTokenIDSecureEnclave`](https://developer.apple.com/documentation/security/ksecattrtokenidsecureenclave)). This makes the private key available for use in signing and verification tasks that happen inside the Secure Enclave with calls to the [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) functions. An attempt to use this constraint while generating a key pair outside the Secure Enclave fails. Similarly, an attempt to sign a block with a private key generated without this constraint inside the Secure Enclave fails.
///
///
        #[doc(alias = "kSecAccessControlPrivateKeyUsage")]
        const PrivateKeyUsage = 1<<30;
/// Option to use an application-provided password for data encryption key generation.
///
/// ## Discussion
///
/// This may be specified in addition to any constraints.
///
///
        #[doc(alias = "kSecAccessControlApplicationPassword")]
        const ApplicationPassword = 1<<31;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecAccessControlCreateFlags {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecAccessControlCreateFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "SecBase")]
impl SecAccessControl {
    /// Creates a new access control object with the specified protection type and flags.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new [`SecAccessControlRef`](https://developer.apple.com/documentation/security/secaccesscontrol) object. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to allocate memory for the new allocator using the default allocator.
    ///
    /// - protection: Protection class to be used for the item. Use one of the values that go with the [`kSecAttrAccessible`](https://developer.apple.com/documentation/security/ksecattraccessible) attribute key, namely those listed in [Accessibility Values](https://developer.apple.com/documentation/security/item-attribute-keys-and-values#accessibility-values).
    ///
    /// - flags: Flags specifying the allowed operations for the item. See [`SecAccessControlCreateFlags`](https://developer.apple.com/documentation/security/secaccesscontrolcreateflags).
    ///
    /// - error: On return, if an error occurred, the reference pointed at by this parameter refers to an error object that indicates the reason for failure. The caller is responsible for releasing the error object. Pass `NULL` for this parameter to ignore the error.
    ///
    ///
    /// ## Return Value
    ///
    /// The newly created access control object. In Objective-C, free this item with [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You use the result of this function as a value for the [`kSecAttrAccessControl`](https://developer.apple.com/documentation/security/ksecattraccesscontrol) attribute in the [`SecItemAdd`](https://developer.apple.com/documentation/security/secitemadd(_:_:)), [`SecItemUpdate`](https://developer.apple.com/documentation/security/secitemupdate(_:_:)), or [`SecKeyGeneratePair`](https://developer.apple.com/documentation/security/seckeygeneratepair(_:_:_:)) functions.
    ///
    /// Accessing keychain items or performing operations on keys that are protected by access control objects may block execution on the main thread. Perform these actions in the background, or use them in combination with the [`kSecUseAuthenticationContext`](https://developer.apple.com/documentation/security/ksecuseauthenticationcontext) and [`kSecUseAuthenticationUI`](https://developer.apple.com/documentation/security/ksecuseauthenticationui) attributes to manage user interactions.
    ///
    ///
    /// Creates new access control object based on protection type and additional flags.
    ///
    /// Created access control object should be used as a value for kSecAttrAccessControl attribute in SecItemAdd,
    /// SecItemUpdate or SecKeyGeneratePair functions.  Accessing keychain items or performing operations on keys which are
    /// protected by access control objects can block the execution because of UI which can appear to satisfy the access control
    /// conditions, therefore it is recommended to either move those potentially blocking operations out of the main
    /// application thread or use combination of kSecUseAuthenticationContext and kSecUseAuthenticationUI attributes to control
    /// where the UI interaction can appear.
    ///
    /// Parameter `allocator`: Allocator to be used by this instance.
    ///
    /// Parameter `protection`: Protection class to be used for the item. One of kSecAttrAccessible constants.
    ///
    /// Parameter `flags`: If no flags are set then all operations are allowed.
    ///
    /// Parameter `error`: Additional error information filled in case of failure.
    ///
    /// Returns: Newly created access control object.
    ///
    /// # Safety
    ///
    /// - `protection` should be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecAccessControlCreateWithFlags")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn with_flags(
        allocator: Option<&CFAllocator>,
        protection: &CFType,
        flags: SecAccessControlCreateFlags,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecAccessControl>> {
        extern "C-unwind" {
            fn SecAccessControlCreateWithFlags(
                allocator: Option<&CFAllocator>,
                protection: &CFType,
                flags: SecAccessControlCreateFlags,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecAccessControl>>;
        }
        let ret = unsafe { SecAccessControlCreateWithFlags(allocator, protection, flags, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecAccessControl::with_flags`"]
#[inline]
pub unsafe extern "C-unwind" fn SecAccessControlCreateWithFlags(
    allocator: Option<&CFAllocator>,
    protection: &CFType,
    flags: SecAccessControlCreateFlags,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecAccessControl>> {
    extern "C-unwind" {
        fn SecAccessControlCreateWithFlags(
            allocator: Option<&CFAllocator>,
            protection: &CFType,
            flags: SecAccessControlCreateFlags,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecAccessControl>>;
    }
    let ret = unsafe { SecAccessControlCreateWithFlags(allocator, protection, flags, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
