//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "SecBase")]
unsafe impl ConcreteType for SecCertificate {
    /// Returns the unique identifier of the opaque type to which a certificate object belongs.
    ///
    /// ## Return Value
    ///
    /// A value that identifies the opaque type of a [`SecCertificateRef`](https://developer.apple.com/documentation/security/seccertificate) object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns a value that uniquely identifies the opaque type of a [`SecCertificateRef`](https://developer.apple.com/documentation/security/seccertificate) object. You can compare this value to the [`CFTypeID`](https://developer.apple.com/documentation/corefoundation/cftypeid) identifier obtained by calling the [`CFGetTypeID`](https://developer.apple.com/documentation/corefoundation/cfgettypeid(_:)) function on a specific object. These values might change from release to release or platform to platform.
    ///
    ///
    /// Returns the type identifier of SecCertificate instances.
    ///
    /// Returns: The CFTypeID of SecCertificate instances.
    #[doc(alias = "SecCertificateGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecCertificateGetTypeID() -> CFTypeID;
        }
        unsafe { SecCertificateGetTypeID() }
    }
}

#[cfg(feature = "SecBase")]
impl SecCertificate {
    /// Creates a certificate object from a DER representation of a certificate.
    ///
    /// Parameters:
    /// - allocator: The `CFAllocator` object you wish to use to allocate the certificate object. Pass `NULL` to use the default allocator.
    ///
    /// - data: A DER (Distinguished Encoding Rules) representation of an X.509 certificate.
    ///
    ///
    /// ## Return Value
    ///
    /// The newly created certificate object. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it. Returns `nil` if the data passed in the `data` parameter is not a valid DER-encoded X.509 certificate.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The certificate object returned by this function is used as input to other functions in the API.
    ///
    ///
    /// Create a certificate given it's DER representation as a CFData.
    ///
    /// Parameter `allocator`: CFAllocator to allocate the certificate with.
    ///
    /// Parameter `data`: DER encoded X.509 certificate.
    ///
    /// Returns: Return NULL if the passed-in data is not a valid DER-encoded
    /// X.509 certificate, return a SecCertificateRef otherwise.
    #[doc(alias = "SecCertificateCreateWithData")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn with_data(
        allocator: Option<&CFAllocator>,
        data: &CFData,
    ) -> Option<CFRetained<SecCertificate>> {
        extern "C-unwind" {
            fn SecCertificateCreateWithData(
                allocator: Option<&CFAllocator>,
                data: &CFData,
            ) -> Option<NonNull<SecCertificate>>;
        }
        let ret = unsafe { SecCertificateCreateWithData(allocator, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a DER representation of a certificate given a certificate object.
    ///
    /// Parameters:
    /// - certificate: The certificate object for which you wish to return the DER (Distinguished Encoding Rules) representation of the X.509 certificate.
    ///
    ///
    /// ## Return Value
    ///
    /// The DER representation of the certificate. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it. Returns `nil` if the data passed in the `certificate` parameter is not a valid certificate object.
    ///
    ///
    /// Return the DER representation of an X.509 certificate.
    ///
    /// Parameter `certificate`: SecCertificate object created with
    /// SecCertificateCreateWithData().
    ///
    /// Returns: DER encoded X.509 certificate.
    #[doc(alias = "SecCertificateCopyData")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn data(&self) -> CFRetained<CFData> {
        extern "C-unwind" {
            fn SecCertificateCopyData(certificate: &SecCertificate) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopyData(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Returns a human-readable summary of a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate object for which you wish to return a summary string.
    ///
    ///
    /// ## Return Value
    ///
    /// A string that contains a human-readable summary of the contents of the certificate. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it. Returns `NULL` if the data passed in the `certificate` parameter is not a valid certificate object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Because all the data in the string comes from the certificate, the string is in whatever language is used in the certificate.
    ///
    ///
    /// Return a simple string which hopefully represents a human
    /// understandable summary.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to derive
    /// the subject summary string.
    ///
    /// All the data in this string comes from the certificate itself
    /// and thus it's in whatever language the certificate itself is in.
    ///
    /// Returns: A CFStringRef which the caller should CFRelease() once it's no
    /// longer needed.
    #[doc(alias = "SecCertificateCopySubjectSummary")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn subject_summary(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SecCertificateCopySubjectSummary(
                certificate: &SecCertificate,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SecCertificateCopySubjectSummary(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the common name of the subject of a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate object from which to retrieve the common name.
    ///
    /// - commonName: On return, points to the common name. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    /// Retrieves the common name of the subject of a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to retrieve the common name.
    ///
    /// Parameter `commonName`: On return, a reference to the common name. Your code must release this reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// All the data in this string comes from the certificate itself, and thus it's in whatever language the certificate itself is in.
    /// Note that the certificate's common name field may not be present, or may be inadequate to describe the certificate; for display purposes,
    /// you should consider using SecCertificateCopySubjectSummary instead of this function.
    ///
    /// # Safety
    ///
    /// `common_name` must be a valid pointer.
    #[doc(alias = "SecCertificateCopyCommonName")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn copy_common_name(&self, common_name: NonNull<*const CFString>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateCopyCommonName(
                certificate: &SecCertificate,
                common_name: NonNull<*const CFString>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateCopyCommonName(self, common_name) }
    }

    /// Retrieves the email addresses for the subject of a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate object from which to retrieve the email addresses.
    ///
    /// - emailAddresses: On return, an array of zero or more `CFStringRef` elements, each containing one email address found in the certificate subject. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Not every certificate subject includes an email address. If the function does not find any email addresses, it returns a `CFArrayRef` object with zero elements in the array.
    ///
    ///
    /// Returns an array of zero or more email addresses for the subject of a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to retrieve the email addresses.
    ///
    /// Parameter `emailAddresses`: On return, an array of zero or more CFStringRef elements corresponding to each email address found.
    /// Your code must release this array reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// `email_addresses` must be a valid pointer.
    #[doc(alias = "SecCertificateCopyEmailAddresses")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn copy_email_addresses(
        &self,
        email_addresses: NonNull<*const CFArray>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateCopyEmailAddresses(
                certificate: &SecCertificate,
                email_addresses: NonNull<*const CFArray>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateCopyEmailAddresses(self, email_addresses) }
    }

    /// Retrieves the normalized issuer sequence from a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate from which to retrieve the data.
    ///
    ///
    /// ## Return Value
    ///
    /// A data object containing the sequence or `NULL` on error. In Objective-C, free this object with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    /// Return the certificate's normalized issuer
    ///
    /// Parameter `certificate`: The certificate from which to get values
    ///
    /// The issuer is a sequence in the format used by SecItemCopyMatching.  The content returned is a DER-encoded X.509 distinguished name. For a display version of the issuer, call SecCertificateCopyValues. The caller must CFRelease the value returned.
    #[doc(alias = "SecCertificateCopyNormalizedIssuerSequence")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn normalized_issuer_sequence(&self) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecCertificateCopyNormalizedIssuerSequence(
                certificate: &SecCertificate,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopyNormalizedIssuerSequence(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the normalized subject sequence from a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate from which to retrieve the data.
    ///
    ///
    /// ## Return Value
    ///
    /// A data object containing the sequence or `NULL` on error. In Objective-C, free this object with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    /// Return the certificate's normalized subject
    ///
    /// Parameter `certificate`: The certificate from which to get values
    ///
    /// The subject is a sequence in the format used by SecItemCopyMatching. The content returned is a DER-encoded X.509 distinguished name. For a display version of the subject, call SecCertificateCopyValues. The caller must CFRelease the value returned.
    #[doc(alias = "SecCertificateCopyNormalizedSubjectSequence")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn normalized_subject_sequence(&self) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecCertificateCopyNormalizedSubjectSequence(
                certificate: &SecCertificate,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopyNormalizedSubjectSequence(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the public key for a given certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate from which to copy the key.
    ///
    ///
    /// ## Return Value
    ///
    /// The public key. In Objective-C, free this key with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The return reference is `NULL` if the public key has an encoding issue or uses an unsupported algorithm.
    ///
    ///
    /// Retrieves the public key for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to retrieve the public key.
    ///
    /// Returns: A reference to the public key for the specified certificate. Your code must release this reference by calling the CFRelease function. If the public key has an encoding issue or uses an unsupported algorithm, the returned reference will be null.
    ///
    /// RSA and ECDSA public keys are supported. All other public key algorithms are unsupported.
    #[doc(alias = "SecCertificateCopyKey")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn key(&self) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecCertificateCopyKey(certificate: &SecCertificate) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecCertificateCopyKey(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the public key from a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate object from which to retrieve the public key.
    ///
    /// - key: In macOS, points to the public key for the specified certificate. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// In iOS, the certificate’s public key.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In macOS, a result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    /// Retrieves the public key for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to retrieve the public key.
    ///
    /// Parameter `key`: On return, a reference to the public key for the specified certificate. Your code must release this reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// NOTE: Deprecated in macOS 10.14; use SecCertificateCopyKey instead for cross-platform availability.
    ///
    /// # Safety
    ///
    /// `key` must be a valid pointer.
    #[doc(alias = "SecCertificateCopyPublicKey")]
    #[cfg(feature = "SecBase")]
    #[deprecated]
    #[inline]
    pub unsafe fn copy_public_key(&self, key: NonNull<*mut SecKey>) -> OSStatus {
        extern "C-unwind" {
            #[cfg_attr(
                target_os = "macos",
                link_name = "SecCertificateCopyPublicKey$LEGACYMAC"
            )]
            fn SecCertificateCopyPublicKey(
                certificate: &SecCertificate,
                key: NonNull<*mut SecKey>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateCopyPublicKey(self, key) }
    }

    /// Returns the certificate’s serial number.
    ///
    /// Parameters:
    /// - certificate: The certificate from which to copy the serial number.
    ///
    /// - error: A [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) pointer the function uses to return an error instance on failure. Set to `nil` to ignore any error.
    ///
    ///
    /// ## Return Value
    ///
    /// The content of a DER-encoded integer (without the tag and length fields) for this certificate’s serial number.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In Objective-C, if the function returns an error free it with a call to [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) when you are done with it. If it returns data, you must free that as well.
    ///
    ///
    /// Return the certificate's serial number.
    ///
    /// Parameter `certificate`: The certificate from which to get values.
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef which will be set on return from the function if an error occurred. If not NULL, the caller is responsible for releasing the CFErrorRef.
    ///
    /// Return the content of a DER-encoded integer (without the tag and length fields) for this certificate's serial number. The caller must CFRelease the value returned.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopySerialNumberData")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn serial_number_data(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecCertificateCopySerialNumberData(
                certificate: &SecCertificate,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopySerialNumberData(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Obtain the starting date of the given certificate.
    ///
    /// Parameter `certificate`: The certificate from which to get values.
    ///
    /// Returns: Returns the absolute time at which the given certificate becomes valid,
    /// or NULL if this value could not be obtained. The caller must CFRelease the value returned.
    #[doc(alias = "SecCertificateCopyNotValidBeforeDate")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn not_valid_before_date(&self) -> Option<CFRetained<CFDate>> {
        extern "C-unwind" {
            fn SecCertificateCopyNotValidBeforeDate(
                certificate: &SecCertificate,
            ) -> Option<NonNull<CFDate>>;
        }
        let ret = unsafe { SecCertificateCopyNotValidBeforeDate(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Obtain the expiration date of the given certificate.
    ///
    /// Parameter `certificate`: The certificate from which to get values.
    ///
    /// Returns: Returns the absolute time at which the given certificate expires,
    /// or NULL if this value could not be obtained. The caller must CFRelease the value returned.
    #[doc(alias = "SecCertificateCopyNotValidAfterDate")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn not_valid_after_date(&self) -> Option<CFRetained<CFDate>> {
        extern "C-unwind" {
            fn SecCertificateCopyNotValidAfterDate(
                certificate: &SecCertificate,
            ) -> Option<NonNull<CFDate>>;
        }
        let ret = unsafe { SecCertificateCopyNotValidAfterDate(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of a certificate’s serial number.
    ///
    /// Parameters:
    /// - certificate: The certificate from which the serial number should be copied.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A data instance containing a DER-encoded integer for the certificate’s serial number (without the tag and length fields) or `nil` if an error occurred. In Objective-C, free this object with a call to [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) when you are done with it.
    ///
    ///
    /// Return the certificate's serial number.
    ///
    /// Parameter `certificate`: The certificate from which to get values.
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef which will be set on return from the function if an error occurred. If not NULL, the caller is responsible for releasing the CFErrorRef.
    ///
    /// Return the content of a DER-encoded integer (without the tag and length fields) for this certificate's serial number. The caller must CFRelease the value returned. NOTE: Deprecated in macOS 10.13; use SecCertificateCopySerialNumberData instead for cross-platform availability.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopySerialNumber")]
    #[cfg(feature = "SecBase")]
    #[deprecated]
    #[inline]
    pub unsafe fn serial_number(&self, error: *mut *mut CFError) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            #[cfg_attr(
                target_os = "macos",
                link_name = "SecCertificateCopySerialNumber$LEGACYMAC"
            )]
            fn SecCertificateCopySerialNumber(
                certificate: &SecCertificate,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopySerialNumber(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// DER-encoded subject distinguished name.
pub const kSecSubjectItemAttr: c_uint = 1937072746;
/// DER-encoded issuer distinguished name.
pub const kSecIssuerItemAttr: c_uint = 1769173877;
/// DER-encoded certificate serial number (without the tag and length).
pub const kSecSerialNumberItemAttr: c_uint = 1936614002;
/// Public key hash.
pub const kSecPublicKeyHashItemAttr: c_uint = 1752198009;
/// Subject key identifier.
pub const kSecSubjectKeyIdentifierItemAttr: c_uint = 1936419172;
/// Certificate type.
pub const kSecCertTypeItemAttr: c_uint = 1668577648;
/// Certificate encoding.
pub const kSecCertEncodingItemAttr: c_uint = 1667591779;

#[cfg(feature = "SecBase")]
impl SecCertificate {
    /// Creates a certificate object based on the specified data, type, and encoding.
    ///
    /// Parameters:
    /// - data: A pointer to the certificate data. The data must be an X509 certificate in binary format.
    ///
    /// - type: The certificate type as defined in `Security.framework/cssmtype.h`. Permissible values are `CSSM_CERT_X_509v1`, `CSSM_CERT_X_509v2`, and `CSSM_CERT_X_509v3`. If you are unsure of the certificate type, use `CSSM_CERT_X_509v3`.
    ///
    /// - encoding: The certificate encoding as defined in `Security.framework/cssmtype.h`. Permissible values are `CSSM_CERT_ENCODING_BER` and `CSSM_CERT_ENCODING_DER`. If you are unsure of the encoding, use `CSSM_CERT_ENCODING_BER`.
    ///
    /// - certificate: On return, points to the newly created certificate object. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This function is deprecated. Use [`SecCertificateCreateWithData(_:_:)`](https://developer.apple.com/documentation/security/seccertificatecreatewithdata(_:_:)) instead.
    ///
    ///
    ///
    /// </div>
    /// The certificate object returned by this function is used as input to several other functions in the API.
    ///
    ///
    /// Creates a certificate based on the input data, type, and encoding.
    ///
    /// Parameter `data`: A pointer to the certificate data.
    ///
    /// Parameter `type`: The certificate type as defined in cssmtype.h.
    ///
    /// Parameter `encoding`: The certificate encoding as defined in cssmtype.h.
    ///
    /// Parameter `certificate`: On return, a reference to the newly created certificate.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7  Please use the SecCertificateCreateWithData API instead.
    ///
    /// # Safety
    ///
    /// - `data` must be a valid pointer.
    /// - `certificate` must be a valid pointer.
    #[doc(alias = "SecCertificateCreateFromData")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated]
    #[inline]
    pub unsafe fn create_from_data(
        data: NonNull<SecAsn1Item>,
        r#type: CSSM_CERT_TYPE,
        encoding: CSSM_CERT_ENCODING,
        certificate: NonNull<*mut SecCertificate>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateCreateFromData(
                data: NonNull<SecAsn1Item>,
                r#type: CSSM_CERT_TYPE,
                encoding: CSSM_CERT_ENCODING,
                certificate: NonNull<*mut SecCertificate>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateCreateFromData(data, r#type, encoding, certificate) }
    }

    /// Adds a certificate to a keychain.
    ///
    /// Parameters:
    /// - certificate: The certificate object for the certificate to add to the keychain.
    ///
    /// - keychain: The keychain object for the keychain to which you want to add the certificate. Pass `NULL` to add the certificate to the default keychain.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To add a certificate to the login keychain, use [`SecItemAdd`](https://developer.apple.com/documentation/security/secitemadd(_:_:)) instead.
    ///
    ///
    ///
    /// </div>
    /// This function requires a certificate object, which can, for example, be created with the [`SecCertificateCreateFromData`](https://developer.apple.com/documentation/security/seccertificatecreatefromdata) function or obtained over a network (see [Secure Transport](https://developer.apple.com/documentation/security/secure-transport)). If the certificate has already been added to the specified keychain, the function returns [`errSecDuplicateItem`](https://developer.apple.com/documentation/security/errsecduplicateitem) and does not add another copy to the keychain. The function looks at the certificate data, not at the certificate object, to determine whether the certificate is a duplicate. It considers two certificates to be duplicates if they have the same primary key attributes.
    ///
    /// ### Special Considerations
    ///
    /// If the keychain is locked, the system asks the user for a password or other token to unlock it. This function can therefore block while waiting for user input.
    ///
    ///
    /// Adds a certificate to the specified keychain.
    ///
    /// Parameter `certificate`: A reference to a certificate.
    ///
    /// Parameter `keychain`: A reference to the keychain in which to add the certificate. Pass NULL to add the certificate to the default keychain.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function is successful only if the certificate was created using the SecCertificateCreateFromData or
    /// SecCertificateCreateWithData functions, and the certificate has not yet been added to the specified keychain.
    #[doc(alias = "SecCertificateAddToKeychain")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn add_to_keychain(&self, keychain: Option<&SecKeychain>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateAddToKeychain(
                certificate: &SecCertificate,
                keychain: Option<&SecKeychain>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateAddToKeychain(self, keychain) }
    }

    /// Retrieves the data for a certificate.
    ///
    /// Parameters:
    /// - certificate: A certificate object for the certificate from which to retrieve the data.
    ///
    /// - data: On return, points to the data for the certificate specified. You must allocate the space for a `CSSM_DATA` structure before calling this function. This data pointer is only guaranteed to remain valid as long as the certificate remains unchanged and valid.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function requires a certificate object, which can, for example, be created with the [`SecCertificateCreateFromData`](https://developer.apple.com/documentation/security/seccertificatecreatefromdata) function, obtained from an identity with the [`SecIdentityCopyCertificate(_:_:)`](https://developer.apple.com/documentation/security/secidentitycopycertificate(_:_:)) function, or obtained over a network (see [Secure Transport](https://developer.apple.com/documentation/security/secure-transport)).
    ///
    ///
    /// Retrieves the data for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to retrieve the data.
    ///
    /// Parameter `data`: On return, the CSSM_DATA structure pointed to by data is filled in. You must allocate the space for a CSSM_DATA structure before calling this function. This data pointer is only guaranteed to remain valid as long as the certificate remains unchanged and valid.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7. Please use the SecCertificateCopyData API instead.
    ///
    /// # Safety
    ///
    /// `data` must be a valid pointer.
    #[doc(alias = "SecCertificateGetData")]
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn get_data(&self, data: CSSM_DATA_PTR) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateGetData(certificate: &SecCertificate, data: CSSM_DATA_PTR)
                -> OSStatus;
        }
        unsafe { SecCertificateGetData(self, data) }
    }

    /// Retrieves the type of a specified certificate.
    ///
    /// Parameters:
    /// - certificate: A certificate object for the certificate for which to obtain the type.
    ///
    /// - certificateType: On return, points to the type of the specified certificate. Certificate types are defined in `Security.framework/cssmtype.h`. You must allocate the space for a `CSSM_CERT_TYPE` structure before calling this function.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    /// Retrieves the type for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to obtain the type.
    ///
    /// Parameter `certificateType`: On return, the certificate type of the certificate. Certificate types are defined in cssmtype.h.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7. Please use the SecCertificateCopyValues API instead.
    ///
    /// # Safety
    ///
    /// `certificate_type` must be a valid pointer.
    #[doc(alias = "SecCertificateGetType")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn r#type(&self, certificate_type: NonNull<CSSM_CERT_TYPE>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateGetType(
                certificate: &SecCertificate,
                certificate_type: NonNull<CSSM_CERT_TYPE>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateGetType(self, certificate_type) }
    }

    /// Unsupported.
    /// Retrieves the subject name for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to obtain the subject name.
    ///
    /// Parameter `subject`: On return, a pointer to a CSSM_X509_NAME struct which contains the subject's X.509 name (x509defs.h). This pointer remains valid until the certificate reference is released. The caller should not attempt to free this pointer.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// Prior to Mac OS X 10.5, this function did not return any output in the subject parameter. Your code should check the returned pointer value (in addition to the function result) before attempting to use it.
    /// For example:
    /// const CSSM_X509_NAME *subject = NULL;
    /// OSStatus status = SecCertificateGetSubject(certificate,
    /// &subject
    /// );
    /// if ( (status == errSecSuccess)
    /// &
    /// &
    /// (subject != NULL) ) {
    /// // subject is valid
    /// }
    /// This API is deprecated in 10.7. Please use the SecCertificateCopyValues API instead.
    ///
    /// # Safety
    ///
    /// `subject` must be a valid pointer.
    #[doc(alias = "SecCertificateGetSubject")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "x509defs"
    ))]
    #[deprecated]
    #[inline]
    pub unsafe fn subject(&self, subject: NonNull<*const CSSM_X509_NAME>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateGetSubject(
                certificate: &SecCertificate,
                subject: NonNull<*const CSSM_X509_NAME>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateGetSubject(self, subject) }
    }

    /// Unsupported.
    /// Retrieves the issuer name for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to obtain the issuer name.
    ///
    /// Parameter `issuer`: On return, a pointer to a CSSM_X509_NAME struct which contains the issuer's X.509 name (x509defs.h). This pointer remains valid until the certificate reference is released. The caller should not attempt to free this pointer.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// Prior to Mac OS X 10.5, this function did not return any output in the issuer parameter. Your code should check the returned pointer value (in addition to the function result) before attempting to use it.
    /// For example:
    /// const CSSM_X509_NAME *issuer = NULL;
    /// OSStatus status = SecCertificateGetIssuer(certificate,
    /// &issuer
    /// );
    /// if ( (status == errSecSuccess)
    /// &
    /// &
    /// (issuer != NULL) ) {
    /// // issuer is valid
    /// }
    /// This API is deprecated in 10.7. Please use the SecCertificateCopyValues API instead.
    ///
    /// # Safety
    ///
    /// `issuer` must be a valid pointer.
    #[doc(alias = "SecCertificateGetIssuer")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "x509defs"
    ))]
    #[deprecated]
    #[inline]
    pub unsafe fn issuer(&self, issuer: NonNull<*const CSSM_X509_NAME>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateGetIssuer(
                certificate: &SecCertificate,
                issuer: NonNull<*const CSSM_X509_NAME>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateGetIssuer(self, issuer) }
    }

    /// Retrieves the certificate library handle from a certificate object.
    ///
    /// Parameters:
    /// - certificate: The certificate object from which to obtain the certificate library handle.
    ///
    /// - clHandle: On return, points to the certificate library handle of the specified certificate. This handle remains valid until the certificate object is released.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The certificate library handle is the CSSM identifier of the certificate library module that is managing the certificate. The certificate library handle is used as an input to a number of CSSM functions.
    ///
    ///
    /// Retrieves the certificate library handle for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to obtain the certificate library handle.
    ///
    /// Parameter `clHandle`: On return, the certificate library handle of the given certificate. This handle remains valid at least as long as the certificate does.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7. Please use the SecCertificateCopyValues API instead.
    ///
    /// # Safety
    ///
    /// `cl_handle` must be a valid pointer.
    #[doc(alias = "SecCertificateGetCLHandle")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn cl_handle(&self, cl_handle: NonNull<CSSM_CL_HANDLE>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateGetCLHandle(
                certificate: &SecCertificate,
                cl_handle: NonNull<CSSM_CL_HANDLE>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateGetCLHandle(self, cl_handle) }
    }

    /// Retrieves the algorithm identifier for a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate object from which to retrieve the algorithm identifier.
    ///
    /// - algid: On return, points to a struct that identifies the algorithm for this certificate. This pointer remains valid until the certificate reference is released. Do not attempt to free this pointer.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `CSSM_X509_ALGORITHM_IDENTIFIER` struct is defined in `Security.framework/x509defs.h` and discussed in _Common Security: CDSA and CSSM, version 2 (with corrigenda)_ from [http://www.opengroup.org/security/cdsa.htm](http://www.opengroup.org/security/cdsa.htm). Possible algorithms are enumerated in `Security.framework/oidsalg.h`.
    ///
    ///
    /// Retrieves the algorithm identifier for a given certificate.
    ///
    /// Parameter `certificate`: A reference to the certificate from which to retrieve the algorithm identifier.
    ///
    /// Parameter `algid`: On return, a pointer to a CSSM_X509_ALGORITHM_IDENTIFIER struct which identifies the algorithm for this certificate (x509defs.h). This pointer remains valid until the certificate reference is released. The caller should not attempt to free this pointer.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    /// discussion This API is deprecated in 10.7. Please use the SecCertificateCopyValues API instead.
    ///
    /// # Safety
    ///
    /// `algid` must be a valid pointer.
    #[doc(alias = "SecCertificateGetAlgorithmID")]
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated]
    #[inline]
    pub unsafe fn algorithm_id(&self, algid: NonNull<*const SecAsn1AlgId>) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateGetAlgorithmID(
                certificate: &SecCertificate,
                algid: NonNull<*const SecAsn1AlgId>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateGetAlgorithmID(self, algid) }
    }

    /// Retrieves the preferred certificate for the specified name and key use.
    ///
    /// Parameters:
    /// - name: A string containing an email address (RFC822) or other name for which a preferred certificate is requested.
    ///
    /// - keyUsage: A key use value, as defined in `Security.framework/cssmtype.h`. Pass `0` to ignore this parameter.
    ///
    /// - certificate: On return, a reference to the preferred certificate, or `NULL` if none was found. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is typically used to obtain the preferred encryption certificate for an email recipient.
    ///
    /// ### Special Considerations
    ///
    /// Use [`SecCertificateCopyPreferred(_:_:)`](https://developer.apple.com/documentation/security/seccertificatecopypreferred(_:_:)) for new development instead.
    ///
    ///
    /// Returns the preferred certificate for the specified name and key usage. If a preferred certificate does not exist for the specified name and key usage, NULL is returned.
    ///
    /// Parameter `name`: A string containing an email address (RFC822) or other name for which a preferred certificate is requested.
    ///
    /// Parameter `keyUsage`: A CSSM_KEYUSE key usage value, as defined in cssmtype.h. Pass 0 to ignore this parameter.
    ///
    /// Parameter `certificate`: On return, a reference to the preferred certificate, or NULL if none was found. You are responsible for releasing this reference by calling the CFRelease function.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function will typically be used to obtain the preferred encryption certificate for an email recipient.
    /// This API is deprecated in 10.7. Please use the SecCertificateCopyPreferred API instead.
    ///
    /// # Safety
    ///
    /// `certificate` must be a valid pointer.
    #[doc(alias = "SecCertificateCopyPreference")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig"))]
    #[deprecated]
    #[inline]
    pub unsafe fn copy_preference(
        name: &CFString,
        key_usage: uint32,
        certificate: NonNull<*mut SecCertificate>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateCopyPreference(
                name: &CFString,
                key_usage: uint32,
                certificate: NonNull<*mut SecCertificate>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateCopyPreference(name, key_usage, certificate) }
    }

    /// Returns the preferred certificate for the specified name and key usage.
    ///
    /// Parameters:
    /// - name: A string containing an email address (RFC 822) or other name for which a preferred certificate is requested.
    ///
    /// - keyUsage: An array containing a list of usage attributes ([`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt), for example), or `NULL` if you do not want to request a certificate based on a particular usage. See Attribute Item Keys for a complete list of possible usage attributes.
    ///
    ///
    /// ## Return Value
    ///
    /// The preferred certificate for the specified name and key usage, or `NULL` if a matching certificate does not exist. In Objective-C, free the certificate with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is typically used to obtain the preferred encryption certificate for an email recipient. If a preferred certificate has not been set for the supplied name, this function returns `NULL`. Your code should then perform a search for possible certificates by calling [`SecItemCopyMatching`](https://developer.apple.com/documentation/security/secitemcopymatching(_:_:)).
    ///
    ///
    /// Returns the preferred certificate for the specified name and key usage. If a preferred certificate does not exist for the specified name and key usage, NULL is returned.
    ///
    /// Parameter `name`: A string containing an email address (RFC822) or other name for which a preferred certificate is requested.
    ///
    /// Parameter `keyUsage`: A CFArrayRef value, containing items defined in SecItem.h  Pass NULL to ignore this parameter. (kSecAttrCanEncrypt, kSecAttrCanDecrypt, kSecAttrCanDerive, kSecAttrCanSign, kSecAttrCanVerify, kSecAttrCanWrap, kSecAttrCanUnwrap)
    ///
    /// Returns: On return, a reference to the preferred certificate, or NULL if none was found. You are responsible for releasing this reference by calling the CFRelease function.
    ///
    /// This function will typically be used to obtain the preferred encryption certificate for an email recipient. If a preferred certificate has not been set
    /// for the supplied name, the returned reference will be NULL. Your code should then perform a search for possible certificates, using the SecItemCopyMatching API.
    ///
    /// # Safety
    ///
    /// `key_usage` generic must be of the correct type.
    #[doc(alias = "SecCertificateCopyPreferred")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn preferred(
        name: &CFString,
        key_usage: Option<&CFArray>,
    ) -> Option<CFRetained<SecCertificate>> {
        extern "C-unwind" {
            fn SecCertificateCopyPreferred(
                name: &CFString,
                key_usage: Option<&CFArray>,
            ) -> Option<NonNull<SecCertificate>>;
        }
        let ret = unsafe { SecCertificateCopyPreferred(name, key_usage) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets the preferred certificate for a specified name, key use, and date.
    ///
    /// Parameters:
    /// - certificate: The certificate object identifying the preferred certificate.
    ///
    /// - name: A string containing an email address (RFC822) or other name with which the preferred certificate is to be associated.
    ///
    /// - keyUsage: A key use value, as defined in `Security.framework/cssmtype.h`. Pass `0` if you don’t want to specify a particular key use.
    ///
    /// - date: The date after which this preference is no longer valid. If supplied, the preferred certificate is changed only if this date is later than the currently saved setting. Pass `NULL` if this preference should not be restricted by date.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is typically used to set the preferred encryption certificate for an email recipient, either manually (when encrypting email to a recipient) or automatically upon receipt of encrypted email.
    ///
    /// ### Special Considerations
    ///
    /// Use [`SecCertificateSetPreferred(_:_:_:)`](https://developer.apple.com/documentation/security/seccertificatesetpreferred(_:_:_:)) for new development instead.
    ///
    /// Because this preference is stored in the default keychain, if the keychain is locked, the system asks the user for a password or other token to unlock it. This function can therefore block while waiting for user input.
    ///
    ///
    /// Sets the preferred certificate for a specified name, key usage, and date.
    ///
    /// Parameter `certificate`: A reference to the certificate which will be preferred.
    ///
    /// Parameter `name`: A string containing an email address (RFC822) or other name for which a preferred certificate will be associated.
    ///
    /// Parameter `keyUsage`: A CSSM_KEYUSE key usage value, as defined in cssmtype.h. Pass 0 to avoid specifying a particular key usage.
    ///
    /// Parameter `date`: (optional) A date reference. If supplied, the preferred certificate will be changed only if this date is later than the currently saved setting. Pass NULL if this preference should not be restricted by date.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function will typically be used to set the preferred encryption certificate for an email recipient, either manually (when encrypting email to a recipient) or automatically upon receipt of encrypted email.
    /// This API is deprecated in 10.7. Plese use the SecCertificateSetPreferred API instead.
    #[doc(alias = "SecCertificateSetPreference")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig"))]
    #[deprecated]
    #[inline]
    pub unsafe fn set_preference(
        &self,
        name: &CFString,
        key_usage: uint32,
        date: Option<&CFDate>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateSetPreference(
                certificate: &SecCertificate,
                name: &CFString,
                key_usage: uint32,
                date: Option<&CFDate>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateSetPreference(self, name, key_usage, date) }
    }

    /// Sets the certificate that should be preferred for the specified name and key use.
    ///
    /// Parameters:
    /// - certificate: The key to use as the preferred certificate for the specified name and key usage.
    ///
    /// - name: A string containing an email address (RFC 822) or other name for which a preferred certificate is requested.
    ///
    /// - keyUsage: An array containing a list of usage attributes ([`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt), for example), or `NULL` if you want this certificate to be preferred for any usage. See Attribute Item Keys for a complete list of possible usage attributes.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    /// Sets the preferred certificate for a specified name and optional key usage.
    ///
    /// Parameter `certificate`: A reference to the preferred certificate. If NULL is passed, any existing preference for the specified name is cleared instead.
    ///
    /// Parameter `name`: A string containing an email address (RFC822) or other name for which a preferred certificate will be associated.
    ///
    /// Parameter `keyUsage`: A CFArrayRef value, containing items defined in SecItem.h  Pass NULL to ignore this parameter. (kSecAttrCanEncrypt, kSecAttrCanDecrypt, kSecAttrCanDerive, kSecAttrCanSign, kSecAttrCanVerify, kSecAttrCanWrap, kSecAttrCanUnwrap)
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function will typically be used to set the preferred encryption certificate for an email recipient, either manually (when encrypting email to a recipient)
    /// or automatically upon receipt of encrypted email.
    ///
    /// # Safety
    ///
    /// `key_usage` generic must be of the correct type.
    #[doc(alias = "SecCertificateSetPreferred")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn set_preferred(
        certificate: Option<&SecCertificate>,
        name: &CFString,
        key_usage: Option<&CFArray>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecCertificateSetPreferred(
                certificate: Option<&SecCertificate>,
                name: &CFString,
                key_usage: Option<&CFArray>,
            ) -> OSStatus;
        }
        unsafe { SecCertificateSetPreferred(certificate, name, key_usage) }
    }
}

/// The flags that indicate key usage in the `KeyUsage` extension of a certificate.
/// Flags to indicate key usages in the KeyUsage extension of a certificate
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecKeyUsage(pub u32);
bitflags::bitflags! {
    impl SecKeyUsage: u32 {
        #[doc(alias = "kSecKeyUsageUnspecified")]
        const Unspecified = 0;
/// The `DigitalSignature` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageDigitalSignature")]
        const DigitalSignature = 1<<0;
/// The `NonRepudiation` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageNonRepudiation")]
        const NonRepudiation = 1<<1;
/// The `ContentCommitment` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageContentCommitment")]
        const ContentCommitment = 1<<1;
/// The `KeyEncipherment` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageKeyEncipherment")]
        const KeyEncipherment = 1<<2;
/// The `DataEncipherment` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageDataEncipherment")]
        const DataEncipherment = 1<<3;
/// The `KeyAgreement` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageKeyAgreement")]
        const KeyAgreement = 1<<4;
/// The `KeyCertSign` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageKeyCertSign")]
        const KeyCertSign = 1<<5;
/// The `CRLSign` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageCRLSign")]
        const CRLSign = 1<<6;
/// The `EncipherOnly` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageEncipherOnly")]
        const EncipherOnly = 1<<7;
/// The `DecipherOnly` bit is set in KeyUsage extension.
        #[doc(alias = "kSecKeyUsageDecipherOnly")]
        const DecipherOnly = 1<<8;
/// The KeyUsage extension is marked critical.
        #[doc(alias = "kSecKeyUsageCritical")]
        const Critical = 1<<31;
/// All flags set.
        #[doc(alias = "kSecKeyUsageAll")]
        const All = 0x7FFFFFFF;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecKeyUsage {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecKeyUsage {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A key whose value indicates the type of certificate property.
    ///
    /// ## Discussion
    ///
    /// Possible values for this key are described in [Certificate Property Type Values](https://developer.apple.com/documentation/security/certificate-property-type-values).
    ///
    ///
    /// Constants used to access dictionary entries returned by SecCertificateCopyValues
    pub static kSecPropertyKeyType: &'static CFString;
}

extern "C" {
    /// A key whose value is the label for a certificate property.
    ///
    /// ## Discussion
    ///
    /// This label may contain a descriptive (localized) string or an OID string.
    ///
    ///
    pub static kSecPropertyKeyLabel: &'static CFString;
}

extern "C" {
    /// A key whose value is the localized label for a certificate property.
    pub static kSecPropertyKeyLocalizedLabel: &'static CFString;
}

extern "C" {
    /// A key whose value is the value for a certificate property.
    ///
    /// ## Discussion
    ///
    /// The value is a Core Foundation type, usually a [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring), [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray), or [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary) object.
    ///
    ///
    pub static kSecPropertyKeyValue: &'static CFString;
}

extern "C" {
    /// A key whose value is a string describing a trust evaluation warning.
    /// Public Constants for property list values returned by SecCertificateCopyValues
    ///
    /// Note that kSecPropertyTypeTitle and kSecPropertyTypeError are defined in SecTrust.h
    pub static kSecPropertyTypeWarning: &'static CFString;
}

extern "C" {
    /// A key whose value is a string describing a trust evaluation success.
    pub static kSecPropertyTypeSuccess: &'static CFString;
}

extern "C" {
    /// A key whose value is a string describing the name of a field in the certificate (`CFSTR("Subject Name")`, for example).
    pub static kSecPropertyTypeSection: &'static CFString;
}

extern "C" {
    /// A key whose value is a data object.
    pub static kSecPropertyTypeData: &'static CFString;
}

extern "C" {
    /// A key whose value is a string.
    pub static kSecPropertyTypeString: &'static CFString;
}

extern "C" {
    /// Specifies a key whose value is a URL.
    pub static kSecPropertyTypeURL: &'static CFString;
}

extern "C" {
    /// Specifies a key whose value is a string containing a date (or a string listing the bytes of an invalid date).
    pub static kSecPropertyTypeDate: &'static CFString;
}

extern "C" {
    /// Specifies a key whose value is an array.
    pub static kSecPropertyTypeArray: &'static CFString;
}

extern "C" {
    /// Specifies a key whose value is a number.
    pub static kSecPropertyTypeNumber: &'static CFString;
}

#[cfg(feature = "SecBase")]
impl SecCertificate {
    /// Creates a dictionary that represents a certificate’s contents.
    ///
    /// Parameters:
    /// - certificate: The certificate from which values should be copied.
    ///
    /// - keys: An array of string OID values, or `NULL`. If non-`NULL`, these OID values determine which values from the certificate to return. If `NULL`, all values are returned.
    ///
    /// Only OIDs that represent top-level keys in the returned dictionary can be specified. Unknown OIDs are ignored. See [Certificate OIDs](https://developer.apple.com/documentation/security/certificate-oids) for the list of known OIDs.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary containing the specified values from the certificate or `NULL` if an error occurs. In Objective-C, free this dictionary with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each entry in this dictionary is itself a dictionary with the keys described in [Certificate Property Keys](https://developer.apple.com/documentation/security/certificate-property-keys).
    ///
    ///
    /// Creates a dictionary that represents a certificate's contents.
    ///
    /// Parameter `certificate`: The certificate from which to get values
    ///
    /// Parameter `keys`: An array of string OID values, or NULL. If present, this is
    /// the subset of values from the certificate to return. If NULL,
    /// all values will be returned. Only OIDs that are top level keys
    /// in the returned dictionary can be specified. Unknown OIDs are
    /// ignored.
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef. This value is
    /// set if an error occurred.  If not NULL the caller is
    /// responsible for releasing the CFErrorRef.
    ///
    /// The keys array will contain all of the keys used in the
    /// returned dictionary. The top level keys in the returned
    /// dictionary are OIDs, many of which are found in SecCertificateOIDs.h.
    /// Each entry that is returned is itself a dictionary with four
    /// entries, whose keys are kSecPropertyKeyType, kSecPropertyKeyLabel,
    /// kSecPropertyKeyLocalizedLabel, kSecPropertyKeyValue. The label
    /// entries may contain a descriptive (localized) string, or an
    /// OID string. The kSecPropertyKeyType describes the type in the
    /// value entry. The value entry may be any CFType, although it
    /// is usually a CFStringRef, CFArrayRef or a CFDictionaryRef.
    ///
    /// # Safety
    ///
    /// - `keys` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopyValues")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn values(
        &self,
        keys: Option<&CFArray>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn SecCertificateCopyValues(
                certificate: &SecCertificate,
                keys: Option<&CFArray>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { SecCertificateCopyValues(self, keys, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of the long description of a certificate.
    ///
    /// Parameters:
    /// - alloc: The allocator that should be used. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the default allocator.
    ///
    /// - certificate: The certificate from which the long description should be copied.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A string object containing the long description, or `NULL` if an error occurred. In Objective-C, free this object with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The format of this string is not guaranteed to be consistent across different operating systems or versions. Do not attempt to parse it programmatically.
    ///
    ///
    /// Return the long description of a certificate
    ///
    /// Parameter `alloc`: The CFAllocator which should be used to allocate
    /// memory for the dictionary and its storage for values. This
    /// parameter may be NULL in which case the current default
    /// CFAllocator is used. If this reference is not a valid
    /// CFAllocator, the behavior is undefined.
    ///
    /// Parameter `certificate`: The certificate from which to retrieve the long description
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef. This value is
    /// set if an error occurred.  If not NULL the caller is
    /// responsible for releasing the CFErrorRef.
    ///
    /// Returns: A CFStringRef of the long description or NULL. If NULL and the error
    /// parameter is supplied the error will be returned in the error parameter
    ///
    /// Note that the format of this string may change in the future
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopyLongDescription")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn long_description(
        alloc: Option<&CFAllocator>,
        certificate: &SecCertificate,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SecCertificateCopyLongDescription(
                alloc: Option<&CFAllocator>,
                certificate: &SecCertificate,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SecCertificateCopyLongDescription(alloc, certificate, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of the short description of a certificate.
    ///
    /// Parameters:
    /// - alloc: The allocator that should be used. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the default allocator.
    ///
    /// - certificate: The certificate from which the short description should be copied.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A string object containing the short description, or `NULL` if an error occurred. In Objective-C, free this object with [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The format of this string is not guaranteed to be consistent across different operating systems or versions. Do not attempt to parse it programmatically.
    ///
    ///
    /// Return the short description of a certificate
    ///
    /// Parameter `alloc`: The CFAllocator which should be used to allocate
    /// memory for the dictionary and its storage for values. This
    /// parameter may be NULL in which case the current default
    /// CFAllocator is used. If this reference is not a valid
    /// CFAllocator, the behavior is undefined.
    ///
    /// Parameter `certificate`: The certificate from which to retrieve the short description
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef. This value is
    /// set if an error occurred.  If not NULL the caller is
    /// responsible for releasing the CFErrorRef.
    ///
    /// Returns: A CFStringRef of the short description or NULL. If NULL and the error
    /// parameter is supplied the error will be returned in the error parameter
    ///
    /// Note that the format of this string may change in the future
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopyShortDescription")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn short_description(
        alloc: Option<&CFAllocator>,
        certificate: &SecCertificate,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SecCertificateCopyShortDescription(
                alloc: Option<&CFAllocator>,
                certificate: &SecCertificate,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SecCertificateCopyShortDescription(alloc, certificate, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a normalized copy of the distinguished name (DN) of the issuer of a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate from which the issuer’s distinguished name should be copied.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A data object containing a DER-encoded X.509 distinguished name suitable for use with [`SecItemCopyMatching`](https://developer.apple.com/documentation/security/secitemcopymatching(_:_:)). Returns `NULL` if an error occurred. In Objective-C, free the object with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To obtain a copy of the issuer’s distinguished name in a format suitable for display purposes, call [`SecCertificateCopyValues`](https://developer.apple.com/documentation/security/seccertificatecopyvalues(_:_:_:)) instead.
    ///
    ///
    /// Return the certificate's normalized issuer
    ///
    /// Parameter `certificate`: The certificate from which to get values
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef. This value is
    /// set if an error occurred.  If not NULL the caller is
    /// responsible for releasing the CFErrorRef.
    ///
    /// The issuer is a sequence in the format used by
    /// SecItemCopyMatching.  The content returned is a DER-encoded
    /// X.509 distinguished name. For a display version of the issuer,
    /// call SecCertificateCopyValues. The caller must CFRelease
    /// the value returned.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopyNormalizedIssuerContent")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "SecCertificateCopyNormalizedIssuerContent is deprecated. Use SecCertificateCopyNormalizedIssuerSequence instead."]
    #[inline]
    pub unsafe fn normalized_issuer_content(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecCertificateCopyNormalizedIssuerContent(
                certificate: &SecCertificate,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopyNormalizedIssuerContent(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a normalized copy of the distinguished name (DN) of the subject of a certificate.
    ///
    /// Parameters:
    /// - certificate: The certificate from which the subject’s distinguished name should be copied.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A data object containing a DER-encoded X.509 distinguished name suitable for use with [`SecItemCopyMatching`](https://developer.apple.com/documentation/security/secitemcopymatching(_:_:)). Returns `NULL` if an error occurred. In Objective-C, free this object with a call to the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To obtain a copy of the subject’s distinguished name in a format suitable for display purposes, call [`SecCertificateCopyValues`](https://developer.apple.com/documentation/security/seccertificatecopyvalues(_:_:_:)) instead.
    ///
    ///
    /// Return the certificate's normalized subject
    ///
    /// Parameter `certificate`: The certificate from which to get values
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef. This value is
    /// set if an error occurred.  If not NULL the caller is
    /// responsible for releasing the CFErrorRef.
    ///
    /// The subject is a sequence in the format used by
    /// SecItemCopyMatching. The content returned is a DER-encoded
    /// X.509 distinguished name. For a display version of the subject,
    /// call SecCertificateCopyValues. The caller must CFRelease
    /// the value returned.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecCertificateCopyNormalizedSubjectContent")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "SecCertificateCopyNormalizedSubjectContent is deprecated. Use SecCertificateCopyNormalizedSubjectSequence instead."]
    #[inline]
    pub unsafe fn normalized_subject_content(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecCertificateCopyNormalizedSubjectContent(
                certificate: &SecCertificate,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecCertificateCopyNormalizedSubjectContent(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::with_data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCreateWithData(
    allocator: Option<&CFAllocator>,
    data: &CFData,
) -> Option<CFRetained<SecCertificate>> {
    extern "C-unwind" {
        fn SecCertificateCreateWithData(
            allocator: Option<&CFAllocator>,
            data: &CFData,
        ) -> Option<NonNull<SecCertificate>>;
    }
    let ret = unsafe { SecCertificateCreateWithData(allocator, data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyData(
    certificate: &SecCertificate,
) -> CFRetained<CFData> {
    extern "C-unwind" {
        fn SecCertificateCopyData(certificate: &SecCertificate) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopyData(certificate) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::subject_summary`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopySubjectSummary(
    certificate: &SecCertificate,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SecCertificateCopySubjectSummary(
            certificate: &SecCertificate,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SecCertificateCopySubjectSummary(certificate) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecCertificate::copy_common_name`"]
    pub fn SecCertificateCopyCommonName(
        certificate: &SecCertificate,
        common_name: NonNull<*const CFString>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecCertificate::copy_email_addresses`"]
    pub fn SecCertificateCopyEmailAddresses(
        certificate: &SecCertificate,
        email_addresses: NonNull<*const CFArray>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::normalized_issuer_sequence`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyNormalizedIssuerSequence(
    certificate: &SecCertificate,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecCertificateCopyNormalizedIssuerSequence(
            certificate: &SecCertificate,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopyNormalizedIssuerSequence(certificate) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::normalized_subject_sequence`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyNormalizedSubjectSequence(
    certificate: &SecCertificate,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecCertificateCopyNormalizedSubjectSequence(
            certificate: &SecCertificate,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopyNormalizedSubjectSequence(certificate) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::key`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyKey(
    certificate: &SecCertificate,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecCertificateCopyKey(certificate: &SecCertificate) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecCertificateCopyKey(certificate) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecCertificate::copy_public_key`"]
    #[cfg_attr(
        target_os = "macos",
        link_name = "SecCertificateCopyPublicKey$LEGACYMAC"
    )]
    pub fn SecCertificateCopyPublicKey(
        certificate: &SecCertificate,
        key: NonNull<*mut SecKey>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::serial_number_data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopySerialNumberData(
    certificate: &SecCertificate,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecCertificateCopySerialNumberData(
            certificate: &SecCertificate,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopySerialNumberData(certificate, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::not_valid_before_date`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyNotValidBeforeDate(
    certificate: &SecCertificate,
) -> Option<CFRetained<CFDate>> {
    extern "C-unwind" {
        fn SecCertificateCopyNotValidBeforeDate(
            certificate: &SecCertificate,
        ) -> Option<NonNull<CFDate>>;
    }
    let ret = unsafe { SecCertificateCopyNotValidBeforeDate(certificate) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::not_valid_after_date`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyNotValidAfterDate(
    certificate: &SecCertificate,
) -> Option<CFRetained<CFDate>> {
    extern "C-unwind" {
        fn SecCertificateCopyNotValidAfterDate(
            certificate: &SecCertificate,
        ) -> Option<NonNull<CFDate>>;
    }
    let ret = unsafe { SecCertificateCopyNotValidAfterDate(certificate) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::serial_number`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopySerialNumber(
    certificate: &SecCertificate,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        #[cfg_attr(
            target_os = "macos",
            link_name = "SecCertificateCopySerialNumber$LEGACYMAC"
        )]
        fn SecCertificateCopySerialNumber(
            certificate: &SecCertificate,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopySerialNumber(certificate, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "renamed to `SecCertificate::create_from_data`"]
    pub fn SecCertificateCreateFromData(
        data: NonNull<SecAsn1Item>,
        r#type: CSSM_CERT_TYPE,
        encoding: CSSM_CERT_ENCODING,
        certificate: NonNull<*mut SecCertificate>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecCertificate::add_to_keychain`"]
    pub fn SecCertificateAddToKeychain(
        certificate: &SecCertificate,
        keychain: Option<&SecKeychain>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecCertificate::get_data`"]
    pub fn SecCertificateGetData(certificate: &SecCertificate, data: CSSM_DATA_PTR) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecCertificate::type`"]
    pub fn SecCertificateGetType(
        certificate: &SecCertificate,
        certificate_type: NonNull<CSSM_CERT_TYPE>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "x509defs"
    ))]
    #[deprecated = "renamed to `SecCertificate::subject`"]
    pub fn SecCertificateGetSubject(
        certificate: &SecCertificate,
        subject: NonNull<*const CSSM_X509_NAME>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "x509defs"
    ))]
    #[deprecated = "renamed to `SecCertificate::issuer`"]
    pub fn SecCertificateGetIssuer(
        certificate: &SecCertificate,
        issuer: NonNull<*const CSSM_X509_NAME>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecCertificate::cl_handle`"]
    pub fn SecCertificateGetCLHandle(
        certificate: &SecCertificate,
        cl_handle: NonNull<CSSM_CL_HANDLE>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated = "renamed to `SecCertificate::algorithm_id`"]
    pub fn SecCertificateGetAlgorithmID(
        certificate: &SecCertificate,
        algid: NonNull<*const SecAsn1AlgId>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig"))]
    #[deprecated = "renamed to `SecCertificate::copy_preference`"]
    pub fn SecCertificateCopyPreference(
        name: &CFString,
        key_usage: uint32,
        certificate: NonNull<*mut SecCertificate>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::preferred`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyPreferred(
    name: &CFString,
    key_usage: Option<&CFArray>,
) -> Option<CFRetained<SecCertificate>> {
    extern "C-unwind" {
        fn SecCertificateCopyPreferred(
            name: &CFString,
            key_usage: Option<&CFArray>,
        ) -> Option<NonNull<SecCertificate>>;
    }
    let ret = unsafe { SecCertificateCopyPreferred(name, key_usage) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig"))]
    #[deprecated = "renamed to `SecCertificate::set_preference`"]
    pub fn SecCertificateSetPreference(
        certificate: &SecCertificate,
        name: &CFString,
        key_usage: uint32,
        date: Option<&CFDate>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecCertificate::set_preferred`"]
    pub fn SecCertificateSetPreferred(
        certificate: Option<&SecCertificate>,
        name: &CFString,
        key_usage: Option<&CFArray>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::values`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyValues(
    certificate: &SecCertificate,
    keys: Option<&CFArray>,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn SecCertificateCopyValues(
            certificate: &SecCertificate,
            keys: Option<&CFArray>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { SecCertificateCopyValues(certificate, keys, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::long_description`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyLongDescription(
    alloc: Option<&CFAllocator>,
    certificate: &SecCertificate,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SecCertificateCopyLongDescription(
            alloc: Option<&CFAllocator>,
            certificate: &SecCertificate,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SecCertificateCopyLongDescription(alloc, certificate, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::short_description`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyShortDescription(
    alloc: Option<&CFAllocator>,
    certificate: &SecCertificate,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SecCertificateCopyShortDescription(
            alloc: Option<&CFAllocator>,
            certificate: &SecCertificate,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SecCertificateCopyShortDescription(alloc, certificate, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::normalized_issuer_content`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyNormalizedIssuerContent(
    certificate: &SecCertificate,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecCertificateCopyNormalizedIssuerContent(
            certificate: &SecCertificate,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopyNormalizedIssuerContent(certificate, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecCertificate::normalized_subject_content`"]
#[inline]
pub unsafe extern "C-unwind" fn SecCertificateCopyNormalizedSubjectContent(
    certificate: &SecCertificate,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecCertificateCopyNormalizedSubjectContent(
            certificate: &SecCertificate,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecCertificateCopyNormalizedSubjectContent(certificate, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
