//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// The domain for CFErrorRefs created by Transforms
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrordomain?language=objc)
    pub static kSecTransformErrorDomain: &'static CFString;
}

extern "C" {
    /// If multiple errors occurred, the CFErrorRef that
    /// is returned from a Transfo]rm API will have a userInfo
    /// dictionary and that dictionary will have the previous
    /// error keyed by the kSecTransformPreviousErrorKey.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformpreviouserrorkey?language=objc)
    pub static kSecTransformPreviousErrorKey: &'static CFString;
}

extern "C" {
    /// The value of this key will be the transform that caused
    /// the transform chain to abort.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformabortoriginatorkey?language=objc)
    pub static kSecTransformAbortOriginatorKey: &'static CFString;
}

/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorattributenotfound?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorAttributeNotFound: CFIndex = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidoperation?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidOperation: CFIndex = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrornotinitializedcorrectly?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorNotInitializedCorrectly: CFIndex = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrormorethanoneoutput?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorMoreThanOneOutput: CFIndex = 4;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidinputdictionary?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidInputDictionary: CFIndex = 5;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidalgorithm?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidAlgorithm: CFIndex = 6;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidlength?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidLength: CFIndex = 7;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidtype?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidType: CFIndex = 8;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidinput?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidInput: CFIndex = 10;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrornamealreadyregistered?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorNameAlreadyRegistered: CFIndex = 11;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorunsupportedattribute?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorUnsupportedAttribute: CFIndex = 12;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformoperationnotsupportedongroup?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformOperationNotSupportedOnGroup: CFIndex = 13;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrormissingparameter?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorMissingParameter: CFIndex = 14;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorinvalidconnection?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorInvalidConnection: CFIndex = 15;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformtransformisexecuting?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformTransformIsExecuting: CFIndex = 16;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransforminvalidoverride?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformInvalidOverride: CFIndex = 17;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformtransformisnotregistered?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformTransformIsNotRegistered: CFIndex = 18;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerrorabortinprogress?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorAbortInProgress: CFIndex = 19;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformerroraborted?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformErrorAborted: CFIndex = 20;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksectransforminvalidargument?language=objc)
#[deprecated = "SecTransform is no longer supported"]
pub const kSecTransformInvalidArgument: CFIndex = 21;

/// [Apple's documentation](https://developer.apple.com/documentation/security/sectransform?language=objc)
#[doc(alias = "SecTransformRef")]
#[deprecated = "SecTransform is no longer supported"]
pub type SecTransform = CFType;

/// [Apple's documentation](https://developer.apple.com/documentation/security/secgrouptransform?language=objc)
#[doc(alias = "SecGroupTransformRef")]
#[deprecated = "SecTransform is no longer supported"]
pub type SecGroupTransform = CFType;

/// Return the CFTypeID for a SecTransform.
///
/// Returns: The CFTypeID
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub extern "C-unwind" fn SecTransformGetTypeID() -> CFTypeID {
    extern "C-unwind" {
        fn SecTransformGetTypeID() -> CFTypeID;
    }
    unsafe { SecTransformGetTypeID() }
}

/// Return the CFTypeID for a SecTransformGroup.
///
/// Returns: The CFTypeID
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub extern "C-unwind" fn SecGroupTransformGetTypeID() -> CFTypeID {
    extern "C-unwind" {
        fn SecGroupTransformGetTypeID() -> CFTypeID;
    }
    unsafe { SecGroupTransformGetTypeID() }
}

extern "C" {
    /// **************    Transform Attribute Names  ***************
    ///
    ///
    /// The name of the input attribute.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransforminputattributename?language=objc)
    #[deprecated = "SecTransform is no longer supported"]
    pub static kSecTransformInputAttributeName: &'static CFString;
}

extern "C" {
    /// The name of the output attribute.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformoutputattributename?language=objc)
    #[deprecated = "SecTransform is no longer supported"]
    pub static kSecTransformOutputAttributeName: &'static CFString;
}

extern "C" {
    /// Set this attribute to a CFWriteStream.
    /// This will signal the transform to write debugging
    /// information to the stream.
    /// If this attribute is set to kCFBooleanTrue then
    /// the debugging data will be written out to
    /// stderr.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformdebugattributename?language=objc)
    #[deprecated = "SecTransform is no longer supported"]
    pub static kSecTransformDebugAttributeName: &'static CFString;
}

extern "C" {
    /// The name of the transform.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformtransformname?language=objc)
    #[deprecated = "SecTransform is no longer supported"]
    pub static kSecTransformTransformName: &'static CFString;
}

extern "C" {
    /// The name of the abort attribute.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/security/ksectransformabortattributename?language=objc)
    #[deprecated = "SecTransform is no longer supported"]
    pub static kSecTransformAbortAttributeName: &'static CFString;
}

/// Creates a transform instance from a CFDictionary of
/// parameters.
///
///
/// Parameter `dictionary`: The dictionary of parameters.
///
///
/// Parameter `error`: An optional pointer to a CFErrorRef. This value is
/// set if an error occurred.  If not NULL the caller is
/// responsible for releasing the CFErrorRef.
///
///
/// Returns: A pointer to a SecTransformRef object.  You
/// must release the object with CFRelease when you are done
/// with it. A NULL will be returned if an error occurred during
/// initialization, and if the error parameter
/// is non-null, it contains the specific error data.
///
/// # Safety
///
/// - `dictionary` generics must be of the correct type.
/// - `error` must be a valid pointer or null.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformCreateFromExternalRepresentation(
    dictionary: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecTransform>> {
    extern "C-unwind" {
        fn SecTransformCreateFromExternalRepresentation(
            dictionary: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecTransform>>;
    }
    let ret = unsafe { SecTransformCreateFromExternalRepresentation(dictionary, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Create a CFDictionaryRef that contains enough
/// information to be able to recreate a transform.
///
///
/// Parameter `transformRef`: The transformRef to be externalized.
///
///
/// This function returns a CFDictionaryRef that contains
/// sufficient information to be able to recreate this
/// transform.  You can pass this CFDictionaryRef to
/// SecTransformCreateFromExternalRepresentation
/// to be able to recreate the transform.  The dictionary
/// can also be written out to disk using the techniques
/// described here.
///
/// http://developer.apple.com/mac/library/documentation/CoreFoundation/Conceptual/CFPropertyLists/Articles/Saving.html
///
/// # Safety
///
/// `transform_ref` should be of the correct type.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformCopyExternalRepresentation(
    transform_ref: &SecTransform,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn SecTransformCopyExternalRepresentation(
            transform_ref: &SecTransform,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { SecTransformCopyExternalRepresentation(transform_ref) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Create a SecGroupTransformRef that acts as a
/// container for a set of connected transforms.
///
///
/// Returns: A reference to a SecGroupTransform.
///
///
/// A SecGroupTransformRef is a container for all of
/// the transforms that are in a directed graph.
/// A SecGroupTransformRef can be used with
/// SecTransformExecute, SecTransformExecuteAsync
/// and SecTransformCopyExternalRepresentation
/// APIs. While the intention is that a
/// SecGroupTransformRef willwork just like a S
/// SecTransformRef that is currently not the case.
/// Using a SecGroupTransformRef with the
/// SecTransformConnectTransforms,
/// SecTransformSetAttribute and
/// SecTransformGetAttribute is undefined.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformCreateGroupTransform() -> CFRetained<SecGroupTransform>
{
    extern "C-unwind" {
        fn SecTransformCreateGroupTransform() -> Option<NonNull<SecGroupTransform>>;
    }
    let ret = unsafe { SecTransformCreateGroupTransform() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Pipe fitting for transforms.
///
///
/// Parameter `sourceTransformRef`: The transform that sends the data to the
/// destinationTransformRef.
///
///
/// Parameter `sourceAttributeName`: The name of the attribute in the sourceTransformRef that
/// supplies the data to the destinationTransformRef.
/// Any attribute of the transform may be used as a source.
///
///
/// Parameter `destinationTransformRef`: The transform that has one of its attributes
/// be set with the data from the sourceTransformRef
/// parameter.
///
///
/// Parameter `destinationAttributeName`: The name of the attribute within the
/// destinationTransformRef whose data is set with the
/// data from the sourceTransformRef sourceAttributeName
/// attribute. Any attribute of the transform may be set.
///
///
/// Parameter `group`: In order to ensure referential integrity, transforms
/// are chained together into a directed graph and
/// placed into a group.  Each transform that makes up the
/// graph must be placed into the same group.  After
/// a SecTransformRef has been placed into a group by
/// calling the SecTransformConnectTransforms it may be
/// released as the group will retain the transform.
/// CFRelease the group after you execute
/// it, or when you determine you will never execute it.
///
/// In the example below, the output of trans1 is
/// set to be the input of trans2.  The output of trans2
/// is set to be the input of trans3.  Since the
/// same group was used for the connections, the three
/// transforms are in the same group.
///
/// <pre>
///
/// ```text
///                         SecGroupTransformRef group =SecTransformCreateGroupTransform();
///                         CFErrorRef error = NULL;
///                         
///                         SecTransformRef trans1; // previously created using a
///                                                 // Transform construction API
///                                                 // like SecEncryptTransformCreate
///                                                 
///                         SecTransformRef trans2;    // previously created using a
///                                                 // Transform construction API
///                                                 // like SecEncryptTransformCreate
///                     
///                         SecTransformRef trans3; // previously created using a
///                                                 // Transform construction API
///                                                 // like SecEncryptTransformCreate
///                         
///                         
///                         SecTransformConnectTransforms(trans1, kSecTransformOutputAttributeName,
///                                                       trans2, kSecTransformInputAttributeName,
///                                                       group, &error);
///                         
///                         SecTransformConnectTransforms(trans2, kSecTransformOutputAttributeName,
///                                                       trans3, kSecTransformInputAttributeName.
///                                                       group, &error);
///                         CFRelease(trans1);
///                         CFRelease(trans2);
///                         CFRelease(trans3);
///                         
///                         CFDataRef = (CFDataRef)SecTransformExecute(group, &error, NULL, NULL);
///                         CFRelease(group);                    
/// ```
///
/// </pre>
///
///
/// Parameter `error`: An optional pointer to a CFErrorRef.  This value
/// is set if an error occurred. If not NULL, the caller
/// is responsible for releasing the CFErrorRef.
///
///
/// Returns: The value returned is SecGroupTransformRef parameter.
/// This will allow for chaining calls to
/// SecTransformConnectTransforms.
///
///
/// This function places transforms into a group by attaching
/// the value of an attribute of one transform to the
/// attribute of another transform.  Typically the attribute
/// supplying the data is the kSecTransformAttrOutput
/// attribute but that is not a requirement.  It can be used to
/// set an attribute like Salt with the output attribute of
/// a random number transform. This function returns an
/// error and the named attribute will not be changed if
/// SecTransformExecute had previously been called on the
/// transform.
///
/// # Safety
///
/// - `source_transform_ref` should be of the correct type.
/// - `destination_transform_ref` should be of the correct type.
/// - `group` should be of the correct type.
/// - `error` must be a valid pointer or null.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformConnectTransforms(
    source_transform_ref: &SecTransform,
    source_attribute_name: &CFString,
    destination_transform_ref: &SecTransform,
    destination_attribute_name: &CFString,
    group: &SecGroupTransform,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecGroupTransform>> {
    extern "C-unwind" {
        fn SecTransformConnectTransforms(
            source_transform_ref: &SecTransform,
            source_attribute_name: &CFString,
            destination_transform_ref: &SecTransform,
            destination_attribute_name: &CFString,
            group: &SecGroupTransform,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecGroupTransform>>;
    }
    let ret = unsafe {
        SecTransformConnectTransforms(
            source_transform_ref,
            source_attribute_name,
            destination_transform_ref,
            destination_attribute_name,
            group,
            error,
        )
    };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Set a static value as the value of an attribute in a
/// transform. This is useful for things like iteration
/// counts and other non-changing values.
///
///
/// Parameter `transformRef`: The transform whose attribute is to be set.
///
///
/// Parameter `key`: The name of the attribute to be set.
///
///
/// Parameter `value`: The static value to set for the named attribute.
///
///
/// Parameter `error`: An optional pointer to a CFErrorRef.  This value
/// is set if an error occurred. If not NULL the caller
/// is responsible for releasing the CFErrorRef.
///
///
/// Returns: Returns true if the call succeeded. If an error occurred,
/// the error parameter has more information
/// about the failure case.
///
///
/// This API allows for setting static data into an
/// attribute for a transform.  This is in contrast to
/// the SecTransformConnectTransforms function which sets derived
/// data. This function will return an error and the
/// named attribute will not be changed if SecTransformExecute
/// has been called on the transform.
///
/// # Safety
///
/// - `transform_ref` should be of the correct type.
/// - `value` should be of the correct type.
/// - `error` must be a valid pointer or null.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformSetAttribute(
    transform_ref: &SecTransform,
    key: &CFString,
    value: &CFType,
    error: *mut *mut CFError,
) -> bool {
    extern "C-unwind" {
        fn SecTransformSetAttribute(
            transform_ref: &SecTransform,
            key: &CFString,
            value: &CFType,
            error: *mut *mut CFError,
        ) -> Boolean;
    }
    let ret = unsafe { SecTransformSetAttribute(transform_ref, key, value, error) };
    ret != 0
}

/// Get the current value of a transform attribute.
///
///
/// Parameter `transformRef`: The transform whose attribute value will be retrieved.
///
///
/// Parameter `key`: The name of the attribute to retrieve.
///
///
/// Returns: The value of an attribute.  If this attribute
/// is being set as the output of another transform
/// and SecTransformExecute has not been called on the
/// transform or if the attribute does not exists
/// then NULL will be returned.
///
///
/// This may be called after SecTransformExecute.
///
/// # Safety
///
/// `transform_ref` should be of the correct type.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformGetAttribute(
    transform_ref: &SecTransform,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn SecTransformGetAttribute(
            transform_ref: &SecTransform,
            key: &CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { SecTransformGetAttribute(transform_ref, key) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Finds a member of a transform group by its name.
///
///
/// Parameter `transform`: The transform group to be searched.
///
///
/// Parameter `name`: The name of the transform to be found.
///
///
/// When a transform instance is created it will be given a
/// unique name.  This name can be used to find that instance
/// in a group.  While it is possible to change this unique
/// name using the SecTransformSetAttribute API, developers
/// should not do so.  This allows
/// SecTransformFindTransformByName to work correctly.
///
///
/// Returns: The transform group member, or NULL if the member
/// was not found.
///
/// # Safety
///
/// `transform` should be of the correct type.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformFindByName(
    transform: &SecGroupTransform,
    name: &CFString,
) -> Option<CFRetained<SecTransform>> {
    extern "C-unwind" {
        fn SecTransformFindByName(
            transform: &SecGroupTransform,
            name: &CFString,
        ) -> Option<NonNull<SecTransform>>;
    }
    let ret = unsafe { SecTransformFindByName(transform, name) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Executes a Transform or transform group synchronously.
///
///
/// Parameter `transformRef`: The transform to execute.
///
///
/// Parameter `errorRef`: An optional pointer to a CFErrorRef.  This value
/// will be set if an error occurred during
/// initialization or execution of the transform or group.
/// If not NULL the caller will be responsible for releasing
/// the returned CFErrorRef.
///
///
/// Returns: This is the result of the transform. The specific value
/// is determined by the transform being executed.
///
///
/// There are two phases that occur when executing a
/// transform. The first phase checks to see if the tranforms
/// have all of their required attributes set.
/// If a GroupTransform is being executed, then a required
/// attribute for a transform is valid if it is connected
/// to another attribute that supplies the required value.
/// If any of the required attributes are not set or connected
/// then SecTransformExecute will not run the transform but will
/// return NULL and the apporiate error is placed in the
/// error parameter if it is not NULL.
///
/// The second phase is the actual execution of the transform.
/// SecTransformExecute executes the transform or
/// GroupTransform and when all of the processing is completed
/// it returns the result.  If an error occurs during
/// execution, then all processing will stop and NULL will be
/// returned and the appropriate error will be placed in the
/// error parameter if it is not NULL.
///
/// # Safety
///
/// - `transform_ref` should be of the correct type.
/// - `error_ref` must be a valid pointer or null.
#[deprecated = "SecTransform is no longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SecTransformExecute(
    transform_ref: &SecTransform,
    error_ref: *mut *mut CFError,
) -> CFRetained<CFType> {
    extern "C-unwind" {
        fn SecTransformExecute(
            transform_ref: &SecTransform,
            error_ref: *mut *mut CFError,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { SecTransformExecute(transform_ref, error_ref) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// A SecMessageBlock is used by a transform instance to
/// deliver messages during asynchronous operations.
///
///
/// Parameter `message`: A CFType containing the message.  This is where
/// either intermediate or final results are returned.
///
///
/// Parameter `error`: If an error occurred, this will contain a CFErrorRef,
/// otherwise this will be NULL. If not NULL the caller
/// is responsible for releasing the CFErrorRef.
///
///
/// Parameter `isFinal`: If set the message returned is the final result
/// otherwise it is an intermediate result.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/secmessageblock?language=objc)
#[cfg(feature = "block2")]
pub type SecMessageBlock = *mut block2::DynBlock<dyn Fn(*const CFType, *mut CFError, Boolean)>;
