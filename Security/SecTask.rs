//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// CFType used for representing a task
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/security/sectask?language=objc)
#[repr(C)]
pub struct SecTask {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl SecTask {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__SecTask"> for SecTask {}
);

unsafe impl ConcreteType for SecTask {
    /// Returns the type ID for CF instances of SecTask.
    ///
    /// Returns: A CFTypeID for SecTask
    #[doc(alias = "SecTaskGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecTaskGetTypeID() -> CFTypeID;
        }
        unsafe { SecTaskGetTypeID() }
    }
}

impl SecTask {
    /// Create a SecTask object for the current task.
    ///
    /// Returns: The newly created SecTask object or NULL on error.  The caller must
    /// CFRelease the returned object.
    #[doc(alias = "SecTaskCreateFromSelf")]
    #[inline]
    pub unsafe fn from_self(allocator: Option<&CFAllocator>) -> Option<CFRetained<SecTask>> {
        extern "C-unwind" {
            fn SecTaskCreateFromSelf(allocator: Option<&CFAllocator>) -> Option<NonNull<SecTask>>;
        }
        let ret = unsafe { SecTaskCreateFromSelf(allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the value of a single entitlement for the represented
    /// task.
    ///
    /// Parameter `task`: A previously created SecTask object
    ///
    /// Parameter `entitlement`: The name of the entitlement to be fetched
    ///
    /// Parameter `error`: On a NULL return, this may be contain a CFError describing
    /// the problem.  This argument may be NULL if the caller is not interested in
    /// detailed errors.
    ///
    /// Returns: The value of the specified entitlement for the process or NULL if
    /// the entitlement value could not be retrieved.  The type of the returned
    /// value will depend on the entitlement specified.  The caller must release
    /// the returned object.
    ///
    /// A NULL return may indicate an error, or it may indicate that
    /// the entitlement is simply not present.  In the latter case, no CFError is
    /// returned.
    #[doc(alias = "SecTaskCopyValueForEntitlement")]
    #[inline]
    pub unsafe fn value_for_entitlement(
        self: &SecTask,
        entitlement: &CFString,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn SecTaskCopyValueForEntitlement(
                task: &SecTask,
                entitlement: &CFString,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { SecTaskCopyValueForEntitlement(self, entitlement, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the values of multiple entitlements for the represented
    /// task.
    ///
    /// Parameter `task`: A previously created SecTask object
    ///
    /// Parameter `entitlements`: An array of entitlement names to be fetched
    ///
    /// Parameter `error`: On a NULL return, this will contain a CFError describing
    /// the problem.  This argument may be NULL if the caller is not interested in
    /// detailed errors.  If a requested entitlement is not present for the
    /// returned dictionary, the entitlement is not set on the task.  The caller
    /// must CFRelease the returned value
    #[doc(alias = "SecTaskCopyValuesForEntitlements")]
    #[inline]
    pub unsafe fn values_for_entitlements(
        self: &SecTask,
        entitlements: &CFArray,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn SecTaskCopyValuesForEntitlements(
                task: &SecTask,
                entitlements: &CFArray,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { SecTaskCopyValuesForEntitlements(self, entitlements, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Return the value of the codesigning identifier.
    ///
    /// Parameter `task`: A previously created SecTask object
    ///
    /// Parameter `error`: On a NULL return, this will contain a CFError describing
    /// the problem.  This argument may be NULL if the caller is not interested in
    /// detailed errors. The caller must CFRelease the returned value
    #[doc(alias = "SecTaskCopySigningIdentifier")]
    #[inline]
    pub unsafe fn signing_identifier(
        self: &SecTask,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SecTaskCopySigningIdentifier(
                task: &SecTask,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SecTaskCopySigningIdentifier(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Return the code sign status flags
    ///
    /// Parameter `task`: A previously created SecTask object
    #[doc(alias = "SecTaskGetCodeSignStatus")]
    #[inline]
    pub unsafe fn code_sign_status(self: &SecTask) -> u32 {
        extern "C-unwind" {
            fn SecTaskGetCodeSignStatus(task: &SecTask) -> u32;
        }
        unsafe { SecTaskGetCodeSignStatus(self) }
    }
}

#[deprecated = "renamed to `SecTask::from_self`"]
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCreateFromSelf(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<SecTask>> {
    extern "C-unwind" {
        fn SecTaskCreateFromSelf(allocator: Option<&CFAllocator>) -> Option<NonNull<SecTask>>;
    }
    let ret = unsafe { SecTaskCreateFromSelf(allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `SecTask::value_for_entitlement`"]
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCopyValueForEntitlement(
    task: &SecTask,
    entitlement: &CFString,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn SecTaskCopyValueForEntitlement(
            task: &SecTask,
            entitlement: &CFString,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { SecTaskCopyValueForEntitlement(task, entitlement, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `SecTask::values_for_entitlements`"]
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCopyValuesForEntitlements(
    task: &SecTask,
    entitlements: &CFArray,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn SecTaskCopyValuesForEntitlements(
            task: &SecTask,
            entitlements: &CFArray,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { SecTaskCopyValuesForEntitlements(task, entitlements, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `SecTask::signing_identifier`"]
#[inline]
pub unsafe extern "C-unwind" fn SecTaskCopySigningIdentifier(
    task: &SecTask,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SecTaskCopySigningIdentifier(
            task: &SecTask,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SecTaskCopySigningIdentifier(task, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `SecTask::code_sign_status`"]
    pub fn SecTaskGetCodeSignStatus(task: &SecTask) -> u32;
}
