//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// Basic X509-style certificate evaluation.
    /// Predefined constants used to specify a policy.
    pub static kSecPolicyAppleX509Basic: &'static CFString;
}

extern "C" {
    /// Basic X509 plus host name verification per RFC 2818.
    pub static kSecPolicyAppleSSL: &'static CFString;
}

extern "C" {
    /// Basic X509 plus email address verification and `KeyUsage` enforcement per RFC 2632.
    pub static kSecPolicyAppleSMIME: &'static CFString;
}

extern "C" {
    /// Extensible Authentication Protocol. Functionally identical to SSL policy. A separate OID is provided to facilitate per-policy, per-certificate trust settings using the `SecTrust` mechanism.
    pub static kSecPolicyAppleEAP: &'static CFString;
}

extern "C" {
    /// Policy for use in IPsec communication. Functionally identical to SSL policy. A separate OID is provided to facilitate per-policy, per-certificate trust settings using the `SecTrust` mechanism.
    pub static kSecPolicyAppleIPsec: &'static CFString;
}

extern "C" {
    /// Policy for use in iChat.
    #[deprecated]
    pub static kSecPolicyAppleiChat: &'static CFString;
}

extern "C" {
    /// Kerberos Pkinit client certificate validation.
    pub static kSecPolicyApplePKINITClient: &'static CFString;
}

extern "C" {
    /// Kerberos Pkinit server certificate validation.
    pub static kSecPolicyApplePKINITServer: &'static CFString;
}

extern "C" {
    /// Policy for use in evaluating Apple code signing certificates.
    ///
    /// ## Discussion
    ///
    /// To learn more about code signing certificates, read [App Distribution Guide](https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582).
    ///
    ///
    pub static kSecPolicyAppleCodeSigning: &'static CFString;
}

extern "C" {
    /// Policy for use in evaluating Mac App Store receipts.
    pub static kSecPolicyMacAppStoreReceipt: &'static CFString;
}

extern "C" {
    /// Policy for use in evaluating Apple ID certificates.
    ///
    /// ## Discussion
    ///
    /// To learn more about Apple ID certificates, read [App Distribution Guide](https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/AppDistributionGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40012582).
    ///
    ///
    pub static kSecPolicyAppleIDValidation: &'static CFString;
}

extern "C" {
    /// Policy that causes evaluation of the validity of the time stamp on a signature. This can be used to allow verification that a certificate was valid at the time that something was signed with that certificate even if the certificate is no longer valid.
    pub static kSecPolicyAppleTimeStamping: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleRevocation: &'static CFString;
}

extern "C" {
    pub static kSecPolicyApplePassbookSigning: &'static CFString;
}

extern "C" {
    pub static kSecPolicyApplePayIssuerEncryption: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleSSLServer: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleSSLClient: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleEAPServer: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleEAPClient: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleIPSecServer: &'static CFString;
}

extern "C" {
    pub static kSecPolicyAppleIPSecClient: &'static CFString;
}

extern "C" {
    /// The object identifier that defines the policy type (`CFStringRef`). All policies have a value for this key.
    /// Predefined property key constants used to get or set values in
    /// a dictionary for a policy instance.
    ///
    /// All policies will have the following read-only value:
    /// kSecPolicyOid       (the policy object identifier)
    ///
    /// Additional policy values which your code can optionally set:
    /// kSecPolicyName      (name which must be matched)
    /// kSecPolicyClient    (evaluate for client, rather than server)
    /// kSecPolicyRevocationFlags   (only valid for a revocation policy)
    /// kSecPolicyTeamIdentifier    (only valid for a Passbook signing policy)
    ///
    ///
    ///
    /// containing a name which must be matched in the certificate to satisfy
    /// this policy. For SSL/TLS, EAP, and IPSec policies, this specifies the
    /// server name which must match the common name of the certificate.
    /// For S/MIME, this specifies the RFC822 email address. For Passbook
    /// signing, this specifies the pass signer.
    ///
    /// this evaluation should be for a client certificate. If not set (or
    /// false), the policy evaluates the certificate as a server certificate.
    ///
    /// kCFNumberCFIndexType bitmask value. See "Revocation Policy Constants"
    /// for a description of individual bits in this value.
    ///
    /// team identifier which must be matched in the certificate to satisfy
    /// this policy. For the Passbook signing policy, this string must match
    /// the Organizational Unit field of the certificate subject.
    pub static kSecPolicyOid: &'static CFString;
}

extern "C" {
    /// A name (`CFStringRef`) that the certificate must match to satisfy this policy. For SSL/TLS, this specifies the server name which must match the common name of the certificate. For S/MIME, this specifies the RFC 822 email address.
    pub static kSecPolicyName: &'static CFString;
}

extern "C" {
    /// If true, indicates this policy should be evaluated against the client certificate. If false, the policy is evaluated against the certificate for the server. Default is false.
    pub static kSecPolicyClient: &'static CFString;
}

extern "C" {
    pub static kSecPolicyRevocationFlags: &'static CFString;
}

extern "C" {
    pub static kSecPolicyTeamIdentifier: &'static CFString;
}

#[cfg(feature = "SecBase")]
unsafe impl ConcreteType for SecPolicy {
    /// Returns the unique identifier of the opaque type to which a policy object belongs.
    ///
    /// ## Return Value
    ///
    /// A value that identifies the opaque type of a [`SecPolicyRef`](https://developer.apple.com/documentation/security/secpolicy) object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns a value that uniquely identifies the opaque type of a [`SecPolicyRef`](https://developer.apple.com/documentation/security/secpolicy) object. You can compare this value to the [`CFTypeID`](https://developer.apple.com/documentation/corefoundation/cftypeid) identifier obtained by calling the [`CFGetTypeID`](https://developer.apple.com/documentation/corefoundation/cfgettypeid(_:)) function on a specific object. These values might change from release to release or platform to platform.
    ///
    ///
    /// Returns the type identifier of SecPolicy instances.
    ///
    /// Returns: The CFTypeID of SecPolicy instances.
    #[doc(alias = "SecPolicyGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecPolicyGetTypeID() -> CFTypeID;
        }
        unsafe { SecPolicyGetTypeID() }
    }
}

#[cfg(feature = "SecBase")]
impl SecPolicy {
    /// Returns a dictionary containing a policy’s properties.
    ///
    /// Parameters:
    /// - policyRef: The policy from which properties should be copied.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary with the policy’s properties. See [Security Policy Keys](https://developer.apple.com/documentation/security/security-policy-keys) for a list of valid keys. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the dictionary’s memory when you are done with it.
    ///
    ///
    /// Returns a dictionary of this policy's properties.
    ///
    /// Parameter `policyRef`: A policy reference.
    ///
    /// Returns: A properties dictionary. See "Policy Value Constants" for a list
    /// of currently defined property keys. It is the caller's responsibility to
    /// CFRelease this reference when it is no longer needed.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function returns the properties for a policy, as set by the
    /// policy's construction function or by a prior call to SecPolicySetProperties.
    #[doc(alias = "SecPolicyCopyProperties")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn properties(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn SecPolicyCopyProperties(policy_ref: &SecPolicy) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { SecPolicyCopyProperties(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a policy object for the default X.509 policy.
    ///
    /// ## Return Value
    ///
    /// The policy object. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release the object when you are finished with it.
    ///
    ///
    /// Returns a policy object for the default X.509 policy.
    ///
    /// Returns: A policy object. The caller is responsible for calling CFRelease
    /// on this when it is no longer needed.
    #[doc(alias = "SecPolicyCreateBasicX509")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn new_basic_x509() -> CFRetained<SecPolicy> {
        extern "C-unwind" {
            fn SecPolicyCreateBasicX509() -> Option<NonNull<SecPolicy>>;
        }
        let ret = unsafe { SecPolicyCreateBasicX509() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Returns a policy object for evaluating SSL certificate chains.
    ///
    /// Parameters:
    /// - server: Specify `true` on the client side to return a policy for SSL server certificates.
    ///
    /// - hostname: If you specify a value for this parameter, the policy will require the specified value to match the host name in the leaf certificate.
    ///
    ///
    /// ## Return Value
    ///
    /// The policy object. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release the object when you are finished with it.
    ///
    ///
    /// Returns a policy object for evaluating SSL certificate chains.
    ///
    /// Parameter `server`: Passing true for this parameter creates a policy for SSL
    /// server certificates.
    ///
    /// Parameter `hostname`: (Optional) If present, the policy will require the specified
    /// hostname to match the hostname in the leaf certificate.
    ///
    /// Returns: A policy object. The caller is responsible for calling CFRelease
    /// on this when it is no longer needed.
    #[doc(alias = "SecPolicyCreateSSL")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn new_ssl(server: bool, hostname: Option<&CFString>) -> CFRetained<SecPolicy> {
        extern "C-unwind" {
            fn SecPolicyCreateSSL(
                server: Boolean,
                hostname: Option<&CFString>,
            ) -> Option<NonNull<SecPolicy>>;
        }
        let ret = unsafe { SecPolicyCreateSSL(server as _, hostname) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

/// Perform revocation     checking using OCSP (Online Certificate Status Protocol).
pub const kSecRevocationOCSPMethod: CFOptionFlags = 1;
/// Perform revocation checking using the CRL (Certification Revocation List) method.
pub const kSecRevocationCRLMethod: CFOptionFlags = 2;
/// Prefer CRL revocation checking over OCSP; by default, OCSP is preferred.
pub const kSecRevocationPreferCRL: CFOptionFlags = 4;
/// Require a positive response to pass the policy.
///
/// ## Discussion
///
/// If the flag is not set, revocation checking is done on a “best attempt” basis, where failure to reach the server is not considered fatal.
///
///
pub const kSecRevocationRequirePositiveResponse: CFOptionFlags = 8;
/// Consult only locally cached replies; do not use network access.
pub const kSecRevocationNetworkAccessDisabled: CFOptionFlags = 16;
/// Perform either OCSP or CRL checking.
///
/// ## Discussion
///
/// The checking is performed according to the method(s) specified in the certificate and the value of [`kSecRevocationPreferCRL`](https://developer.apple.com/documentation/security/ksecrevocationprefercrl).
///
///
pub const kSecRevocationUseAnyAvailableMethod: CFOptionFlags = 3;

#[cfg(feature = "SecBase")]
impl SecPolicy {
    /// Returns a policy object for checking revocation of certificates.
    ///
    /// Parameters:
    /// - revocationFlags: Flags that specify revocation checking options. See [Revocation Policy Constants](https://developer.apple.com/documentation/security/revocation-policy-constants) for a list of possible values.
    ///
    ///
    /// ## Return Value
    ///
    /// A policy object or `nil` on failure.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// It’s usually not necessary to create a revocation policy yourself unless you wish to override default system behavior, for example to force a particular method, or to disable revocation checking entirely.
    ///
    ///
    /// Returns a policy object for checking revocation of certificates.
    ///
    /// Returns: A policy object. The caller is responsible for calling CFRelease
    /// on this when it is no longer needed.
    ///
    /// Parameter `revocationFlags`: Flags to specify revocation checking options.
    ///
    /// Use this function to create a revocation policy with behavior
    /// specified by revocationFlags. See the "Revocation Policy Constants" section
    /// for a description of these flags. Note: it is usually not necessary to
    /// create a revocation policy yourself unless you wish to override default
    /// system behavior (e.g. to force a particular method, or to disable
    /// revocation checking entirely.)
    #[doc(alias = "SecPolicyCreateRevocation")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn new_revocation(revocation_flags: CFOptionFlags) -> Option<CFRetained<SecPolicy>> {
        extern "C-unwind" {
            fn SecPolicyCreateRevocation(
                revocation_flags: CFOptionFlags,
            ) -> Option<NonNull<SecPolicy>>;
        }
        let ret = unsafe { SecPolicyCreateRevocation(revocation_flags) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a policy object based on an object identifier for the policy type.
    ///
    /// Parameters:
    /// - policyIdentifier: The identifier for the desired policy type.
    ///
    /// - properties: A properties dictionary. See [Security Policy Keys](https://developer.apple.com/documentation/security/security-policy-keys) for a list of valid property names to use as keys in this dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// A new policy, or `NULL` if the policy could not be created.
    ///
    ///
    /// Returns a policy object based on an object identifier for the
    /// policy type. See the "Policy Constants" section for a list of defined
    /// policy object identifiers.
    ///
    /// Parameter `policyIdentifier`: The identifier for the desired policy type.
    ///
    /// Parameter `properties`: (Optional) A properties dictionary. See "Policy Value
    /// Constants" for a list of currently defined property keys.
    ///
    /// Returns: The returned policy reference, or NULL if the policy could not be
    /// created.
    ///
    /// # Safety
    ///
    /// - `policy_identifier` should be of the correct type.
    /// - `properties` generic must be of the correct type.
    /// - `properties` generic must be of the correct type.
    #[doc(alias = "SecPolicyCreateWithProperties")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn with_properties(
        policy_identifier: &CFType,
        properties: Option<&CFDictionary>,
    ) -> Option<CFRetained<SecPolicy>> {
        extern "C-unwind" {
            fn SecPolicyCreateWithProperties(
                policy_identifier: &CFType,
                properties: Option<&CFDictionary>,
            ) -> Option<NonNull<SecPolicy>>;
        }
        let ret = unsafe { SecPolicyCreateWithProperties(policy_identifier, properties) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for signing.
    /// Predefined property key constants used to get or set values in
    /// a dictionary for a policy instance.
    ///
    /// Some policy values may specify CFBooleanRef key usage constraints:
    /// kSecPolicyKU_DigitalSignature
    /// kSecPolicyKU_NonRepudiation
    /// kSecPolicyKU_KeyEncipherment
    /// kSecPolicyKU_DataEncipherment
    /// kSecPolicyKU_KeyAgreement
    /// kSecPolicyKU_KeyCertSign
    /// kSecPolicyKU_CRLSign
    /// kSecPolicyKU_EncipherOnly
    /// kSecPolicyKU_DecipherOnly
    ///
    /// kSecPolicyKU policy values define certificate-level key purposes,
    /// in contrast to the key-level definitions in SecItem.h
    ///
    /// For example, a key in a certificate might be acceptable to use for
    /// signing a CRL, but not for signing another certificate. In either
    /// case, this key would have the ability to sign (i.e. kSecAttrCanSign
    /// is true), but may only sign for specific purposes allowed by these
    /// policy constants. Similarly, a public key might have the capability
    /// to perform encryption or decryption, but the certificate in which it
    /// resides might have a decipher-only certificate policy.
    ///
    /// These constants correspond to values defined in RFC 5280, section
    /// 4.2.1.3 (Key Usage) which define the purpose of a key contained in a
    /// certificate, in contrast to section 4.1.2.7 which define the uses that
    /// a key is capable of.
    ///
    /// Note: these constants are not available on iOS. Your code should
    /// avoid direct reliance on these values for making policy decisions
    /// and use higher level policies where possible.
    ///
    ///
    /// have a key usage that allows it to be used for signing.
    ///
    /// have a key usage that allows it to be used for non-repudiation.
    ///
    /// have a key usage that allows it to be used for key encipherment.
    ///
    /// have a key usage that allows it to be used for data encipherment.
    ///
    /// have a key usage that allows it to be used for key agreement.
    ///
    /// have a key usage that allows it to be used for signing certificates.
    ///
    /// have a key usage that allows it to be used for signing CRLs.
    ///
    /// have a key usage that permits it to be used for encryption only.
    ///
    /// have a key usage that permits it to be used for decryption only.
    pub static kSecPolicyKU_DigitalSignature: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for non-repudiation.
    pub static kSecPolicyKU_NonRepudiation: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for key encryption.
    pub static kSecPolicyKU_KeyEncipherment: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for data encryption.
    pub static kSecPolicyKU_DataEncipherment: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for key agreement.
    pub static kSecPolicyKU_KeyAgreement: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for signing certificates.
    pub static kSecPolicyKU_KeyCertSign: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used for signing certificate revocation lists (CRLs).
    pub static kSecPolicyKU_CRLSign: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used _only_ for encryption.
    pub static kSecPolicyKU_EncipherOnly: &'static CFString;
}

extern "C" {
    /// If true, the certificate’s key usage must allow it to be used _only_ for decryption.
    pub static kSecPolicyKU_DecipherOnly: &'static CFString;
}

#[cfg(feature = "SecBase")]
impl SecPolicy {
    /// Returns a policy object for the specified policy type object identifier.
    ///
    /// Parameters:
    /// - policyOID: The object identifier (OID) of the policy type for this policy.
    ///
    /// Returns a policy object based on an object identifier for the
    /// policy type. See the "Policy Constants" section for a list of defined
    /// policy object identifiers.
    ///
    /// Parameter `policyOID`: The OID of the desired policy.
    ///
    /// Returns: The returned policy reference, or NULL if the policy could not be
    /// created.
    ///
    /// This function is deprecated in Mac OS X 10.9 and later;
    /// use SecPolicyCreateWithProperties (or a more specific policy creation
    /// function) instead.
    ///
    /// # Safety
    ///
    /// `policy_oid` should be of the correct type.
    #[doc(alias = "SecPolicyCreateWithOID")]
    #[cfg(feature = "SecBase")]
    #[deprecated]
    #[inline]
    pub unsafe fn with_oid(policy_oid: &CFType) -> Option<CFRetained<SecPolicy>> {
        extern "C-unwind" {
            fn SecPolicyCreateWithOID(policy_oid: &CFType) -> Option<NonNull<SecPolicy>>;
        }
        let ret = unsafe { SecPolicyCreateWithOID(policy_oid) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves a policy’s object identifier.
    ///
    /// Parameters:
    /// - policyRef: The policy object for which to obtain the object identifier. You can obtain a policy object with the [`SecPolicySearchCopyNext`](https://developer.apple.com/documentation/security/secpolicysearchcopynext) function.
    ///
    /// - oid: On return, points to the policy’s object identifier. This identifier is owned by the policy object and remains valid until that object is destroyed; do not release it separately.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The policy’s object identifier, in the form of a `CSSM_OID` structure, is used in the CSSM API together with the policy’s value. Use the [`SecPolicyGetValue`](https://developer.apple.com/documentation/security/secpolicygetvalue) function to obtain the value that corresponds to this object identifier.
    ///
    ///
    /// Returns a policy's object identifier.
    ///
    /// Parameter `policyRef`: A policy reference.
    ///
    /// Parameter `oid`: On return, a pointer to the policy's object identifier.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function is deprecated in Mac OS X 10.7 and later;
    /// use SecPolicyCopyProperties instead.
    ///
    /// # Safety
    ///
    /// `oid` must be a valid pointer.
    #[doc(alias = "SecPolicyGetOID")]
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated]
    #[inline]
    pub unsafe fn oid(&self, oid: NonNull<SecAsn1Oid>) -> OSStatus {
        extern "C-unwind" {
            fn SecPolicyGetOID(policy_ref: &SecPolicy, oid: NonNull<SecAsn1Oid>) -> OSStatus;
        }
        unsafe { SecPolicyGetOID(self, oid) }
    }

    /// Retrieves a policy’s value.
    ///
    /// Parameters:
    /// - policyRef: The policy object for which to retrieve the value.
    ///
    /// - value: On return, points to the policy’s value. This value is owned by the policy object and remains valid until that object is destroyed; do not release it separately.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A policy’s value is defined and interpreted by the policy. If you are using CSSM, you can specify object-identifier–policy-value pairs as input to the `CSSM_TP_POLICYINFO` function. Use the [`SecPolicyGetOID`](https://developer.apple.com/documentation/security/secpolicygetoid) function to obtain the object identifier (OID) for a policy.
    ///
    /// Depending on how the policy uses the value, the value can be specific to a transaction. Because some other process might be using this policy object, it is best not to assign a new value to the policy using the same policy object. Instead, obtain a new policy object before assigning a new value to the policy.
    ///
    ///
    /// Returns a policy's value.
    ///
    /// Parameter `policyRef`: A policy reference.
    ///
    /// Parameter `value`: On return, a pointer to the policy's value.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function is deprecated in Mac OS X 10.7 and later;
    /// use SecPolicyCopyProperties instead.
    ///
    /// # Safety
    ///
    /// `value` must be a valid pointer.
    #[doc(alias = "SecPolicyGetValue")]
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated]
    #[inline]
    pub unsafe fn value(&self, value: NonNull<SecAsn1Item>) -> OSStatus {
        extern "C-unwind" {
            fn SecPolicyGetValue(policy_ref: &SecPolicy, value: NonNull<SecAsn1Item>) -> OSStatus;
        }
        unsafe { SecPolicyGetValue(self, value) }
    }

    /// Sets a policy’s value.
    ///
    /// Parameters:
    /// - policyRef: The policy object whose value you wish to set.
    ///
    /// - value: The value to be set into the policy object, replacing any previous value.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A policy’s value is defined and interpreted by the policy. If you are using CSSM, you can specify object-identifier–policy-value pairs as input to the `CSSM_TP_POLICYINFO` function. Use the [`SecPolicyGetOID`](https://developer.apple.com/documentation/security/secpolicygetoid) function to obtain the object identifier (OID) for a policy.
    ///
    /// Depending on how the policy uses the value, the value can be specific to a transaction. Because some other process might be using this policy object, it is best not to assign a new value to the policy using the same policy object. Instead, obtain a new policy object before assigning a new value to the policy.
    ///
    ///
    /// Sets a policy's value.
    ///
    /// Parameter `policyRef`: A policy reference.
    ///
    /// Parameter `value`: The value to be set into the policy object, replacing any
    /// previous value.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function is deprecated in Mac OS X 10.7 and later. Policy
    /// instances should be considered read-only; in cases where your code would
    /// consider changing properties of a policy, it should instead create a new
    /// policy instance with the desired properties.
    ///
    /// # Safety
    ///
    /// `value` must be a valid pointer.
    #[doc(alias = "SecPolicySetValue")]
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated]
    #[inline]
    pub unsafe fn set_value(&self, value: NonNull<SecAsn1Item>) -> OSStatus {
        extern "C-unwind" {
            fn SecPolicySetValue(policy_ref: &SecPolicy, value: NonNull<SecAsn1Item>) -> OSStatus;
        }
        unsafe { SecPolicySetValue(self, value) }
    }

    /// Sets properties for a policy.
    ///
    /// Parameters:
    /// - policyRef: The policy to alter
    ///
    /// - properties: A `CFDictionaryRef` object containing the new set of properties. For a list of valid property keys, see [Security Policy Keys](https://developer.apple.com/documentation/security/security-policy-keys).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The property [`kSecPolicyOid`](https://developer.apple.com/documentation/security/ksecpolicyoid) is read-only and thus cannot be changed by this function.
    ///
    ///
    ///
    /// </div>
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    /// Sets a policy's properties.
    ///
    /// Parameter `policyRef`: A policy reference.
    ///
    /// Parameter `properties`: A properties dictionary. See "Policy Value Constants"
    /// for a list of currently defined property keys. This dictionary replaces the
    /// policy's existing properties, if any. Note that the policy OID (specified
    /// by kSecPolicyOid) is a read-only property of the policy and cannot be set.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function is deprecated in Mac OS X 10.9 and later. Policy
    /// instances should be considered read-only; in cases where your code would
    /// consider changing properties of a policy, it should instead create a new
    /// policy instance with the desired properties.
    ///
    /// # Safety
    ///
    /// - `properties` generic must be of the correct type.
    /// - `properties` generic must be of the correct type.
    #[doc(alias = "SecPolicySetProperties")]
    #[cfg(feature = "SecBase")]
    #[deprecated]
    #[inline]
    pub unsafe fn set_properties(&self, properties: &CFDictionary) -> OSStatus {
        extern "C-unwind" {
            fn SecPolicySetProperties(
                policy_ref: &SecPolicy,
                properties: &CFDictionary,
            ) -> OSStatus;
        }
        unsafe { SecPolicySetProperties(self, properties) }
    }

    /// Retrieves the trust policy handle for a policy object.
    ///
    /// Parameters:
    /// - policyRef: The policy object from which to obtain the trust policy handle.
    ///
    /// - tpHandle: On return, points to the policy object’s trust policy handle. The handle remains valid until the policy object is released.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The trust policy handle is the CSSM identifier of the trust policy module that is managing the certificate. The trust policy handle is uses as an input to a number of CSSM functions.
    ///
    ///
    /// Returns the CSSM trust policy handle for the given policy.
    ///
    /// Parameter `policyRef`: A policy reference.
    ///
    /// Parameter `tpHandle`: On return, a pointer to a value of type CSSM_TP_HANDLE.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This function is deprecated in Mac OS X 10.7 and later.
    ///
    /// # Safety
    ///
    /// `tp_handle` must be a valid pointer.
    #[doc(alias = "SecPolicyGetTPHandle")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn tp_handle(&self, tp_handle: NonNull<CSSM_TP_HANDLE>) -> OSStatus {
        extern "C-unwind" {
            fn SecPolicyGetTPHandle(
                policy_ref: &SecPolicy,
                tp_handle: NonNull<CSSM_TP_HANDLE>,
            ) -> OSStatus;
        }
        unsafe { SecPolicyGetTPHandle(self, tp_handle) }
    }
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecPolicy::properties`"]
#[inline]
pub unsafe extern "C-unwind" fn SecPolicyCopyProperties(
    policy_ref: &SecPolicy,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn SecPolicyCopyProperties(policy_ref: &SecPolicy) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { SecPolicyCopyProperties(policy_ref) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecPolicy::new_basic_x509`"]
#[inline]
pub unsafe extern "C-unwind" fn SecPolicyCreateBasicX509() -> CFRetained<SecPolicy> {
    extern "C-unwind" {
        fn SecPolicyCreateBasicX509() -> Option<NonNull<SecPolicy>>;
    }
    let ret = unsafe { SecPolicyCreateBasicX509() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecPolicy::new_ssl`"]
#[inline]
pub unsafe extern "C-unwind" fn SecPolicyCreateSSL(
    server: bool,
    hostname: Option<&CFString>,
) -> CFRetained<SecPolicy> {
    extern "C-unwind" {
        fn SecPolicyCreateSSL(
            server: Boolean,
            hostname: Option<&CFString>,
        ) -> Option<NonNull<SecPolicy>>;
    }
    let ret = unsafe { SecPolicyCreateSSL(server as _, hostname) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecPolicy::new_revocation`"]
#[inline]
pub unsafe extern "C-unwind" fn SecPolicyCreateRevocation(
    revocation_flags: CFOptionFlags,
) -> Option<CFRetained<SecPolicy>> {
    extern "C-unwind" {
        fn SecPolicyCreateRevocation(revocation_flags: CFOptionFlags)
            -> Option<NonNull<SecPolicy>>;
    }
    let ret = unsafe { SecPolicyCreateRevocation(revocation_flags) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecPolicy::with_properties`"]
#[inline]
pub unsafe extern "C-unwind" fn SecPolicyCreateWithProperties(
    policy_identifier: &CFType,
    properties: Option<&CFDictionary>,
) -> Option<CFRetained<SecPolicy>> {
    extern "C-unwind" {
        fn SecPolicyCreateWithProperties(
            policy_identifier: &CFType,
            properties: Option<&CFDictionary>,
        ) -> Option<NonNull<SecPolicy>>;
    }
    let ret = unsafe { SecPolicyCreateWithProperties(policy_identifier, properties) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecPolicy::with_oid`"]
#[inline]
pub unsafe extern "C-unwind" fn SecPolicyCreateWithOID(
    policy_oid: &CFType,
) -> Option<CFRetained<SecPolicy>> {
    extern "C-unwind" {
        fn SecPolicyCreateWithOID(policy_oid: &CFType) -> Option<NonNull<SecPolicy>>;
    }
    let ret = unsafe { SecPolicyCreateWithOID(policy_oid) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated = "renamed to `SecPolicy::oid`"]
    pub fn SecPolicyGetOID(policy_ref: &SecPolicy, oid: NonNull<SecAsn1Oid>) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated = "renamed to `SecPolicy::value`"]
    pub fn SecPolicyGetValue(policy_ref: &SecPolicy, value: NonNull<SecAsn1Item>) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecAsn1Types", feature = "SecBase"))]
    #[deprecated = "renamed to `SecPolicy::set_value`"]
    pub fn SecPolicySetValue(policy_ref: &SecPolicy, value: NonNull<SecAsn1Item>) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecPolicy::set_properties`"]
    pub fn SecPolicySetProperties(policy_ref: &SecPolicy, properties: &CFDictionary) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecPolicy::tp_handle`"]
    pub fn SecPolicyGetTPHandle(
        policy_ref: &SecPolicy,
        tp_handle: NonNull<CSSM_TP_HANDLE>,
    ) -> OSStatus;
}
