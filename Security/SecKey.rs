//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// Type uint32 (`CSSM_KEYCLASS`); value is one of `CSSM_KEYCLASS_PUBLIC_KEY`, `CSSM_KEYCLASS_PRIVATE_KEY` or `CSSM_KEYCLASS_SESSION_KEY`.
#[deprecated = "No longer supported"]
pub const kSecKeyKeyClass: c_int = 0;
/// Type blob; human readable name of the key. Same as `kSecLabelItemAttr` for typical keychain items.
#[deprecated = "No longer supported"]
pub const kSecKeyPrintName: c_int = 1;
/// Type blob; currently unused.
#[deprecated = "No longer supported"]
pub const kSecKeyAlias: c_int = 2;
/// Type uint32; value is nonzero. This key is permanent (stored in some keychain) and is always `1`.
#[deprecated = "No longer supported"]
pub const kSecKeyPermanent: c_int = 3;
/// Type uint32; value is nonzero. This key is protected by a user login, a password, or both.
#[deprecated = "No longer supported"]
pub const kSecKeyPrivate: c_int = 4;
/// Type uint32; value is nonzero. Attributes of this key can be modified.
#[deprecated = "No longer supported"]
pub const kSecKeyModifiable: c_int = 5;
///
/// ## Discussion
///
/// Type blob; for private and public keys this contains the hash of the public key.  This is used to associate certificates and keys.  Its value matches the value of the `kSecPublicKeyHashItemAttr` attribute of a certificate and it’s used to construct an identity from a certificate and a key. For symmetric keys this is whatever the creator of the key passed in when they generated the key.
///
///
#[deprecated = "No longer supported"]
pub const kSecKeyLabel: c_int = 6;
/// Type blob; currently unused.
#[deprecated = "No longer supported"]
pub const kSecKeyApplicationTag: c_int = 7;
/// Type data. The data points to a `CSSM_GUID` structure representing the module ID of the CSP owning this key.
#[deprecated = "No longer supported"]
pub const kSecKeyKeyCreator: c_int = 8;
/// Type uint32; value is a CSSM algorithm (`CSSM_ALGORITHMS`) representing the algorithm associated with this key.
#[deprecated = "No longer supported"]
pub const kSecKeyKeyType: c_int = 9;
/// Type uint32; value is the number of bits in this key.
#[deprecated = "No longer supported"]
pub const kSecKeyKeySizeInBits: c_int = 10;
/// Type uint32; value is the effective number of bits in this key.  For example, a DES key has a key size in bits (`kSecKeyKeySizeInBits`) of 64 but a value for `kSecKeyEffectiveKeySize` of 56.
#[deprecated = "No longer supported"]
pub const kSecKeyEffectiveKeySize: c_int = 11;
/// Type `CSSM_DATE`.  Earliest date at which this key may be used.  If the value is all zeros or not present, no restriction applies.
#[deprecated = "No longer supported"]
pub const kSecKeyStartDate: c_int = 12;
/// Type `CSSM_DATE`.  Latest date at which this key may be used.  If the value is all zeros or not present, no restriction applies.
#[deprecated = "No longer supported"]
pub const kSecKeyEndDate: c_int = 13;
/// Type uint32; value is nonzero. This key cannot be wrapped with `CSSM_ALGID_NONE`.
#[deprecated = "No longer supported"]
pub const kSecKeySensitive: c_int = 14;
/// Type uint32; value is nonzero. This key has always been marked sensitive.
#[deprecated = "No longer supported"]
pub const kSecKeyAlwaysSensitive: c_int = 15;
/// Type uint32; value is nonzero. This key can be wrapped.
#[deprecated = "No longer supported"]
pub const kSecKeyExtractable: c_int = 16;
/// Type uint32; value is nonzero. This key was never marked extractable.
#[deprecated = "No longer supported"]
pub const kSecKeyNeverExtractable: c_int = 17;
/// Type uint32; value is nonzero. This key can be used in an encrypt operation.
#[deprecated = "No longer supported"]
pub const kSecKeyEncrypt: c_int = 18;
/// Type uint32; value is nonzero. This key can be used in a decrypt operation.
#[deprecated = "No longer supported"]
pub const kSecKeyDecrypt: c_int = 19;
/// Type uint32; value is nonzero. This key can be used in a key derivation operation.
#[deprecated = "No longer supported"]
pub const kSecKeyDerive: c_int = 20;
/// Type uint32, value is nonzero. This key can be used in a sign operation.
#[deprecated = "No longer supported"]
pub const kSecKeySign: c_int = 21;
/// Type uint32, value is nonzero. This key can be used in a verify operation.
#[deprecated = "No longer supported"]
pub const kSecKeyVerify: c_int = 22;
/// Type uint32.
#[deprecated = "No longer supported"]
pub const kSecKeySignRecover: c_int = 23;
/// Type uint32. This key can unwrap other keys.
#[deprecated = "No longer supported"]
pub const kSecKeyVerifyRecover: c_int = 24;
/// Type uint32; value is nonzero. This key can wrap other keys.
#[deprecated = "No longer supported"]
pub const kSecKeyWrap: c_int = 25;
/// Type uint32; value is nonzero. This key can unwrap other keys.
#[deprecated = "No longer supported"]
pub const kSecKeyUnwrap: c_int = 26;

/// The credential type to be returned by [`SecKeyGetCredentials`](https://developer.apple.com/documentation/security/seckeygetcredentials).
///
/// ## Overview
///
/// See the section “Servers and the Keychain” in the [macOS Keychain Services Tasks](https://developer.apple.com/library/archive/documentation/Security/Conceptual/keychainServConcepts/03tasks/tasks.html#//apple_ref/doc/uid/TP30000897-CH205) chapter of [Keychain Services Programming Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html#//apple_ref/doc/uid/TP30000897) for information on the use of UI with keychain tasks.
///
///
/// Determines the type of credential returned by SecKeyGetCredentials.
// NS_ENUM
#[cfg(feature = "cssmconfig")]
#[deprecated = "No longer supported"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecCredentialType(pub uint32);
#[cfg(feature = "cssmconfig")]
impl SecCredentialType {
    /// The default setting for determining whether to present UI is used.
    ///
    /// ## Discussion
    ///
    /// The default setting can be changed with a call to [`SecKeychainSetUserInteractionAllowed`](https://developer.apple.com/documentation/security/seckeychainsetuserinteractionallowed(_:)).
    ///
    ///
    #[doc(alias = "kSecCredentialTypeDefault")]
    #[deprecated = "No longer supported"]
    pub const Default: Self = Self(0);
    /// Keychain operations on keys that have this credential are allowed to present UI if required.
    #[doc(alias = "kSecCredentialTypeWithUI")]
    #[deprecated = "No longer supported"]
    pub const WithUI: Self = Self(1);
    /// Keychain operations on keys that have this credential are not allowed to present UI, and will fail if UI is required.
    #[doc(alias = "kSecCredentialTypeNoUI")]
    #[deprecated = "No longer supported"]
    pub const NoUI: Self = Self(2);
}

#[cfg(all(feature = "cssmconfig", feature = "objc2"))]
unsafe impl Encode for SecCredentialType {
    const ENCODING: Encoding = uint32::ENCODING;
}

#[cfg(all(feature = "cssmconfig", feature = "objc2"))]
unsafe impl RefEncode for SecCredentialType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The types of padding to use when you create or verify a digital signature.
/// Supported padding types.
// NS_OPTIONS
#[deprecated = "Replaced with SecKeyAlgorithm"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecPadding(pub u32);
bitflags::bitflags! {
    impl SecPadding: u32 {
/// No padding.
        #[doc(alias = "kSecPaddingNone")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const None = 0;
/// PKCS1 padding.
///
/// ## Discussion
///
/// For elliptic curve, defaults to a signature in x9.62 DER encoding.
///
///
        #[doc(alias = "kSecPaddingPKCS1")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1 = 1;
        #[doc(alias = "kSecPaddingOAEP")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const OAEP = 2;
        #[doc(alias = "kSecPaddingSigRaw")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const SigRaw = 0x4000;
/// Data to be signed is an MD2 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding is done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1MD2")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1MD2 = 0x8000;
/// Data to be signed is an MD5 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding is done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1MD5")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1MD5 = 0x8001;
/// Data to be signed is a SHA1 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding will be done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1SHA1")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1SHA1 = 0x8002;
/// Data to be signed is a SHA224 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding will be done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1SHA224")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1SHA224 = 0x8003;
/// Data to be signed is a SHA256 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding will be done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1SHA256")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1SHA256 = 0x8004;
/// Data to be signed is a SHA384 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding will be done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1SHA384")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1SHA384 = 0x8005;
/// Data to be signed is a SHA512 hash.
///
/// ## Discussion
///
/// Standard ASN.1 padding will be done, as well as PKCS1 padding of the underlying RSA operation. Used with [`SecKeyRawSign`](https://developer.apple.com/documentation/security/seckeyrawsign(_:_:_:_:_:_:)) and [`SecKeyRawVerify`](https://developer.apple.com/documentation/security/seckeyrawverify(_:_:_:_:_:_:)) only.
///
///
        #[doc(alias = "kSecPaddingPKCS1SHA512")]
#[deprecated = "Replaced with SecKeyAlgorithm"]
        const PKCS1SHA512 = 0x8006;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecPadding {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecPadding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The supported sizes for keys of various common types.
/// Supported key lengths.
// NS_ENUM
#[deprecated = "No longer supported"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecKeySizes(pub u32);
impl SecKeySizes {
    /// The default key size for the specified type.
    #[doc(alias = "kSecDefaultKeySize")]
    #[deprecated = "No longer supported"]
    pub const SecDefaultKeySize: Self = Self(0);
    /// 192-bit DES.
    #[doc(alias = "kSec3DES192")]
    #[deprecated = "No longer supported"]
    pub const Sec3DES192: Self = Self(192);
    /// 128-bit AES.
    #[doc(alias = "kSecAES128")]
    #[deprecated = "No longer supported"]
    pub const SecAES128: Self = Self(128);
    /// 192-bit AES.
    #[doc(alias = "kSecAES192")]
    #[deprecated = "No longer supported"]
    pub const SecAES192: Self = Self(192);
    /// 256-bit AES.
    #[doc(alias = "kSecAES256")]
    #[deprecated = "No longer supported"]
    pub const SecAES256: Self = Self(256);
    /// 192-bit ECC Keys for Suite-B from RFC 4492 section 5.1.1.
    #[doc(alias = "kSecp192r1")]
    #[deprecated = "No longer supported"]
    pub const Secp192r1: Self = Self(192);
    /// 256-bit ECC Keys for Suite-B from RFC 4492 section 5.1.1.
    #[doc(alias = "kSecp256r1")]
    #[deprecated = "No longer supported"]
    pub const Secp256r1: Self = Self(256);
    /// 384-bit ECC Keys for Suite-B from RFC 4492 section 5.1.1.
    #[doc(alias = "kSecp384r1")]
    #[deprecated = "No longer supported"]
    pub const Secp384r1: Self = Self(384);
    /// 521-bit ECC Keys for Suite-B from RFC 4492 section 5.1.1.
    #[doc(alias = "kSecp521r1")]
    #[deprecated = "No longer supported"]
    pub const Secp521r1: Self = Self(521);
    /// 1024 bits is the minimum size for an RSA key.
    #[doc(alias = "kSecRSAMin")]
    #[deprecated = "No longer supported"]
    pub const SecRSAMin: Self = Self(1024);
    /// 4096 bits is the maximum size for an RSA key.
    #[doc(alias = "kSecRSAMax")]
    #[deprecated = "No longer supported"]
    pub const SecRSAMax: Self = Self(4096);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecKeySizes {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecKeySizes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A key whose value is a dictionary of cryptographic key attributes specific to a private key.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is a [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary) containing key-value pairs for attributes specific to the private key to be generated.
    ///
    ///
    /// Predefined key constants used to get or set values in a dictionary.
    /// These are used to provide explicit parameters to key generation functions
    /// when non-default values are desired. See the description of the
    /// SecKeyGeneratePair API for usage information.
    ///
    /// containing attributes specific for the private key to be generated.
    ///
    /// containing attributes specific for the public key to be generated.
    pub static kSecPrivateKeyAttrs: &'static CFString;
}

extern "C" {
    /// A key whose value is a dictionary of cryptographic key attributes specific to a public key.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is a [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary) containing key-value pairs for attributes specific to the public key to be generated.
    ///
    ///
    pub static kSecPublicKeyAttrs: &'static CFString;
}

#[cfg(feature = "SecBase")]
unsafe impl ConcreteType for SecKey {
    /// Returns the unique identifier of the opaque type to which a key object belongs.
    ///
    /// ## Return Value
    ///
    /// A value that identifies the opaque type of a [`SecKeyRef`](https://developer.apple.com/documentation/security/seckey) object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns a value that uniquely identifies the opaque type of a [`SecKeyRef`](https://developer.apple.com/documentation/security/seckey) object. You can compare this value to the [`CFTypeID`](https://developer.apple.com/documentation/corefoundation/cftypeid) identifier obtained by calling the [`CFGetTypeID`](https://developer.apple.com/documentation/corefoundation/cfgettypeid(_:)) function on a specific object. These values might change from release to release or platform to platform.
    ///
    ///
    /// Returns the type identifier of SecKey instances.
    ///
    /// Returns: The CFTypeID of SecKey instances.
    #[doc(alias = "SecKeyGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecKeyGetTypeID() -> CFTypeID;
        }
        unsafe { SecKeyGetTypeID() }
    }
}

#[cfg(feature = "SecBase")]
impl SecKey {
    /// Creates an asymmetric key pair and stores it in a keychain.
    ///
    /// Parameters:
    /// - keychainRef: The keychain object for the keychain in which to store the private and public key items. Specify `NULL` for the default keychain.
    ///
    /// - algorithm: The algorithm to use to generate the key pair. Possible values are defined in `Security.framework/cssmtype.h`. Algorithms supported by the AppleCSP module are listed in [Apple Cryptographic Service Provider Functional Specification](https://developer.apple.com/library/archive/documentation/Security/Reference/SecAppleCryptoSpec/Apple_Cryptographic_Service_Provider_Functional_Specification.pdf). This parameter is ignored if the `contextHandle` parameter is not `0`.
    ///
    /// - keySizeInBits: A key size for the key pair. See [Apple Cryptographic Service Provider Functional Specification](https://developer.apple.com/library/archive/documentation/Security/Reference/SecAppleCryptoSpec/Apple_Cryptographic_Service_Provider_Functional_Specification.pdf) for permissible key sizes for each algorithm supported by the AppleCSP module.
    ///
    /// - contextHandle: A CSSM CSP handle, or `0`. If this argument is not `0`, the `algorithm` and `keySizeInBits` parameters are ignored.
    ///
    /// - publicKeyUsage: A bit mask indicating all permitted uses for the new public key. The possible values for the `CSSM_KEYUSE` data type are defined in `Security.framework/cssmtype.h`.
    ///
    /// - publicKeyAttr: A bit mask defining attribute values for the new public key. The bit mask values are equivalent to those defined for `CSSM_KEYATTR_FLAGS` in `Security.framework/cssmtype.h`.
    ///
    /// - privateKeyUsage: A bit mask indicating all permitted uses for the new private key. The possible values for the `CSSM_KEYUSE` data type are defined in `Security.framework/cssmtype.h`.
    ///
    /// - privateKeyAttr: A bit mask defining attribute values for the new private key. The bit mask values are defined in `CSSM_KEYATTR_FLAGS` in `Security.framework/cssmtype.h`. Supported values are `CSSM_KETATTR_EXTRACTABLE` (the key can be taken out of the keychain) and `CSSM_KEYATTR_SENSITIVE` (an extractable key can be taken out of the keychain only in wrapped form—that is, encrypted). (Note that you must set _both_ of these bits if you want the key to be extractable in wrapped form.) For any other value of this attribute, the key cannot be taken out of the keychain under any circumstances.
    ///
    /// - initialAccess: An access object that sets the initial access control list for each of the keys returned. See Creating an Access Object in [Keychain services](https://developer.apple.com/documentation/security/keychain-services) for functions that create an access object. For default access, specify `NULL`. The default is free access to the tool or application that calls this function, with attempted access to sensitive information by any other application causing a confirmation dialog to be displayed.
    ///
    /// - publicKey: On return, points to the keychain item object of the new public key. Use this object as input to the [`SecKeyGetCSSMKey`](https://developer.apple.com/documentation/security/seckeygetcssmkey) function to obtain the `CSSM_KEY` structure containing the key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    /// - privateKey: On return, points to the keychain item object of the new private key. Use this object as input to the [`SecKeyGetCSSMKey`](https://developer.apple.com/documentation/security/seckeygetcssmkey) function to obtain the `CSSM_KEY` structure containing the key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function uses default values for any attributes required by specific key-generation algorithms. Algorithms supported by the AppleCSP module are listed in [Apple Cryptographic Service Provider Functional Specification](https://developer.apple.com/library/archive/documentation/Security/Reference/SecAppleCryptoSpec/Apple_Cryptographic_Service_Provider_Functional_Specification.pdf). For details about algorithms and default values for key-generation parameters, download the CDSA security framework from Apple’s Open Source website at [https://opensource.apple.com/](https://opensource.apple.com/) and read the file `Supported_CSP_Algorithms.doc` in the Documentation folder.
    ///
    /// If you need extra parameters to generate a key—as required by some algorithms—call [`SecKeychainGetCSPHandle`](https://developer.apple.com/documentation/security/seckeychaingetcsphandle) to obtain a CSSM CSP handle and then call `CSSM_CSP_CreateKeyGenContext` to create a context. With this context, use `CSSM_UpdateContextAttributes` to add additional parameters. Finally, call `CSSM_DeleteContext` to dispose of the context after calling this function.
    ///
    ///
    /// Creates an asymmetric key pair and stores it in a specified keychain.
    ///
    /// Parameter `keychainRef`: A reference to the keychain in which to store the private and public key items. Specify NULL for the default keychain.
    ///
    /// Parameter `algorithm`: An algorithm for the key pair. This parameter is ignored if a valid (non-zero) contextHandle is supplied.
    ///
    /// Parameter `keySizeInBits`: A key size for the key pair. This parameter is ignored if a valid (non-zero) contextHandle is supplied.
    ///
    /// Parameter `contextHandle`: (optional) A CSSM_CC_HANDLE, or 0. If this argument is supplied, the algorithm and keySizeInBits parameters are ignored. If extra parameters are needed to generate a key (some algorithms require this), you should create a context using CSSM_CSP_CreateKeyGenContext, using the CSPHandle obtained by calling SecKeychainGetCSPHandle. Then use CSSM_UpdateContextAttributes to add parameters, and dispose of the context using CSSM_DeleteContext after calling this function.
    ///
    /// Parameter `publicKeyUsage`: A bit mask indicating all permitted uses for the new public key. CSSM_KEYUSE bit mask values are defined in cssmtype.h.
    ///
    /// Parameter `publicKeyAttr`: A bit mask defining attribute values for the new public key. The bit mask values are equivalent to a CSSM_KEYATTR_FLAGS and are defined in cssmtype.h.
    ///
    /// Parameter `privateKeyUsage`: A bit mask indicating all permitted uses for the new private key. CSSM_KEYUSE bit mask values are defined in cssmtype.h.
    ///
    /// Parameter `privateKeyAttr`: A bit mask defining attribute values for the new private key. The bit mask values are equivalent to a CSSM_KEYATTR_FLAGS and are defined in cssmtype.h.
    ///
    /// Parameter `initialAccess`: (optional) A SecAccess object that determines the initial access rights to the private key. The public key is given "any/any" access rights by default.
    ///
    /// Parameter `publicKey`: (optional) On return, the keychain item reference of the generated public key. Use the SecKeyGetCSSMKey function to obtain the CSSM_KEY. The caller must call CFRelease on this value if it is returned. Pass NULL if a reference to this key is not required.
    ///
    /// Parameter `privateKey`: (optional) On return, the keychain item reference of the generated private key. Use the SecKeyGetCSSMKey function to obtain the CSSM_KEY. The caller must call CFRelease on this value if it is returned. Pass NULL if a reference to this key is not required.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated for 10.7. Please use the SecKeyGeneratePair API instead.
    ///
    /// # Safety
    ///
    /// - `public_key` must be a valid pointer or null.
    /// - `private_key` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreatePair")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "CSSM is not supported"]
    #[inline]
    pub unsafe fn create_pair(
        keychain_ref: Option<&SecKeychain>,
        algorithm: CSSM_ALGORITHMS,
        key_size_in_bits: uint32,
        context_handle: CSSM_CC_HANDLE,
        public_key_usage: CSSM_KEYUSE,
        public_key_attr: uint32,
        private_key_usage: CSSM_KEYUSE,
        private_key_attr: uint32,
        initial_access: Option<&SecAccess>,
        public_key: *mut *mut SecKey,
        private_key: *mut *mut SecKey,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecKeyCreatePair(
                keychain_ref: Option<&SecKeychain>,
                algorithm: CSSM_ALGORITHMS,
                key_size_in_bits: uint32,
                context_handle: CSSM_CC_HANDLE,
                public_key_usage: CSSM_KEYUSE,
                public_key_attr: uint32,
                private_key_usage: CSSM_KEYUSE,
                private_key_attr: uint32,
                initial_access: Option<&SecAccess>,
                public_key: *mut *mut SecKey,
                private_key: *mut *mut SecKey,
            ) -> OSStatus;
        }
        unsafe {
            SecKeyCreatePair(
                keychain_ref,
                algorithm,
                key_size_in_bits,
                context_handle,
                public_key_usage,
                public_key_attr,
                private_key_usage,
                private_key_attr,
                initial_access,
                public_key,
                private_key,
            )
        }
    }

    /// Creates a symmetric key and optionally stores it in a keychain.
    ///
    /// Parameters:
    /// - keychainRef: The keychain in which to store the generated key. Specify `NULL` to generate a transient key.
    ///
    /// - algorithm: The algorithm to use in generating the symmetric key. Possible values are defined in `cssmtype.h`. Algorithms supported by the AppleCSP module are listed in [Apple Cryptographic Service Provider Functional Specification](https://developer.apple.com/library/archive/documentation/Security/Reference/SecAppleCryptoSpec/Apple_Cryptographic_Service_Provider_Functional_Specification.pdf). This parameter is ignored if the `contextHandle` parameter is not `0`.
    ///
    /// - keySizeInBits: A key size for the key pair. This parameter is ignored if the `contextHandle` parameter is not `0`.
    ///
    /// - contextHandle: A CSSM CSP handle, or `0`. If this argument is not `0`, the `algorithm` and `keySizeInBits` parameters are ignored.
    ///
    /// - keyUsage: A bit mask indicating all permitted uses for the new key. The possible values for the `CSSM_KEYUSE` data type are defined in `cssmtype.h`.
    ///
    /// - keyAttr: A bit mask defining attribute values for the new key. The bit mask values are defined in `CSSM_KEYATTR_FLAGS` in `cssmtype.h`.
    ///
    /// - initialAccess: An access object that sets the initial access control list for the key returned. See Creating an Access Object in [Keychain services](https://developer.apple.com/documentation/security/keychain-services) for functions that create an access object. This parameter is ignored if you specify `NULL` for the `keychainRef` parameter.
    ///
    /// - keyRef: On return, points to the keychain item object of the new public key. Use this object as input to the [`SecKeyGetCSSMKey`](https://developer.apple.com/documentation/security/seckeygetcssmkey) function to obtain the `CSSM_KEY` structure containing the key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Key-generation algorithms supported by the AppleCSP module are listed in [Apple Cryptographic Service Provider Functional Specification](https://developer.apple.com/library/archive/documentation/Security/Reference/SecAppleCryptoSpec/Apple_Cryptographic_Service_Provider_Functional_Specification.pdf). For details about algorithms and default values for key-generation parameters, download the CDSA security framework from Apple’s Open Source website at [https://opensource.apple.com/](https://opensource.apple.com/) and read the file `Supported_CSP_Algorithms.doc` in the Documentation folder.
    ///
    /// If you need extra parameters to generate a key—as required by some algorithms—call [`SecKeychainGetCSPHandle`](https://developer.apple.com/documentation/security/seckeychaingetcsphandle) to obtain a CSSM CSP handle and then call `CSSM_CSP_CreateKeyGenContext` to create a context. With this context, use `CSSM_UpdateContextAttributes` to add additional parameters. Finally, call `CSSM_DeleteContext` to dispose of the context after calling this function.
    ///
    /// ### Special Considerations
    ///
    /// Use [`SecKeyGenerateSymmetric(_:_:)`](https://developer.apple.com/documentation/security/seckeygeneratesymmetric(_:_:)) instead.
    ///
    ///
    /// Creates a symmetric key and optionally stores it in a specified keychain.
    ///
    /// Parameter `keychainRef`: (optional) A reference to the keychain in which to store the generated key. Specify NULL to generate a transient key.
    ///
    /// Parameter `algorithm`: An algorithm for the symmetric key. This parameter is ignored if a valid (non-zero) contextHandle is supplied.
    ///
    /// Parameter `keySizeInBits`: A key size for the key pair. This parameter is ignored if a valid (non-zero) contextHandle is supplied.
    ///
    /// Parameter `contextHandle`: (optional) A CSSM_CC_HANDLE, or 0. If this argument is supplied, the algorithm and keySizeInBits parameters are ignored. If extra parameters are needed to generate a key (some algorithms require this), you should create a context using CSSM_CSP_CreateKeyGenContext, using the CSPHandle obtained by calling SecKeychainGetCSPHandle. Then use CSSM_UpdateContextAttributes to add parameters, and dispose of the context using CSSM_DeleteContext after calling this function.
    ///
    /// Parameter `keyUsage`: A bit mask indicating all permitted uses for the new key. CSSM_KEYUSE bit mask values are defined in cssmtype.h.
    ///
    /// Parameter `keyAttr`: A bit mask defining attribute values for the new key. The bit mask values are equivalent to a CSSM_KEYATTR_FLAGS and are defined in cssmtype.h.
    ///
    /// Parameter `initialAccess`: (optional) A SecAccess object that determines the initial access rights for the key. This parameter is ignored if the keychainRef is NULL.
    ///
    /// Parameter `keyRef`: On return, a reference to the generated key. Use the SecKeyGetCSSMKey function to obtain the CSSM_KEY. The caller must call CFRelease on this value if it is returned.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated for 10.7.  Please use the SecKeyGenerateSymmetric API instead.
    ///
    /// # Safety
    ///
    /// `key_ref` must be a valid pointer or null.
    #[doc(alias = "SecKeyGenerate")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "CSSM is not supported"]
    #[inline]
    pub unsafe fn generate(
        keychain_ref: Option<&SecKeychain>,
        algorithm: CSSM_ALGORITHMS,
        key_size_in_bits: uint32,
        context_handle: CSSM_CC_HANDLE,
        key_usage: CSSM_KEYUSE,
        key_attr: uint32,
        initial_access: Option<&SecAccess>,
        key_ref: *mut *mut SecKey,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecKeyGenerate(
                keychain_ref: Option<&SecKeychain>,
                algorithm: CSSM_ALGORITHMS,
                key_size_in_bits: uint32,
                context_handle: CSSM_CC_HANDLE,
                key_usage: CSSM_KEYUSE,
                key_attr: uint32,
                initial_access: Option<&SecAccess>,
                key_ref: *mut *mut SecKey,
            ) -> OSStatus;
        }
        unsafe {
            SecKeyGenerate(
                keychain_ref,
                algorithm,
                key_size_in_bits,
                context_handle,
                key_usage,
                key_attr,
                initial_access,
                key_ref,
            )
        }
    }

    /// Retrieves a pointer to the `CSSM_KEY` structure containing the key stored in a keychain item.
    ///
    /// Parameters:
    /// - key: A keychain key item object.
    ///
    /// - cssmKey: A pointer to a `CSSM_KEY` structure for the specified key. You should not modify or free this data, because it is owned by the system.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `CSSM_KEY` structure is used to represent keys in CSSM and is used as an input value to several CSSM functions. The `CSSM_KEY` structure is valid until the keychain item object is released.
    ///
    ///
    /// Returns a pointer to the CSSM_KEY for the given key item reference.
    ///
    /// Parameter `key`: A keychain key item reference. The key item must be of class type kSecPublicKeyItemClass, kSecPrivateKeyItemClass, or kSecSymmetricKeyItemClass.
    ///
    /// Parameter `cssmKey`: On return, a pointer to a CSSM_KEY structure for the given key. This pointer remains valid until the key reference is released. The caller should not attempt to modify or free this data.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// The CSSM_KEY is valid until the key item reference is released. This API is deprecated in 10.7. Its use should no longer be needed.
    ///
    /// # Safety
    ///
    /// `cssm_key` must be a valid pointer.
    #[doc(alias = "SecKeyGetCSSMKey")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated]
    #[inline]
    pub unsafe fn cssm_key(&self, cssm_key: NonNull<*const CSSM_KEY>) -> OSStatus {
        extern "C-unwind" {
            fn SecKeyGetCSSMKey(key: &SecKey, cssm_key: NonNull<*const CSSM_KEY>) -> OSStatus;
        }
        unsafe { SecKeyGetCSSMKey(self, cssm_key) }
    }

    /// Returns the CSSM CSP handle for a key.
    ///
    /// Parameters:
    /// - keyRef: The key for which you want a CSSM CSP handle.
    ///
    /// - cspHandle: On return, points to the CSSM CSP handle for the specified key. This pointer remains valid until the key reference is released. Do not attempt to modify or free this data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A CSSM CSP handle is required as an input to a number of CSSM functions.
    ///
    ///
    /// Returns the CSSM_CSP_HANDLE for the given key reference. The handle is valid until the key reference is released.
    ///
    /// Parameter `keyRef`: A key reference.
    ///
    /// Parameter `cspHandle`: On return, the CSSM_CSP_HANDLE for the given keychain.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// This API is deprecated in 10.7. Its use should no longer be needed.
    ///
    /// # Safety
    ///
    /// `csp_handle` must be a valid pointer.
    #[doc(alias = "SecKeyGetCSPHandle")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated]
    #[inline]
    pub unsafe fn csp_handle(&self, csp_handle: NonNull<CSSM_CSP_HANDLE>) -> OSStatus {
        extern "C-unwind" {
            fn SecKeyGetCSPHandle(
                key_ref: &SecKey,
                csp_handle: NonNull<CSSM_CSP_HANDLE>,
            ) -> OSStatus;
        }
        unsafe { SecKeyGetCSPHandle(self, csp_handle) }
    }

    /// Returns an access credential for a key.
    ///
    /// Parameters:
    /// - keyRef: The key for which you want an access credential.
    ///
    /// - operation: The type of operation to be performed with this key. Possible values are listed under “Authorization tag types” in `Security.framework/cssmtype.h`.
    ///
    /// - credentialType: The type of credential requested. See [`SecCredentialType`](https://developer.apple.com/documentation/security/seccredentialtype) for possible values.
    ///
    /// - outCredentials: On return, points to an access credential for the specified key. This pointer remains valid until the key reference is released. Do not attempt to modify or free this data.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// An access credential is required as an input to a number of CSSM functions.
    ///
    ///
    /// For a given key, return a pointer to a CSSM_ACCESS_CREDENTIALS structure which will allow the key to be used.
    ///
    /// Parameter `keyRef`: The key for which a credential is requested.
    ///
    /// Parameter `operation`: The type of operation to be performed with this key. See "Authorization tag type" for defined operations (cssmtype.h).
    ///
    /// Parameter `credentialType`: The type of credential requested.
    ///
    /// Parameter `outCredentials`: On return, a pointer to a CSSM_ACCESS_CREDENTIALS structure. This pointer remains valid until the key reference is released. The caller should not attempt to modify or free this data.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// `out_credentials` must be a valid pointer.
    #[doc(alias = "SecKeyGetCredentials")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated]
    #[inline]
    pub unsafe fn credentials(
        &self,
        operation: CSSM_ACL_AUTHORIZATION_TAG,
        credential_type: SecCredentialType,
        out_credentials: NonNull<*const CSSM_ACCESS_CREDENTIALS>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecKeyGetCredentials(
                key_ref: &SecKey,
                operation: CSSM_ACL_AUTHORIZATION_TAG,
                credential_type: SecCredentialType,
                out_credentials: NonNull<*const CSSM_ACCESS_CREDENTIALS>,
            ) -> OSStatus;
        }
        unsafe { SecKeyGetCredentials(self, operation, credential_type, out_credentials) }
    }

    /// Generates a random symmetric key.
    ///
    /// Parameters:
    /// - parameters: A key generation parameter dictionary. At minimum, this must contain [`kSecAttrKeyType`](https://developer.apple.com/documentation/security/ksecattrkeytype) and [`kSecAttrKeySizeInBits`](https://developer.apple.com/documentation/security/ksecattrkeysizeinbits). In addition, this function assumes default values for the following keys:
    ///
    /// - [`kSecAttrLabel`](https://developer.apple.com/documentation/security/ksecattrlabel) defaults to `NULL`.
    ///
    /// - [`kSecAttrIsPermanent`](https://developer.apple.com/documentation/security/ksecattrispermanent) if this key is present and has a value of [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue), the key or key pair will be added to the default keychain.
    ///
    /// - [`kSecAttrApplicationTag`](https://developer.apple.com/documentation/security/ksecattrapplicationtag) defaults to `NULL`.
    ///
    /// - [`kSecAttrEffectiveKeySize`](https://developer.apple.com/documentation/security/ksecattreffectivekeysize) defaults to `NULL`, which means the effective key size is the same as the key size ([`kSecAttrKeySizeInBits`](https://developer.apple.com/documentation/security/ksecattrkeysizeinbits)).
    ///
    /// - [`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt) defaults to [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for private keys, [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for public keys.
    ///
    /// - [`kSecAttrCanDecrypt`](https://developer.apple.com/documentation/security/ksecattrcandecrypt) defaults to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for private keys, [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for public keys.
    ///
    /// - [`kSecAttrCanDerive`](https://developer.apple.com/documentation/security/ksecattrcanderive) defaults to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue).
    ///
    /// - [`kSecAttrCanSign`](https://developer.apple.com/documentation/security/ksecattrcansign) defaults to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for private keys, [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for public keys.
    ///
    /// - [`kSecAttrCanVerify`](https://developer.apple.com/documentation/security/ksecattrcanverify) defaults to [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for private keys, [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for public keys.
    ///
    /// - [`kSecAttrCanWrap`](https://developer.apple.com/documentation/security/ksecattrcanwrap) defaults to [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for private keys, [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for public keys.
    ///
    /// - [`kSecAttrCanUnwrap`](https://developer.apple.com/documentation/security/ksecattrcanunwrap) defaults to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for private keys, [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for public keys.
    ///
    /// These default values can be overridden by adding a value for the associated key in the parameter dictionary.
    ///
    /// When used as a replacement for [`SecKeyGenerate`](https://developer.apple.com/documentation/security/seckeygenerate), set the [`kSecUseKeychain`](https://developer.apple.com/documentation/security/ksecusekeychain) key to the keychain ([`SecKeychainRef`](https://developer.apple.com/documentation/security/seckeychain)) into which the key should be stored, [`kSecAttrLabel`](https://developer.apple.com/documentation/security/ksecattrlabel) to a user-visible label for the key, and [`kSecAttrApplicationLabel`](https://developer.apple.com/documentation/security/ksecattrapplicationlabel) to an identifier defined by your application, for subsequent use in calls to [`SecItemCopyMatching`](https://developer.apple.com/documentation/security/secitemcopymatching(_:_:)). Additionally, you can specify keychain access controls for the key by setting [`kSecAttrAccess`](https://developer.apple.com/documentation/security/ksecattraccess) to a [`SecAccessRef`](https://developer.apple.com/documentation/security/secaccess) object.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A newly generated symmetric key, or `NULL` on failure. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the key’s memory when you are done with it.
    ///
    ///
    /// Generates a random symmetric key with the specified length
    /// and algorithm type.
    ///
    ///
    /// Parameter `parameters`: A dictionary containing one or more key-value pairs.
    /// See the discussion sections below for a complete overview of options.
    ///
    /// Parameter `error`: An optional pointer to a CFErrorRef. This value is set
    /// if an error occurred. If not NULL, the caller is responsible for
    /// releasing the CFErrorRef.
    ///
    /// Returns: On return, a SecKeyRef reference to the symmetric key, or
    /// NULL if the key could not be created.
    ///
    ///
    /// In order to generate a symmetric key, the parameters dictionary
    /// must at least contain the following keys:
    ///
    /// kSecAttrKeyType with a value of kSecAttrKeyTypeAES or any other
    /// kSecAttrKeyType defined in SecItem.h
    /// kSecAttrKeySizeInBits with a value being a CFNumberRef containing
    /// the requested key size in bits.  Example sizes for AES keys are:
    /// 128, 192, 256, 512.
    ///
    /// To store the generated symmetric key in a keychain, set these keys:
    /// kSecUseKeychain (value is a SecKeychainRef)
    /// kSecAttrLabel (a user-visible label whose value is a CFStringRef,
    /// e.g. "My App's Encryption Key")
    /// kSecAttrApplicationLabel (a label defined by your application, whose
    /// value is a CFDataRef and which can be used to find this key in a
    /// subsequent call to SecItemCopyMatching, e.g. "ID-1234567890-9876-0151")
    ///
    /// To specify the generated key's access control settings, set this key:
    /// kSecAttrAccess (value is a SecAccessRef)
    ///
    /// The keys below may be optionally set in the parameters dictionary
    /// (with a CFBooleanRef value) to override the default usage values:
    ///
    /// kSecAttrCanEncrypt (defaults to true if not explicitly specified)
    /// kSecAttrCanDecrypt (defaults to true if not explicitly specified)
    /// kSecAttrCanWrap (defaults to true if not explicitly specified)
    /// kSecAttrCanUnwrap (defaults to true if not explicitly specified)
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyGenerateSymmetric")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn generate_symmetric(
        parameters: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyGenerateSymmetric(
                parameters: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecKeyGenerateSymmetric(parameters, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Constructs a SecKeyRef object for a symmetric key.
    ///
    /// Parameters:
    /// - parameters: A parameter dictionary that describes the key. See the discussion for details.
    ///
    /// - keyData: A `CFDataRef` object that contains the raw key data.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// A symmetric key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the key’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The parameters dictionary must contain (at minimum) an entry for the [`kSecAttrKeyType`](https://developer.apple.com/documentation/security/ksecattrkeytype) key with a value of [`kSecAttrKeyTypeAES`](https://developer.apple.com/documentation/security/ksecattrkeytypeaes) or any other key type defined in Key Type Value.
    ///
    /// The keys below may be optionally set in the parameters dictionary (with a `CFBooleanRef` value) to override the default key usage values:
    ///
    /// - [`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt)
    ///
    /// - [`kSecAttrCanDecrypt`](https://developer.apple.com/documentation/security/ksecattrcandecrypt)
    ///
    /// - [`kSecAttrCanWrap`](https://developer.apple.com/documentation/security/ksecattrcanwrap)
    ///
    /// - [`kSecAttrCanUnwrap`](https://developer.apple.com/documentation/security/ksecattrcanunwrap)
    ///
    /// These values default to `true` if no value is specified.
    ///
    ///
    /// Creates a symmetric key with the given data and sets the
    /// algorithm type specified.
    ///
    ///
    /// Parameter `parameters`: A dictionary containing one or more key-value pairs.
    /// See the discussion sections below for a complete overview of options.
    ///
    /// Returns: On return, a SecKeyRef reference to the symmetric key.
    ///
    ///
    /// In order to generate a symmetric key the parameters dictionary must
    /// at least contain the following keys:
    ///
    /// kSecAttrKeyType with a value of kSecAttrKeyTypeAES or any other
    /// kSecAttrKeyType defined in SecItem.h
    ///
    /// The keys below may be optionally set in the parameters dictionary
    /// (with a CFBooleanRef value) to override the default usage values:
    ///
    /// kSecAttrCanEncrypt (defaults to true if not explicitly specified)
    /// kSecAttrCanDecrypt (defaults to true if not explicitly specified)
    /// kSecAttrCanWrap (defaults to true if not explicitly specified)
    /// kSecAttrCanUnwrap (defaults to true if not explicitly specified)
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreateFromData")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn from_data(
        parameters: &CFDictionary,
        key_data: &CFData,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyCreateFromData(
                parameters: &CFDictionary,
                key_data: &CFData,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecKeyCreateFromData(parameters, key_data, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// A block called with the results of a call to [`SecKeyGeneratePairAsync`](https://developer.apple.com/documentation/security/seckeygeneratepairasync(_:_:_:)).
/// Delivers the result from an asynchronous key pair generation.
///
/// Parameter `publicKey`: - the public key generated.   You must retain publicKey if you wish to use it after your block returns.
///
/// Parameter `privateKey`: - the private key generated.  You must retain publicKey if you wish to use it after your block returns.
///
/// Parameter `error`: - Any errors returned.   You must retain error if you wish to use it after your block returns.
#[cfg(all(feature = "SecBase", feature = "block2"))]
pub type SecKeyGeneratePairBlock =
    *mut block2::DynBlock<dyn Fn(NonNull<SecKey>, NonNull<SecKey>, NonNull<CFError>)>;

#[cfg(feature = "SecBase")]
impl SecKey {
    /// Returns a key object in which the key data is derived from a password.
    ///
    /// Parameters:
    /// - password: The password from which the key should be derived.
    ///
    /// - parameters: A set of parameters for deriving the password.
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// The derived key object, or `NULL` on error. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the key’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The parameters dictionary must contain at least the following keys:
    ///
    /// - [`kSecKeyKeyType`](https://developer.apple.com/documentation/security/kseckeykeytype)—the type of symmetric key to generate.
    ///
    /// - [`kSecAttrSalt`](https://developer.apple.com/documentation/security/ksecattrsalt)—a `CFDataRef` object containing the salt value that is mixed into the pseudorandom rounds.
    ///
    /// The parameters dictionary may contain the following optional keys:
    ///
    /// - [`kSecAttrPRF`](https://developer.apple.com/documentation/security/ksecattrprf) - the algorithm to use for the pseudorandom-function.
    ///
    /// If zero, this defaults to [`kSecAttrPRFHmacAlgSHA1`](https://developer.apple.com/documentation/security/ksecattrprfhmacalgsha1). For a list of possible values, see `kSecAttrPRF Value Constants`.
    ///
    /// - [`kSecAttrRounds`](https://developer.apple.com/documentation/security/ksecattrrounds)—the number of times to call the pseudorandom function. If zero, the count is computed so that computation will take 1/10 of a second (on average).
    ///
    /// - [`kSecAttrKeySizeInBits`](https://developer.apple.com/documentation/security/ksecattrkeysizeinbits)—a `CFNumberRef` value containing the requested key size in bits. The key size must be valid for the key type. Defaults to 128 if not provided.
    ///
    ///
    /// Derives a symmetric key from a password.
    ///
    ///
    /// Parameter `password`: The password from which the keyis to be derived.
    ///
    /// Parameter `parameters`: A dictionary containing one or more key-value pairs.
    ///
    /// Parameter `error`: If the call fails this will contain the error code.
    ///
    ///
    /// In order to derive a key the parameters dictionary must contain at least contain the following keys:
    /// kSecAttrSalt - a CFData for the salt value for mixing in the pseudo-random rounds.
    /// kSecAttrPRF - the algorithm to use for the pseudo-random-function.
    /// If 0, this defaults to kSecAttrPRFHmacAlgSHA1. Possible values are:
    ///
    /// kSecAttrPRFHmacAlgSHA1
    /// kSecAttrPRFHmacAlgSHA224
    /// kSecAttrPRFHmacAlgSHA256
    /// kSecAttrPRFHmacAlgSHA384
    /// kSecAttrPRFHmacAlgSHA512
    ///
    /// kSecAttrRounds - the number of rounds to call the pseudo random function.
    /// If 0, a count will be computed to average 1/10 of a second.
    /// kSecAttrKeySizeInBits with a value being a CFNumberRef
    /// containing the requested key size in bits.  Example sizes for RSA keys are:
    /// 512, 768, 1024, 2048.
    ///
    ///
    /// Returns: On success a SecKeyRef is returned.  On failure this result is NULL and the
    /// error parameter contains the reason.
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyDeriveFromPassword")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn derive_from_password(
        password: &CFString,
        parameters: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyDeriveFromPassword(
                password: &CFString,
                parameters: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecKeyDeriveFromPassword(password, parameters, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Wraps a symmetric key with another key.
    ///
    /// Parameters:
    /// - keyToWrap: The key to wrap.
    ///
    /// - wrappingKey: The key to use when wrapping `keyToWrap`.
    ///
    /// - parameters: A parameter list for the unwrapping process. This is usually either an empty dictionary or a dictionary containing a value for [`kSecAttrSalt`](https://developer.apple.com/documentation/security/ksecattrsalt).
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// The wrapped key, or `NULL` on error. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the data’s memory when you are done with it.
    ///
    ///
    /// Wraps a symmetric key with a symmetric key.
    ///
    ///
    /// Parameter `keyToWrap`: The key which is to be wrapped.
    ///
    /// Parameter `wrappingKey`: The key wrapping key.
    ///
    /// Parameter `parameters`: The parameter list to use for wrapping the key.
    ///
    /// Parameter `error`: If the call fails this will contain the error code.
    ///
    ///
    /// Returns: On success a CFDataRef is returned.  On failure this result is NULL and the
    /// error parameter contains the reason.
    ///
    ///
    /// In order to wrap a key the parameters dictionary may contain the following key:
    /// kSecSalt - a CFData for the salt value for the encrypt.
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyWrapSymmetric")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn wrap_symmetric(
        &self,
        wrapping_key: &SecKey,
        parameters: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecKeyWrapSymmetric(
                key_to_wrap: &SecKey,
                wrapping_key: &SecKey,
                parameters: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecKeyWrapSymmetric(self, wrapping_key, parameters, error) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Unwraps a wrapped symmetric key.
    ///
    /// Parameters:
    /// - keyToUnwrap: The wrapped key to unwrap.
    ///
    /// - unwrappingKey: The key that must be used to unwrap `keyToUnwrap`.
    ///
    /// - parameters: A parameter list for the unwrapping process. This is usually either an empty dictionary or a dictionary containing a value for [`kSecAttrSalt`](https://developer.apple.com/documentation/security/ksecattrsalt).
    ///
    /// - error: A pointer to a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) variable where an error object is stored upon failure. If not `NULL`, the caller is responsible for checking this variable and releasing the resulting object if it exists.
    ///
    ///
    /// ## Return Value
    ///
    /// The unwrapped key, or `NULL` on failure. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the key’s memory when you are done with it.
    ///
    ///
    /// Unwrap a wrapped symmetric key.
    ///
    ///
    /// Parameter `keyToUnwrap`: The wrapped key to unwrap.
    ///
    /// Parameter `unwrappingKey`: The key unwrapping key.
    ///
    /// Parameter `parameters`: The parameter list to use for unwrapping the key.
    ///
    /// Parameter `error`: If the call fails this will contain the error code.
    ///
    ///
    /// Returns: On success a SecKeyRef is returned.  On failure this result is NULL and the
    /// error parameter contains the reason.
    ///
    ///
    /// In order to unwrap a key the parameters dictionary may contain the following key:
    /// kSecSalt - a CFData for the salt value for the decrypt.
    ///
    /// # Safety
    ///
    /// - `key_to_unwrap` must be a valid pointer.
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyUnwrapSymmetric")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn unwrap_symmetric(
        key_to_unwrap: NonNull<*const CFData>,
        unwrapping_key: &SecKey,
        parameters: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyUnwrapSymmetric(
                key_to_unwrap: NonNull<*const CFData>,
                unwrapping_key: &SecKey,
                parameters: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecKey>>;
        }
        let ret =
            unsafe { SecKeyUnwrapSymmetric(key_to_unwrap, unwrapping_key, parameters, error) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Creates an asymmetric key pair.
    ///
    /// Parameters:
    /// - parameters: A dictionary of key-value pairs that specify the type of keys to be generated.
    ///
    /// - publicKey: On return, points to the keychain item object of the new public key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    /// - privateKey: On return, points to the keychain item object of the new private key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to release this object when you are finished with it.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Security Framework Result Codes](https://developer.apple.com/documentation/security/security-framework-result-codes).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In order to generate a key pair, the dictionary passed in the `parameters` parameter must contain at least the following key-value pairs:
    ///
    /// - A [`kSecAttrKeyType`](https://developer.apple.com/documentation/security/ksecattrkeytype) key with a value of any key type defined in `SecItem.h` (see [Keychain services](https://developer.apple.com/documentation/security/keychain-services)), for example, [`kSecAttrKeyTypeRSA`](https://developer.apple.com/documentation/security/ksecattrkeytypersa).
    ///
    /// - A [`kSecAttrKeySizeInBits`](https://developer.apple.com/documentation/security/ksecattrkeysizeinbits) key with a value specifying the requested key size in bits. This can be specified as either a `CFNumberRef` or `CFStringRef` value. For example, RSA keys may have key size values of 512, 768, 1024, or 2048.
    ///
    /// In addition, you can specify a number of other optional attributes for the public and private keys. The way you do this depends on whether you are writing code for macOS or iOS:
    ///
    /// - In macOS, add the key-value pairs to the `parameters` dictionary directly. The specified attributes are applied to both the public and private keys.
    ///
    /// - In iOS, add dictionaries for the keys [`kSecPublicKeyAttrs`](https://developer.apple.com/documentation/security/ksecpublickeyattrs) and [`kSecPrivateKeyAttrs`](https://developer.apple.com/documentation/security/ksecprivatekeyattrs) to the `parameters` dictionary, and provide the attributes in those dictionaries. The attributes specified in these dictionaries are added to either the public or private key, respectively, allowing you to apply separate attributes to each key.
    ///
    /// The possible attributes are as follows; for details on each attribute, see [Keychain services](https://developer.apple.com/documentation/security/keychain-services):
    ///
    /// - [`kSecAttrLabel`](https://developer.apple.com/documentation/security/ksecattrlabel)—Default `NULL`.
    ///
    /// - [`kSecAttrIsPermanent`](https://developer.apple.com/documentation/security/ksecattrispermanent)—If this key is present and has a Boolean value of `true`, the key or key pair is added to the default       keychain.
    ///
    /// - [`kSecAttrApplicationTag`](https://developer.apple.com/documentation/security/ksecattrapplicationtag)—Default `NULL`.
    ///
    /// - [`kSecAttrEffectiveKeySize`](https://developer.apple.com/documentation/security/ksecattreffectivekeysize)—Default (`NULL`) sets the effective key size to the same as the total key size (`kSecAttrKeySizeInBits`).
    ///
    /// - [`kSecAttrCanEncrypt`](https://developer.apple.com/documentation/security/ksecattrcanencrypt)—Default `false` for private keys, `true` for public keys.
    ///
    /// - [`kSecAttrCanDecrypt`](https://developer.apple.com/documentation/security/ksecattrcandecrypt)—Default `true` for private keys, `false` for public keys.
    ///
    /// - [`kSecAttrCanDerive`](https://developer.apple.com/documentation/security/ksecattrcanderive)—Default `true`.
    ///
    /// - [`kSecAttrCanSign`](https://developer.apple.com/documentation/security/ksecattrcansign)—Default `true` for private keys, `false` for public keys.
    ///
    /// - [`kSecAttrCanVerify`](https://developer.apple.com/documentation/security/ksecattrcanverify)—Default `false` for private keys, `true` for public keys.
    ///
    /// - [`kSecAttrCanUnwrap`](https://developer.apple.com/documentation/security/ksecattrcanunwrap)—Default `true` for private keys, `false` for public keys.
    ///
    ///
    /// Generate a private/public keypair.
    ///
    /// Parameter `parameters`: A dictionary containing one or more key-value pairs.
    /// See the discussion sections below for a complete overview of options.
    ///
    /// Parameter `publicKey`: On return, a SecKeyRef reference to the public key.
    ///
    /// Parameter `privateKey`: On return, a SecKeyRef reference to the private key.
    ///
    /// Returns: A result code. See "Security Error Codes" (SecBase.h).
    ///
    ///
    /// In order to generate a keypair the parameters dictionary must
    /// at least contain the following keys:
    ///
    /// kSecAttrKeyType with a value of kSecAttrKeyTypeRSA or any other
    /// kSecAttrKeyType defined in SecItem.h
    /// kSecAttrKeySizeInBits with a value being a CFNumberRef containing
    /// the requested key size in bits.  Example sizes for RSA keys are:
    /// 512, 768, 1024, 2048.
    ///
    /// The values below may be set either in the top-level dictionary or in a
    /// dictionary that is the value of the kSecPrivateKeyAttrs or
    /// kSecPublicKeyAttrs key in the top-level dictionary.  Setting these
    /// attributes explicitly will override the defaults below.  See SecItem.h
    /// for detailed information on these attributes including the types of
    /// the values.
    ///
    /// kSecAttrLabel default NULL
    /// kSecUseKeychain default NULL, which specifies the default keychain
    /// kSecAttrIsPermanent default false
    /// if this key is present and has a Boolean value of true, the key or
    /// key pair will be added to the keychain.
    /// kSecAttrTokenID default NULL
    /// The CFStringRef ID of the token to generate the key or keypair on. This
    /// attribute can contain CFStringRef and can be present only in the top-level
    /// parameters dictionary.
    /// kSecAttrApplicationTag default NULL
    /// kSecAttrEffectiveKeySize default NULL same as kSecAttrKeySizeInBits
    /// kSecAttrCanEncrypt default false for private keys, true for public keys
    /// kSecAttrCanDecrypt default true for private keys, false for public keys
    /// kSecAttrCanDerive default true
    /// kSecAttrCanSign default true for private keys, false for public keys
    /// kSecAttrCanVerify default false for private keys, true for public keys
    /// kSecAttrCanWrap default false for private keys, true for public keys
    /// kSecAttrCanUnwrap default true for private keys, false for public keys
    ///
    /// NOTE: The function always saves keys in the keychain on macOS and as such attribute
    /// kSecAttrIsPermanent is ignored. The function respects attribute kSecAttrIsPermanent
    /// on iOS, tvOS and watchOS.
    /// It is recommended to use SecKeyCreateRandomKey() which respects kSecAttrIsPermanent
    /// on all platforms.
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `public_key` must be a valid pointer or null.
    /// - `private_key` must be a valid pointer or null.
    #[doc(alias = "SecKeyGeneratePair")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "Use SecKeyCreateRandomKey"]
    #[inline]
    pub unsafe fn generate_pair(
        parameters: &CFDictionary,
        public_key: *mut *mut SecKey,
        private_key: *mut *mut SecKey,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecKeyGeneratePair(
                parameters: &CFDictionary,
                public_key: *mut *mut SecKey,
                private_key: *mut *mut SecKey,
            ) -> OSStatus;
        }
        unsafe { SecKeyGeneratePair(parameters, public_key, private_key) }
    }

    /// Generates a new public-private key pair.
    ///
    /// Parameters:
    /// - parameters: A dictionary you use to specify the attributes of the generated keys. See [Key Generation Attributes](https://developer.apple.com/documentation/security/key-generation-attributes) for details.
    ///
    /// - error: An error reference pointer that [`SecKeyCreateRandomKey`](https://developer.apple.com/documentation/security/seckeycreaterandomkey(_:_:)) populates with a suitable error instance on failure.
    ///
    ///
    /// ## Return Value
    ///
    /// The newly generated private key, or `NULL` on failure. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the key when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To get the associated public key, use [`SecKeyCopyPublicKey`](https://developer.apple.com/documentation/security/seckeycopypublickey(_:)). [`SecKeyCreateRandomKey`](https://developer.apple.com/documentation/security/seckeycreaterandomkey(_:_:)) fails and returns [`errSecInteractionNotAllowed`](https://developer.apple.com/documentation/security/errsecinteractionnotallowed) if you call it in the background on iPhone or iPad while the device is locked.
    ///
    ///
    /// Generates a new public/private key pair.
    ///
    /// Parameter `parameters`: A dictionary containing one or more key-value pairs.
    /// See the discussion sections below for a complete overview of options.
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: Newly generated private key.  To get associated public key, use SecKeyCopyPublicKey().
    ///
    /// In order to generate a keypair the parameters dictionary must
    /// at least contain the following keys:
    ///
    /// kSecAttrKeyType with a value being kSecAttrKeyTypeRSA or any other
    /// kSecAttrKeyType defined in SecItem.h
    /// kSecAttrKeySizeInBits with a value being a CFNumberRef or CFStringRef
    /// containing the requested key size in bits.  Example sizes for RSA
    /// keys are: 512, 768, 1024, 2048.
    ///
    /// The values below may be set either in the top-level dictionary or in a
    /// dictionary that is the value of the kSecPrivateKeyAttrs or
    /// kSecPublicKeyAttrs key in the top-level dictionary.  Setting these
    /// attributes explicitly will override the defaults below.  See SecItem.h
    /// for detailed information on these attributes including the types of
    /// the values.
    ///
    /// kSecAttrLabel default NULL
    /// kSecAttrIsPermanent if this key is present and has a Boolean value of true,
    /// the key or key pair will be added to the default keychain.
    /// kSecAttrTokenID if this key should be generated on specified token.  This
    /// attribute can contain CFStringRef and can be present only in the top-level
    /// parameters dictionary.
    /// kSecAttrApplicationTag default NULL
    /// kSecAttrEffectiveKeySize default NULL same as kSecAttrKeySizeInBits
    /// kSecAttrCanEncrypt default false for private keys, true for public keys
    /// kSecAttrCanDecrypt default true for private keys, false for public keys
    /// kSecAttrCanDerive default true
    /// kSecAttrCanSign default true for private keys, false for public keys
    /// kSecAttrCanVerify default false for private keys, true for public keys
    /// kSecAttrCanWrap default false for private keys, true for public keys
    /// kSecAttrCanUnwrap default true for private keys, false for public keys
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreateRandomKey")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn new_random_key(
        parameters: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyCreateRandomKey(
                parameters: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecKeyCreateRandomKey(parameters, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Restores a key from an external representation of that key.
    ///
    /// Parameters:
    /// - keyData: Data representing the key. The format of the data depends on the type of key being created. See the description of the return value of the [`SecKeyCopyExternalRepresentation`](https://developer.apple.com/documentation/security/seckeycopyexternalrepresentation(_:_:)) function for details.
    ///
    /// - attributes: A dictionary containing attributes describing the key to be imported. This dictionary must include at least the following keys:
    ///
    /// - [`kSecAttrKeyType`](https://developer.apple.com/documentation/security/ksecattrkeytype)
    ///
    /// - [`kSecAttrKeyClass`](https://developer.apple.com/documentation/security/ksecattrkeyclass)
    ///
    /// - error: The address of a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) object. If an error occurs, this is set to point at an error instance that describes the failure.
    ///
    ///
    /// ## Return Value
    ///
    /// The restored key or `NULL` on failure. In Objective-C, call [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) to free the key’s memory when you are done with it.
    ///
    ///
    /// Create a SecKey from a well-defined external representation.
    ///
    /// Parameter `keyData`: CFData representing the key. The format of the data depends on the type of key being created.
    ///
    /// Parameter `attributes`: Dictionary containing attributes describing the key to be imported. The keys in this dictionary
    /// are kSecAttr* constants from SecItem.h.  Mandatory attributes are:
    /// kSecAttrKeyType
    /// kSecAttrKeyClass
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: A SecKey object representing the key, or NULL on failure.
    ///
    /// This function does not add keys to any keychain, but the SecKey object it returns can be added
    /// to keychain using the SecItemAdd function.
    /// The requested data format depend on the type of key (kSecAttrKeyType) being created:
    /// kSecAttrKeyTypeRSA               PKCS#1 format, public key can be also in x509 public key format
    /// kSecAttrKeyTypeECSECPrimeRandom  ANSI X9.63 format (04 || X || Y [ || K])
    ///
    /// # Safety
    ///
    /// - `attributes` generic must be of the correct type.
    /// - `attributes` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreateWithData")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn with_data(
        key_data: &CFData,
        attributes: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyCreateWithData(
                key_data: &CFData,
                attributes: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecKeyCreateWithData(key_data, attributes, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Gets the block length associated with a cryptographic key.
    ///
    /// Parameters:
    /// - key: The key for which you want the block length.
    ///
    ///
    /// ## Return Value
    ///
    /// The block length associated with the key in bytes. If the key is an RSA key, for example, this is the size of the modulus.
    ///
    ///
    /// Returns block length of the key in bytes.
    ///
    /// Parameter `key`: The key for which the block length is requested.
    ///
    /// Returns: The block length of the key in bytes.
    ///
    /// If for example key is an RSA key the value returned by
    /// this function is the size of the modulus.
    #[doc(alias = "SecKeyGetBlockSize")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn block_size(&self) -> usize {
        extern "C-unwind" {
            fn SecKeyGetBlockSize(key: &SecKey) -> usize;
        }
        unsafe { SecKeyGetBlockSize(self) }
    }

    /// Returns an external representation of the given key suitable for the key’s type.
    ///
    /// Parameters:
    /// - key: The key to export.
    ///
    /// - error: The address of a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) object. If an error occurs, this is set to point at an error instance that describes the failure.
    ///
    ///
    /// ## Return Value
    ///
    /// A data object representing the key in a format suitable for the key type or `NULL` on error. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the key’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The operation fails if the key is not exportable, for example if it is bound to a smart card or to the Secure Enclave. It also fails in macOS if the key has the attribute [`kSecKeyExtractable`](https://developer.apple.com/documentation/security/kseckeyextractable) set to [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    /// The method returns data in the PKCS #1 format for an RSA key. For an elliptic curve public key, the format follows the ANSI X9.63 standard using a byte string of `04 || X || Y.` For an elliptic curve private key, the output is formatted as the public key concatenated with the big endian encoding of the secret scalar, or `04 || X || Y || K`. All of these representations use constant size integers, including leading zeros as needed.
    ///
    ///
    /// Create an external representation for the given key suitable for the key's type.
    ///
    /// Parameter `key`: The key to be exported.
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: A CFData representing the key in a format suitable for that key type.
    ///
    /// This function may fail if the key is not exportable (e.g., bound to a smart card or Secure Enclave).
    /// The format in which the key will be exported depends on the type of key:
    /// kSecAttrKeyTypeRSA               PKCS#1 format
    /// kSecAttrKeyTypeECSECPrimeRandom  ANSI X9.63 format (04 || X || Y [ || K])
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCopyExternalRepresentation")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn external_representation(
        &self,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecKeyCopyExternalRepresentation(
                key: &SecKey,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecKeyCopyExternalRepresentation(self, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Gets the attributes of a given key.
    ///
    /// Parameters:
    /// - key: The key whose attributes you want.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary containing the key’s attributes. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free this dictionary’s memory when you are done with it.
    ///
    ///
    /// Retrieve keychain attributes of a key.
    ///
    /// Parameter `key`: The key whose attributes are to be retrieved.
    ///
    /// Returns: Dictionary containing attributes of the key. The keys that populate this dictionary are defined
    /// and discussed in SecItem.h.
    ///
    /// The attributes provided by this function are:
    /// kSecAttrCanEncrypt
    /// kSecAttrCanDecrypt
    /// kSecAttrCanDerive
    /// kSecAttrCanSign
    /// kSecAttrCanVerify
    /// kSecAttrKeyClass
    /// kSecAttrKeyType
    /// kSecAttrKeySizeInBits
    /// kSecAttrTokenID
    /// kSecAttrApplicationLabel
    /// The set of values is not fixed. Future versions may return more values in this dictionary.
    #[doc(alias = "SecKeyCopyAttributes")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn attributes(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn SecKeyCopyAttributes(key: &SecKey) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { SecKeyCopyAttributes(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Gets the public key associated with the given private key.
    ///
    /// Parameters:
    /// - key: The private key for which you want the corresponding public key.
    ///
    ///
    /// ## Return Value
    ///
    /// The public key corresponding to the given private key. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free this key’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The returned public key may be `nil` if the app that created the private key didn’t also store the corresponding public key in the keychain, or if the system can’t reconstruct the corresponding public key.
    ///
    ///
    /// Retrieve the public key from a key pair or private key.
    ///
    /// Parameter `key`: The key from which to retrieve a public key.
    ///
    /// Returns: The public key or NULL if public key is not available for specified key.
    ///
    /// Fails if key does not contain a public key or no public key can be computed from it.
    #[doc(alias = "SecKeyCopyPublicKey")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn public_key(&self) -> Option<CFRetained<SecKey>> {
        extern "C-unwind" {
            fn SecKeyCopyPublicKey(key: &SecKey) -> Option<NonNull<SecKey>>;
        }
        let ret = unsafe { SecKeyCopyPublicKey(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// The algorithms that cryptographic keys enable.
/// Available algorithms for performing cryptographic operations with SecKey object.  String representation
/// of constant can be used for logging or debugging purposes, because they contain human readable names of the algorithm.
///
///
/// Raw RSA sign/verify operation, size of input data must be the same as value returned by SecKeyGetBlockSize().
///
///
/// RSA sign/verify operation, assumes that input data is digest and OID and digest algorithm as specified in PKCS# v1.5.
/// This algorithm is typically not used directly, instead use algorithm with specified digest, like
/// kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA256.
///
///
/// RSA signature with PKCS#1 padding, input data must be SHA-1 generated digest.
///
///
/// RSA signature with PKCS#1 padding, input data must be SHA-224 generated digest.
///
///
/// RSA signature with PKCS#1 padding, input data must be SHA-256 generated digest.
///
///
/// RSA signature with PKCS#1 padding, input data must be SHA-384 generated digest.
///
///
/// RSA signature with PKCS#1 padding, input data must be SHA-512 generated digest.
///
///
/// RSA signature with PKCS#1 padding, SHA-1 digest is generated by called function automatically from input data of any size.
///
///
/// RSA signature with PKCS#1 padding, SHA-224 digest is generated by called function automatically from input data of any size.
///
///
/// RSA signature with PKCS#1 padding, SHA-256 digest is generated by called function automatically from input data of any size.
///
///
/// RSA signature with PKCS#1 padding, SHA-384 digest is generated by called function automatically from input data of any size.
///
///
/// RSA signature with PKCS#1 padding, SHA-512 digest is generated by called function automatically from input data of any size.
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, input data must be SHA-1 generated digest.
/// PSS padding is calculated using MGF1 with SHA1 and saltLength parameter is set to 20 (SHA-1 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, input data must be SHA-224 generated digest.
/// PSS padding is calculated using MGF1 with SHA224 and saltLength parameter is set to 28 (SHA-224 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, input data must be SHA-256 generated digest.
/// PSS padding is calculated using MGF1 with SHA256 and saltLength parameter is set to 32 (SHA-256 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, input data must be SHA-384 generated digest.
/// PSS padding is calculated using MGF1 with SHA384 and saltLength parameter is set to 48 (SHA-384 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, input data must be SHA-512 generated digest.
/// PSS padding is calculated using MGF1 with SHA512 and saltLength parameter is set to 64 (SHA-512 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, SHA-1 digest is generated by called function automatically from input data of any size.
/// PSS padding is calculated using MGF1 with SHA1 and saltLength parameter is set to 20 (SHA-1 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, SHA-224 digest is generated by called function automatically from input data of any size.
/// PSS padding is calculated using MGF1 with SHA224 and saltLength parameter is set to 28 (SHA-224 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, SHA-256 digest is generated by called function automatically from input data of any size.
/// PSS padding is calculated using MGF1 with SHA256 and saltLength parameter is set to 32 (SHA-256 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, SHA-384 digest is generated by called function automatically from input data of any size.
/// PSS padding is calculated using MGF1 with SHA384 and saltLength parameter is set to 48 (SHA-384 output size).
///
///
/// RSA signature with RSASSA-PSS padding according to PKCS#1 v2.1, SHA-512 digest is generated by called function automatically from input data of any size.
/// PSS padding is calculated using MGF1 with SHA512 and saltLength parameter is set to 64 (SHA-512 output size).
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, input data must be message digest generated by some hash functions.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, input data must be message digest created by SHA1 algorithm.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, input data must be message digest created by SHA224 algorithm.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, input data must be message digest created by SHA256 algorithm.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, input data must be message digest created by SHA384 algorithm.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, input data must be message digest created by SHA512 algorithm.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, SHA-1 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, SHA-224 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, SHA-256 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, SHA-384 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is in DER x9.62 encoding, SHA-512 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest generated by some hash functions.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest created by SHA1 algorithm.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest created by SHA224 algorithm.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest created by SHA256 algorithm.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest created by SHA384 algorithm.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest created by SHA512 algorithm.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, SHA-1 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, SHA-224 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, SHA-256 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, SHA-384 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, SHA-512 digest is generated by called function automatically from input data of any size.
///
///
/// ECDSA algorithm, signature is concatenated r and s, big endian, input data must be message digest generated by some hash function.
/// This is deprecated algorithm, replaced by kSecKeyAlgorithmECDSASignatureDigestRFC4754
///
///
/// Raw RSA encryption or decryption, size of data must match RSA key modulus size.  Note that direct
/// use of this algorithm without padding is cryptographically very weak, it is important to always introduce
/// some kind of padding.  Input data size must be less or equal to the key block size and returned block has always
/// the same size as block size, as returned by SecKeyGetBlockSize().
///
///
/// RSA encryption or decryption, data is padded using PKCS#1 padding scheme.  This algorithm should be used only for
/// backward compatibility with existing protocols and data. New implementations should choose cryptographically
/// stronger algorithm instead (see kSecKeyAlgorithmRSAEncryptionOAEP).  Input data must be at most
/// "key block size - 11" bytes long and returned block has always the same size as block size, as returned
/// by SecKeyGetBlockSize().
///
///
/// RSA encryption or decryption, data is padded using OAEP padding scheme internally using SHA1. Input data must be at most
/// "key block size - 42" bytes long and returned block has always the same size as block size, as returned
/// by SecKeyGetBlockSize().  Use kSecKeyAlgorithmRSAEncryptionOAEPSHA1AESGCM to be able to encrypt and decrypt arbitrary long data.
///
///
/// RSA encryption or decryption, data is padded using OAEP padding scheme internally using SHA224. Input data must be at most
/// "key block size - 58" bytes long and returned block has always the same size as block size, as returned
/// by SecKeyGetBlockSize().  Use kSecKeyAlgorithmRSAEncryptionOAEPSHA224AESGCM to be able to encrypt and decrypt arbitrary long data.
///
///
/// RSA encryption or decryption, data is padded using OAEP padding scheme internally using SHA256. Input data must be at most
/// "key block size - 66" bytes long and returned block has always the same size as block size, as returned
/// by SecKeyGetBlockSize().  Use kSecKeyAlgorithmRSAEncryptionOAEPSHA256AESGCM to be able to encrypt and decrypt arbitrary long data.
///
///
/// RSA encryption or decryption, data is padded using OAEP padding scheme internally using SHA384. Input data must be at most
/// "key block size - 98" bytes long and returned block has always the same size as block size, as returned
/// by SecKeyGetBlockSize().  Use kSecKeyAlgorithmRSAEncryptionOAEPSHA384AESGCM to be able to encrypt and decrypt arbitrary long data.
///
///
/// RSA encryption or decryption, data is padded using OAEP padding scheme internally using SHA512. Input data must be at most
/// "key block size - 130" bytes long and returned block has always the same size as block size, as returned
/// by SecKeyGetBlockSize().  Use kSecKeyAlgorithmRSAEncryptionOAEPSHA512AESGCM to be able to encrypt and decrypt arbitrary long data.
///
///
/// Randomly generated AES session key is encrypted by RSA with OAEP padding.  User data are encrypted using session key in GCM
/// mode with all-zero 16 bytes long IV (initialization vector).  Finally 16 byte AES-GCM tag is appended to ciphertext.
/// 256bit AES key is used if RSA key is 4096bit or bigger, otherwise 128bit AES key is used.  Raw public key data is used
/// as authentication data for AES-GCM encryption.
///
///
/// Randomly generated AES session key is encrypted by RSA with OAEP padding.  User data are encrypted using session key in GCM
/// mode with all-zero 16 bytes long IV (initialization vector).  Finally 16 byte AES-GCM tag is appended to ciphertext.
/// 256bit AES key is used if RSA key is 4096bit or bigger, otherwise 128bit AES key is used.  Raw public key data is used
/// as authentication data for AES-GCM encryption.
///
///
/// Randomly generated AES session key is encrypted by RSA with OAEP padding.  User data are encrypted using session key in GCM
/// mode with all-zero 16 bytes long IV (initialization vector).  Finally 16 byte AES-GCM tag is appended to ciphertext.
/// 256bit AES key is used if RSA key is 4096bit or bigger, otherwise 128bit AES key is used.  Raw public key data is used
/// as authentication data for AES-GCM encryption.
///
///
/// Randomly generated AES session key is encrypted by RSA with OAEP padding.  User data are encrypted using session key in GCM
/// mode with all-zero 16 bytes long IV (initialization vector).  Finally 16 byte AES-GCM tag is appended to ciphertext.
/// 256bit AES key is used if RSA key is 4096bit or bigger, otherwise 128bit AES key is used.  Raw public key data is used
/// as authentication data for AES-GCM encryption.
///
///
/// Randomly generated AES session key is encrypted by RSA with OAEP padding.  User data are encrypted using session key in GCM
/// mode with all-zero 16 bytes long IV (initialization vector).  Finally 16 byte AES-GCM tag is appended to ciphertext.
/// 256bit AES key is used if RSA key is 4096bit or bigger, otherwise 128bit AES key is used.  Raw public key data is used
/// as authentication data for AES-GCM encryption.
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA256AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA1.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA224AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA224.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA256AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA256.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA384AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA384.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA512AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA512.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA256AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA1.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA224AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA224.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA256AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA256.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA384AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA384.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// Legacy ECIES encryption or decryption, use kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA512AESGCM in new code.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA512.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG and all-zero 16 byte long IV (initialization vector).
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA224.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA256.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA384.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA512.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA224.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA256.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA384.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// ECIES encryption or decryption.  This algorithm does not limit the size of the message to be encrypted or decrypted.
/// Encryption is done using AES-GCM with key negotiated by kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA512.  AES Key size
/// is 128bit for EC keys
/// <
/// =256bit and 256bit for bigger EC keys. Ephemeral public key data is used as sharedInfo for KDF.
/// AES-GCM uses 16 bytes long TAG, AES key is first half of KDF output and 16 byte long IV (initialization vector) is second half
/// of KDF output.
///
///
/// Compute shared secret using ECDH cofactor algorithm, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys.
/// This algorithm does not accept any parameters, length of output raw shared secret is given by the length of the key.
///
///
/// Compute shared secret using ECDH cofactor algorithm, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA1 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH cofactor algorithm, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA224 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH cofactor algorithm, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA256 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH cofactor algorithm, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA384 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH cofactor algorithm, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA512 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH algorithm without cofactor, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys.
/// This algorithm does not accept any parameters, length of output raw shared secret is given by the length of the key.
///
///
/// Compute shared secret using ECDH algorithm without cofactor, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA1 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH algorithm without cofactor, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA224 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH algorithm without cofactor, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA256 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH algorithm without cofactor, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA384 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
///
///
/// Compute shared secret using ECDH algorithm without cofactor, suitable only for kSecAttrKeyTypeECSECPrimeRandom keys
/// and apply ANSI X9.63 KDF with SHA512 as hashing function.  Requires kSecKeyKeyExchangeParameterRequestedSize and allows
/// kSecKeyKeyExchangeParameterSharedInfo parameters to be used.
// NS_TYPED_ENUM
pub type SecKeyAlgorithm = CFString;

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureRaw: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPKCS1v15Raw: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPKCS1v15SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePKCS1v15SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPSSSHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPSSSHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPSSSHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPSSSHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureDigestPSSSHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePSSSHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePSSSHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePSSSHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePSSSHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSASignatureMessagePSSSHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureDigestX962: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureDigestX962SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureDigestX962SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureDigestX962SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureDigestX962SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureDigestX962SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureMessageX962SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureMessageX962SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureMessageX962SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureMessageX962SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDSASignatureMessageX962SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating message digest signatures.
    pub static kSecKeyAlgorithmECDSASignatureDigestRFC4754: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating signatures of SHA1 message digests.
    pub static kSecKeyAlgorithmECDSASignatureDigestRFC4754SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating signatures of SHA224 message digests.
    pub static kSecKeyAlgorithmECDSASignatureDigestRFC4754SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating signatures of SHA256 message digests.
    pub static kSecKeyAlgorithmECDSASignatureDigestRFC4754SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating signatures of SHA384 message digests.
    pub static kSecKeyAlgorithmECDSASignatureDigestRFC4754SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating signatures of SHA512 message digests.
    pub static kSecKeyAlgorithmECDSASignatureDigestRFC4754SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating message signatures by calculating and signing the SHA1 message digest.
    pub static kSecKeyAlgorithmECDSASignatureMessageRFC4754SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating message signatures by calculating and signing the SHA224 message digest.
    pub static kSecKeyAlgorithmECDSASignatureMessageRFC4754SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating message signatures by calculating and signing the SHA256 message digest.
    pub static kSecKeyAlgorithmECDSASignatureMessageRFC4754SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating message signatures by calculating and signing the SHA384 message digest.
    pub static kSecKeyAlgorithmECDSASignatureMessageRFC4754SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    /// An algorithm for generating message signatures by calculating and signing the SHA512 message digest.
    pub static kSecKeyAlgorithmECDSASignatureMessageRFC4754SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    #[deprecated]
    pub static kSecKeyAlgorithmECDSASignatureRFC4754: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionRaw: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionPKCS1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA1AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA224AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA256AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA384AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmRSAEncryptionOAEPSHA512AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardX963SHA1AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardX963SHA224AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardX963SHA256AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardX963SHA384AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardX963SHA512AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorX963SHA1AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorX963SHA224AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorX963SHA256AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorX963SHA384AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorX963SHA512AESGCM: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA224AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA256AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA384AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionStandardVariableIVX963SHA512AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA224AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA256AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA384AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECIESEncryptionCofactorVariableIVX963SHA512AESGCM:
        &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeStandard: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeStandardX963SHA512: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeCofactor: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA1: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA224: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA256: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA384: &'static SecKeyAlgorithm;
}

extern "C" {
    pub static kSecKeyAlgorithmECDHKeyExchangeCofactorX963SHA512: &'static SecKeyAlgorithm;
}

#[cfg(feature = "SecBase")]
impl SecKey {
    /// Creates the cryptographic signature for a block of data using a private key and specified algorithm.
    ///
    /// Parameters:
    /// - key: The private key to use in creating the signature.
    ///
    /// - algorithm: The signing algorithm to use. Use one of the signing algorithms listed in [`SecKeyAlgorithm`](https://developer.apple.com/documentation/security/seckeyalgorithm). You can use the [`SecKeyIsAlgorithmSupported`](https://developer.apple.com/documentation/security/seckeyisalgorithmsupported(_:_:_:)) function to test that the key is suitable for the algorithm.
    ///
    /// - dataToSign: The data whose signature you want.
    ///
    /// - error: The address of a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) object. If an error occurs, this is set to point at an error instance that describes the failure.
    ///
    ///
    /// ## Return Value
    ///
    /// The digital signature or `NULL` on failure. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the data’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You later evaluate the combined data and signature with the corresponding public key and a call to the [`SecKeyVerifySignature`](https://developer.apple.com/documentation/security/seckeyverifysignature(_:_:_:_:_:)) function.
    ///
    ///
    /// Given a private key and data to sign, generate a digital signature.
    ///
    /// Parameter `key`: Private key with which to sign.
    ///
    /// Parameter `algorithm`: One of SecKeyAlgorithm constants suitable to generate signature with this key.
    ///
    /// Parameter `dataToSign`: The data to be signed, typically the digest of the actual data.
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: The signature over dataToSign represented as a CFData, or NULL on failure.
    ///
    /// Computes digital signature using specified key over input data.  The operation algorithm
    /// further defines the exact format of input data, operation to be performed and output signature.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreateSignature")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn signature(
        &self,
        algorithm: &SecKeyAlgorithm,
        data_to_sign: &CFData,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecKeyCreateSignature(
                key: &SecKey,
                algorithm: &SecKeyAlgorithm,
                data_to_sign: &CFData,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecKeyCreateSignature(self, algorithm, data_to_sign, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Verifies the cryptographic signature of a block of data using a public key and specified algorithm.
    ///
    /// Parameters:
    /// - key: The public key to use in evaluating the signature.
    ///
    /// - algorithm: The algorithm that was used to create the signature. Use one of the signing algorithms listed in [`SecKeyAlgorithm`](https://developer.apple.com/documentation/security/seckeyalgorithm). You can use the [`SecKeyIsAlgorithmSupported`](https://developer.apple.com/documentation/security/seckeyisalgorithmsupported(_:_:_:)) function to test that the key is suitable for the algorithm.
    ///
    /// - signedData: The data that was signed.
    ///
    /// - signature: The signature that was created with a call to the [`SecKeyCreateSignature`](https://developer.apple.com/documentation/security/seckeycreatesignature(_:_:_:_:)) function.
    ///
    /// - error: The address of a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) object. If an error occurs, this is set to point at an error instance that describes the failure.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean indicating whether or not the data and signature are intact.
    ///
    ///
    /// Given a public key, data which has been signed, and a signature, verify the signature.
    ///
    /// Parameter `key`: Public key with which to verify the signature.
    ///
    /// Parameter `algorithm`: One of SecKeyAlgorithm constants suitable to verify signature with this key.
    ///
    /// Parameter `signedData`: The data over which sig is being verified, typically the digest of the actual data.
    ///
    /// Parameter `signature`: The signature to verify.
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: True if the signature was valid, False otherwise.
    ///
    /// Verifies digital signature operation using specified key and signed data.  The operation algorithm
    /// further defines the exact format of input data, signature and operation to be performed.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyVerifySignature")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn verify_signature(
        &self,
        algorithm: &SecKeyAlgorithm,
        signed_data: &CFData,
        signature: &CFData,
        error: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn SecKeyVerifySignature(
                key: &SecKey,
                algorithm: &SecKeyAlgorithm,
                signed_data: &CFData,
                signature: &CFData,
                error: *mut *mut CFError,
            ) -> Boolean;
        }
        let ret = unsafe { SecKeyVerifySignature(self, algorithm, signed_data, signature, error) };
        ret != 0
    }

    /// Encrypts a block of data using a public key and specified algorithm.
    ///
    /// Parameters:
    /// - key: The public key to use to perform the encryption.
    ///
    /// - algorithm: The encryption algorithm to use. Use one of the encryption algorithms listed in [`SecKeyAlgorithm`](https://developer.apple.com/documentation/security/seckeyalgorithm). You can use the [`SecKeyIsAlgorithmSupported`](https://developer.apple.com/documentation/security/seckeyisalgorithmsupported(_:_:_:)) function to test that the key is suitable for the algorithm.
    ///
    /// - plaintext: The data to be encrypted.
    ///
    /// - error: The address of a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) object. If an error occurs, this is set to point at an error instance that describes the failure.
    ///
    ///
    /// ## Return Value
    ///
    /// The encrypted data or `NULL` on failure. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the data’s memory when you are done with it.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can decrypt this data with the corresponding private key and a call to [`SecKeyCreateDecryptedData`](https://developer.apple.com/documentation/security/seckeycreatedecrypteddata(_:_:_:_:)).
    ///
    ///
    /// Encrypt a block of plaintext.
    ///
    /// Parameter `key`: Public key with which to encrypt the data.
    ///
    /// Parameter `algorithm`: One of SecKeyAlgorithm constants suitable to perform encryption with this key.
    ///
    /// Parameter `plaintext`: The data to encrypt. The length and format of the data must conform to chosen algorithm,
    /// typically be less or equal to the value returned by SecKeyGetBlockSize().
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: The ciphertext represented as a CFData, or NULL on failure.
    ///
    /// Encrypts plaintext data using specified key.  The exact type of the operation including the format
    /// of input and output data is specified by encryption algorithm.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreateEncryptedData")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn encrypted_data(
        &self,
        algorithm: &SecKeyAlgorithm,
        plaintext: &CFData,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecKeyCreateEncryptedData(
                key: &SecKey,
                algorithm: &SecKeyAlgorithm,
                plaintext: &CFData,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecKeyCreateEncryptedData(self, algorithm, plaintext, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Decrypts a block of data using a private key and specified algorithm.
    ///
    /// Parameters:
    /// - key: The private key to use to perform the decryption.
    ///
    /// - algorithm: The algorithm that was used to encrypt the data in the first place. Use one of the encryption algorithms listed in [`SecKeyAlgorithm`](https://developer.apple.com/documentation/security/seckeyalgorithm). You can use the [`SecKeyIsAlgorithmSupported`](https://developer.apple.com/documentation/security/seckeyisalgorithmsupported(_:_:_:)) function to test that the key is suitable for the algorithm.
    ///
    /// - ciphertext: The data, produced with the corresponding public key and a call to the [`SecKeyCreateEncryptedData`](https://developer.apple.com/documentation/security/seckeycreateencrypteddata(_:_:_:_:)) function, that you want to decrypt.
    ///
    /// - error: The address of a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) object. If an error occurs, this is set to point at an error instance that describes the failure.
    ///
    ///
    /// ## Return Value
    ///
    /// The decrypted data or `NULL` on failure. In Objective-C, call the [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) function to free the data’s memory when you are done with it.
    ///
    ///
    /// Decrypt a block of ciphertext.
    ///
    /// Parameter `key`: Private key with which to decrypt the data.
    ///
    /// Parameter `algorithm`: One of SecKeyAlgorithm constants suitable to perform decryption with this key.
    ///
    /// Parameter `ciphertext`: The data to decrypt. The length and format of the data must conform to chosen algorithm,
    /// typically be less or equal to the value returned by SecKeyGetBlockSize().
    ///
    /// Parameter `error`: On error, will be populated with an error object describing the failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: The plaintext represented as a CFData, or NULL on failure.
    ///
    /// Decrypts ciphertext data using specified key.  The exact type of the operation including the format
    /// of input and output data is specified by decryption algorithm.
    ///
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCreateDecryptedData")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn decrypted_data(
        &self,
        algorithm: &SecKeyAlgorithm,
        ciphertext: &CFData,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecKeyCreateDecryptedData(
                key: &SecKey,
                algorithm: &SecKeyAlgorithm,
                ciphertext: &CFData,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { SecKeyCreateDecryptedData(self, algorithm, ciphertext, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// The dictionary keys used to specify Diffie-Hellman key exchange parameters.
///
/// ## Discussion
///
/// Use these constants as keys in the dictionary that you input to the [`SecKeyCopyKeyExchangeResult`](https://developer.apple.com/documentation/security/seckeycopykeyexchangeresult(_:_:_:_:_:)) function as a means to refine the process of Diffie-Hellman key exchange.
///
///
/// for KDF (key derivation function).
// NS_TYPED_ENUM
pub type SecKeyKeyExchangeParameter = CFString;

extern "C" {
    pub static kSecKeyKeyExchangeParameterRequestedSize: &'static SecKeyKeyExchangeParameter;
}

extern "C" {
    pub static kSecKeyKeyExchangeParameterSharedInfo: &'static SecKeyKeyExchangeParameter;
}

#[cfg(feature = "SecBase")]
impl SecKey {
    /// Performs the Diffie-Hellman style of key exchange with optional key-derivation steps.
    ///
    /// ## Return Value
    ///
    /// A data object representing the result of the key exchange operation or `NULL` on failure. In Objective-C, call [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) to free the data object’s memory when you are done with it.
    ///
    ///
    /// Perform Diffie-Hellman style of key exchange operation, optionally with additional key-derivation steps.
    ///
    /// Parameter `algorithm`: One of SecKeyAlgorithm constants suitable to perform this operation.
    ///
    /// Parameter `publicKey`: Remote party's public key.
    ///
    /// Parameter `parameters`: Dictionary with parameters, see SecKeyKeyExchangeParameter constants.  Used algorithm
    /// determines the set of required and optional parameters to be used.
    ///
    /// Parameter `error`: Pointer to an error object on failure.
    /// See "Security Error Codes" (SecBase.h).
    ///
    /// Returns: Result of key exchange operation as a CFDataRef, or NULL on failure.
    ///
    /// # Safety
    ///
    /// - `parameters` generic must be of the correct type.
    /// - `parameters` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecKeyCopyKeyExchangeResult")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn key_exchange_result(
        &self,
        algorithm: &SecKeyAlgorithm,
        public_key: &SecKey,
        parameters: &CFDictionary,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn SecKeyCopyKeyExchangeResult(
                private_key: &SecKey,
                algorithm: &SecKeyAlgorithm,
                public_key: &SecKey,
                parameters: &CFDictionary,
                error: *mut *mut CFError,
            ) -> Option<NonNull<CFData>>;
        }
        let ret =
            unsafe { SecKeyCopyKeyExchangeResult(self, algorithm, public_key, parameters, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// The types of operations that you can use a cryptographic key to perform.
/// Defines types of cryptographic operations available with SecKey instance.
///
///
/// Represents SecKeyCreateSignature()
///
///
/// Represents SecKeyVerifySignature()
///
///
/// Represents SecKeyCreateEncryptedData()
///
///
/// Represents SecKeyCreateDecryptedData()
///
///
/// Represents SecKeyCopyKeyExchangeResult()
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SecKeyOperationType(pub CFIndex);
impl SecKeyOperationType {
    #[doc(alias = "kSecKeyOperationTypeSign")]
    pub const Sign: Self = Self(0);
    #[doc(alias = "kSecKeyOperationTypeVerify")]
    pub const Verify: Self = Self(1);
    #[doc(alias = "kSecKeyOperationTypeEncrypt")]
    pub const Encrypt: Self = Self(2);
    #[doc(alias = "kSecKeyOperationTypeDecrypt")]
    pub const Decrypt: Self = Self(3);
    #[doc(alias = "kSecKeyOperationTypeKeyExchange")]
    pub const KeyExchange: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SecKeyOperationType {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SecKeyOperationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "SecBase")]
impl SecKey {
    /// Returns a Boolean indicating whether a key is suitable for an operation using a certain algorithm.
    ///
    /// Parameters:
    /// - key: The key whose suitability you want to test.
    ///
    /// - operation: The operation that you want to perform with the key. Use one of the values from [`SecKeyOperationType`](https://developer.apple.com/documentation/security/seckeyoperationtype).
    ///
    /// - algorithm: The algorithm that you want to perform with the key. Use one of the values from [`SecKeyAlgorithm`](https://developer.apple.com/documentation/security/seckeyalgorithm).
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean indicating whether the key can be used for the given operation and algorithm.
    ///
    ///
    /// Checks whether key supports specified algorithm for specified operation.
    ///
    /// Parameter `key`: Key to query
    ///
    /// Parameter `operation`: Operation type for which the key is queried
    ///
    /// Parameter `algorithm`: Algorithm which is queried
    ///
    /// Returns: True if key supports specified algorithm for specified operation, False otherwise.
    #[doc(alias = "SecKeyIsAlgorithmSupported")]
    #[cfg(feature = "SecBase")]
    #[inline]
    pub unsafe fn is_algorithm_supported(
        &self,
        operation: SecKeyOperationType,
        algorithm: &SecKeyAlgorithm,
    ) -> bool {
        extern "C-unwind" {
            fn SecKeyIsAlgorithmSupported(
                key: &SecKey,
                operation: SecKeyOperationType,
                algorithm: &SecKeyAlgorithm,
            ) -> Boolean;
        }
        let ret = unsafe { SecKeyIsAlgorithmSupported(self, operation, algorithm) };
        ret != 0
    }
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecKey::create_pair`"]
    pub fn SecKeyCreatePair(
        keychain_ref: Option<&SecKeychain>,
        algorithm: CSSM_ALGORITHMS,
        key_size_in_bits: uint32,
        context_handle: CSSM_CC_HANDLE,
        public_key_usage: CSSM_KEYUSE,
        public_key_attr: uint32,
        private_key_usage: CSSM_KEYUSE,
        private_key_attr: uint32,
        initial_access: Option<&SecAccess>,
        public_key: *mut *mut SecKey,
        private_key: *mut *mut SecKey,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecKey::generate`"]
    pub fn SecKeyGenerate(
        keychain_ref: Option<&SecKeychain>,
        algorithm: CSSM_ALGORITHMS,
        key_size_in_bits: uint32,
        context_handle: CSSM_CC_HANDLE,
        key_usage: CSSM_KEYUSE,
        key_attr: uint32,
        initial_access: Option<&SecAccess>,
        key_ref: *mut *mut SecKey,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "renamed to `SecKey::cssm_key`"]
    pub fn SecKeyGetCSSMKey(key: &SecKey, cssm_key: NonNull<*const CSSM_KEY>) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecKey::csp_handle`"]
    pub fn SecKeyGetCSPHandle(key_ref: &SecKey, csp_handle: NonNull<CSSM_CSP_HANDLE>) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "renamed to `SecKey::credentials`"]
    pub fn SecKeyGetCredentials(
        key_ref: &SecKey,
        operation: CSSM_ACL_AUTHORIZATION_TAG,
        credential_type: SecCredentialType,
        out_credentials: NonNull<*const CSSM_ACCESS_CREDENTIALS>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::generate_symmetric`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyGenerateSymmetric(
    parameters: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyGenerateSymmetric(
            parameters: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyGenerateSymmetric(parameters, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::from_data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCreateFromData(
    parameters: &CFDictionary,
    key_data: &CFData,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyCreateFromData(
            parameters: &CFDictionary,
            key_data: &CFData,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyCreateFromData(parameters, key_data, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::derive_from_password`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyDeriveFromPassword(
    password: &CFString,
    parameters: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyDeriveFromPassword(
            password: &CFString,
            parameters: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyDeriveFromPassword(password, parameters, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::wrap_symmetric`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyWrapSymmetric(
    key_to_wrap: &SecKey,
    wrapping_key: &SecKey,
    parameters: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecKeyWrapSymmetric(
            key_to_wrap: &SecKey,
            wrapping_key: &SecKey,
            parameters: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecKeyWrapSymmetric(key_to_wrap, wrapping_key, parameters, error) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::unwrap_symmetric`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyUnwrapSymmetric(
    key_to_unwrap: NonNull<*const CFData>,
    unwrapping_key: &SecKey,
    parameters: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyUnwrapSymmetric(
            key_to_unwrap: NonNull<*const CFData>,
            unwrapping_key: &SecKey,
            parameters: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyUnwrapSymmetric(key_to_unwrap, unwrapping_key, parameters, error) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecKey::generate_pair`"]
    pub fn SecKeyGeneratePair(
        parameters: &CFDictionary,
        public_key: *mut *mut SecKey,
        private_key: *mut *mut SecKey,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::new_random_key`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCreateRandomKey(
    parameters: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyCreateRandomKey(
            parameters: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyCreateRandomKey(parameters, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::with_data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCreateWithData(
    key_data: &CFData,
    attributes: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyCreateWithData(
            key_data: &CFData,
            attributes: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyCreateWithData(key_data, attributes, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecKey::block_size`"]
    pub fn SecKeyGetBlockSize(key: &SecKey) -> usize;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::external_representation`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCopyExternalRepresentation(
    key: &SecKey,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecKeyCopyExternalRepresentation(
            key: &SecKey,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecKeyCopyExternalRepresentation(key, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::attributes`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCopyAttributes(
    key: &SecKey,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn SecKeyCopyAttributes(key: &SecKey) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { SecKeyCopyAttributes(key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::public_key`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCopyPublicKey(key: &SecKey) -> Option<CFRetained<SecKey>> {
    extern "C-unwind" {
        fn SecKeyCopyPublicKey(key: &SecKey) -> Option<NonNull<SecKey>>;
    }
    let ret = unsafe { SecKeyCopyPublicKey(key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::signature`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCreateSignature(
    key: &SecKey,
    algorithm: &SecKeyAlgorithm,
    data_to_sign: &CFData,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecKeyCreateSignature(
            key: &SecKey,
            algorithm: &SecKeyAlgorithm,
            data_to_sign: &CFData,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecKeyCreateSignature(key, algorithm, data_to_sign, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::verify_signature`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyVerifySignature(
    key: &SecKey,
    algorithm: &SecKeyAlgorithm,
    signed_data: &CFData,
    signature: &CFData,
    error: *mut *mut CFError,
) -> bool {
    extern "C-unwind" {
        fn SecKeyVerifySignature(
            key: &SecKey,
            algorithm: &SecKeyAlgorithm,
            signed_data: &CFData,
            signature: &CFData,
            error: *mut *mut CFError,
        ) -> Boolean;
    }
    let ret = unsafe { SecKeyVerifySignature(key, algorithm, signed_data, signature, error) };
    ret != 0
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::encrypted_data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCreateEncryptedData(
    key: &SecKey,
    algorithm: &SecKeyAlgorithm,
    plaintext: &CFData,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecKeyCreateEncryptedData(
            key: &SecKey,
            algorithm: &SecKeyAlgorithm,
            plaintext: &CFData,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecKeyCreateEncryptedData(key, algorithm, plaintext, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::decrypted_data`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCreateDecryptedData(
    key: &SecKey,
    algorithm: &SecKeyAlgorithm,
    ciphertext: &CFData,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecKeyCreateDecryptedData(
            key: &SecKey,
            algorithm: &SecKeyAlgorithm,
            ciphertext: &CFData,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { SecKeyCreateDecryptedData(key, algorithm, ciphertext, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::key_exchange_result`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyCopyKeyExchangeResult(
    private_key: &SecKey,
    algorithm: &SecKeyAlgorithm,
    public_key: &SecKey,
    parameters: &CFDictionary,
    error: *mut *mut CFError,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn SecKeyCopyKeyExchangeResult(
            private_key: &SecKey,
            algorithm: &SecKeyAlgorithm,
            public_key: &SecKey,
            parameters: &CFDictionary,
            error: *mut *mut CFError,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe {
        SecKeyCopyKeyExchangeResult(private_key, algorithm, public_key, parameters, error)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecKey::is_algorithm_supported`"]
#[inline]
pub unsafe extern "C-unwind" fn SecKeyIsAlgorithmSupported(
    key: &SecKey,
    operation: SecKeyOperationType,
    algorithm: &SecKeyAlgorithm,
) -> bool {
    extern "C-unwind" {
        fn SecKeyIsAlgorithmSupported(
            key: &SecKey,
            operation: SecKeyOperationType,
            algorithm: &SecKeyAlgorithm,
        ) -> Boolean;
    }
    let ret = unsafe { SecKeyIsAlgorithmSupported(key, operation, algorithm) };
    ret != 0
}
