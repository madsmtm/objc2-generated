//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/security/secaccessownertype?language=objc)
pub type SecAccessOwnerType = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/security/ksecuseonlyuid?language=objc)
pub const kSecUseOnlyUID: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksecuseonlygid?language=objc)
pub const kSecUseOnlyGID: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksechonorroot?language=objc)
pub const kSecHonorRoot: c_uint = 256;
/// [Apple's documentation](https://developer.apple.com/documentation/security/ksecmatchbits?language=objc)
pub const kSecMatchBits: c_uint = 3;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationany?language=objc)
    pub static kSecACLAuthorizationAny: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationlogin?language=objc)
    pub static kSecACLAuthorizationLogin: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationgenkey?language=objc)
    pub static kSecACLAuthorizationGenKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationdelete?language=objc)
    pub static kSecACLAuthorizationDelete: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationexportwrapped?language=objc)
    pub static kSecACLAuthorizationExportWrapped: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationexportclear?language=objc)
    pub static kSecACLAuthorizationExportClear: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationimportwrapped?language=objc)
    pub static kSecACLAuthorizationImportWrapped: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationimportclear?language=objc)
    pub static kSecACLAuthorizationImportClear: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationsign?language=objc)
    pub static kSecACLAuthorizationSign: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationencrypt?language=objc)
    pub static kSecACLAuthorizationEncrypt: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationdecrypt?language=objc)
    pub static kSecACLAuthorizationDecrypt: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationmac?language=objc)
    pub static kSecACLAuthorizationMAC: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationderive?language=objc)
    pub static kSecACLAuthorizationDerive: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationkeychaincreate?language=objc)
    pub static kSecACLAuthorizationKeychainCreate: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationkeychaindelete?language=objc)
    pub static kSecACLAuthorizationKeychainDelete: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationkeychainitemread?language=objc)
    pub static kSecACLAuthorizationKeychainItemRead: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationkeychainiteminsert?language=objc)
    pub static kSecACLAuthorizationKeychainItemInsert: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationkeychainitemmodify?language=objc)
    pub static kSecACLAuthorizationKeychainItemModify: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationkeychainitemdelete?language=objc)
    pub static kSecACLAuthorizationKeychainItemDelete: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationchangeacl?language=objc)
    pub static kSecACLAuthorizationChangeACL: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationchangeowner?language=objc)
    pub static kSecACLAuthorizationChangeOwner: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationpartitionid?language=objc)
    pub static kSecACLAuthorizationPartitionID: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/security/ksecaclauthorizationintegrity?language=objc)
    pub static kSecACLAuthorizationIntegrity: &'static CFString;
}

#[cfg(feature = "SecBase")]
unsafe impl ConcreteType for SecAccess {
    /// Returns the type identifier of SecAccess instances.
    ///
    /// Returns: The CFTypeID of SecAccess instances.
    #[doc(alias = "SecAccessGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecAccessGetTypeID() -> CFTypeID;
        }
        unsafe { SecAccessGetTypeID() }
    }
}

#[cfg(feature = "SecBase")]
impl SecAccess {
    /// Creates a new SecAccessRef that is set to the currently designated system default
    /// configuration of a (newly created) security object. Note that the precise nature of
    /// this default may change between releases.
    ///
    /// Parameter `descriptor`: The name of the item as it should appear in security dialogs
    ///
    /// Parameter `trustedlist`: A CFArray of TrustedApplicationRefs, specifying which applications
    /// should be allowed to access an item without triggering confirmation dialogs.
    /// If NULL, defaults to (just) the application creating the item. To set no applications,
    /// pass a CFArray with no elements.
    ///
    /// Parameter `accessRef`: On return, a pointer to the new access reference.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// - `trustedlist` generic must be of the correct type.
    /// - `access_ref` must be a valid pointer.
    #[doc(alias = "SecAccessCreate")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "SecKeychain is deprecated"]
    #[inline]
    pub unsafe fn create(
        descriptor: &CFString,
        trustedlist: Option<&CFArray>,
        access_ref: NonNull<*mut SecAccess>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecAccessCreate(
                descriptor: &CFString,
                trustedlist: Option<&CFArray>,
                access_ref: NonNull<*mut SecAccess>,
            ) -> OSStatus;
        }
        unsafe { SecAccessCreate(descriptor, trustedlist, access_ref) }
    }

    /// Creates a new SecAccessRef using the owner and access control list you provide.
    ///
    /// Parameter `owner`: A pointer to a CSSM access control list owner.
    ///
    /// Parameter `aclCount`: An unsigned 32-bit integer representing the number of items in the access control list.
    ///
    /// Parameter `acls`: A pointer to the access control list.
    ///
    /// Parameter `accessRef`: On return, a pointer to the new access reference.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// For 10.7 and later please use the SecAccessCreateWithOwnerAndACL API
    ///
    /// # Safety
    ///
    /// - `owner` must be a valid pointer.
    /// - `acls` must be a valid pointer.
    /// - `access_ref` must be a valid pointer.
    #[doc(alias = "SecAccessCreateFromOwnerAndACL")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "CSSM is not supported"]
    #[inline]
    pub unsafe fn create_from_owner_and_acl(
        owner: NonNull<CSSM_ACL_OWNER_PROTOTYPE>,
        acl_count: uint32,
        acls: NonNull<CSSM_ACL_ENTRY_INFO>,
        access_ref: NonNull<*mut SecAccess>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecAccessCreateFromOwnerAndACL(
                owner: NonNull<CSSM_ACL_OWNER_PROTOTYPE>,
                acl_count: uint32,
                acls: NonNull<CSSM_ACL_ENTRY_INFO>,
                access_ref: NonNull<*mut SecAccess>,
            ) -> OSStatus;
        }
        unsafe { SecAccessCreateFromOwnerAndACL(owner, acl_count, acls, access_ref) }
    }

    /// Creates a new SecAccessRef using either for a user or a group with a list of ACLs
    ///
    /// Parameter `userId`: An user id that specifies the user to associate with this SecAccessRef.
    ///
    /// Parameter `groupId`: A group id that specifies the group to associate with this SecAccessRef.
    ///
    /// Parameter `ownerType`: Specifies the how the ownership of the new SecAccessRef is defined.
    ///
    /// Parameter `acls`: A CFArrayRef of the ACLs to associate with this SecAccessRef
    ///
    /// Parameter `error`: Optionally a pointer to a CFErrorRef to return any errors with may have occured
    ///
    /// Returns: A pointer to the new access reference.
    ///
    /// # Safety
    ///
    /// - `acls` generic must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "SecAccessCreateWithOwnerAndACL")]
    #[cfg(all(feature = "SecBase", feature = "libc"))]
    #[deprecated = "SecKeychain is deprecated"]
    #[inline]
    pub unsafe fn with_owner_and_acl(
        user_id: libc::uid_t,
        group_id: libc::gid_t,
        owner_type: SecAccessOwnerType,
        acls: Option<&CFArray>,
        error: *mut *mut CFError,
    ) -> Option<CFRetained<SecAccess>> {
        extern "C-unwind" {
            fn SecAccessCreateWithOwnerAndACL(
                user_id: libc::uid_t,
                group_id: libc::gid_t,
                owner_type: SecAccessOwnerType,
                acls: Option<&CFArray>,
                error: *mut *mut CFError,
            ) -> Option<NonNull<SecAccess>>;
        }
        let ret =
            unsafe { SecAccessCreateWithOwnerAndACL(user_id, group_id, owner_type, acls, error) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the owner and the access control list of a given access.
    ///
    /// Parameter `accessRef`: A reference to the access from which to retrieve the information.
    ///
    /// Parameter `owner`: On return, a pointer to the access control list owner.
    ///
    /// Parameter `aclCount`: On return, a pointer to an unsigned 32-bit integer representing the number of items in the access control list.
    ///
    /// Parameter `acls`: On return, a pointer to the access control list.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// For 10.7 and later please use the SecAccessCopyOwnerAndACL API
    ///
    /// # Safety
    ///
    /// - `owner` must be a valid pointer.
    /// - `acl_count` must be a valid pointer.
    /// - `acls` must be a valid pointer.
    #[doc(alias = "SecAccessGetOwnerAndACL")]
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "CSSM is not supported"]
    #[inline]
    pub unsafe fn get_owner_and_acl(
        &self,
        owner: NonNull<CSSM_ACL_OWNER_PROTOTYPE_PTR>,
        acl_count: NonNull<uint32>,
        acls: NonNull<CSSM_ACL_ENTRY_INFO_PTR>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecAccessGetOwnerAndACL(
                access_ref: &SecAccess,
                owner: NonNull<CSSM_ACL_OWNER_PROTOTYPE_PTR>,
                acl_count: NonNull<uint32>,
                acls: NonNull<CSSM_ACL_ENTRY_INFO_PTR>,
            ) -> OSStatus;
        }
        unsafe { SecAccessGetOwnerAndACL(self, owner, acl_count, acls) }
    }

    /// Retrieves the owner and the access control list of a given access.
    ///
    /// Parameter `accessRef`: A reference to the access from which to retrieve the information.
    ///
    /// Parameter `userId`: On return, the user id of the owner
    ///
    /// Parameter `groupId`: On return, the group id of the owner
    ///
    /// Parameter `ownerType`: On return, the type of owner for this AccessRef
    ///
    /// Parameter `aclList`: On return, a pointer to a new created CFArray of SecACL instances.  The caller is responsible for calling CFRelease on this array.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// - `user_id` must be a valid pointer or null.
    /// - `group_id` must be a valid pointer or null.
    /// - `owner_type` must be a valid pointer or null.
    /// - `acl_list` must be a valid pointer or null.
    #[doc(alias = "SecAccessCopyOwnerAndACL")]
    #[cfg(all(feature = "SecBase", feature = "libc"))]
    #[deprecated = "SecKeychain is deprecated"]
    #[inline]
    pub unsafe fn copy_owner_and_acl(
        &self,
        user_id: *mut libc::uid_t,
        group_id: *mut libc::gid_t,
        owner_type: *mut SecAccessOwnerType,
        acl_list: *mut *const CFArray,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecAccessCopyOwnerAndACL(
                access_ref: &SecAccess,
                user_id: *mut libc::uid_t,
                group_id: *mut libc::gid_t,
                owner_type: *mut SecAccessOwnerType,
                acl_list: *mut *const CFArray,
            ) -> OSStatus;
        }
        unsafe { SecAccessCopyOwnerAndACL(self, user_id, group_id, owner_type, acl_list) }
    }

    /// Copies all the access control lists of a given access.
    ///
    /// Parameter `accessRef`: A reference to the access from which to retrieve the information.
    ///
    /// Parameter `aclList`: On return, a pointer to a new created CFArray of SecACL instances.  The caller is responsible for calling CFRelease on this array.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// # Safety
    ///
    /// `acl_list` must be a valid pointer.
    #[doc(alias = "SecAccessCopyACLList")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "SecKeychain is deprecated"]
    #[inline]
    pub unsafe fn copy_acl_list(&self, acl_list: NonNull<*const CFArray>) -> OSStatus {
        extern "C-unwind" {
            fn SecAccessCopyACLList(
                access_ref: &SecAccess,
                acl_list: NonNull<*const CFArray>,
            ) -> OSStatus;
        }
        unsafe { SecAccessCopyACLList(self, acl_list) }
    }

    /// Copies selected access control lists from a given access.
    ///
    /// Parameter `accessRef`: A reference to the access from which to retrieve the information.
    ///
    /// Parameter `action`: An authorization tag specifying what action with which to select the action control lists.
    ///
    /// Parameter `aclList`: On return, a pointer to the selected access control lists.
    ///
    /// Returns: A result code.  See "Security Error Codes" (SecBase.h).
    ///
    /// For 10.7 and later please use the SecAccessCopyMatchingACLList API
    ///
    /// # Safety
    ///
    /// `acl_list` must be a valid pointer.
    #[doc(alias = "SecAccessCopySelectedACLList")]
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "CSSM is not supported"]
    #[inline]
    pub unsafe fn copy_selected_acl_list(
        &self,
        action: CSSM_ACL_AUTHORIZATION_TAG,
        acl_list: NonNull<*const CFArray>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecAccessCopySelectedACLList(
                access_ref: &SecAccess,
                action: CSSM_ACL_AUTHORIZATION_TAG,
                acl_list: NonNull<*const CFArray>,
            ) -> OSStatus;
        }
        unsafe { SecAccessCopySelectedACLList(self, action, acl_list) }
    }

    /// Copies selected access control lists from a given access.
    ///
    /// Parameter `accessRef`: A reference to the access from which to retrieve the information.
    ///
    /// Parameter `authorizationTag`: An authorization tag specifying what action with which to select the action control lists.
    ///
    /// Returns: A pointer to the selected access control lists.
    ///
    /// # Safety
    ///
    /// `authorization_tag` should be of the correct type.
    #[doc(alias = "SecAccessCopyMatchingACLList")]
    #[cfg(feature = "SecBase")]
    #[deprecated = "SecKeychain is deprecated"]
    #[inline]
    pub unsafe fn matching_acl_list(
        &self,
        authorization_tag: &CFType,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn SecAccessCopyMatchingACLList(
                access_ref: &SecAccess,
                authorization_tag: &CFType,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { SecAccessCopyMatchingACLList(self, authorization_tag) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecAccess::create`"]
    pub fn SecAccessCreate(
        descriptor: &CFString,
        trustedlist: Option<&CFArray>,
        access_ref: NonNull<*mut SecAccess>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "renamed to `SecAccess::create_from_owner_and_acl`"]
    pub fn SecAccessCreateFromOwnerAndACL(
        owner: NonNull<CSSM_ACL_OWNER_PROTOTYPE>,
        acl_count: uint32,
        acls: NonNull<CSSM_ACL_ENTRY_INFO>,
        access_ref: NonNull<*mut SecAccess>,
    ) -> OSStatus;
}

#[cfg(all(feature = "SecBase", feature = "libc"))]
#[deprecated = "renamed to `SecAccess::with_owner_and_acl`"]
#[inline]
pub unsafe extern "C-unwind" fn SecAccessCreateWithOwnerAndACL(
    user_id: libc::uid_t,
    group_id: libc::gid_t,
    owner_type: SecAccessOwnerType,
    acls: Option<&CFArray>,
    error: *mut *mut CFError,
) -> Option<CFRetained<SecAccess>> {
    extern "C-unwind" {
        fn SecAccessCreateWithOwnerAndACL(
            user_id: libc::uid_t,
            group_id: libc::gid_t,
            owner_type: SecAccessOwnerType,
            acls: Option<&CFArray>,
            error: *mut *mut CFError,
        ) -> Option<NonNull<SecAccess>>;
    }
    let ret = unsafe { SecAccessCreateWithOwnerAndACL(user_id, group_id, owner_type, acls, error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(
        feature = "SecAsn1Types",
        feature = "SecBase",
        feature = "cssmconfig",
        feature = "cssmtype"
    ))]
    #[deprecated = "renamed to `SecAccess::get_owner_and_acl`"]
    pub fn SecAccessGetOwnerAndACL(
        access_ref: &SecAccess,
        owner: NonNull<CSSM_ACL_OWNER_PROTOTYPE_PTR>,
        acl_count: NonNull<uint32>,
        acls: NonNull<CSSM_ACL_ENTRY_INFO_PTR>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "libc"))]
    #[deprecated = "renamed to `SecAccess::copy_owner_and_acl`"]
    pub fn SecAccessCopyOwnerAndACL(
        access_ref: &SecAccess,
        user_id: *mut libc::uid_t,
        group_id: *mut libc::gid_t,
        owner_type: *mut SecAccessOwnerType,
        acl_list: *mut *const CFArray,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "SecBase")]
    #[deprecated = "renamed to `SecAccess::copy_acl_list`"]
    pub fn SecAccessCopyACLList(
        access_ref: &SecAccess,
        acl_list: NonNull<*const CFArray>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "SecBase", feature = "cssmconfig", feature = "cssmtype"))]
    #[deprecated = "renamed to `SecAccess::copy_selected_acl_list`"]
    pub fn SecAccessCopySelectedACLList(
        access_ref: &SecAccess,
        action: CSSM_ACL_AUTHORIZATION_TAG,
        acl_list: NonNull<*const CFArray>,
    ) -> OSStatus;
}

#[cfg(feature = "SecBase")]
#[deprecated = "renamed to `SecAccess::matching_acl_list`"]
#[inline]
pub unsafe extern "C-unwind" fn SecAccessCopyMatchingACLList(
    access_ref: &SecAccess,
    authorization_tag: &CFType,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn SecAccessCopyMatchingACLList(
            access_ref: &SecAccess,
            authorization_tag: &CFType,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { SecAccessCopyMatchingACLList(access_ref, authorization_tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
