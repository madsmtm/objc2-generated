//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "CSCommon")]
unsafe impl ConcreteType for SecRequirement {
    /// Returns the type identifier of all SecRequirement instances.
    #[doc(alias = "SecRequirementGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SecRequirementGetTypeID() -> CFTypeID;
        }
        unsafe { SecRequirementGetTypeID() }
    }
}

#[cfg(feature = "CSCommon")]
impl SecRequirement {
    /// Create a SecRequirement object from binary form.
    /// This is the effective inverse of SecRequirementCopyData.
    ///
    ///
    /// Parameter `data`: A binary blob obtained earlier from a valid SecRequirement object
    /// using the SecRequirementCopyData call. This is the only publicly supported
    /// way to get such a data blob.
    ///
    /// Parameter `flags`: Optional flags. Pass kSecCSDefaultFlags for standard behavior.
    ///
    /// Parameter `requirement`: On successful return, contains a reference to a SecRequirement
    /// object that behaves identically to the one the data blob was obtained from.
    ///
    /// Returns: Upon success, errSecSuccess. Upon error, an OSStatus value documented in
    /// CSCommon.h or certain other Security framework headers.
    ///
    /// # Safety
    ///
    /// `requirement` must be a valid pointer.
    #[doc(alias = "SecRequirementCreateWithData")]
    #[cfg(feature = "CSCommon")]
    #[inline]
    pub unsafe fn create_with_data(
        data: &CFData,
        flags: SecCSFlags,
        requirement: NonNull<*mut SecRequirement>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecRequirementCreateWithData(
                data: &CFData,
                flags: SecCSFlags,
                requirement: NonNull<*mut SecRequirement>,
            ) -> OSStatus;
        }
        unsafe { SecRequirementCreateWithData(data, flags, requirement) }
    }

    /// Create a SecRequirement object by compiling a valid text representation
    /// of a requirement.
    ///
    ///
    /// Parameter `text`: A CFString containing the text form of a (single) Code Requirement.
    ///
    /// Parameter `flags`: Optional flags. Pass kSecCSDefaultFlags for standard behavior.
    ///
    /// Parameter `requirement`: On successful return, contains a reference to a SecRequirement
    /// object that implements the conditions described in text.
    ///
    /// Returns: Upon success, errSecSuccess. Upon error, an OSStatus value documented in
    /// CSCommon.h or certain other Security framework headers.
    ///
    /// # Safety
    ///
    /// `requirement` must be a valid pointer.
    #[doc(alias = "SecRequirementCreateWithString")]
    #[cfg(feature = "CSCommon")]
    #[inline]
    pub unsafe fn create_with_string(
        text: &CFString,
        flags: SecCSFlags,
        requirement: NonNull<*mut SecRequirement>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecRequirementCreateWithString(
                text: &CFString,
                flags: SecCSFlags,
                requirement: NonNull<*mut SecRequirement>,
            ) -> OSStatus;
        }
        unsafe { SecRequirementCreateWithString(text, flags, requirement) }
    }

    /// # Safety
    ///
    /// - `errors` must be a valid pointer or null.
    /// - `requirement` must be a valid pointer.
    #[doc(alias = "SecRequirementCreateWithStringAndErrors")]
    #[cfg(feature = "CSCommon")]
    #[inline]
    pub unsafe fn create_with_string_and_errors(
        text: &CFString,
        flags: SecCSFlags,
        errors: *mut *mut CFError,
        requirement: NonNull<*mut SecRequirement>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecRequirementCreateWithStringAndErrors(
                text: &CFString,
                flags: SecCSFlags,
                errors: *mut *mut CFError,
                requirement: NonNull<*mut SecRequirement>,
            ) -> OSStatus;
        }
        unsafe { SecRequirementCreateWithStringAndErrors(text, flags, errors, requirement) }
    }

    /// Extracts a stable, persistent binary form of a SecRequirement.
    /// This is the effective inverse of SecRequirementCreateWithData.
    ///
    ///
    /// Parameter `requirement`: A valid SecRequirement object.
    ///
    /// Parameter `flags`: Optional flags. Pass kSecCSDefaultFlags for standard behavior.
    ///
    /// Parameter `data`: On successful return, contains a reference to a CFData object
    /// containing a binary blob that can be fed to SecRequirementCreateWithData
    /// to recreate a SecRequirement object with identical behavior.
    ///
    /// Returns: Upon success, errSecSuccess. Upon error, an OSStatus value documented in
    /// CSCommon.h or certain other Security framework headers.
    ///
    /// # Safety
    ///
    /// `data` must be a valid pointer.
    #[doc(alias = "SecRequirementCopyData")]
    #[cfg(feature = "CSCommon")]
    #[inline]
    pub unsafe fn copy_data(&self, flags: SecCSFlags, data: NonNull<*const CFData>) -> OSStatus {
        extern "C-unwind" {
            fn SecRequirementCopyData(
                requirement: &SecRequirement,
                flags: SecCSFlags,
                data: NonNull<*const CFData>,
            ) -> OSStatus;
        }
        unsafe { SecRequirementCopyData(self, flags, data) }
    }

    /// Converts a SecRequirement object into text form.
    /// This is the effective inverse of SecRequirementCreateWithString.
    ///
    /// Repeated application of this function may produce text that differs in
    /// formatting, may contain different source comments, and may perform its
    /// validation functions in different order. However, it is guaranteed that
    /// recompiling the text using SecRequirementCreateWithString will produce a
    /// SecRequirement object that behaves identically to the one you start with.
    ///
    ///
    /// Parameter `requirement`: A valid SecRequirement object.
    ///
    /// Parameter `flags`: Optional flags. Pass kSecCSDefaultFlags for standard behavior.
    ///
    /// Parameter `text`: On successful return, contains a reference to a CFString object
    /// containing a text representation of the requirement.
    ///
    /// Returns: Upon success, errSecSuccess. Upon error, an OSStatus value documented in
    /// CSCommon.h or certain other Security framework headers.
    ///
    /// # Safety
    ///
    /// `text` must be a valid pointer.
    #[doc(alias = "SecRequirementCopyString")]
    #[cfg(feature = "CSCommon")]
    #[inline]
    pub unsafe fn copy_string(
        &self,
        flags: SecCSFlags,
        text: NonNull<*const CFString>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn SecRequirementCopyString(
                requirement: &SecRequirement,
                flags: SecCSFlags,
                text: NonNull<*const CFString>,
            ) -> OSStatus;
        }
        unsafe { SecRequirementCopyString(self, flags, text) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "CSCommon")]
    #[deprecated = "renamed to `SecRequirement::create_with_data`"]
    pub fn SecRequirementCreateWithData(
        data: &CFData,
        flags: SecCSFlags,
        requirement: NonNull<*mut SecRequirement>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CSCommon")]
    #[deprecated = "renamed to `SecRequirement::create_with_string`"]
    pub fn SecRequirementCreateWithString(
        text: &CFString,
        flags: SecCSFlags,
        requirement: NonNull<*mut SecRequirement>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CSCommon")]
    #[deprecated = "renamed to `SecRequirement::create_with_string_and_errors`"]
    pub fn SecRequirementCreateWithStringAndErrors(
        text: &CFString,
        flags: SecCSFlags,
        errors: *mut *mut CFError,
        requirement: NonNull<*mut SecRequirement>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CSCommon")]
    #[deprecated = "renamed to `SecRequirement::copy_data`"]
    pub fn SecRequirementCopyData(
        requirement: &SecRequirement,
        flags: SecCSFlags,
        data: NonNull<*const CFData>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CSCommon")]
    #[deprecated = "renamed to `SecRequirement::copy_string`"]
    pub fn SecRequirementCopyString(
        requirement: &SecRequirement,
        flags: SecCSFlags,
        text: NonNull<*const CFString>,
    ) -> OSStatus;
}
