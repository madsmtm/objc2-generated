//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

extern_class!(
    /// The HKAttachmentStore class provides an interface for accessing and storing HKAttachment objects.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/healthkit/hkattachmentstore?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct HKAttachmentStore;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for HKAttachmentStore {}
);

impl HKAttachmentStore {
    extern_methods!(
        #[cfg(feature = "HKHealthStore")]
        /// The designated initializer to create an HKAttachmentStore.
        ///
        /// Parameter `healthStore`: Specifies the HKHealthStore object to use.
        #[unsafe(method(initWithHealthStore:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithHealthStore(
            this: Allocated<Self>,
            health_store: &HKHealthStore,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "HKAttachment",
            feature = "HKObject",
            feature = "block2",
            feature = "objc2-uniform-type-identifiers"
        ))]
        /// Creates a new HKAttachment using the passed in NSURL and attaches it to the specified HKObject.
        ///
        /// Parameter `object`: The object for which to add the HKAttachment.
        ///
        /// Parameter `name`: The name of the attachment.
        ///
        /// Parameter `contentType`: The content type of the attachment.
        ///
        /// Parameter `URL`: The NSURL to use to create the attachment.
        ///
        /// Parameter `metadata`: Extra information describing the attachment.
        ///
        /// Parameter `completion`: Called with an HKAttachment instance once the file was successfully saved and attached,
        /// otherwise called with an error.
        ///
        /// # Safety
        ///
        /// `metadata` generic should be of the correct type.
        #[unsafe(method(addAttachmentToObject:name:contentType:URL:metadata:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttachmentToObject_name_contentType_URL_metadata_completion(
            &self,
            object: &HKObject,
            name: &NSString,
            content_type: &UTType,
            url: &NSURL,
            metadata: Option<&NSDictionary<NSString, AnyObject>>,
            completion: &block2::DynBlock<dyn Fn(*mut HKAttachment, *mut NSError)>,
        );

        #[cfg(all(feature = "HKAttachment", feature = "HKObject", feature = "block2"))]
        /// Removes the given HKAttachment from the specified HKObject.
        ///
        /// Parameter `attachment`: The HKAttachment to be removed.
        ///
        /// Parameter `object`: The object from which to remove the attachment.
        ///
        /// Parameter `completion`: Called once the remove operation finishes.
        #[unsafe(method(removeAttachment:fromObject:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAttachment_fromObject_completion(
            &self,
            attachment: &HKAttachment,
            object: &HKObject,
            completion: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>,
        );

        #[cfg(all(feature = "HKAttachment", feature = "HKObject", feature = "block2"))]
        /// Retrieves a list of attachments for a given object.
        ///
        /// Parameter `object`: The object for which to retrieve attachments.
        ///
        /// Parameter `completion`: Called with a list of attachments or an error.
        #[unsafe(method(getAttachmentsForObject:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAttachmentsForObject_completion(
            &self,
            object: &HKObject,
            completion: &block2::DynBlock<dyn Fn(*mut NSArray<HKAttachment>, *mut NSError)>,
        );

        #[cfg(all(feature = "HKAttachment", feature = "block2"))]
        /// Retrieves the NSData for the given HKAttachment.
        ///
        /// Prefer
        /// `streamDataForAttachment:completion:`for large files that support incremental reading to limit your app's peak memory usage.
        /// The attachment's data may not always be available locally, and could be stored in iCloud.
        ///
        /// Parameter `attachment`: The attachment object to read data from.
        ///
        /// Parameter `completion`: Called with an NSData or an error.
        ///
        /// Returns: An NSProgress object to use for tracking the progress of downloading the attachment's data from iCloud.
        #[unsafe(method(getDataForAttachment:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDataForAttachment_completion(
            &self,
            attachment: &HKAttachment,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "HKAttachment", feature = "block2"))]
        /// Streams the given HKAttachment's data as ordered NSData chunks.
        ///
        /// The dataHandler's done parameter is set to YES when all chunks have been streamed.
        /// The attachment's data may not always be available locally, and could be stored in iCloud.
        ///
        /// Parameter `attachment`: The attachment object to read data from.
        ///
        /// Parameter `dataHandler`: Called with an NSData chunk or an error. When done is YES, the operation has completed.
        ///
        /// Returns: An NSProgress object to use for tracking the progress of downloading the attachment's data from iCloud.
        #[unsafe(method(streamDataForAttachment:dataHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn streamDataForAttachment_dataHandler(
            &self,
            attachment: &HKAttachment,
            data_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError, Bool)>,
        ) -> Retained<NSProgress>;
    );
}

/// Methods declared on superclass `NSObject`.
impl HKAttachmentStore {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
