//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Options for specifying the statistic to calculate.
///
/// ## Overview
///
/// You cannot combine a discrete option with a cumulative option. You can, however, combine multiple discrete options together to perform multiple calculations. You can also combine the [`HKStatisticsOptionSeparateBySource`](https://developer.apple.com/documentation/healthkit/hkstatisticsoptions/separatebysource) option with any of the other options.
///
/// ## Swift
///
/// ```swift
/// let cumulativeActiveEnergyBurned = HKQuantityType(.activeEnergyBurned)
///  
/// let discreteHeartRate = HKQuantityType(.heartRate)
///  
/// // Cannot combine cumulative options with discrete options.
/// // However, you can combine a cumulative option and separated by source
/// let cumulativeQuery = HKStatisticsQuery(quantityType:cumulativeActiveEnergyBurned,
///                                         quantitySamplePredicate:nil,
///                                         options: [.cumulativeSum, .separateBySource]) {
///                                             query, statistics, error in
///                                             
///                                             // ... process the results here
/// }
///  
/// // You can also combine any number of discrete options
/// // and the separated by source option.
/// let discreteQuery = HKStatisticsQuery(quantityType: discreteHeartRate,
///                                       quantitySamplePredicate: nil,
///                                       options: [.discreteAverage, .discreteMin, .discreteMax, .separateBySource]) {
///                                             query, statistics, error in
///                                             
///                                             // ... process the results here
/// }
/// ```
///
/// ## Objective-C
///
/// ```objc
/// HKQuantityType *cumulativeActiveEnergyBurned =
/// [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierActiveEnergyBurned];
///  
/// HKQuantityType *discreteHeartRate =
/// [HKObjectType quantityTypeForIdentifier:HKQuantityTypeIdentifierHeartRate];
///  
/// // Cannot combine cumulative options with discrete options.
/// // However, you can combine a cumulative option and seperated by source
/// HKStatisticsQuery *cumulativeQuery =
/// [[HKStatisticsQuery alloc]
///  initWithQuantityType:cumulativeActiveEnergyBurned
///  quantitySamplePredicate:nil
///  options:HKStatisticsOptionCumulativeSum | HKStatisticsOptionSeparateBySource
///  completionHandler:^(HKStatisticsQuery *query, HKStatistics *result, NSError *error) {
///  
///       // ... process the results here
///  }];
///  
/// // You can also combine any number of discrete options
/// // and the seperated by source option.
/// HKStatisticsQuery *discreteQuery =
/// [[HKStatisticsQuery alloc]
///  initWithQuantityType:discreteHeartRate
///  quantitySamplePredicate:nil
///  options:HKStatisticsOptionDiscreteAverage | HKStatisticsOptionDiscreteMin |
///  HKStatisticsOptionDiscreteMax | HKStatisticsOptionSeparateBySource
///  completionHandler:^(HKStatisticsQuery *query, HKStatistics *result, NSError *error) {
///  
///      // ... process the results here
///  }];
/// ```
///
///
/// Options for specifying which statistics to calculate
///
/// When querying for HKStatistics objects, an options bitmask will specify which statistics will be
/// calculated.
///
/// Statistics are classified as discrete or cumulative.  If a discrete statistics option is specified for a
/// cumulative HKQuantityType, an exception will be thrown.  If a cumulative statistics options is specified
/// for a discrete HKQuantityType, an exception will also be thrown.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct HKStatisticsOptions(pub NSUInteger);
bitflags::bitflags! {
    impl HKStatisticsOptions: NSUInteger {
/// An option indicating that the system will not calculate any statistics values.
        #[doc(alias = "HKStatisticsOptionNone")]
        const None = 0;
/// An option indicating that the system calculates the specified statistics separately for each source.
        #[doc(alias = "HKStatisticsOptionSeparateBySource")]
        const SeparateBySource = 1<<0;
/// An option indicating that the system calculates the average quantity for the samples.
        #[doc(alias = "HKStatisticsOptionDiscreteAverage")]
        const DiscreteAverage = 1<<1;
/// An option indicating that the system calculates the minimum quantity for the samples.
        #[doc(alias = "HKStatisticsOptionDiscreteMin")]
        const DiscreteMin = 1<<2;
/// An option indicating that the system calculates the maximum quantity for the samples.
        #[doc(alias = "HKStatisticsOptionDiscreteMax")]
        const DiscreteMax = 1<<3;
/// An option indicating that the system calculates the sum of all the quantities for the samples.
        #[doc(alias = "HKStatisticsOptionCumulativeSum")]
        const CumulativeSum = 1<<4;
/// An option indicating that the system returns the most recent quantity from the matching samples.
        #[doc(alias = "HKStatisticsOptionMostRecent")]
        const MostRecent = 1<<5;
/// An option indicating that the system returns the most recent quantity from the matching samples.
        #[doc(alias = "HKStatisticsOptionDiscreteMostRecent")]
#[deprecated]
        const DiscreteMostRecent = HKStatisticsOptions::MostRecent.0;
/// An option indicating that the system calculates the total duration covering all the samples.
        #[doc(alias = "HKStatisticsOptionDuration")]
        const Duration = 1<<6;
    }
}

unsafe impl Encode for HKStatisticsOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for HKStatisticsOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that represents the result of calculating the minimum, maximum, average, or sum over a set of samples from the HealthKit store.
    ///
    /// ## Overview
    ///
    /// HealthKit creates statistic objects using either a statistics query or a statistics collection query. For the statistics query, it performs the specified calculations over all the samples that match the query. For the statistics collection query, it partitions the matching samples into a set of time intervals and performs the calculations over each interval separately.
    ///
    /// By default, these queries automatically merge the data from all of your data sources before performing the calculations. If you want to merge the data yourself, you can set the [`HKStatisticsOptionSeparateBySource`](https://developer.apple.com/documentation/healthkit/hkstatisticsoptions/separatebysource) option. You can then request the statistical data for each source separately.
    ///
    /// When requesting data from a statistics object, your request must match the options you used when creating the query. For example, if you create a query using the [`HKStatisticsOptionDiscreteAverage`](https://developer.apple.com/documentation/healthkit/hkstatisticsoptions/discreteaverage) option, you must access the results using the [`averageQuantity`](https://developer.apple.com/documentation/healthkit/hkstatistics/averagequantity()) method.
    ///
    /// For more information on calculating statistical data, see [`HKStatisticsQuery`](https://developer.apple.com/documentation/healthkit/hkstatisticsquery) Class Reference. To calculate the statistics over a series of time intervals, see the [`HKStatisticsCollectionQuery`](https://developer.apple.com/documentation/healthkit/hkstatisticscollectionquery) Class Reference.
    ///
    ///
    /// Represents statistics for quantity samples over a period of time.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct HKStatistics;
);

unsafe impl Send for HKStatistics {}

unsafe impl Sync for HKStatistics {}

extern_conformance!(
    unsafe impl NSCoding for HKStatistics {}
);

extern_conformance!(
    unsafe impl NSCopying for HKStatistics {}
);

unsafe impl CopyingHelper for HKStatistics {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for HKStatistics {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for HKStatistics {}
);

impl HKStatistics {
    extern_methods!(
        #[cfg(feature = "HKObjectType")]
        #[unsafe(method(quantityType))]
        #[unsafe(method_family = none)]
        pub unsafe fn quantityType(&self) -> Retained<HKQuantityType>;

        #[unsafe(method(startDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn startDate(&self) -> Retained<NSDate>;

        #[unsafe(method(endDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn endDate(&self) -> Retained<NSDate>;

        #[cfg(feature = "HKSource")]
        #[unsafe(method(sources))]
        #[unsafe(method_family = none)]
        pub unsafe fn sources(&self) -> Option<Retained<NSArray<HKSource>>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "HKQuantity", feature = "HKSource"))]
        /// Returns the average quantity for the given source in the time period represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(averageQuantityForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn averageQuantityForSource(
            &self,
            source: &HKSource,
        ) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKQuantity")]
        /// Returns the average quantity in the time period represented by the receiver.
        #[unsafe(method(averageQuantity))]
        #[unsafe(method_family = none)]
        pub unsafe fn averageQuantity(&self) -> Option<Retained<HKQuantity>>;

        #[cfg(all(feature = "HKQuantity", feature = "HKSource"))]
        /// Returns the minimum quantity for the given source in the time period represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(minimumQuantityForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumQuantityForSource(
            &self,
            source: &HKSource,
        ) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKQuantity")]
        /// Returns the minimum quantity in the time period represented by the receiver.
        #[unsafe(method(minimumQuantity))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumQuantity(&self) -> Option<Retained<HKQuantity>>;

        #[cfg(all(feature = "HKQuantity", feature = "HKSource"))]
        /// Returns the maximum quantity for the given source in the time period represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(maximumQuantityForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumQuantityForSource(
            &self,
            source: &HKSource,
        ) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKQuantity")]
        /// Returns the maximum quantity in the time period represented by the receiver.
        #[unsafe(method(maximumQuantity))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumQuantity(&self) -> Option<Retained<HKQuantity>>;

        #[cfg(all(feature = "HKQuantity", feature = "HKSource"))]
        /// Returns the most recent quantity for the given source in the time period represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(mostRecentQuantityForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mostRecentQuantityForSource(
            &self,
            source: &HKSource,
        ) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKQuantity")]
        /// Returns the most recent quantity in the time period represented by the receiver.
        #[unsafe(method(mostRecentQuantity))]
        #[unsafe(method_family = none)]
        pub unsafe fn mostRecentQuantity(&self) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKSource")]
        /// Returns the date interval of the most recent quantity for the given source in the time period
        /// represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(mostRecentQuantityDateIntervalForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mostRecentQuantityDateIntervalForSource(
            &self,
            source: &HKSource,
        ) -> Option<Retained<NSDateInterval>>;

        /// Returns the date interval of the most recent quantity in the time period represented by the receiver.
        #[unsafe(method(mostRecentQuantityDateInterval))]
        #[unsafe(method_family = none)]
        pub unsafe fn mostRecentQuantityDateInterval(&self) -> Option<Retained<NSDateInterval>>;

        #[cfg(all(feature = "HKQuantity", feature = "HKSource"))]
        /// Returns the sum quantity for the given source in the time period represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(sumQuantityForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sumQuantityForSource(
            &self,
            source: &HKSource,
        ) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKQuantity")]
        /// Returns the sum of quantities in the time period represented by the receiver.
        #[unsafe(method(sumQuantity))]
        #[unsafe(method_family = none)]
        pub unsafe fn sumQuantity(&self) -> Option<Retained<HKQuantity>>;

        #[cfg(feature = "HKQuantity")]
        /// Total duration (in seconds) covered by the samples represented by these statistics.
        /// Only present if HKStatisticsOptionDuration is is specified.
        ///
        ///
        ///
        /// Total duration, as a time-unit compatible quantity, covered by the samples represented by these statistics.
        ///
        /// Only present if HKStatisticsOptionDuration is is specified.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> Option<Retained<HKQuantity>>;

        #[cfg(all(feature = "HKQuantity", feature = "HKSource"))]
        /// Returns the duration, as a time-unit compatible quantity, for the given source in the time period represented by the receiver.
        ///
        /// If HKStatisticsOptionSeparateBySource is not specified, then this will always be nil.
        #[unsafe(method(durationForSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn durationForSource(&self, source: &HKSource) -> Option<Retained<HKQuantity>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl HKStatistics {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
