//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants indicating the status of a command.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MPRemoteCommandHandlerStatus(pub NSInteger);
impl MPRemoteCommandHandlerStatus {
    /// The requested command executed successfully.
    /// There was no error executing the requested command.
    #[doc(alias = "MPRemoteCommandHandlerStatusSuccess")]
    pub const Success: Self = Self(0);
    /// The requested command couldn’t execute because its required content isn’t available.
    /// The command could not be executed because the requested content does not
    /// exist in the current application state.
    #[doc(alias = "MPRemoteCommandHandlerStatusNoSuchContent")]
    pub const NoSuchContent: Self = Self(100);
    /// The requested command couldn’t execute because no Now Playing item is available.
    /// The command could not be executed because there is no now playing item
    /// available that is required for this command. As an example, an
    /// application would return this error code if an "enable language option"
    /// command is received, but nothing is currently playing.
    #[doc(alias = "MPRemoteCommandHandlerStatusNoActionableNowPlayingItem")]
    pub const NoActionableNowPlayingItem: Self = Self(110);
    /// The requested command couldn’t execute because a required device isn’t available.
    ///
    /// ## Discussion
    ///
    /// Commands that require a device to perform their action should return this status when the device is unavailable. For example, you’d return this status if your command requires headphones, but none are available.
    ///
    ///
    /// The command could not be executed because a device required
    /// is not available. For instance, if headphones are required, or if a watch
    /// app realizes that it needs the companion to fulfull a request.
    #[doc(alias = "MPRemoteCommandHandlerStatusDeviceNotFound")]
    pub const DeviceNotFound: Self = Self(120);
    /// The requested command failed to execute.
    /// The command could not be executed for another reason.
    #[doc(alias = "MPRemoteCommandHandlerStatusCommandFailed")]
    pub const CommandFailed: Self = Self(200);
}

unsafe impl Encode for MPRemoteCommandHandlerStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MPRemoteCommandHandlerStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that responds to remote command events.
    ///
    /// ## Overview
    ///
    /// The Media Player framework defines a standard set of remote command objects for handling media-related events. When an accessory or iOS user interface generates a remote control event, the system notifies the corresponding command object on the shared [`MPRemoteCommandCenter`](https://developer.apple.com/documentation/mediaplayer/mpremotecommandcenter) instance. That command object executes any attached handlers.
    ///
    /// To respond to a particular event, register a handler with the appropriate [`MPRemoteCommand`](https://developer.apple.com/documentation/mediaplayer/mpremotecommand) object.
    ///
    /// Listing 1. Registering a remote control event handler
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Get the shared command center.", "let commandCenter = MPRemoteCommandCenter.shared()", "", "// Add a handler for the play command.", "commandCenter.playCommand.addTarget { [unowned self] event in", "    if self.player.rate == 0.0 {", "        self.player.play()", "        return .success", "    }", "    return .commandFailed", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Get the shared command center.", "MPRemoteCommandCenter *commandCenter = [MPRemoteCommandCenter sharedCommandCenter];", "", "// Add a handler for the play command.", "[commandCenter.playCommand addTargetWithHandler:^MPRemoteCommandHandlerStatus(MPRemoteCommandEvent * _Nonnull event) {", "    if (self.player.rate == 0.0) {", "        [self.player play];", "        return MPRemoteCommandHandlerStatusSuccess;", "    }", "    return MPRemoteCommandHandlerStatusCommandFailed;", "}];"], metadata: None }] }] })
    /// If you explicitly don’t want to enable a given command, fetch the command object and set its enabled property to [`false`](https://developer.apple.com/documentation/swift/false). Disabling a remote command lets the system know that it shouldn’t display any related UI for that command when your app is the Now Playing app.
    ///
    /// The framework defines many subclasses to handle specific kinds of commands. Sometimes, these subclasses let you specify other information related to the command. For example, feedback commands let you specify a localized string that describes the meaning of the feedback. When supporting a particular command, be sure to look up the specific class used to handle those events.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPRemoteCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPRemoteCommand {}
);

impl MPRemoteCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Whether a button (for example) should be enabled and tappable for this
        /// particular command.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(addTarget:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTarget_action(&self, target: &AnyObject, action: Sel);

        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(removeTarget:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTarget_action(&self, target: &AnyObject, action: Option<Sel>);

        /// # Safety
        ///
        /// `target` should be of the correct type.
        #[unsafe(method(removeTarget:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTarget(&self, target: Option<&AnyObject>);

        #[cfg(all(feature = "MPRemoteCommandEvent", feature = "block2"))]
        /// Returns an opaque object to act as the target.
        #[unsafe(method(addTargetWithHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTargetWithHandler(
            &self,
            handler: &block2::DynBlock<
                dyn Fn(NonNull<MPRemoteCommandEvent>) -> MPRemoteCommandHandlerStatus,
            >,
        ) -> Retained<AnyObject>;
    );
}

extern_class!(
    /// An object that defines the skip intervals for the player.
    ///
    /// ## Overview
    ///
    /// You use a skip interval to move the playback of a media item, forward or backward, the indicated number of seconds. For example, a forward skip interval of 30 seconds at 2 minutes and 30 seconds into a song would immediately jump to 3 minutes into the song and continue playing. The skipped content isn’t played.
    ///
    ///
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSkipIntervalCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSkipIntervalCommand {}
);

impl MPSkipIntervalCommand {
    extern_methods!(
        /// An array of NSNumbers (NSTimeIntervals) that contain preferred skip intervals.
        #[unsafe(method(preferredIntervals))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredIntervals(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`preferredIntervals`][Self::preferredIntervals].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPreferredIntervals:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredIntervals(&self, preferred_intervals: &NSArray<NSNumber>);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPSkipIntervalCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that reflects the feedback state for the playing item.
    ///
    /// ## Overview
    ///
    /// The shared [`MPRemoteCommandCenter`](https://developer.apple.com/documentation/mediaplayer/mpremotecommandcenter) object vends feedback objects for liking, disliking, and bookmarking media items. Use these objects to register handlers for the types of feedback your app supports and to perform the appropriate tasks when that feedback changes. When the currently playing item changes, you can also use this object to set the feedback state for the new item.
    ///
    /// When the state of a feedback item changes, the system delivers an appropriate event to registered handlers of this object. Your handler code must determine which media item receives the feedback and then apply the update the feedback state for that item. You might also perform other tasks related to receiving feedback. For example, if the user likes the currently playing song, you might update the appropriate UI in your app or use the information to recommend similar songs.
    ///
    ///
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPFeedbackCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPFeedbackCommand {}
);

impl MPFeedbackCommand {
    extern_methods!(
        /// Whether the feedback command is in an "active" state. An example of when a
        /// feedback command would be active is if the user already "liked" a particular
        /// content item.
        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isActive(&self) -> bool;

        /// Setter for [`isActive`][Self::isActive].
        #[unsafe(method(setActive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setActive(&self, active: bool);

        /// A localized string briefly describing the context of the command.
        #[unsafe(method(localizedTitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedTitle(&self) -> Retained<NSString>;

        /// Setter for [`localizedTitle`][Self::localizedTitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedTitle(&self, localized_title: &NSString);

        /// An optional shorter version of the localized title for this feedback
        /// command. MediaPlayer uses this property to display this command's title on
        /// remote control interfaces with little screen space.
        #[unsafe(method(localizedShortTitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedShortTitle(&self) -> Retained<NSString>;

        /// Setter for [`localizedShortTitle`][Self::localizedShortTitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedShortTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedShortTitle(&self, localized_short_title: &NSString);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPFeedbackCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that provides a detailed rating for the playing item.
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPRatingCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPRatingCommand {}
);

impl MPRatingCommand {
    extern_methods!(
        /// Minimum rating for the command.
        #[unsafe(method(minimumRating))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumRating(&self) -> c_float;

        /// Setter for [`minimumRating`][Self::minimumRating].
        #[unsafe(method(setMinimumRating:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumRating(&self, minimum_rating: c_float);

        /// Maximum rating for the command.
        #[unsafe(method(maximumRating))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumRating(&self) -> c_float;

        /// Setter for [`maximumRating`][Self::maximumRating].
        #[unsafe(method(setMaximumRating:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumRating(&self, maximum_rating: c_float);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPRatingCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that responds to requests to change the playback rate of the playing item.
    ///
    /// ## Overview
    ///
    /// Apps can change the current playback rate of a media item to one of the supported rates defined by the [`supportedPlaybackRates`](https://developer.apple.com/documentation/mediaplayer/mpchangeplaybackratecommand/supportedplaybackrates) property.
    ///
    ///
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangePlaybackRateCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangePlaybackRateCommand {}
);

impl MPChangePlaybackRateCommand {
    extern_methods!(
        /// An array of NSNumbers (floats) that contain supported playback rates that
        /// the command can send.
        #[unsafe(method(supportedPlaybackRates))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedPlaybackRates(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`supportedPlaybackRates`][Self::supportedPlaybackRates].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSupportedPlaybackRates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportedPlaybackRates(
            &self,
            supported_playback_rates: &NSArray<NSNumber>,
        );
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangePlaybackRateCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that responds to requests to change the current playback position of the playing item.
    /// Command for changing the current playback position in a now playing item.
    /// Sends out MPChangePlaybackPositionCommandEvents.
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangePlaybackPositionCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangePlaybackPositionCommand {}
);

impl MPChangePlaybackPositionCommand {
    extern_methods!();
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangePlaybackPositionCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that responds to requests to change the current shuffle mode used during playback.
    /// Command for changing the current shuffle mode to use during playback. To
    /// update the system's current representation of your app's shuffle mode, set
    /// the currentShuffleType property on this command to the proper shuffle type
    /// value.
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangeShuffleModeCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangeShuffleModeCommand {}
);

impl MPChangeShuffleModeCommand {
    extern_methods!(
        #[cfg(feature = "MPRemoteControlTypes")]
        /// The app's current shuffle type.
        #[unsafe(method(currentShuffleType))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentShuffleType(&self) -> MPShuffleType;

        #[cfg(feature = "MPRemoteControlTypes")]
        /// Setter for [`currentShuffleType`][Self::currentShuffleType].
        #[unsafe(method(setCurrentShuffleType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCurrentShuffleType(&self, current_shuffle_type: MPShuffleType);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangeShuffleModeCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that responds to requests to change the current repeat mode used during playback.
    /// Command for changing the current repeat mode to use during playback. To
    /// update the system's current representation of your app's repeat mode, set
    /// the currentRepeatType property on this command to the proper repeat type
    /// value.
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangeRepeatModeCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangeRepeatModeCommand {}
);

impl MPChangeRepeatModeCommand {
    extern_methods!(
        #[cfg(feature = "MPRemoteControlTypes")]
        /// The app's current repeat mode.
        #[unsafe(method(currentRepeatType))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentRepeatType(&self) -> MPRepeatType;

        #[cfg(feature = "MPRemoteControlTypes")]
        /// Setter for [`currentRepeatType`][Self::currentRepeatType].
        #[unsafe(method(setCurrentRepeatType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCurrentRepeatType(&self, current_repeat_type: MPRepeatType);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangeRepeatModeCommand {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}
