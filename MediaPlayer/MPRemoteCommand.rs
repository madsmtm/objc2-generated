//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpremotecommandhandlerstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MPRemoteCommandHandlerStatus(pub NSInteger);
impl MPRemoteCommandHandlerStatus {
    /// There was no error executing the requested command.
    #[doc(alias = "MPRemoteCommandHandlerStatusSuccess")]
    pub const Success: Self = Self(0);
    /// The command could not be executed because the requested content does not
    /// exist in the current application state.
    #[doc(alias = "MPRemoteCommandHandlerStatusNoSuchContent")]
    pub const NoSuchContent: Self = Self(100);
    /// The command could not be executed because there is no now playing item
    /// available that is required for this command. As an example, an
    /// application would return this error code if an "enable language option"
    /// command is received, but nothing is currently playing.
    #[doc(alias = "MPRemoteCommandHandlerStatusNoActionableNowPlayingItem")]
    pub const NoActionableNowPlayingItem: Self = Self(110);
    /// The command could not be executed because a device required
    /// is not available. For instance, if headphones are required, or if a watch
    /// app realizes that it needs the companion to fulfull a request.
    #[doc(alias = "MPRemoteCommandHandlerStatusDeviceNotFound")]
    pub const DeviceNotFound: Self = Self(120);
    /// The command could not be executed for another reason.
    #[doc(alias = "MPRemoteCommandHandlerStatusCommandFailed")]
    pub const CommandFailed: Self = Self(200);
}

unsafe impl Encode for MPRemoteCommandHandlerStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MPRemoteCommandHandlerStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpremotecommand?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPRemoteCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPRemoteCommand {}
);

impl MPRemoteCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

        /// Whether a button (for example) should be enabled and tappable for this
        /// particular command.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(addTarget:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTarget_action(&self, target: &AnyObject, action: Sel);

        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(removeTarget:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTarget_action(&self, target: &AnyObject, action: Option<Sel>);

        /// # Safety
        ///
        /// `target` should be of the correct type.
        #[unsafe(method(removeTarget:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTarget(&self, target: Option<&AnyObject>);

        #[cfg(all(feature = "MPRemoteCommandEvent", feature = "block2"))]
        /// Returns an opaque object to act as the target.
        #[unsafe(method(addTargetWithHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTargetWithHandler(
            &self,
            handler: &block2::DynBlock<
                dyn Fn(NonNull<MPRemoteCommandEvent>) -> MPRemoteCommandHandlerStatus,
            >,
        ) -> Retained<AnyObject>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpskipintervalcommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSkipIntervalCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSkipIntervalCommand {}
);

impl MPSkipIntervalCommand {
    extern_methods!(
        /// An array of NSNumbers (NSTimeIntervals) that contain preferred skip intervals.
        #[unsafe(method(preferredIntervals))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredIntervals(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`preferredIntervals`][Self::preferredIntervals].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPreferredIntervals:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredIntervals(&self, preferred_intervals: &NSArray<NSNumber>);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPSkipIntervalCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpfeedbackcommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPFeedbackCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPFeedbackCommand {}
);

impl MPFeedbackCommand {
    extern_methods!(
        /// Whether the feedback command is in an "active" state. An example of when a
        /// feedback command would be active is if the user already "liked" a particular
        /// content item.
        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isActive(&self) -> bool;

        /// Setter for [`isActive`][Self::isActive].
        #[unsafe(method(setActive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setActive(&self, active: bool);

        /// A localized string briefly describing the context of the command.
        #[unsafe(method(localizedTitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedTitle(&self) -> Retained<NSString>;

        /// Setter for [`localizedTitle`][Self::localizedTitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedTitle(&self, localized_title: &NSString);

        /// An optional shorter version of the localized title for this feedback
        /// command. MediaPlayer uses this property to display this command's title on
        /// remote control interfaces with little screen space.
        #[unsafe(method(localizedShortTitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedShortTitle(&self) -> Retained<NSString>;

        /// Setter for [`localizedShortTitle`][Self::localizedShortTitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedShortTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedShortTitle(&self, localized_short_title: &NSString);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPFeedbackCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpratingcommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPRatingCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPRatingCommand {}
);

impl MPRatingCommand {
    extern_methods!(
        /// Minimum rating for the command.
        #[unsafe(method(minimumRating))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumRating(&self) -> c_float;

        /// Setter for [`minimumRating`][Self::minimumRating].
        #[unsafe(method(setMinimumRating:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumRating(&self, minimum_rating: c_float);

        /// Maximum rating for the command.
        #[unsafe(method(maximumRating))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumRating(&self) -> c_float;

        /// Setter for [`maximumRating`][Self::maximumRating].
        #[unsafe(method(setMaximumRating:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumRating(&self, maximum_rating: c_float);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPRatingCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpchangeplaybackratecommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangePlaybackRateCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangePlaybackRateCommand {}
);

impl MPChangePlaybackRateCommand {
    extern_methods!(
        /// An array of NSNumbers (floats) that contain supported playback rates that
        /// the command can send.
        #[unsafe(method(supportedPlaybackRates))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedPlaybackRates(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`supportedPlaybackRates`][Self::supportedPlaybackRates].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSupportedPlaybackRates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportedPlaybackRates(
            &self,
            supported_playback_rates: &NSArray<NSNumber>,
        );
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangePlaybackRateCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}

extern_class!(
    /// Command for changing the current playback position in a now playing item.
    /// Sends out MPChangePlaybackPositionCommandEvents.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpchangeplaybackpositioncommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangePlaybackPositionCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangePlaybackPositionCommand {}
);

impl MPChangePlaybackPositionCommand {
    extern_methods!();
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangePlaybackPositionCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}

extern_class!(
    /// Command for changing the current shuffle mode to use during playback. To
    /// update the system's current representation of your app's shuffle mode, set
    /// the currentShuffleType property on this command to the proper shuffle type
    /// value.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpchangeshufflemodecommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangeShuffleModeCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangeShuffleModeCommand {}
);

impl MPChangeShuffleModeCommand {
    extern_methods!(
        #[cfg(feature = "MPRemoteControlTypes")]
        /// The app's current shuffle type.
        #[unsafe(method(currentShuffleType))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentShuffleType(&self) -> MPShuffleType;

        #[cfg(feature = "MPRemoteControlTypes")]
        /// Setter for [`currentShuffleType`][Self::currentShuffleType].
        #[unsafe(method(setCurrentShuffleType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCurrentShuffleType(&self, current_shuffle_type: MPShuffleType);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangeShuffleModeCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}

extern_class!(
    /// Command for changing the current repeat mode to use during playback. To
    /// update the system's current representation of your app's repeat mode, set
    /// the currentRepeatType property on this command to the proper repeat type
    /// value.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaplayer/mpchangerepeatmodecommand?language=objc)
    #[unsafe(super(MPRemoteCommand, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPChangeRepeatModeCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPChangeRepeatModeCommand {}
);

impl MPChangeRepeatModeCommand {
    extern_methods!(
        #[cfg(feature = "MPRemoteControlTypes")]
        /// The app's current repeat mode.
        #[unsafe(method(currentRepeatType))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentRepeatType(&self) -> MPRepeatType;

        #[cfg(feature = "MPRemoteControlTypes")]
        /// Setter for [`currentRepeatType`][Self::currentRepeatType].
        #[unsafe(method(setCurrentRepeatType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCurrentRepeatType(&self, current_repeat_type: MPRepeatType);
    );
}

/// Methods declared on superclass `MPRemoteCommand`.
impl MPChangeRepeatModeCommand {
    extern_methods!(
        // +new (unavailable)

        // -init (unavailable)

    );
}
