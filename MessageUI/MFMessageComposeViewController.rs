//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-messages")]
#[cfg(not(target_os = "visionos"))]
use objc2_messages::*;
#[cfg(feature = "objc2-ui-kit")]
use objc2_ui_kit::*;

use crate::*;

/// These constants describe the result of the message-composition interface.
/// Composition result sent to the delegate upon user completion.
///
/// This result will inform the client of the user's message composition action.  If the
/// user cancels the composition,
/// <tt>
/// MessageComposeResultCancelled
/// </tt>
/// will be sent to the delegate.
/// Typically
/// <tt>
/// MessageComposeResultSent
/// </tt>
/// will be sent, but
/// <tt>
/// MessageComposeResultFailed
/// </tt>
/// will
/// be sent in the case of failure.
/// </p>
/// Send may only be interpreted as a successful queueing of
/// the message for later sending. The actual send will occur when the device is able to send.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MessageComposeResult(pub NSInteger);
impl MessageComposeResult {
    /// The user canceled the composition.
    #[doc(alias = "MessageComposeResultCancelled")]
    pub const Cancelled: Self = Self(0);
    /// The user successfully queued or sent the message.
    #[doc(alias = "MessageComposeResultSent")]
    pub const Sent: Self = Self(1);
    /// The user’s attempt to save or send the message was unsuccessful.
    #[doc(alias = "MessageComposeResultFailed")]
    pub const Failed: Self = Self(2);
}

unsafe impl Encode for MessageComposeResult {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MessageComposeResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The URL for the item that is attached to the message.
    pub static MFMessageComposeViewControllerAttachmentURL: &'static NSString;
}

extern "C" {
    /// The key for the alternate filename for the file-based item attached to the message.
    ///
    /// ## Discussion
    ///
    /// Use this constant with the [`attachments`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/attachments) property to retrieve the optional, more descriptive name for a message attachment.
    ///
    ///
    pub static MFMessageComposeViewControllerAttachmentAlternateFilename: &'static NSString;
}

extern "C" {
    /// Posted when the value returned by the [`canSendText()`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendtext()) class method has changed.
    ///
    /// ## Discussion
    ///
    /// Upon receiving this notification, query its `userInfo` dictionary with the [`MFMessageComposeViewControllerTextMessageAvailabilityKey`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontrollertextmessageavailabilitykey) key. If the availability of text message sending has changed, your app should invalidate caches and update its user interface as appropriate.
    ///
    ///
    /// Notification posted when the value of
    /// <tt>
    /// +[MFMessageComposeViewController canSendText]
    /// </tt>
    /// has changed.
    ///
    /// This notification is posted when the value of
    /// <tt>
    /// +[MFMessageComposeViewController canSendText]
    /// </tt>
    /// has changed. Clients should invalidate any caches and update UI as appropriate.
    pub static MFMessageComposeViewControllerTextMessageAvailabilityDidChangeNotification:
        &'static NSString;
}

extern "C" {
    /// The value of this key is a number object that contains a Boolean value.
    ///
    /// ## Discussion
    ///
    /// This value matches the result of the [`canSendText`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendtext()) class method.The `userInfo` dictionary for the [`MFMessageComposeViewControllerTextMessageAvailabilityDidChange`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/mfmessagecomposeviewcontrollertextmessageavailabilitydidchange) notification includes this key. The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that contains a Boolean value. This value matches the result of the [`canSendText`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendtext()) class method.
    ///
    ///
    /// UserInfo key for MFMessageComposeViewControllerTextMessageAvailabilityDidChangeNotification
    /// containing the value of
    /// <tt>
    /// +[MFMessageComposeViewController canSendText]
    /// </tt>
    ///
    /// The value of this key is an NSNumber containing a BOOL value. This value matches
    /// the result of
    /// <tt>
    /// +[MFMessageComposeViewController canSendText]
    /// </tt>
    /// .
    pub static MFMessageComposeViewControllerTextMessageAvailabilityKey: &'static NSString;
}

extern_class!(
    /// A standard view controller whose interface lets the user compose and send SMS or MMS messages.
    ///
    /// ## Overview
    ///
    /// Use an [`MFMessageComposeViewController`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller) object to display the standard message composition interface inside your app. Before presenting the interface, populate the fields with the set of initial recipients and the message you want to send. After presenting the interface, a person can edit your initial values before sending the message.
    ///
    /// The composition interface doesn’t guarantee the delivery of your message; it only lets you construct the initial message and present it for a person’s approval. The person may opt to cancel the composition interface which discards the message and its contents. If the person opts to send the message, the Messages app takes on the responsibility of sending the message.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/07bae83d9a320eacd640c791b55b8cd9/media-4288093~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/e75d28ad3cf6ade12a7f581320e3a862/media-4288093%402x.png 2x" />
    ///     <img alt="a screenshot of the New Message screen, with a phone number in the To field and a short sentence in the composition text field." src="https://docs-assets.developer.apple.com/published/e75d28ad3cf6ade12a7f581320e3a862/media-4288093%402x.png" />
    /// </picture>
    ///
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  You must not modify the view hierarchy presented by this view controller. However, you can customize the appearance of the interface using the [`UIAppearance`](https://developer.apple.com/documentation/uikit/uiappearance) protocol.
    ///
    ///
    ///
    /// </div>
    /// An alternate way to compose SMS messages is to create and open a URL that uses the `sms` scheme. URLs of that type go directly to the Messages app, which uses your URL to configure the message. For information about the structure of `sms` URLs, see [Apple URL Scheme Reference](https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899).
    ///
    /// ### Checking the availability of the composition interface
    ///
    /// Before presenting the message compose view controller, always call the [`canSendText`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendtext()) method to see if the person configured the current device to send messages. If the user’s device isn’t set up to send or receive messages, you can notify the user or disable the messaging features in your application. You shouldn’t attempt to use this interface if the [`canSendText`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendtext()) method returns [`false`](https://developer.apple.com/documentation/swift/false). If messaging is available, you can also use the [`canSendAttachments`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendattachments()) and [`canSendSubject`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/cansendsubject()) methods to determine if those specific messaging features are available.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["if !MFMessageComposeViewController.canSendText() {", "    print(\"SMS services are not available\")", "}", ""], metadata: None }] }, TabItem { title: "Obj-C", content: [CodeListing { syntax: Some("objc"), code: ["if (![MFMessageComposeViewController canSendText]) {", "   NSLog(@\"Message services are not available.\");", "}"], metadata: None }] }] })
    /// ### Configuring and displaying the composition interface
    ///
    /// After verifying that message services are available, you can create and configure the message composition view controller and then present it like any other view controller. Use the methods of this class to specify the message’s recipients and the contents of the message. If attachments or a subject line are supported, you can set values for them as well. The sample code below shows how to configure the composition interface and present it modally. Always assign a delegate to the [`messageComposeDelegate`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller/messagecomposedelegate) property, because the delegate is responsible for dismissing the composition interface later. The delegate object must conform to the [`MFMessageComposeViewControllerDelegate`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontrollerdelegate) protocol.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let composeVC = MFMessageComposeViewController()", "composeVC.messageComposeDelegate = self", " ", "// Configure the fields of the interface.", "composeVC.recipients = [\"4085551212\"]", "composeVC.body = \"Hello from California!\"", " ", "// Present the view controller modally.", "self.present(composeVC, animated: true, completion: nil)", ""], metadata: None }] }, TabItem { title: "Obj-C", content: [CodeListing { syntax: Some("objc"), code: ["MFMessageComposeViewController* composeVC = [[MFMessageComposeViewController alloc] init];", "composeVC.messageComposeDelegate = self;", " ", "// Configure the fields of the interface.", "composeVC.recipients = @[@\"14085551212\"];", "composeVC.body = @\"Hello from California!\";", " ", "// Present the view controller modally.", "[self present:composeVC animated:YES completion:nil];", ""], metadata: None }] }] })
    /// The message compose view controller isn’t dismissed automatically. When the user taps the buttons to send the message or cancel the interface, the message compose view controller calls the [`messageComposeViewController:didFinishWithResult:`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontrollerdelegate/messagecomposeviewcontroller(_:didfinishwith:)) method of its delegate. Your implementation of that method must dismiss the view controller explicitly, as shown in the sample code below. You can also use this method to check the result of the operation.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func messageComposeViewController(controller: MFMessageComposeViewController,", "                                  didFinishWithResult result: MessageComposeResult) {", "    // Check the result or perform other tasks.", "    ", "    // Dismiss the message compose view controller.", "    controller.dismissViewControllerAnimated(true, completion: nil)}", ""], metadata: None }] }, TabItem { title: "Obj-C", content: [CodeListing { syntax: Some("objc"), code: ["- (void)messageComposeViewController:(MFMessageComposeViewController *)controller", "                 didFinishWithResult:(MessageComposeResult)result {", "   // Check the result or perform other tasks.    // Dismiss the message compose view controller.", "   [self dismissViewControllerAnimated:YES completion:nil];}", ""], metadata: None }] }] })
    /// For more information on how to present and dismiss view controllers, see [View Controller Programming Guide for iOS](https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457).
    ///
    /// ### Detecting changes to the availability of messaging
    ///
    /// Add an observer to the [`MFMessageComposeViewControllerTextMessageAvailabilityDidChange`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/mfmessagecomposeviewcontrollertextmessageavailabilitydidchange) notification to get notified of changes to the messaging capabilities of the current device. The system delivers that notification to your observer when the status of messaging changes.
    ///
    ///
    /// The MFMessageComposeViewController class provides an interface for editing and sending a message.
    ///
    /// The MFMessageComposeViewController class manages all user interaction.  The client needs to set
    /// the recipient or recipients.  The client may also set the body of the message. After setup, the
    /// client needs to only display the view.
    /// <p>
    /// The provided delegate will be informed of the user's composition completion and how they chose
    /// to complete the operation.
    /// </p>
    /// <p>
    /// Prior to use, clients should verify the user has set up the device for sending messages via
    /// <tt>
    /// +[MFMessageComposeViewController canSendText]
    /// </tt>
    /// .
    /// </p>
    #[unsafe(super(UINavigationController, UIViewController, UIResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2-ui-kit")]
    pub struct MFMessageComposeViewController;
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl NSCoding for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl UIAppearanceContainer for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl UIContentContainer for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl UIFocusEnvironment for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl UIResponderStandardEditActions for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
extern_conformance!(
    unsafe impl UITraitEnvironment for MFMessageComposeViewController {}
);

#[cfg(feature = "objc2-ui-kit")]
impl MFMessageComposeViewController {
    extern_methods!(
        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// if the user has set up the device for sending text only messages.
        ///
        /// If the return value is YES, the client can set the recipients and body of the message.
        /// If the return value is NO, the client may notify the user of the failure, or the
        /// client may open an SMS URL via
        /// <tt>
        /// -[UIApplication openURL:]
        /// </tt>
        /// .
        #[unsafe(method(canSendText))]
        #[unsafe(method_family = none)]
        pub unsafe fn canSendText(mtm: MainThreadMarker) -> bool;

        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// <tt>
        /// if the user has set up the device for including subjects in messages.
        /// </tt>
        /// .
        #[unsafe(method(canSendSubject))]
        #[unsafe(method_family = none)]
        pub unsafe fn canSendSubject(mtm: MainThreadMarker) -> bool;

        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// <tt>
        /// if the user has set up the device for including attachments in messages.
        /// </tt>
        /// .
        #[unsafe(method(canSendAttachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn canSendAttachments(mtm: MainThreadMarker) -> bool;

        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// if the attachment at the specified URL could be accepted by the current composition.
        ///
        /// If the return value is YES, the UTI is acceptable for attachment to a message, a return value of NO
        /// indicates that the given UTI is unsupported.
        #[unsafe(method(isSupportedAttachmentUTI:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSupportedAttachmentUTI(uti: &NSString, mtm: MainThreadMarker) -> bool;

        /// This property is the delegate for the MFMessageComposeViewController method callbacks.
        #[unsafe(method(messageComposeDelegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn messageComposeDelegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MFMessageComposeViewControllerDelegate>>>;

        /// Setter for [`messageComposeDelegate`][Self::messageComposeDelegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setMessageComposeDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMessageComposeDelegate(
            &self,
            message_compose_delegate: Option<
                &ProtocolObject<dyn MFMessageComposeViewControllerDelegate>,
            >,
        );

        /// Calling this method will disable the camera/attachment button in the view controller.  After the controller has been presented,
        /// this call will have no effect.  The camera / attachment button is visible by default.
        #[unsafe(method(disableUserAttachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn disableUserAttachments(&self);

        /// This property sets the initial value of the To field for the message to the specified addresses.
        ///
        /// This property will set the initial value of the To field for the message from an NSArray of
        /// NSString instances specifying the message addresses of recipients. This should be called prior
        /// to display.
        /// <p>
        /// After the view has been presented to the user, this property will no longer change the value.
        /// </p>
        #[unsafe(method(recipients))]
        #[unsafe(method_family = none)]
        pub unsafe fn recipients(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`recipients`][Self::recipients].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRecipients:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRecipients(&self, recipients: Option<&NSArray<NSString>>);

        /// This property sets the initial value of the body of the message to the specified content.
        ///
        /// This property will set the initial value of the body of the message.  This should be called prior
        /// to display.
        /// <p>
        /// After the view has been presented to the user, this property will no longer change the value.
        /// </p>
        #[unsafe(method(body))]
        #[unsafe(method_family = none)]
        pub unsafe fn body(&self) -> Option<Retained<NSString>>;

        /// Setter for [`body`][Self::body].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBody:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBody(&self, body: Option<&NSString>);

        /// This property sets the initial value of the subject of the message to the specified content.
        ///
        /// This property will set the initial value of the subject of the message.  This should be called prior
        /// to display.
        /// <p>
        /// After the view has been presented to the user, this property will no longer change the value.
        /// </p>
        #[unsafe(method(subject))]
        #[unsafe(method_family = none)]
        pub unsafe fn subject(&self) -> Option<Retained<NSString>>;

        /// Setter for [`subject`][Self::subject].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSubject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSubject(&self, subject: Option<&NSString>);

        /// This property returns an NSArray of NSDictionaries describing the properties of the current attachments.
        ///
        /// This property returns an NSArray of NSDictionaries describing the properties of the current attachments.
        /// See MFMessageComposeViewControllerAttachmentURL, MFMessageComposeViewControllerAttachmentAlternateFilename.
        #[unsafe(method(attachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachments(&self) -> Option<Retained<NSArray<NSDictionary>>>;

        #[cfg(feature = "objc2-messages")]
        #[cfg(not(target_os = "visionos"))]
        /// This property sets the initial interactive message.
        #[unsafe(method(message))]
        #[unsafe(method_family = none)]
        pub unsafe fn message(&self) -> Option<Retained<MSMessage>>;

        #[cfg(feature = "objc2-messages")]
        #[cfg(not(target_os = "visionos"))]
        /// Setter for [`message`][Self::message].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMessage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMessage(&self, message: Option<&MSMessage>);

        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// if the attachment at the specified URL was added to the composition successfully.
        ///
        /// If the return value is YES, the attachment was added to the composition. If the return value is NO,
        /// the attachment was not added to the composition.  All attachment URLs must be file urls.  The file
        /// URL must not be NIL.  The alternate filename will be display to the user in leiu of the attachments URL.
        /// The alternate filename may be NIL.
        #[unsafe(method(addAttachmentURL:withAlternateFilename:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttachmentURL_withAlternateFilename(
            &self,
            attachment_url: &NSURL,
            alternate_filename: Option<&NSString>,
        ) -> bool;

        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// if the attachment was added to the composition successfully.
        ///
        /// If the return value is YES, the attachment was added to the composition. If the return value is NO,
        /// the attachment was not added to the composition.  The data and typeIdentifer must be non-nil.  typeIdentifier should be a valid Uniform Type Identifier.
        #[unsafe(method(addAttachmentData:typeIdentifier:filename:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttachmentData_typeIdentifier_filename(
            &self,
            attachment_data: &NSData,
            uti: &NSString,
            filename: &NSString,
        ) -> bool;

        /// Parameter `itemProvider`: created from ShareSheet
        ///
        /// Returns
        /// <tt>
        /// YES
        /// </tt>
        /// if the item provider was added to the composition successfully.
        ///
        /// If the return value is YES, the itemProvider was added to the composition. If the return value is NO,
        /// the itemProvider was not added to the composition.  The itemProvider must be non-nil.
        #[unsafe(method(insertCollaborationItemProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertCollaborationItemProvider(
            &self,
            item_provider: &NSItemProvider,
        ) -> bool;
    );
}

/// Methods declared on superclass `UINavigationController`.
#[cfg(feature = "objc2-ui-kit")]
impl MFMessageComposeViewController {
    extern_methods!(
        /// # Safety
        ///
        /// - `navigation_bar_class` probably has further requirements.
        /// - `toolbar_class` probably has further requirements.
        #[unsafe(method(initWithNavigationBarClass:toolbarClass:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNavigationBarClass_toolbarClass(
            this: Allocated<Self>,
            navigation_bar_class: Option<&AnyClass>,
            toolbar_class: Option<&AnyClass>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithRootViewController:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRootViewController(
            this: Allocated<Self>,
            root_view_controller: &UIViewController,
        ) -> Retained<Self>;

        #[unsafe(method(initWithNibName:bundle:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNibName_bundle(
            this: Allocated<Self>,
            nib_name_or_nil: Option<&NSString>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2-ui-kit")]
impl MFMessageComposeViewController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_protocol!(
    /// An interface for responding to user interactions with a message compose view controller.
    ///
    /// ## Overview
    ///
    /// The [`MFMessageComposeViewControllerDelegate`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontrollerdelegate) protocol defines a single method that custom objects can implement to respond to updates from a message composition view (an instance of the  [`MFMessageComposeViewController`](https://developer.apple.com/documentation/messageui/mfmessagecomposeviewcontroller) class). Use the method of this protocol to respond to the end of the user composing an SMS message. The method includes information about whether the user chose to send or cancel the message, or whether the attempt to send it failed.
    ///
    ///
    /// Protocol for delegate callbacks to MFMessageComposeViewControllerDelegate instances.
    ///
    /// This protocol will be implemented by delegates of MFMessageComposeViewController instances.
    /// It will be called at various times while the user is composing, sending, or canceling
    /// message composition.
    pub unsafe trait MFMessageComposeViewControllerDelegate: NSObjectProtocol {
        #[cfg(feature = "objc2-ui-kit")]
        /// Delegate callback which is called upon user's completion of message composition.
        ///
        /// This delegate callback will be called when the user completes the message composition.
        /// How the user chose to complete this task will be given as one of the parameters to the
        /// callback.  Upon this call, the client should remove the view associated with the controller,
        /// typically by dismissing modally.
        ///
        /// Parameter `controller`: The MFMessageComposeViewController instance which is returning the result.
        ///
        /// Parameter `result`: MessageComposeResult indicating how the user chose to complete the composition process.
        #[unsafe(method(messageComposeViewController:didFinishWithResult:))]
        #[unsafe(method_family = none)]
        unsafe fn messageComposeViewController_didFinishWithResult(
            &self,
            controller: &MFMessageComposeViewController,
            result: MessageComposeResult,
        );
    }
);
