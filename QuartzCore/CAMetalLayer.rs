//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-metal")]
use objc2_metal::*;

use crate::*;

extern_protocol!(
    /// A Metal drawable associated with a Core Animation layer.
    ///
    /// ## Overview
    ///
    /// A [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer) instance owns any instance that implements this protocol. Don’t implement this protocol yourself. See the [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer) reference for information on how to request drawable objects.
    ///
    ///
    #[cfg(feature = "objc2-metal")]
    pub unsafe trait CAMetalDrawable: MTLDrawable {
        #[unsafe(method(texture))]
        #[unsafe(method_family = none)]
        fn texture(&self) -> Retained<ProtocolObject<dyn MTLTexture>>;

        #[cfg(feature = "CALayer")]
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        fn layer(&self) -> Retained<CAMetalLayer>;
    }
);

extern_class!(
    /// A Core Animation layer that Metal can render into, typically displayed onscreen.
    ///
    /// ## Overview
    ///
    /// Use a [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer) when you want to use Metal to render a layer’s contents; for example, to render into a view. Consider using [`MTKView`](https://developer.apple.com/documentation/metalkit/mtkview) instead, because this class automatically wraps a [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer) object and provides a higher-level abstraction.
    ///
    /// If you’re using UIKit, to create a view that uses a [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer), create a subclass of [UIView](https://developer.apple.com/library/archive/releasenotes/iPhone/RN-iPhoneSDK/index.html#//apple_ref/doc/uid/TP40007428-CH1-SW18) and override its [`layerClass`](https://developer.apple.com/documentation/uikit/uiview/layerclass) class method to return a [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer):
    ///
    /// ```objc
    /// + (Class) layerClass
    /// {
    ///     return [CAMetalLayer class];
    /// }
    /// ```
    ///
    /// If you’re using AppKit, configure an [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object to use a backing layer and assign a [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer) object to the view:
    ///
    /// ```objc
    /// myView.wantsLayer = YES;
    /// myView.layer = [CAMetalLayer layer];
    /// ```
    ///
    /// Adjust the layer’s properties to configure its underlying pixel format and other display behaviors.
    ///
    /// ### Rendering the Layer’s Contents
    ///
    /// A [`CAMetalLayer`](https://developer.apple.com/documentation/quartzcore/cametallayer) creates a pool of Metal drawable objects ([`CAMetalDrawable`](https://developer.apple.com/documentation/quartzcore/cametaldrawable)). At any given time, one of these drawable objects contains the contents of the layer. To change the layer’s contents, ask the layer for a drawable object, render into it, and then update the layer’s contents to point to the new drawable.
    ///
    /// Call the layer’s [`nextDrawable`](https://developer.apple.com/documentation/quartzcore/cametallayer/nextdrawable()) method to obtain a drawable object. Get the drawable object’s texture and create a render pass that renders to that texture, as shown in the code below:
    ///
    /// ```objc
    /// CAMetalLayer *metalLayer = (CAMetalLayer*)self.layer;
    /// id<CAMetalDrawable> *drawable = [metalLayer nextDrawable];
    ///
    /// MTLRenderPassDescriptor *renderPassDescriptor
    ///                                = [MTLRenderPassDescriptor renderPassDescriptor];
    ///
    /// renderPassDescriptor.colorAttachments[0].texture = drawable.texture;
    /// renderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;
    /// renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0,0.0,0.0,1.0);
    /// ...
    /// ```
    ///
    /// To change the layer’s contents to the new drawable, call the [`presentDrawable:`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/present(_:)) method (or one of its variants) on the command buffer containing the encoded render pass, passing in the drawable object to present.
    ///
    /// ```objc
    /// [commandBuffer presentDrawable:drawable];
    /// ```
    ///
    /// ### Keeping References to Drawables
    ///
    /// The layer reuses a drawable only if it isn’t onscreen and there are no strong references to it. Further, if a drawable isn’t available when you call [`nextDrawable`](https://developer.apple.com/documentation/quartzcore/cametallayer/nextdrawable()), the system waits for one to become available. To avoid stalls in your app, request a new drawable only when you need it, and release any references to it as quickly as possible after you’re done with it.
    ///
    /// For example, before retrieving a new drawable, you might perform other work on the CPU or submit commands to the GPU that don’t require the drawable. Then, obtain the drawable and encode a command buffer to render into it, as described above. After you commit this command buffer, release all strong references to the drawable. If you don’t release drawables correctly, the layer runs out of drawables, and future calls to [`nextDrawable`](https://developer.apple.com/documentation/quartzcore/cametallayer/nextdrawable()) return `nil`.
    ///
    /// ### Releasing the Drawable
    ///
    /// Don’t release the drawable explicitly; instead, embed your render loop within an autorelease pool block:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func draw(in view: MTKView) {", "    autoreleasepool {", "        render(view: view)", "    }", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (void)drawInMTKView:(MTKView *)view {", "    @autoreleasepool {", "        [self render:view];", "    }", "}"], metadata: None }] }] })
    /// This block releases drawables promptly and avoids possible deadlock situations with multiple drawables. Release drawables as soon as possible after committing your onscreen render pass.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  As of iOS 10 and tvOS 10, you can safely retain a drawable to query its properties, such as [`drawableID`](https://developer.apple.com/documentation/metal/mtldrawable/drawableid) and [`presentedTime`](https://developer.apple.com/documentation/metal/mtldrawable/presentedtime), after the system has presented it. If you don’t need to query these properties, release the drawable when you no longer need it.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(CALayer, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CALayer")]
    pub struct CAMetalLayer;
);

#[cfg(all(feature = "CALayer", feature = "CAMediaTiming"))]
extern_conformance!(
    unsafe impl CAMediaTiming for CAMetalLayer {}
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl NSCoding for CAMetalLayer {}
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl NSObjectProtocol for CAMetalLayer {}
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl NSSecureCoding for CAMetalLayer {}
);

#[cfg(feature = "CALayer")]
impl CAMetalLayer {
    extern_methods!(
        #[cfg(feature = "objc2-metal")]
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub fn device(&self) -> Option<Retained<ProtocolObject<dyn MTLDevice>>>;

        #[cfg(feature = "objc2-metal")]
        /// Setter for [`device`][Self::device].
        #[unsafe(method(setDevice:))]
        #[unsafe(method_family = none)]
        pub fn setDevice(&self, device: Option<&ProtocolObject<dyn MTLDevice>>);

        #[cfg(feature = "objc2-metal")]
        #[unsafe(method(preferredDevice))]
        #[unsafe(method_family = none)]
        pub fn preferredDevice(&self) -> Option<Retained<ProtocolObject<dyn MTLDevice>>>;

        #[cfg(feature = "objc2-metal")]
        #[unsafe(method(pixelFormat))]
        #[unsafe(method_family = none)]
        pub fn pixelFormat(&self) -> MTLPixelFormat;

        #[cfg(feature = "objc2-metal")]
        /// Setter for [`pixelFormat`][Self::pixelFormat].
        #[unsafe(method(setPixelFormat:))]
        #[unsafe(method_family = none)]
        pub fn setPixelFormat(&self, pixel_format: MTLPixelFormat);

        #[unsafe(method(framebufferOnly))]
        #[unsafe(method_family = none)]
        pub fn framebufferOnly(&self) -> bool;

        /// Setter for [`framebufferOnly`][Self::framebufferOnly].
        #[unsafe(method(setFramebufferOnly:))]
        #[unsafe(method_family = none)]
        pub fn setFramebufferOnly(&self, framebuffer_only: bool);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(drawableSize))]
        #[unsafe(method_family = none)]
        pub fn drawableSize(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`drawableSize`][Self::drawableSize].
        #[unsafe(method(setDrawableSize:))]
        #[unsafe(method_family = none)]
        pub fn setDrawableSize(&self, drawable_size: CGSize);

        #[cfg(feature = "objc2-metal")]
        #[unsafe(method(nextDrawable))]
        #[unsafe(method_family = none)]
        pub fn nextDrawable(&self) -> Option<Retained<ProtocolObject<dyn CAMetalDrawable>>>;

        #[unsafe(method(maximumDrawableCount))]
        #[unsafe(method_family = none)]
        pub fn maximumDrawableCount(&self) -> NSUInteger;

        /// Setter for [`maximumDrawableCount`][Self::maximumDrawableCount].
        #[unsafe(method(setMaximumDrawableCount:))]
        #[unsafe(method_family = none)]
        pub fn setMaximumDrawableCount(&self, maximum_drawable_count: NSUInteger);

        #[unsafe(method(presentsWithTransaction))]
        #[unsafe(method_family = none)]
        pub fn presentsWithTransaction(&self) -> bool;

        /// Setter for [`presentsWithTransaction`][Self::presentsWithTransaction].
        #[unsafe(method(setPresentsWithTransaction:))]
        #[unsafe(method_family = none)]
        pub fn setPresentsWithTransaction(&self, presents_with_transaction: bool);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(colorspace))]
        #[unsafe(method_family = none)]
        pub fn colorspace(&self) -> Option<Retained<CGColorSpace>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`colorspace`][Self::colorspace].
        #[unsafe(method(setColorspace:))]
        #[unsafe(method_family = none)]
        pub fn setColorspace(&self, colorspace: Option<&CGColorSpace>);

        #[unsafe(method(wantsExtendedDynamicRangeContent))]
        #[unsafe(method_family = none)]
        pub fn wantsExtendedDynamicRangeContent(&self) -> bool;

        /// Setter for [`wantsExtendedDynamicRangeContent`][Self::wantsExtendedDynamicRangeContent].
        #[unsafe(method(setWantsExtendedDynamicRangeContent:))]
        #[unsafe(method_family = none)]
        pub fn setWantsExtendedDynamicRangeContent(
            &self,
            wants_extended_dynamic_range_content: bool,
        );

        #[cfg(feature = "CAEDRMetadata")]
        #[unsafe(method(EDRMetadata))]
        #[unsafe(method_family = none)]
        pub fn EDRMetadata(&self) -> Option<Retained<CAEDRMetadata>>;

        #[cfg(feature = "CAEDRMetadata")]
        /// Setter for [`EDRMetadata`][Self::EDRMetadata].
        #[unsafe(method(setEDRMetadata:))]
        #[unsafe(method_family = none)]
        pub fn setEDRMetadata(&self, edr_metadata: Option<&CAEDRMetadata>);

        #[unsafe(method(displaySyncEnabled))]
        #[unsafe(method_family = none)]
        pub fn displaySyncEnabled(&self) -> bool;

        /// Setter for [`displaySyncEnabled`][Self::displaySyncEnabled].
        #[unsafe(method(setDisplaySyncEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setDisplaySyncEnabled(&self, display_sync_enabled: bool);

        #[unsafe(method(allowsNextDrawableTimeout))]
        #[unsafe(method_family = none)]
        pub fn allowsNextDrawableTimeout(&self) -> bool;

        /// Setter for [`allowsNextDrawableTimeout`][Self::allowsNextDrawableTimeout].
        #[unsafe(method(setAllowsNextDrawableTimeout:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsNextDrawableTimeout(&self, allows_next_drawable_timeout: bool);

        #[unsafe(method(developerHUDProperties))]
        #[unsafe(method_family = none)]
        pub fn developerHUDProperties(&self) -> Option<Retained<NSDictionary>>;

        /// Setter for [`developerHUDProperties`][Self::developerHUDProperties].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `developer_hud_properties` generic should be of the correct type.
        #[unsafe(method(setDeveloperHUDProperties:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDeveloperHUDProperties(
            &self,
            developer_hud_properties: Option<&NSDictionary>,
        );

        #[cfg(feature = "objc2-metal")]
        #[unsafe(method(residencySet))]
        #[unsafe(method_family = none)]
        pub fn residencySet(&self) -> Retained<ProtocolObject<dyn MTLResidencySet>>;
    );
}

/// Methods declared on superclass `CALayer`.
#[cfg(feature = "CALayer")]
impl CAMetalLayer {
    extern_methods!(
        /// Layer creation and initialization. *
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        pub fn layer() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `layer` should be of the correct type.
        #[unsafe(method(initWithLayer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithLayer(this: Allocated<Self>, layer: &AnyObject) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "CALayer")]
impl CAMetalLayer {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "CALayer")]
impl DefaultRetained for CAMetalLayer {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
