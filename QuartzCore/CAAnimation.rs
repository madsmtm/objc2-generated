//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

// NS_TYPED_ENUM
pub type CAAnimationCalculationMode = NSString;

// NS_TYPED_ENUM
pub type CAAnimationRotationMode = NSString;

// NS_TYPED_ENUM
pub type CATransitionType = NSString;

// NS_TYPED_ENUM
pub type CATransitionSubtype = NSString;

extern_class!(
    /// The abstract superclass for animations in Core Animation.
    ///
    /// ## Overview
    ///
    /// `CAAnimation` provides the basic support for the [`CAMediaTiming`](https://developer.apple.com/documentation/quartzcore/camediatiming) and [`CAAction`](https://developer.apple.com/documentation/quartzcore/caaction) protocols. You do not create instance of [`CAAnimation`](https://developer.apple.com/documentation/quartzcore/caanimation): to animate Core Animation layers or SceneKit objects, create instances of the concrete subclasses [`CABasicAnimation`](https://developer.apple.com/documentation/quartzcore/cabasicanimation), [`CAKeyframeAnimation`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation), [`CAAnimationGroup`](https://developer.apple.com/documentation/quartzcore/caanimationgroup), or [`CATransition`](https://developer.apple.com/documentation/quartzcore/catransition).
    ///
    /// ### Animating Core Animation Layers
    ///
    /// You can animate the contents of your iOS or macOS app’s user interface by attaching animations to [`CALayer`](https://developer.apple.com/documentation/quartzcore/calayer) objects. For more information, see [Core Animation Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514).
    ///
    /// ### Animating Scene Kit Content
    ///
    /// In Scene Kit, animation objects represent not only property-based animations, but also animations of geometry data created with external 3D authoring tools and loaded from a scene file. You use the properties of the [`CAAnimation`](https://developer.apple.com/documentation/quartzcore/caanimation) object representing a geometry animation to control its timing, monitor its progress, and attach actions for Scene Kit to trigger during the animation. You can attach animations to Scene Kit objects that adopt the [`SCNAnimatable`](https://developer.apple.com/documentation/scenekit/scnanimatable) protocol, including nodes, geometries, and materials.
    ///
    /// In a Scene Kit app, [`CAAnimation`](https://developer.apple.com/documentation/quartzcore/caanimation) objects support additional methods and properties, listed under Controlling SceneKit Animation Timing, Fading between SceneKit Animations, and Attaching SceneKit Animation Events.
    ///
    ///
    /// The base animation class. *
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CAAnimation;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CAAnimation {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CAAnimation {}
);

extern_conformance!(
    unsafe impl NSCoding for CAAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for CAAnimation {}
);

unsafe impl CopyingHelper for CAAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CAAnimation {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CAAnimation {}
);

impl CAAnimation {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;

        #[unsafe(method(defaultValueForKey:))]
        #[unsafe(method_family = none)]
        pub fn defaultValueForKey(key: &NSString) -> Option<Retained<AnyObject>>;

        #[unsafe(method(shouldArchiveValueForKey:))]
        #[unsafe(method_family = none)]
        pub fn shouldArchiveValueForKey(&self, key: &NSString) -> bool;

        #[cfg(feature = "CAMediaTimingFunction")]
        #[unsafe(method(timingFunction))]
        #[unsafe(method_family = none)]
        pub fn timingFunction(&self) -> Option<Retained<CAMediaTimingFunction>>;

        #[cfg(feature = "CAMediaTimingFunction")]
        /// Setter for [`timingFunction`][Self::timingFunction].
        #[unsafe(method(setTimingFunction:))]
        #[unsafe(method_family = none)]
        pub fn setTimingFunction(&self, timing_function: Option<&CAMediaTimingFunction>);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn CAAnimationDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn CAAnimationDelegate>>);

        #[unsafe(method(isRemovedOnCompletion))]
        #[unsafe(method_family = none)]
        pub fn isRemovedOnCompletion(&self) -> bool;

        /// Setter for [`isRemovedOnCompletion`][Self::isRemovedOnCompletion].
        #[unsafe(method(setRemovedOnCompletion:))]
        #[unsafe(method_family = none)]
        pub fn setRemovedOnCompletion(&self, removed_on_completion: bool);

        #[cfg(feature = "CAFrameRateRange")]
        #[unsafe(method(preferredFrameRateRange))]
        #[unsafe(method_family = none)]
        pub fn preferredFrameRateRange(&self) -> CAFrameRateRange;

        #[cfg(feature = "CAFrameRateRange")]
        /// Setter for [`preferredFrameRateRange`][Self::preferredFrameRateRange].
        #[unsafe(method(setPreferredFrameRateRange:))]
        #[unsafe(method_family = none)]
        pub fn setPreferredFrameRateRange(&self, preferred_frame_rate_range: CAFrameRateRange);
    );
}

/// Methods declared on superclass `NSObject`.
impl CAAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CAAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// Methods your app can implement to respond when animations start and stop.
    ///
    /// ## Overview
    ///
    /// You can use an animation delegate to execute additional logic when an animation starts or ends. For example, you may want to remove a layer from its parent once a fade out animation has completed.
    ///
    /// The following example shows code taken from a class that implements [`CAAnimationDelegate`](https://developer.apple.com/documentation/quartzcore/caanimationdelegate) and has had a layer, named `sublayer`, added to its layer. The `fadeOut` function animates the opacity of `sublayer` and, once the animation has completed, [`animationDidStop:finished:`](https://developer.apple.com/documentation/quartzcore/caanimationdelegate/animationdidstop(_:finished:)) removes it from its superlayer.
    ///
    /// ```swift
    /// func fadeOut() {
    ///     let fadeOutAnimation = CABasicAnimation()
    ///     fadeOutAnimation.keyPath = "opacity"
    ///     fadeOutAnimation.fromValue = 1
    ///     fadeOutAnimation.toValue = 0
    ///     fadeOutAnimation.duration = 0.25
    ///     
    ///     fadeOutAnimation.delegate = self
    ///     
    ///     sublayer.add(fadeOutAnimation,
    ///                       forKey: "fade")
    /// }
    ///     
    /// func animationDidStop(_ anim: CAAnimation, finished flag: Bool) {
    ///     sublayer.removeFromSuperlayer()
    /// }
    /// ```
    ///
    ///
    pub unsafe trait CAAnimationDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(animationDidStart:))]
        #[unsafe(method_family = none)]
        fn animationDidStart(&self, anim: &CAAnimation);

        #[optional]
        #[unsafe(method(animationDidStop:finished:))]
        #[unsafe(method_family = none)]
        fn animationDidStop_finished(&self, anim: &CAAnimation, flag: bool);
    }
);

extern_class!(
    /// An abstract subclass for creating animations that manipulate the value of layer properties.
    ///
    /// ## Overview
    ///
    /// The property to animate is specified using a key path that is relative to the layer using the animation.
    ///
    /// You do not create instances of [`CAPropertyAnimation`](https://developer.apple.com/documentation/quartzcore/capropertyanimation): to animate the properties of a Core Animation layer, create instance of the concrete subclasses [`CABasicAnimation`](https://developer.apple.com/documentation/quartzcore/cabasicanimation) or [`CAKeyframeAnimation`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation).
    ///
    ///
    /// Subclass for property-based animations. *
    #[unsafe(super(CAAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CAPropertyAnimation;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CAPropertyAnimation {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CAPropertyAnimation {}
);

extern_conformance!(
    unsafe impl NSCoding for CAPropertyAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for CAPropertyAnimation {}
);

unsafe impl CopyingHelper for CAPropertyAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CAPropertyAnimation {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CAPropertyAnimation {}
);

impl CAPropertyAnimation {
    extern_methods!(
        #[unsafe(method(animationWithKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn animationWithKeyPath(path: Option<&NSString>) -> Retained<Self>;

        #[unsafe(method(keyPath))]
        #[unsafe(method_family = none)]
        pub fn keyPath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`keyPath`][Self::keyPath].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn setKeyPath(&self, key_path: Option<&NSString>);

        #[unsafe(method(isAdditive))]
        #[unsafe(method_family = none)]
        pub fn isAdditive(&self) -> bool;

        /// Setter for [`isAdditive`][Self::isAdditive].
        #[unsafe(method(setAdditive:))]
        #[unsafe(method_family = none)]
        pub fn setAdditive(&self, additive: bool);

        #[unsafe(method(isCumulative))]
        #[unsafe(method_family = none)]
        pub fn isCumulative(&self) -> bool;

        /// Setter for [`isCumulative`][Self::isCumulative].
        #[unsafe(method(setCumulative:))]
        #[unsafe(method_family = none)]
        pub fn setCumulative(&self, cumulative: bool);

        #[cfg(feature = "CAValueFunction")]
        #[unsafe(method(valueFunction))]
        #[unsafe(method_family = none)]
        pub fn valueFunction(&self) -> Option<Retained<CAValueFunction>>;

        #[cfg(feature = "CAValueFunction")]
        /// Setter for [`valueFunction`][Self::valueFunction].
        #[unsafe(method(setValueFunction:))]
        #[unsafe(method_family = none)]
        pub fn setValueFunction(&self, value_function: Option<&CAValueFunction>);
    );
}

/// Methods declared on superclass `CAAnimation`.
impl CAPropertyAnimation {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CAPropertyAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CAPropertyAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// An object that provides basic, single-keyframe animation capabilities for a layer property.
    ///
    /// ## Overview
    ///
    /// You create an instance of  [`CABasicAnimation`](https://developer.apple.com/documentation/quartzcore/cabasicanimation) using the inherited [`animationWithKeyPath:`](https://developer.apple.com/documentation/quartzcore/capropertyanimation/init(keypath:)) method, specifying the key path of the property to be animated in the render tree.
    ///
    /// For example, you can animate a layer’s scalar (i.e. containing a single value) properties such as its [`opacity`](https://developer.apple.com/documentation/quartzcore/calayer/opacity). The following code fades in a layer by animating its opacity from `0` to `1`.
    ///
    /// ```swift
    /// let animation = CABasicAnimation(keyPath: "opacity")
    /// animation.fromValue = 0
    /// animation.toValue = 1
    /// ```
    ///
    /// Non-scalar properties, such as [`backgroundColor`](https://developer.apple.com/documentation/quartzcore/calayer/backgroundcolor), can also be animated. Core Animation will interpolate between the [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) color and the [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) color. The animation created in the following code fades a layer’s background color from red to blue.
    ///
    /// ```swift
    /// let animation = CABasicAnimation(keyPath: "backgroundColor")
    /// animation.fromValue = NSColor.red.cgColor
    /// animation.toValue = NSColor.blue.cgColor
    /// ```
    ///
    /// If you want to animate the individual components of a non-scalar property with different values, you pass the values to [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) and [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) as arrays. The following animation moves a layer from `(0, 0)` to `(100, 100)`.
    ///
    /// ```swift
    /// let animation = CABasicAnimation(keyPath: "position")
    /// animation.fromValue = [0, 0]
    /// animation.toValue = [100, 100]
    /// ```
    ///
    /// The `keyPath` can access the individual components of a property. For example, the following animation stretches a layer by animating its [`transform`](https://developer.apple.com/documentation/quartzcore/calayer/transform) object’s `x` from `1` to `2`.
    ///
    /// ```swift
    /// let animation = CABasicAnimation(keyPath: "transform.scale.x")
    /// animation.fromValue = 1
    /// animation.toValue = 2
    /// ```
    ///
    /// ### Setting Interpolation Values
    ///
    /// The [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue), [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue) and [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) properties define the values being interpolated between. All are optional, and no more than two should be non-`nil`. The object type should match the type of the property being animated.
    ///
    /// The interpolation values are used as follows:
    ///
    /// - Both [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) and [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) are non-`nil`. Interpolates between [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) and [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue).
    ///
    /// - [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) and [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue) are non-`nil`. Interpolates between [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) and ([`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) + [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue)).
    ///
    /// - [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue) and [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) are non-`nil`. Interpolates between ([`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) - [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue)) and [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue).
    ///
    /// - [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) is non-`nil`. Interpolates between [`fromValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/fromvalue) and the current presentation value of the property.
    ///
    /// - [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue) is non-`nil`. Interpolates between the current value of `keyPath` in the target layer’s presentation layer and [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue).
    ///
    /// - [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue) is non-`nil`. Interpolates between the current value of `keyPath` in the target layer’s presentation layer and that value plus [`byValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/byvalue).
    ///
    /// - All properties are `nil`. Interpolates between the previous value of `keyPath` in the target layer’s presentation layer and the current value of  `keyPath` in the target layer’s presentation layer.
    ///
    ///
    /// Subclass for basic (single-keyframe) animations. *
    #[unsafe(super(CAPropertyAnimation, CAAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CABasicAnimation;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CABasicAnimation {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CABasicAnimation {}
);

extern_conformance!(
    unsafe impl NSCoding for CABasicAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for CABasicAnimation {}
);

unsafe impl CopyingHelper for CABasicAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CABasicAnimation {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CABasicAnimation {}
);

impl CABasicAnimation {
    extern_methods!(
        #[unsafe(method(fromValue))]
        #[unsafe(method_family = none)]
        pub fn fromValue(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`fromValue`][Self::fromValue].
        ///
        /// # Safety
        ///
        /// `from_value` should be of the correct type.
        #[unsafe(method(setFromValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFromValue(&self, from_value: Option<&AnyObject>);

        #[unsafe(method(toValue))]
        #[unsafe(method_family = none)]
        pub fn toValue(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`toValue`][Self::toValue].
        ///
        /// # Safety
        ///
        /// `to_value` should be of the correct type.
        #[unsafe(method(setToValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setToValue(&self, to_value: Option<&AnyObject>);

        #[unsafe(method(byValue))]
        #[unsafe(method_family = none)]
        pub fn byValue(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`byValue`][Self::byValue].
        ///
        /// # Safety
        ///
        /// `by_value` should be of the correct type.
        #[unsafe(method(setByValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setByValue(&self, by_value: Option<&AnyObject>);
    );
}

/// Methods declared on superclass `CAPropertyAnimation`.
impl CABasicAnimation {
    extern_methods!(
        #[unsafe(method(animationWithKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn animationWithKeyPath(path: Option<&NSString>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `CAAnimation`.
impl CABasicAnimation {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CABasicAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CABasicAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// An object that provides keyframe animation capabilities for a layer object.
    ///
    /// ## Overview
    ///
    /// You create a [`CAKeyframeAnimation`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation) object using the inherited [`animationWithKeyPath:`](https://developer.apple.com/documentation/quartzcore/capropertyanimation/init(keypath:)) method, specifying the key path of the property that you want to animate on the layer. You can then specify the keyframe values to use to control the timing and animation behavior.
    ///
    /// For most types of animations, you specify the keyframe values using the [`values`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/values) and [`keyTimes`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/keytimes) properties. During the animation, Core Animation generates intermediate values by interpolating between the values you provide. When animating a value that is a coordinate point, such as the layer’s position, you can specify a [`path`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/path) for that point to follow instead of individual values. The pacing of the animation is controlled by the timing information you provide.
    ///
    /// The following code shows how to create a keyframe animation that animates a layer’s background color from red to green to blue over a two second duration.
    ///
    /// ```swift
    /// let colorKeyframeAnimation = CAKeyframeAnimation(keyPath: "backgroundColor")
    ///
    /// colorKeyframeAnimation.values = [UIColor.red.cgColor,
    ///                                  UIColor.green.cgColor,
    ///                                  UIColor.blue.cgColor]
    /// colorKeyframeAnimation.keyTimes = [0, 0.5, 1]
    /// colorKeyframeAnimation.duration = 2
    /// ```
    ///
    ///
    /// General keyframe animation class. *
    #[unsafe(super(CAPropertyAnimation, CAAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CAKeyframeAnimation;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CAKeyframeAnimation {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CAKeyframeAnimation {}
);

extern_conformance!(
    unsafe impl NSCoding for CAKeyframeAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for CAKeyframeAnimation {}
);

unsafe impl CopyingHelper for CAKeyframeAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CAKeyframeAnimation {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CAKeyframeAnimation {}
);

impl CAKeyframeAnimation {
    extern_methods!(
        #[unsafe(method(values))]
        #[unsafe(method_family = none)]
        pub fn values(&self) -> Option<Retained<NSArray>>;

        /// Setter for [`values`][Self::values].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `values` generic should be of the correct type.
        #[unsafe(method(setValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValues(&self, values: Option<&NSArray>);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(path))]
        #[unsafe(method_family = none)]
        pub fn path(&self) -> Option<Retained<CGPath>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`path`][Self::path].
        #[unsafe(method(setPath:))]
        #[unsafe(method_family = none)]
        pub fn setPath(&self, path: Option<&CGPath>);

        #[unsafe(method(keyTimes))]
        #[unsafe(method_family = none)]
        pub fn keyTimes(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`keyTimes`][Self::keyTimes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setKeyTimes:))]
        #[unsafe(method_family = none)]
        pub fn setKeyTimes(&self, key_times: Option<&NSArray<NSNumber>>);

        #[cfg(feature = "CAMediaTimingFunction")]
        #[unsafe(method(timingFunctions))]
        #[unsafe(method_family = none)]
        pub fn timingFunctions(&self) -> Option<Retained<NSArray<CAMediaTimingFunction>>>;

        #[cfg(feature = "CAMediaTimingFunction")]
        /// Setter for [`timingFunctions`][Self::timingFunctions].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTimingFunctions:))]
        #[unsafe(method_family = none)]
        pub fn setTimingFunctions(&self, timing_functions: Option<&NSArray<CAMediaTimingFunction>>);

        #[unsafe(method(calculationMode))]
        #[unsafe(method_family = none)]
        pub fn calculationMode(&self) -> Retained<CAAnimationCalculationMode>;

        /// Setter for [`calculationMode`][Self::calculationMode].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCalculationMode:))]
        #[unsafe(method_family = none)]
        pub fn setCalculationMode(&self, calculation_mode: &CAAnimationCalculationMode);

        #[unsafe(method(tensionValues))]
        #[unsafe(method_family = none)]
        pub fn tensionValues(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`tensionValues`][Self::tensionValues].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTensionValues:))]
        #[unsafe(method_family = none)]
        pub fn setTensionValues(&self, tension_values: Option<&NSArray<NSNumber>>);

        #[unsafe(method(continuityValues))]
        #[unsafe(method_family = none)]
        pub fn continuityValues(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`continuityValues`][Self::continuityValues].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setContinuityValues:))]
        #[unsafe(method_family = none)]
        pub fn setContinuityValues(&self, continuity_values: Option<&NSArray<NSNumber>>);

        #[unsafe(method(biasValues))]
        #[unsafe(method_family = none)]
        pub fn biasValues(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`biasValues`][Self::biasValues].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBiasValues:))]
        #[unsafe(method_family = none)]
        pub fn setBiasValues(&self, bias_values: Option<&NSArray<NSNumber>>);

        #[unsafe(method(rotationMode))]
        #[unsafe(method_family = none)]
        pub fn rotationMode(&self) -> Option<Retained<CAAnimationRotationMode>>;

        /// Setter for [`rotationMode`][Self::rotationMode].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRotationMode:))]
        #[unsafe(method_family = none)]
        pub fn setRotationMode(&self, rotation_mode: Option<&CAAnimationRotationMode>);
    );
}

/// Methods declared on superclass `CAPropertyAnimation`.
impl CAKeyframeAnimation {
    extern_methods!(
        #[unsafe(method(animationWithKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn animationWithKeyPath(path: Option<&NSString>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `CAAnimation`.
impl CAKeyframeAnimation {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CAKeyframeAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CAKeyframeAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// Simple linear calculation between keyframe values.
    ///
    /// ## Discussion
    ///
    /// The following code shows how to create a keyframe animation object using linear interpolation.
    ///
    /// Listing 1. Creating linearly interpolated keyframes
    ///
    /// ```swift
    /// let keyframeAnimation = CAKeyframeAnimation(keyPath: "position.y")
    /// keyframeAnimation.calculationMode = kCAAnimationLinear
    /// keyframeAnimation.keyTimes = [0, 0.25, 0.5, 0.75, 1]
    /// keyframeAnimation.values = [310, 60, 120, 60, 310]
    /// ```
    ///
    /// A layer animated with the keyframe animation created by the code above and with linearly interpolated horizontal movement would describe a path similar to the following figure.
    ///
    ///
    /// ![Tracing the path of an animation using linearly interpolated keyframes](https://docs-assets.developer.apple.com/published/0c5d43aa12ef1a5f2a1deb521dc2f0c1/media-2776788%402x.png)
    ///
    ///
    ///
    pub static kCAAnimationLinear: &'static CAAnimationCalculationMode;
}

extern "C" {
    /// Each keyframe value is used in turn, no interpolated values are calculated.
    ///
    /// ## Discussion
    ///
    /// Keyframe animations based on discrete calculation interpolation require one less element in the [`values`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/values) array than the [`keyTimes`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/keytimes) array. Each `value / keyTime` pair represents the value from the specified time until the next keyframe.
    ///
    /// For example, given the [`CAKeyframeAnimation`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation) created in the following code, the penultimate keyTime, `0.75`, has a related value of `60`. The value of `position.y` will remain at `60` until the animation completes.
    ///
    /// ```swift
    /// let keyframeAnimation = CAKeyframeAnimation(keyPath: "position.y")
    /// keyframeAnimation.calculationMode = kCAAnimationDiscrete
    ///   
    /// // keyframe 0: (0, 310), keyframe 1: (0.25, 60), keyframe 2: (0.5, 120), keyframe 3: (0.75, 60)
    /// keyframeAnimation.keyTimes = [0, 0.25, 0.5, 0.75, 1]
    /// keyframeAnimation.values = [310, 60, 120, 60]
    /// ```
    ///
    /// A layer animated with the keyframe animation created by the code above and with linearly interpolated horizontal movement would describe a path similar to the following figure.
    ///
    ///
    /// ![Tracing the path of an animation using discrete keyframes](https://docs-assets.developer.apple.com/published/f6830fc8c7adaba08416790741e03cd7/media-2776786%402x.png)
    ///
    ///
    ///
    pub static kCAAnimationDiscrete: &'static CAAnimationCalculationMode;
}

extern "C" {
    /// Linear keyframe values are interpolated to produce an even pace throughout the animation.
    ///
    /// ## Discussion
    ///
    /// `kCAAnimationPaced` gives a linearly interpolated animation, but [`keyTimes`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/keytimes) and [`timingFunction`](https://developer.apple.com/documentation/quartzcore/caanimation/timingfunction) are ignored and keyframe times are automatically generated to give the animation a constant velocity.
    ///
    /// The following code shows how to create a keyframe animation object using paced interpolation.
    ///
    /// Listing 1. Creating paced key values
    ///
    /// ```objc
    /// let keyframeAnimation = CAKeyframeAnimation(keyPath: "position.y")
    /// keyframeAnimation.calculationMode = kCAAnimationPaced
    /// keyframeAnimation.values = [310, 60, 120, 60, 310]
    /// ```
    ///
    /// A layer animated with the keyframe animation created by the code above and with linearly interpolated horizontal movement would describe a path similar to the following figure.
    ///
    ///
    /// ![Tracing the path of an animation using paced key values](https://docs-assets.developer.apple.com/published/59fe9ad7c28a77c4f7d2456ef55d3394/media-2776792%402x.png)
    ///
    ///
    ///
    pub static kCAAnimationPaced: &'static CAAnimationCalculationMode;
}

extern "C" {
    /// Smooth spline calculation between keyframe values.
    ///
    /// ## Discussion
    ///
    /// Intermediate frames are computed using a Catmull-Rom spline that passes through the keyframes. You can adjust the shape of the spline by specifying an optional set of tension, continuity, and bias values, which modify the spline using the standard Kochanek-Bartels form.
    ///
    /// The following code shows how to create a keyframe animation object using cubic interpolation.
    ///
    /// ```swift
    /// let keyframeAnimation = CAKeyframeAnimation(keyPath: "position.y")
    /// keyframeAnimation.calculationMode = kCAAnimationCubic
    /// keyframeAnimation.keyTimes = [0, 0.25, 0.5, 0.75, 1]
    /// keyframeAnimation.values = [310, 60, 120, 60, 310]
    /// ```
    ///
    /// A layer animated with the keyframe animation created by the code above and with linearly interpolated horizontal movement would describe a path similar to the following figure.
    ///
    ///
    /// ![Tracing the path of an animation using cubic spline interpolated keyframes](https://docs-assets.developer.apple.com/published/cef95992066b7134e9bc67ba36c6bb69/media-2776790%402x.png)
    ///
    ///
    ///
    pub static kCAAnimationCubic: &'static CAAnimationCalculationMode;
}

extern "C" {
    /// Cubic keyframe values are interpolated to produce an even pace throughout the animation.
    ///
    /// ## Discussion
    ///
    /// `kCAAnimationCubicPaced` gives a linearly interpolated animation, but [`keyTimes`](https://developer.apple.com/documentation/quartzcore/cakeyframeanimation/keytimes) and [`timingFunction`](https://developer.apple.com/documentation/quartzcore/caanimation/timingfunction) are ignored and keyframe times are automatically generated to give the animation a constant velocity.
    ///
    /// The following code shows how to create a keyframe animation object using paced cubic interpolation.
    ///
    /// ```objc
    /// let keyframeAnimation = CAKeyframeAnimation(keyPath: "position.y")
    /// keyframeAnimation.calculationMode = kCAAnimationCubicPaced
    /// keyframeAnimation.values = [310, 60, 120, 60, 310]
    /// ```
    ///
    /// A layer animated with the keyframe animation created by the code above and with linearly interpolated horizontal movement would describe a path similar to the following figure.
    ///
    ///
    /// ![Tracing the path of an animation using cubic paced key values](https://docs-assets.developer.apple.com/published/eb23aecda8eb2e1e569d68b1ca5c2938/media-2776794%402x.png)
    ///
    ///
    ///
    pub static kCAAnimationCubicPaced: &'static CAAnimationCalculationMode;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// The objects travel on a tangent to the path.
    ///
    ///
    pub static kCAAnimationRotateAuto: &'static CAAnimationRotationMode;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// The objects travel at a 180 degree tangent to the path.
    ///
    ///
    pub static kCAAnimationRotateAutoReverse: &'static CAAnimationRotationMode;
}

extern_class!(
    /// An animation that applies a spring-like force to a layer’s properties.
    ///
    /// ## Overview
    ///
    /// You would typically use a spring animation to animate a layer’s position so that it appears to be pulled towards a target by a spring. The further the layer is from the target, the greater the acceleration towards it is.
    ///
    /// [`CASpringAnimation`](https://developer.apple.com/documentation/quartzcore/caspringanimation) allows control over physically based attributes such as the spring’s damping and stiffness.
    ///
    /// You can use a spring animation to animation properties of a layer other than its position. The following code shows how to create a spring animation that bounces a layer into view by animating its scale from `0` to `1`. Because the spring animation can overshoot its [`toValue`](https://developer.apple.com/documentation/quartzcore/cabasicanimation/tovalue), the animated layer may exceed its frame.
    ///
    /// ```swift
    /// let springAnimation = CASpringAnimation(keyPath: "transform.scale")
    ///
    /// springAnimation.fromValue = 0
    /// springAnimation.toValue = 1
    /// ```
    ///
    ///
    /// Subclass for mass-spring animations.
    #[unsafe(super(CABasicAnimation, CAPropertyAnimation, CAAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CASpringAnimation;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CASpringAnimation {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CASpringAnimation {}
);

extern_conformance!(
    unsafe impl NSCoding for CASpringAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for CASpringAnimation {}
);

unsafe impl CopyingHelper for CASpringAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CASpringAnimation {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CASpringAnimation {}
);

impl CASpringAnimation {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(mass))]
        #[unsafe(method_family = none)]
        pub fn mass(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`mass`][Self::mass].
        #[unsafe(method(setMass:))]
        #[unsafe(method_family = none)]
        pub fn setMass(&self, mass: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(stiffness))]
        #[unsafe(method_family = none)]
        pub fn stiffness(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`stiffness`][Self::stiffness].
        #[unsafe(method(setStiffness:))]
        #[unsafe(method_family = none)]
        pub fn setStiffness(&self, stiffness: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(damping))]
        #[unsafe(method_family = none)]
        pub fn damping(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`damping`][Self::damping].
        #[unsafe(method(setDamping:))]
        #[unsafe(method_family = none)]
        pub fn setDamping(&self, damping: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(initialVelocity))]
        #[unsafe(method_family = none)]
        pub fn initialVelocity(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`initialVelocity`][Self::initialVelocity].
        #[unsafe(method(setInitialVelocity:))]
        #[unsafe(method_family = none)]
        pub fn setInitialVelocity(&self, initial_velocity: CGFloat);

        #[unsafe(method(allowsOverdamping))]
        #[unsafe(method_family = none)]
        pub fn allowsOverdamping(&self) -> bool;

        /// Setter for [`allowsOverdamping`][Self::allowsOverdamping].
        #[unsafe(method(setAllowsOverdamping:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsOverdamping(&self, allows_overdamping: bool);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(settlingDuration))]
        #[unsafe(method_family = none)]
        pub fn settlingDuration(&self) -> CFTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(initWithPerceptualDuration:bounce:))]
        #[unsafe(method_family = init)]
        pub fn initWithPerceptualDuration_bounce(
            this: Allocated<Self>,
            perceptual_duration: CFTimeInterval,
            bounce: CGFloat,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(perceptualDuration))]
        #[unsafe(method_family = none)]
        pub fn perceptualDuration(&self) -> CFTimeInterval;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(bounce))]
        #[unsafe(method_family = none)]
        pub fn bounce(&self) -> CGFloat;
    );
}

/// Methods declared on superclass `CAPropertyAnimation`.
impl CASpringAnimation {
    extern_methods!(
        #[unsafe(method(animationWithKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn animationWithKeyPath(path: Option<&NSString>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `CAAnimation`.
impl CASpringAnimation {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CASpringAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CASpringAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// An object that provides an animated transition between a layer’s states.
    ///
    /// ## Overview
    ///
    /// You can transition between a layer’s states by creating and adding a [`CATransition`](https://developer.apple.com/documentation/quartzcore/catransition) object to it. The default transition is a cross fade, but you can specify different effects from a set of predefined transitions.
    ///
    /// The following code shows how you can transition between the two states of a [`CATextLayer`](https://developer.apple.com/documentation/quartzcore/catextlayer) named `transitioningLayer`. When the layer is first created, its [`backgroundColor`](https://developer.apple.com/documentation/quartzcore/calayer/backgroundcolor) is set to red and its [`string`](https://developer.apple.com/documentation/quartzcore/catextlayer/string) property is set to `Red`. When the `runTransition()` function is called, a new [`CATransition`](https://developer.apple.com/documentation/quartzcore/catransition) object is created and added to `transitioningLayer`, and the state of the layer is changed so that its background color is blue and its rendered text reads `Blue`.
    ///
    /// The end result is that the push transition animates the red state from left to right with the blue state entering the scene from the left.
    ///
    /// ```swift
    /// let transitioningLayer = CATextLayer()
    ///      
    /// override func viewDidLoad() {
    ///     super.viewDidLoad()
    ///     transitioningLayer.frame = CGRect(x: 10, y: 10,
    ///                                       width: 320, height: 160)
    ///     
    ///     view.layer.addSublayer(transitioningLayer)
    ///     
    ///     // Initial "red" state
    ///     transitioningLayer.backgroundColor = UIColor.red.cgColor
    ///     transitioningLayer.string = "Red"
    /// }
    ///       
    ///    
    /// func runTransition() {
    ///     let transition = CATransition()
    ///     transition.duration = 2
    ///     
    ///     transition.type = kCATransitionPush
    ///     
    ///     transitioningLayer.add(transition,
    ///                            forKey: "transition")
    ///     
    ///     // Transition to "blue" state
    ///     transitioningLayer.backgroundColor = UIColor.blue.cgColor
    ///     transitioningLayer.string = "Blue"
    /// }
    /// ```
    ///
    ///
    /// Transition animation subclass. *
    #[unsafe(super(CAAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CATransition;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CATransition {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CATransition {}
);

extern_conformance!(
    unsafe impl NSCoding for CATransition {}
);

extern_conformance!(
    unsafe impl NSCopying for CATransition {}
);

unsafe impl CopyingHelper for CATransition {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CATransition {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CATransition {}
);

impl CATransition {
    extern_methods!(
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub fn r#type(&self) -> Retained<CATransitionType>;

        /// Setter for [`type`][Self::type].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setType:))]
        #[unsafe(method_family = none)]
        pub fn setType(&self, r#type: &CATransitionType);

        #[unsafe(method(subtype))]
        #[unsafe(method_family = none)]
        pub fn subtype(&self) -> Option<Retained<CATransitionSubtype>>;

        /// Setter for [`subtype`][Self::subtype].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSubtype:))]
        #[unsafe(method_family = none)]
        pub fn setSubtype(&self, subtype: Option<&CATransitionSubtype>);

        #[unsafe(method(startProgress))]
        #[unsafe(method_family = none)]
        pub fn startProgress(&self) -> c_float;

        /// Setter for [`startProgress`][Self::startProgress].
        #[unsafe(method(setStartProgress:))]
        #[unsafe(method_family = none)]
        pub fn setStartProgress(&self, start_progress: c_float);

        #[unsafe(method(endProgress))]
        #[unsafe(method_family = none)]
        pub fn endProgress(&self) -> c_float;

        /// Setter for [`endProgress`][Self::endProgress].
        #[unsafe(method(setEndProgress:))]
        #[unsafe(method_family = none)]
        pub fn setEndProgress(&self, end_progress: c_float);

        #[unsafe(method(filter))]
        #[unsafe(method_family = none)]
        pub fn filter(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`filter`][Self::filter].
        ///
        /// # Safety
        ///
        /// `filter` should be of the correct type.
        #[unsafe(method(setFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilter(&self, filter: Option<&AnyObject>);
    );
}

/// Methods declared on superclass `CAAnimation`.
impl CATransition {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CATransition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CATransition {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// The layer’s content fades as it becomes visible or hidden.
    pub static kCATransitionFade: &'static CATransitionType;
}

extern "C" {
    /// The layer’s content slides into place over any existing content.
    ///
    /// ## Discussion
    ///
    /// The [Common Transition Subtypes](https://developer.apple.com/documentation/quartzcore/common-transition-subtypes) are used with this transition.
    ///
    ///
    pub static kCATransitionMoveIn: &'static CATransitionType;
}

extern "C" {
    /// The layer’s content pushes any existing content as it slides into place.
    ///
    /// ## Discussion
    ///
    /// The [Common Transition Subtypes](https://developer.apple.com/documentation/quartzcore/common-transition-subtypes) are used with this transition.
    ///
    ///
    pub static kCATransitionPush: &'static CATransitionType;
}

extern "C" {
    /// The layer’s content is revealed gradually in the direction specified by the transition subtype.
    ///
    /// ## Discussion
    ///
    /// The [Common Transition Subtypes](https://developer.apple.com/documentation/quartzcore/common-transition-subtypes) are used with this transition.
    ///
    ///
    pub static kCATransitionReveal: &'static CATransitionType;
}

extern "C" {
    /// The transition begins at the right side of the layer.
    pub static kCATransitionFromRight: &'static CATransitionSubtype;
}

extern "C" {
    /// The transition begins at the left side of the layer.
    pub static kCATransitionFromLeft: &'static CATransitionSubtype;
}

extern "C" {
    /// The transition begins at the top of the layer.
    pub static kCATransitionFromTop: &'static CATransitionSubtype;
}

extern "C" {
    /// The transition begins at the bottom of the layer.
    pub static kCATransitionFromBottom: &'static CATransitionSubtype;
}

extern_class!(
    /// An object that allows multiple animations to be grouped and run concurrently.
    ///
    /// ## Overview
    ///
    /// The grouped animations run in the time space specified by the [`CAAnimationGroup`](https://developer.apple.com/documentation/quartzcore/caanimationgroup) instance.
    ///
    /// The duration of the grouped animations are not scaled to the duration of their [`CAAnimationGroup`](https://developer.apple.com/documentation/quartzcore/caanimationgroup). Instead, the animations are clipped to the duration of the animation group. For example, a 10 second animation grouped within an animation group with a duration of 5 seconds displays only the first 5 seconds of the animation.
    ///
    /// The following code shows how you can create a grouped animation containing  opacity and scale animations to fade out a layer while expanding it. The animation starts with an opacity of `1` and a scale of `1` on all axes. As the animation’s scale increases to `(3, 3, 3)`, the opacity drops to `0` and the animated layer vanishes.
    ///
    /// ```swift
    /// let fadeOut = CABasicAnimation(keyPath: "opacity")
    /// fadeOut.fromValue = 1
    /// fadeOut.toValue = 0
    /// fadeOut.duration = 1
    ///      
    /// let expandScale = CABasicAnimation()
    /// expandScale.keyPath = "transform"
    /// expandScale.valueFunction = CAValueFunction(name: kCAValueFunctionScale)
    /// expandScale.fromValue = [1, 1, 1]
    /// expandScale.toValue = [3, 3, 3]
    ///      
    /// let fadeAndScale = CAAnimationGroup()
    /// fadeAndScale.animations = [fadeOut, expandScale]
    /// fadeAndScale.duration = 1
    /// ```
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The [`delegate`](https://developer.apple.com/documentation/quartzcore/caanimation/delegate) and [`removedOnCompletion`](https://developer.apple.com/documentation/quartzcore/caanimation/isremovedoncompletion) properties of animations in the [`animations`](https://developer.apple.com/documentation/quartzcore/caanimationgroup/animations) array are currently ignored. The [`CAAnimationGroup`](https://developer.apple.com/documentation/quartzcore/caanimationgroup) delegate does receive these messages.
    ///
    ///
    ///
    /// </div>
    ///
    /// Animation subclass for grouped animations. *
    #[unsafe(super(CAAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CAAnimationGroup;
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl CAAction for CAAnimationGroup {}
);

#[cfg(feature = "CAMediaTiming")]
extern_conformance!(
    unsafe impl CAMediaTiming for CAAnimationGroup {}
);

extern_conformance!(
    unsafe impl NSCoding for CAAnimationGroup {}
);

extern_conformance!(
    unsafe impl NSCopying for CAAnimationGroup {}
);

unsafe impl CopyingHelper for CAAnimationGroup {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CAAnimationGroup {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CAAnimationGroup {}
);

impl CAAnimationGroup {
    extern_methods!(
        #[unsafe(method(animations))]
        #[unsafe(method_family = none)]
        pub fn animations(&self) -> Option<Retained<NSArray<CAAnimation>>>;

        /// Setter for [`animations`][Self::animations].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAnimations:))]
        #[unsafe(method_family = none)]
        pub fn setAnimations(&self, animations: Option<&NSArray<CAAnimation>>);
    );
}

/// Methods declared on superclass `CAAnimation`.
impl CAAnimationGroup {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub fn animation() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl CAAnimationGroup {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for CAAnimationGroup {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
