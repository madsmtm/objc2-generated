//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

// NS_TYPED_ENUM
pub type CAShapeLayerFillRule = NSString;

// NS_TYPED_ENUM
pub type CAShapeLayerLineJoin = NSString;

// NS_TYPED_ENUM
pub type CAShapeLayerLineCap = NSString;

extern_class!(
    /// A layer that draws a cubic Bezier spline in its coordinate space.
    ///
    /// ## Overview
    ///
    /// The shape is composited between the layer’s contents and its first sublayer.
    ///
    /// The shape will be drawn antialiased, and whenever possible it will be mapped into screen space before being rasterized to preserve resolution independence. However, certain kinds of image processing operations, such as CoreImage filters, applied to the layer or its ancestors may force rasterization in a local coordinate space.
    ///
    /// The following code shows how you can build complex, composite paths and display them using a shape layer. In this example, a series of progressively transformed ellipses form a simple flower shape. The shape layer that displays the path has its [`fillRule`](https://developer.apple.com/documentation/quartzcore/cashapelayer/fillrule) set to [`kCAFillRuleEvenOdd`](https://developer.apple.com/documentation/quartzcore/cashapelayerfillrule/evenodd) which stops the overlapping “petals” from filling with the yellow [`fillColor`](https://developer.apple.com/documentation/quartzcore/cashapelayer/fillcolor).
    ///
    /// ```swift
    /// let width: CGFloat = 640
    /// let height: CGFloat = 640
    ///      
    /// let shapeLayer = CAShapeLayer()
    /// shapeLayer.frame = CGRect(x: 0, y: 0,
    ///                           width: width, height: height)
    ///      
    /// let path = CGMutablePath()
    ///      
    /// stride(from: 0, to: CGFloat.pi * 2, by: CGFloat.pi / 6).forEach {
    ///     angle in
    ///     var transform  = CGAffineTransform(rotationAngle: angle)
    ///         .concatenating(CGAffineTransform(translationX: width / 2, y: height / 2))
    ///     
    ///     let petal = CGPath(ellipseIn: CGRect(x: -20, y: 0, width: 40, height: 100),
    ///                        transform: &transform)
    ///     
    ///     path.addPath(petal)
    /// }
    ///     
    /// shapeLayer.path = path
    /// shapeLayer.strokeColor = UIColor.red.cgColor
    /// shapeLayer.fillColor = UIColor.yellow.cgColor
    /// shapeLayer.fillRule = kCAFillRuleEvenOdd
    /// ```
    ///
    /// The following figure shows the resulting shape layer.
    ///
    ///
    /// ![Composite path displayed in a shape layer](https://docs-assets.developer.apple.com/published/67723bba6f48e3e15851ddfb2c5a2a8c/media-2825196%402x.png)
    ///
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Shape rasterization may favor speed over accuracy. For example, pixels with multiple intersecting path segments may not give exact results.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(CALayer, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CALayer")]
    pub struct CAShapeLayer;
);

#[cfg(all(feature = "CALayer", feature = "CAMediaTiming"))]
extern_conformance!(
    unsafe impl CAMediaTiming for CAShapeLayer {}
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl NSCoding for CAShapeLayer {}
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl NSObjectProtocol for CAShapeLayer {}
);

#[cfg(feature = "CALayer")]
extern_conformance!(
    unsafe impl NSSecureCoding for CAShapeLayer {}
);

#[cfg(feature = "CALayer")]
impl CAShapeLayer {
    extern_methods!(
        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(path))]
        #[unsafe(method_family = none)]
        pub fn path(&self) -> Option<Retained<CGPath>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`path`][Self::path].
        #[unsafe(method(setPath:))]
        #[unsafe(method_family = none)]
        pub fn setPath(&self, path: Option<&CGPath>);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(fillColor))]
        #[unsafe(method_family = none)]
        pub fn fillColor(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`fillColor`][Self::fillColor].
        #[unsafe(method(setFillColor:))]
        #[unsafe(method_family = none)]
        pub fn setFillColor(&self, fill_color: Option<&CGColor>);

        #[unsafe(method(fillRule))]
        #[unsafe(method_family = none)]
        pub fn fillRule(&self) -> Retained<CAShapeLayerFillRule>;

        /// Setter for [`fillRule`][Self::fillRule].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFillRule:))]
        #[unsafe(method_family = none)]
        pub fn setFillRule(&self, fill_rule: &CAShapeLayerFillRule);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(strokeColor))]
        #[unsafe(method_family = none)]
        pub fn strokeColor(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`strokeColor`][Self::strokeColor].
        #[unsafe(method(setStrokeColor:))]
        #[unsafe(method_family = none)]
        pub fn setStrokeColor(&self, stroke_color: Option<&CGColor>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(strokeStart))]
        #[unsafe(method_family = none)]
        pub fn strokeStart(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`strokeStart`][Self::strokeStart].
        #[unsafe(method(setStrokeStart:))]
        #[unsafe(method_family = none)]
        pub fn setStrokeStart(&self, stroke_start: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(strokeEnd))]
        #[unsafe(method_family = none)]
        pub fn strokeEnd(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`strokeEnd`][Self::strokeEnd].
        #[unsafe(method(setStrokeEnd:))]
        #[unsafe(method_family = none)]
        pub fn setStrokeEnd(&self, stroke_end: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(lineWidth))]
        #[unsafe(method_family = none)]
        pub fn lineWidth(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`lineWidth`][Self::lineWidth].
        #[unsafe(method(setLineWidth:))]
        #[unsafe(method_family = none)]
        pub fn setLineWidth(&self, line_width: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(miterLimit))]
        #[unsafe(method_family = none)]
        pub fn miterLimit(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`miterLimit`][Self::miterLimit].
        #[unsafe(method(setMiterLimit:))]
        #[unsafe(method_family = none)]
        pub fn setMiterLimit(&self, miter_limit: CGFloat);

        #[unsafe(method(lineCap))]
        #[unsafe(method_family = none)]
        pub fn lineCap(&self) -> Retained<CAShapeLayerLineCap>;

        /// Setter for [`lineCap`][Self::lineCap].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLineCap:))]
        #[unsafe(method_family = none)]
        pub fn setLineCap(&self, line_cap: &CAShapeLayerLineCap);

        #[unsafe(method(lineJoin))]
        #[unsafe(method_family = none)]
        pub fn lineJoin(&self) -> Retained<CAShapeLayerLineJoin>;

        /// Setter for [`lineJoin`][Self::lineJoin].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLineJoin:))]
        #[unsafe(method_family = none)]
        pub fn setLineJoin(&self, line_join: &CAShapeLayerLineJoin);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(lineDashPhase))]
        #[unsafe(method_family = none)]
        pub fn lineDashPhase(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`lineDashPhase`][Self::lineDashPhase].
        #[unsafe(method(setLineDashPhase:))]
        #[unsafe(method_family = none)]
        pub fn setLineDashPhase(&self, line_dash_phase: CGFloat);

        #[unsafe(method(lineDashPattern))]
        #[unsafe(method_family = none)]
        pub fn lineDashPattern(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// Setter for [`lineDashPattern`][Self::lineDashPattern].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLineDashPattern:))]
        #[unsafe(method_family = none)]
        pub fn setLineDashPattern(&self, line_dash_pattern: Option<&NSArray<NSNumber>>);
    );
}

/// Methods declared on superclass `CALayer`.
#[cfg(feature = "CALayer")]
impl CAShapeLayer {
    extern_methods!(
        /// Layer creation and initialization. *
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        pub fn layer() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `layer` should be of the correct type.
        #[unsafe(method(initWithLayer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithLayer(this: Allocated<Self>, layer: &AnyObject) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "CALayer")]
impl CAShapeLayer {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "CALayer")]
impl DefaultRetained for CAShapeLayer {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// Specifies the non-zero winding rule. Count each left-to-right path as +1 and each right-to-left path as -1. If the sum of all crossings is 0, the point is outside the path. If the sum is nonzero, the point is inside the path and the region containing it is filled.
    pub static kCAFillRuleNonZero: &'static CAShapeLayerFillRule;
}

extern "C" {
    /// Specifies the even-odd winding rule. Count the total number of path crossings. If the number of crossings is even, the point is outside the path. If the number of crossings is odd, the point is inside the path and the region containing it should be filled.
    pub static kCAFillRuleEvenOdd: &'static CAShapeLayerFillRule;
}

extern "C" {
    /// Specifies a miter line shape of the joints between connected segments of a stroked path.
    pub static kCALineJoinMiter: &'static CAShapeLayerLineJoin;
}

extern "C" {
    /// Specifies a round line shape of the joints between connected segments of a stroked path.
    pub static kCALineJoinRound: &'static CAShapeLayerLineJoin;
}

extern "C" {
    /// Specifies a bevel line shape of the joints between connected segments of a stroked path.
    pub static kCALineJoinBevel: &'static CAShapeLayerLineJoin;
}

extern "C" {
    /// Specifies a butt line cap style for endpoints for an open path when stroked.
    pub static kCALineCapButt: &'static CAShapeLayerLineCap;
}

extern "C" {
    /// Specifies a round line cap style for endpoints for an open path when stroked.
    pub static kCALineCapRound: &'static CAShapeLayerLineCap;
}

extern "C" {
    /// Specifies a square line cap style for endpoints for an open path when stroked.
    pub static kCALineCapSquare: &'static CAShapeLayerLineCap;
}
